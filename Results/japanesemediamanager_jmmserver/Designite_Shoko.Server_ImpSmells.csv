Implementation smell,Namespace,Class,File,Method,Description
Long Method,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetAnimeRatings,The method has 101 lines of code.
Long Method,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,SaveImportFolder,The method has 106 lines of code.
Long Method,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,SaveServerSettings,The method has 167 lines of code.
Long Method,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetRecommendations,The method has 119 lines of code.
Long Method,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetMyListFilesForRemoval,The method has 104 lines of code.
Long Method,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetGroupFileSummary,The method has 180 lines of code.
Long Method,Shoko.Server,Importer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\Importer.cs,RunImport_GetImages,The method has 251 lines of code.
Long Method,Shoko.Server,Importer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\Importer.cs,RemoveRecordsWithoutPhysicalFiles,The method has 161 lines of code.
Long Method,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,StartUpServer,The method has 109 lines of code.
Long Method,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,WorkerMyAnime2_DoWork,The method has 137 lines of code.
Long Method,Shoko.Server,ShokoServiceImplementationImage,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementationImage.cs,GetImagePath,The method has 136 lines of code.
Long Method,Shoko.Server,TagFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utilities\TagFilter.cs,ProcessTags,The method has 202 lines of code.
Long Method,Shoko.Server,ShokoServiceImplementationMetro,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementationMetro.cs,GetAnimeDetail,The method has 158 lines of code.
Long Method,Shoko.Server,ShokoServiceImplementationMetro,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementationMetro.cs,SetTvDBInfo,The method has 169 lines of code.
Long Method,Shoko.Server,Languages,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Languages.cs,GetFlagImage,The method has 103 lines of code.
Long Method,Shoko.Server,Languages,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Languages.cs,GetLanguageDescription,The method has 103 lines of code.
Long Method,Shoko.Server,ServerSettings,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ServerSettings.cs,LoadSettingsFromFile,The method has 326 lines of code.
Long Method,Shoko.Server,ServerSettings,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ServerSettings.cs,ToContract,The method has 100 lines of code.
Long Method,Shoko.Server,ServerSettings,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ServerSettings.cs,DebugSettingsToLog,The method has 132 lines of code.
Long Method,AniDBAPI,AniDBHTTPHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\AniDBHTTPHelper.cs,ProcessAnimeDetails,The method has 111 lines of code.
Long Method,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The method has 121 lines of code.
Long Method,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The method has 264 lines of code.
Long Method,Shoko.Server.Commands,CommandRequest_DownloadImage,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_DownloadImage.cs,ProcessCommand,The method has 163 lines of code.
Long Method,Shoko.Server.Commands,CommandRequest_HashFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_HashFile.cs,ProcessFile_LocalInfo,The method has 291 lines of code.
Long Method,Shoko.Server.Commands,CommandRequest_ProcessFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_ProcessFile.cs,ProcessFile_AniDB,The method has 231 lines of code.
Long Method,Shoko.Server.Commands,CommandRequest_ValidateAllImages,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_ValidateAllImages.cs,ProcessCommand,The method has 219 lines of code.
Long Method,Shoko.Server.Commands,CommandRequest_ValidateAllImages,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_ValidateAllImages.cs,RemoveImageAndQueueRedownload,The method has 126 lines of code.
Long Method,Shoko.Server.Commands,CommandRequest_SyncMyList,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\AniDB\CommandRequest_SyncMyList.cs,ProcessCommand,The method has 184 lines of code.
Long Method,Shoko.Server.Commands,CommandRequest_TraktSearchAnime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Trakt\CommandRequest_TraktSearchAnime.cs,ProcessCommand,The method has 112 lines of code.
Long Method,Shoko.Server.API.v2.Models.common,Group,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Models\common\Group.cs,GenerateFromAnimeGroup,The method has 172 lines of code.
Long Method,Shoko.Server.API.v2.Models.common,Group,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Models\common\Group.cs,GenerateSizes,The method has 101 lines of code.
Long Method,Shoko.Server.API.v2.Models.common,Filter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Models\common\Filter.cs,GenerateFromGroupFilter,The method has 103 lines of code.
Long Method,Shoko.Server.API.v2.Models.common,Episode,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Models\common\Episode.cs,GenerateFromAnimeEpisode,The method has 100 lines of code.
Long Method,Shoko.Server.API.v2.Models.common,Serie,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Models\common\Serie.cs,GenerateFromAnimeSeries,The method has 184 lines of code.
Long Method,Shoko.Server.API.v2.Models.common,Serie,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Models\common\Serie.cs,GenerateSizes,The method has 101 lines of code.
Long Method,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,Common,The method has 115 lines of code.
Long Method,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,Search,The method has 206 lines of code.
Long Method,Shoko.Server.API.v2.Modules,Image,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Image.cs,GetImagePath,The method has 200 lines of code.
Long Method,Shoko.Server.Databases,BaseDatabase<T>,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Databases\BaseDatabase.cs,CreateInitialGroupFilters,The method has 146 lines of code.
Long Method,Shoko.Server.Models,SVR_VideoLocal_Place,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_VideoLocal_Place.cs,RenameFile,The method has 125 lines of code.
Long Method,Shoko.Server.Models,SVR_VideoLocal_Place,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_VideoLocal_Place.cs,MoveWithResultString,The method has 187 lines of code.
Long Method,Shoko.Server.Models,SVR_VideoLocal_Place,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_VideoLocal_Place.cs,MoveFileIfRequired,The method has 220 lines of code.
Long Method,Shoko.Server.Models,SVR_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AniDB_Anime.cs,CreateCharacters,The method has 142 lines of code.
Long Method,Shoko.Server.Models,SVR_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AniDB_Anime.cs,UpdateContractDetailedBatch,The method has 106 lines of code.
Long Method,Shoko.Server.Models,SVR_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AniDB_Anime.cs,UpdateContractDetailed,The method has 109 lines of code.
Long Method,Shoko.Server.Models,SVR_AnimeGroup,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeGroup.cs,BatchUpdateContracts,The method has 248 lines of code.
Long Method,Shoko.Server.Models,SVR_AnimeSeries,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeSeries.cs,UpdateContract,The method has 101 lines of code.
Long Method,Shoko.Server.Models,SVR_AnimeSeries,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeSeries.cs,GetConditionTypesChanged,The method has 108 lines of code.
Long Method,Shoko.Server.Models,SVR_AnimeSeries,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeSeries.cs,UpdateStats,The method has 194 lines of code.
Long Method,Shoko.Server.Models,SVR_GroupFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_GroupFilter.cs,EvaluateConditions,The method has 335 lines of code.
Long Method,Shoko.Server.Models,SVR_GroupFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_GroupFilter.cs,EvaluateConditions,The method has 351 lines of code.
Long Method,Shoko.Server.Models,SVR_VideoLocal,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_VideoLocal.cs,ToggleWatchedStatus,The method has 142 lines of code.
Long Method,Shoko.Server.Renamer,LegacyRenamer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Renamer\LegacyRenamer.cs,EvaluateTestI,The method has 360 lines of code.
Long Method,Shoko.Server.Renamer,LegacyRenamer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Renamer\LegacyRenamer.cs,PerformActionOnFileNameADD,The method has 329 lines of code.
Long Method,Shoko.Server.Repositories.Cached,GroupFilterRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\GroupFilterRepository.cs,CreateOrVerifyLockedFilters,The method has 113 lines of code.
Long Method,Shoko.Server.Repositories.Cached,GroupFilterRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\GroupFilterRepository.cs,CreateOrVerifyDirectoryFilters,The method has 185 lines of code.
Long Method,Shoko.Server.Repositories.Cached,VideoLocalRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\VideoLocalRepository.cs,RegenerateDb,The method has 148 lines of code.
Long Method,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,TranslateVideoStream,The method has 149 lines of code.
Long Method,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The method has 265 lines of code.
Long Method,Shoko.Server.PlexAndKodi,CommonImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\CommonImplementation.cs,GetItemsFromPlaylist,The method has 103 lines of code.
Long Method,Shoko.Server.PlexAndKodi,CommonImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\CommonImplementation.cs,VoteAnime,The method has 101 lines of code.
Long Method,Shoko.Server.PlexAndKodi,CommonImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\CommonImplementation.cs,GetItemsFromSerie,The method has 134 lines of code.
Long Method,Shoko.Server.PlexAndKodi,Helper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Helper.cs,GenerateVideoFromAnimeEpisode,The method has 105 lines of code.
Long Method,Shoko.Server.PlexAndKodi,Helper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Helper.cs,FillSerie,The method has 103 lines of code.
Long Method,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe32,The method has 175 lines of code.
Long Method,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe32,The method has 177 lines of code.
Long Method,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe32,The method has 103 lines of code.
Long Method,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe32,The method has 111 lines of code.
Long Method,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressHCCtx_32,The method has 170 lines of code.
Long Method,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe64,The method has 181 lines of code.
Long Method,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe64,The method has 180 lines of code.
Long Method,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe64,The method has 104 lines of code.
Long Method,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe64,The method has 112 lines of code.
Long Method,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressHCCtx_64,The method has 168 lines of code.
Long Method,Shoko.Server.Providers.MyAnimeList,MALHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\MyAnimeList\MALHelper.cs,UpdateMALSeries,The method has 147 lines of code.
Long Method,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,GetTraktEpisodeIdV2,The method has 121 lines of code.
Long Method,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,SyncCollectionToTrakt,The method has 237 lines of code.
Long Method,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,ReconSyncTraktEpisode,The method has 114 lines of code.
Complex Method,Shoko.Server,AniDBHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDBHelper.cs,SaveResultsForAnimeXML,Cyclomatic complexity of the method is 10
Complex Method,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetNextUnwatchedEpisode,Cyclomatic complexity of the method is 15
Complex Method,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,RemoveAssociationOnFile,Cyclomatic complexity of the method is 9
Complex Method,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,AssociateMultipleFiles,Cyclomatic complexity of the method is 9
Complex Method,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetMyReleaseGroupsForAniDBEpisode,Cyclomatic complexity of the method is 11
Complex Method,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,DeleteAnimeGroup,Cyclomatic complexity of the method is 11
Complex Method,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,CreateSeriesFromAnime,Cyclomatic complexity of the method is 11
Complex Method,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,DeleteAnimeSeries,Cyclomatic complexity of the method is 12
Complex Method,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetAnimeRatings,Cyclomatic complexity of the method is 30
Complex Method,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,SaveUser,Cyclomatic complexity of the method is 14
Complex Method,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,SaveImportFolder,Cyclomatic complexity of the method is 12
Complex Method,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,DirectoriesFromImportFolderPath,Cyclomatic complexity of the method is 9
Complex Method,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,SaveServerSettings,Cyclomatic complexity of the method is 14
Complex Method,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetRecommendations,Cyclomatic complexity of the method is 29
Complex Method,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,CalculateRecommendationScore,Cyclomatic complexity of the method is 11
Complex Method,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetReleaseGroupsForAnime,Cyclomatic complexity of the method is 8
Complex Method,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,UseMyTvDBLinksWebCache,Cyclomatic complexity of the method is 12
Complex Method,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,UseMyTraktLinksWebCache,Cyclomatic complexity of the method is 12
Complex Method,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,RenameAndMoveFile,Cyclomatic complexity of the method is 12
Complex Method,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetMissingEpisodes,Cyclomatic complexity of the method is 14
Complex Method,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetMyListFilesForRemoval,Cyclomatic complexity of the method is 11
Complex Method,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetAllEpisodesWithMultipleFiles,Cyclomatic complexity of the method is 11
Complex Method,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetFilesByGroupAndResolution,Cyclomatic complexity of the method is 8
Complex Method,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetGroupFileSummary,Cyclomatic complexity of the method is 26
Complex Method,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,CompareVideoCodecTo,Cyclomatic complexity of the method is 9
Complex Method,Shoko.Server,Importer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\Importer.cs,RunImport_IntegrityCheck,Cyclomatic complexity of the method is 15
Complex Method,Shoko.Server,Importer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\Importer.cs,RunImport_NewFiles,Cyclomatic complexity of the method is 8
Complex Method,Shoko.Server,Importer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\Importer.cs,RunImport_GetImages,Cyclomatic complexity of the method is 67
Complex Method,Shoko.Server,Importer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\Importer.cs,UpdateAniDBFileData,Cyclomatic complexity of the method is 11
Complex Method,Shoko.Server,Importer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\Importer.cs,CheckForTvDBUpdates,Cyclomatic complexity of the method is 8
Complex Method,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,WorkerSetupDB_DoWork,Cyclomatic complexity of the method is 9
Complex Method,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,WorkerMyAnime2_DoWork,Cyclomatic complexity of the method is 13
Complex Method,Shoko.Server,LogRotator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LogRotator.cs,Delete_Logs,Cyclomatic complexity of the method is 8
Complex Method,Shoko.Server,ShokoServiceImplementationMetro,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementationMetro.cs,SetTvDBInfo,Cyclomatic complexity of the method is 32
Complex Method,Shoko.Server,ServerSettings,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ServerSettings.cs,LoadSettingsFromFile,Cyclomatic complexity of the method is 32
Complex Method,Shoko.Server,ServerSettings,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ServerSettings.cs,LoadLegacySettingsFromFile,Cyclomatic complexity of the method is 10
Complex Method,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,GrantAccess,Cyclomatic complexity of the method is 8
Complex Method,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,ReparseDescription,Cyclomatic complexity of the method is 12
Complex Method,AniDBAPI,AniDBHTTPHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\AniDBHTTPHelper.cs,ProcessAnimeDetails,Cyclomatic complexity of the method is 21
Complex Method,AniDBAPI,AniDBHTTPHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\AniDBHTTPHelper.cs,ConvertReltTypeTextToEnum,Cyclomatic complexity of the method is 12
Complex Method,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,Cyclomatic complexity of the method is 9
Complex Method,AniDBAPI,Raw_AniDB_MyListFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_MyListFile.cs,ProcessHTTPSource,Cyclomatic complexity of the method is 8
Complex Method,AniDBAPI.Commands,AniDBHTTPCommand_GetFullAnime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBHTTPCommand_GetFullAnime.cs,Process,Cyclomatic complexity of the method is 10
Complex Method,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,Cyclomatic complexity of the method is 10
Complex Method,Shoko.Server.Commands,CommandRequest_DownloadImage,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_DownloadImage.cs,ProcessCommand,Cyclomatic complexity of the method is 9
Complex Method,Shoko.Server.Commands,CommandRequest_HashFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_HashFile.cs,ProcessFile_LocalInfo,Cyclomatic complexity of the method is 40
Complex Method,Shoko.Server.Commands,CommandRequest_HashFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_HashFile.cs,FillMissingHashes,Cyclomatic complexity of the method is 10
Complex Method,Shoko.Server.Commands,CommandRequest_HashFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_HashFile.cs,FillHashesAgainstVideoLocalRepo,Cyclomatic complexity of the method is 16
Complex Method,Shoko.Server.Commands,CommandRequest_HashFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_HashFile.cs,FillHashesAgainstAniDBRepo,Cyclomatic complexity of the method is 16
Complex Method,Shoko.Server.Commands,CommandRequest_HashFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_HashFile.cs,FillHashesAgainstWebCache,Cyclomatic complexity of the method is 16
Complex Method,Shoko.Server.Commands,CommandRequest_LinkFileManually,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_LinkFileManually.cs,ProcessCommand,Cyclomatic complexity of the method is 10
Complex Method,Shoko.Server.Commands,CommandRequest_ValidateAllImages,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_ValidateAllImages.cs,ProcessCommand,Cyclomatic complexity of the method is 26
Complex Method,Shoko.Server.Commands,CommandProcessorGeneral,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\CommandProcessorGeneral.cs,WorkerCommands_DoWork,Cyclomatic complexity of the method is 10
Complex Method,Shoko.Server.Commands,CommandProcessorHasher,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\CommandProcessorHasher.cs,WorkerCommands_DoWork,Cyclomatic complexity of the method is 11
Complex Method,Shoko.Server.Commands,CommandProcessorImages,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\CommandProcessorImages.cs,WorkerCommands_DoWork,Cyclomatic complexity of the method is 10
Complex Method,Shoko.Server.Commands,CommandRequest_AddFileToMyList,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\AniDB\CommandRequest_AddFileToMyList.cs,ProcessCommand,Cyclomatic complexity of the method is 12
Complex Method,Shoko.Server.Commands,CommandRequest_GetAniDBTitles,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\AniDB\CommandRequest_GetAniDBTitles.cs,ProcessCommand,Cyclomatic complexity of the method is 10
Complex Method,Shoko.Server.Commands,CommandRequest_GetReleaseGroupStatus,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\AniDB\CommandRequest_GetReleaseGroupStatus.cs,ProcessCommand,Cyclomatic complexity of the method is 10
Complex Method,Shoko.Server.Commands,CommandRequest_GetUpdated,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\AniDB\CommandRequest_GetUpdated.cs,ProcessCommand,Cyclomatic complexity of the method is 10
Complex Method,Shoko.Server.Commands,CommandRequest_SyncMyList,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\AniDB\CommandRequest_SyncMyList.cs,ProcessCommand,Cyclomatic complexity of the method is 21
Complex Method,Shoko.Server.Commands,CommandRequest_SyncMyVotes,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\AniDB\CommandRequest_SyncMyVotes.cs,ProcessCommand,Cyclomatic complexity of the method is 8
Complex Method,Shoko.Server.Commands,CommandRequest_TvDBSearchAnime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\TvDB\CommandRequest_TvDBSearchAnime.cs,ProcessSearchResults,Cyclomatic complexity of the method is 10
Complex Method,Shoko.Server.API.v2.Models.common,Group,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Models\common\Group.cs,GenerateFromAnimeGroup,Cyclomatic complexity of the method is 26
Complex Method,Shoko.Server.API.v2.Models.common,RawFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Models\common\RawFile.cs,RawFile,Cyclomatic complexity of the method is 10
Complex Method,Shoko.Server.API.v2.Models.common,Filter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Models\common\Filter.cs,GenerateFromGroupFilter,Cyclomatic complexity of the method is 12
Complex Method,Shoko.Server.API.v2.Models.common,Episode,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Models\common\Episode.cs,GenerateFromAnimeEpisode,Cyclomatic complexity of the method is 17
Complex Method,Shoko.Server.API.v2.Models.common,Serie,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Models\common\Serie.cs,GenerateFromAnimeSeries,Cyclomatic complexity of the method is 33
Complex Method,Shoko.Server.API.v2.Models.common,Serie,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Models\common\Serie.cs,CompareTo,Cyclomatic complexity of the method is 15
Complex Method,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,GetMultipleFiles,Cyclomatic complexity of the method is 9
Complex Method,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,CheckTitlesFuzzy,Cyclomatic complexity of the method is 9
Complex Method,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,CheckTagsFuzzy,Cyclomatic complexity of the method is 14
Complex Method,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,GetCastFromSeries,Cyclomatic complexity of the method is 8
Complex Method,Shoko.Server.API.v2.Modules,Init,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Init.cs,SetAniDB,Cyclomatic complexity of the method is 8
Complex Method,Shoko.Server.API.v2.Modules,Init,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Init.cs,SetDatabaseSettings,Cyclomatic complexity of the method is 17
Complex Method,Shoko.Server.API.v2.Modules,Init,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Init.cs,SetSetting,Cyclomatic complexity of the method is 8
Complex Method,Shoko.Server.Commands.Plex,CommandRequest_PlexSyncWatched,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Plex\CommandRequest_PlexSyncWatched.cs,ProcessCommand,Cyclomatic complexity of the method is 8
Complex Method,Shoko.Server.FileHelper,Hasher,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\Hasher.cs,CalculateHashes,Cyclomatic complexity of the method is 8
Complex Method,Shoko.Server.FileHelper,Hasher,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\Hasher.cs,CalculateHashes_here,Cyclomatic complexity of the method is 17
Complex Method,Shoko.Server.Models,SVR_VideoLocal_Place,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_VideoLocal_Place.cs,RenameFile,Cyclomatic complexity of the method is 19
Complex Method,Shoko.Server.Models,SVR_VideoLocal_Place,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_VideoLocal_Place.cs,FillVideoInfoFromMedia,Cyclomatic complexity of the method is 9
Complex Method,Shoko.Server.Models,SVR_VideoLocal_Place,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_VideoLocal_Place.cs,RefreshMediaInfo,Cyclomatic complexity of the method is 14
Complex Method,Shoko.Server.Models,SVR_VideoLocal_Place,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_VideoLocal_Place.cs,RenameAndMoveAsRequired,Cyclomatic complexity of the method is 9
Complex Method,Shoko.Server.Models,SVR_VideoLocal_Place,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_VideoLocal_Place.cs,MoveWithResultString,Cyclomatic complexity of the method is 22
Complex Method,Shoko.Server.Models,SVR_VideoLocal_Place,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_VideoLocal_Place.cs,MoveFileIfRequired,Cyclomatic complexity of the method is 15
Complex Method,Shoko.Server.Models,SVR_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AniDB_Anime.cs,GetFormattedTitle,Cyclomatic complexity of the method is 10
Complex Method,Shoko.Server.Models,SVR_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AniDB_Anime.cs,CreateEpisodes,Cyclomatic complexity of the method is 10
Complex Method,Shoko.Server.Models,SVR_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AniDB_Anime.cs,CreateTags,Cyclomatic complexity of the method is 9
Complex Method,Shoko.Server.Models,SVR_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AniDB_Anime.cs,CreateCharacters,Cyclomatic complexity of the method is 12
Complex Method,Shoko.Server.Models,SVR_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AniDB_Anime.cs,UpdateContractDetailedBatch,Cyclomatic complexity of the method is 12
Complex Method,Shoko.Server.Models,SVR_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AniDB_Anime.cs,UpdateContractDetailed,Cyclomatic complexity of the method is 21
Complex Method,Shoko.Server.Models,SVR_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AniDB_Anime.cs,ToAzure,Cyclomatic complexity of the method is 8
Complex Method,Shoko.Server.Models,SVR_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AniDB_File.cs,CreateLanguages,Cyclomatic complexity of the method is 13
Complex Method,Shoko.Server.Models,SVR_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AniDB_File.cs,CreateCrossEpisodes,Cyclomatic complexity of the method is 10
Complex Method,Shoko.Server.Models,SVR_AnimeGroup,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeGroup.cs,GetConditionTypesChanged,Cyclomatic complexity of the method is 29
Complex Method,Shoko.Server.Models,SVR_AnimeGroup,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeGroup.cs,BatchUpdateContracts,Cyclomatic complexity of the method is 37
Complex Method,Shoko.Server.Models,SVR_AnimeGroup,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeGroup.cs,UpdateGroupFilters,Cyclomatic complexity of the method is 8
Complex Method,Shoko.Server.Models,SVR_AnimeSeries,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeSeries.cs,GetFormattedTitle,Cyclomatic complexity of the method is 10
Complex Method,Shoko.Server.Models,SVR_AnimeSeries,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeSeries.cs,UpdateGroupFilters,Cyclomatic complexity of the method is 8
Complex Method,Shoko.Server.Models,SVR_AnimeSeries,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeSeries.cs,BatchUpdateContracts,Cyclomatic complexity of the method is 11
Complex Method,Shoko.Server.Models,SVR_AnimeSeries,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeSeries.cs,UpdateContract,Cyclomatic complexity of the method is 13
Complex Method,Shoko.Server.Models,SVR_AnimeSeries,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeSeries.cs,GetConditionTypesChanged,Cyclomatic complexity of the method is 28
Complex Method,Shoko.Server.Models,SVR_AnimeSeries,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeSeries.cs,UpdateStats,Cyclomatic complexity of the method is 41
Complex Method,Shoko.Server.Models,SVR_AnimeSeries,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeSeries.cs,SearchSeriesByStaff,Cyclomatic complexity of the method is 8
Complex Method,Shoko.Server.Models,EpisodeList,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeSeries.cs,Add,Cyclomatic complexity of the method is 9
Complex Method,Shoko.Server.Models,SVR_GroupFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_GroupFilter.cs,EvaluateGroupFilter,Cyclomatic complexity of the method is 9
Complex Method,Shoko.Server.Models,SVR_GroupFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_GroupFilter.cs,Equals,Cyclomatic complexity of the method is 13
Complex Method,Shoko.Server.Models,SVR_VideoLocal,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_VideoLocal.cs,ToggleWatchedStatus,Cyclomatic complexity of the method is 20
Complex Method,Shoko.Server.Models,SVR_VideoLocal,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_VideoLocal.cs,GetMediaFromUser,Cyclomatic complexity of the method is 12
Complex Method,Shoko.Server.Models,VideoLocalComparer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_VideoLocal.cs,Compare,Cyclomatic complexity of the method is 11
Complex Method,Shoko.Server.Providers.TvDB,TvDBApiHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TvDB\TvDBApiHelper.cs,LinkAniDBTvDB,Cyclomatic complexity of the method is 9
Complex Method,Shoko.Server.Providers.TvDB,TvDBApiHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TvDB\TvDBApiHelper.cs,RemoveAllAniDBTvDBLinks,Cyclomatic complexity of the method is 9
Complex Method,Shoko.Server.Providers.TvDB,TvDBApiHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TvDB\TvDBApiHelper.cs,IncrementalTvDBUpdate,Cyclomatic complexity of the method is 13
Complex Method,Shoko.Server.Renamer,LegacyRenamer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Renamer\LegacyRenamer.cs,EvaluateTestF,Cyclomatic complexity of the method is 8
Complex Method,Shoko.Server.Renamer,LegacyRenamer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Renamer\LegacyRenamer.cs,EvaluateTestZ,Cyclomatic complexity of the method is 8
Complex Method,Shoko.Server.Renamer,LegacyRenamer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Renamer\LegacyRenamer.cs,EvaluateTestW,Cyclomatic complexity of the method is 10
Complex Method,Shoko.Server.Renamer,LegacyRenamer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Renamer\LegacyRenamer.cs,EvaluateTestU,Cyclomatic complexity of the method is 10
Complex Method,Shoko.Server.Renamer,LegacyRenamer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Renamer\LegacyRenamer.cs,EvaluateTestI,Cyclomatic complexity of the method is 62
Complex Method,Shoko.Server.Renamer,LegacyRenamer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Renamer\LegacyRenamer.cs,GetNewFileName,Cyclomatic complexity of the method is 12
Complex Method,Shoko.Server.Renamer,LegacyRenamer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Renamer\LegacyRenamer.cs,PerformActionOnFileNameADD,Cyclomatic complexity of the method is 62
Complex Method,Shoko.Server.Renamer,LegacyRenamer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Renamer\LegacyRenamer.cs,EvaluateTest,Cyclomatic complexity of the method is 11
Complex Method,Shoko.Server.Renamer,LegacyRenamer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Renamer\LegacyRenamer.cs,GetDestinationFolder,Cyclomatic complexity of the method is 20
Complex Method,Shoko.Server.Repositories.Cached,GroupFilterRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\GroupFilterRepository.cs,CreateOrVerifyDirectoryFilters,Cyclomatic complexity of the method is 19
Complex Method,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,TranslateVideoStream,Cyclomatic complexity of the method is 37
Complex Method,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,TranslateAudioStream,Cyclomatic complexity of the method is 23
Complex Method,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,TranslateTextStream,Cyclomatic complexity of the method is 10
Complex Method,Shoko.Server.FileHelper.Subtitles,TextSubtitles,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\Subtitles\TextSubtitles.cs,GetStreams,Cyclomatic complexity of the method is 16
Complex Method,Shoko.Server.FileHelper.Subtitles,VobSubSubtitles,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\Subtitles\VobSubSubtitles.cs,GetStreams,Cyclomatic complexity of the method is 9
Complex Method,Shoko.Server.PlexAndKodi,CommonImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\CommonImplementation.cs,GetItemsFromPlaylist,Cyclomatic complexity of the method is 12
Complex Method,Shoko.Server.PlexAndKodi,CommonImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\CommonImplementation.cs,Search,Cyclomatic complexity of the method is 9
Complex Method,Shoko.Server.PlexAndKodi,CommonImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\CommonImplementation.cs,GetItemsFromGroup,Cyclomatic complexity of the method is 15
Complex Method,Shoko.Server.PlexAndKodi,CommonImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\CommonImplementation.cs,VoteAnime,Cyclomatic complexity of the method is 11
Complex Method,Shoko.Server.PlexAndKodi,Helper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Helper.cs,AddLinksToAnimeEpisodeVideo,Cyclomatic complexity of the method is 8
Complex Method,Shoko.Server.PlexAndKodi,Helper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Helper.cs,VideoFromAnimeEpisode,Cyclomatic complexity of the method is 14
Complex Method,Shoko.Server.PlexAndKodi,Helper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Helper.cs,GenerateVideoFromAnimeEpisode,Cyclomatic complexity of the method is 14
Complex Method,Shoko.Server.PlexAndKodi,Helper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Helper.cs,GetValidVideoRecursive,Cyclomatic complexity of the method is 10
Complex Method,Shoko.Server.PlexAndKodi,Helper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Helper.cs,AddInformationFromMasterSeries,Cyclomatic complexity of the method is 10
Complex Method,Shoko.Server.PlexAndKodi,BaseObject,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\BaseObject.cs,Init,Cyclomatic complexity of the method is 8
Complex Method,Shoko.Server.Providers.MovieDB,MovieDBHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\MovieDB\MovieDBHelper.cs,SaveMovieToDatabase,Cyclomatic complexity of the method is 16
Complex Method,Shoko.Server.Tasks,AutoAnimeGroupCalculator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Tasks\AutoAnimeGroupCalculator.cs,FindSuitableAnimeByWeighting,Cyclomatic complexity of the method is 10
Complex Method,Shoko.Server.Tasks,AutoAnimeGroupCalculator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Tasks\AutoAnimeGroupCalculator.cs,ShouldConsiderAnimeRelation,Cyclomatic complexity of the method is 8
Complex Method,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,CheckArguments,Cyclomatic complexity of the method is 8
Complex Method,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe32,Cyclomatic complexity of the method is 18
Complex Method,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe32,Cyclomatic complexity of the method is 21
Complex Method,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe32,Cyclomatic complexity of the method is 16
Complex Method,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe32,Cyclomatic complexity of the method is 19
Complex Method,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4HC_InsertAndFindBestMatch_32,Cyclomatic complexity of the method is 9
Complex Method,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4HC_InsertAndGetWiderMatch_32,Cyclomatic complexity of the method is 10
Complex Method,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_encodeSequence_32,Cyclomatic complexity of the method is 9
Complex Method,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressHCCtx_32,Cyclomatic complexity of the method is 26
Complex Method,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe64,Cyclomatic complexity of the method is 19
Complex Method,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe64,Cyclomatic complexity of the method is 19
Complex Method,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe64,Cyclomatic complexity of the method is 16
Complex Method,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe64,Cyclomatic complexity of the method is 19
Complex Method,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4HC_InsertAndFindBestMatch_64,Cyclomatic complexity of the method is 9
Complex Method,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4HC_InsertAndGetWiderMatch_64,Cyclomatic complexity of the method is 11
Complex Method,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_encodeSequence_64,Cyclomatic complexity of the method is 9
Complex Method,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressHCCtx_64,Cyclomatic complexity of the method is 26
Complex Method,Shoko.Server.Commands.MAL,CommandRequest_MALDownloadStatusFromMAL,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\MAL\CommandRequest_MALDownloadStatusFromMAL.cs,ProcessCommand,Cyclomatic complexity of the method is 15
Complex Method,Shoko.Server.Providers.MyAnimeList,MALHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\MyAnimeList\MALHelper.cs,UpdateMALSeries,Cyclomatic complexity of the method is 27
Complex Method,Shoko.Server.Providers.TraktTV.Contracts,TraktV2SyncCollectionEpisodesByNumber,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\Contracts\Sync\TraktV2SyncCollectionEpisodesByNumber.cs,AddEpisode,Cyclomatic complexity of the method is 11
Complex Method,Shoko.Server.Providers.TraktTV.Contracts,TraktV2SyncWatchedEpisodesByNumber,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\Contracts\Sync\TraktV2SyncWatchedEpisodesByNumber.cs,AddEpisode,Cyclomatic complexity of the method is 11
Complex Method,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,GetTraktEpisodeIdV2,Cyclomatic complexity of the method is 22
Complex Method,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,SaveExtendedShowInfoV2,Cyclomatic complexity of the method is 8
Complex Method,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,GetShowCommentsV2,Cyclomatic complexity of the method is 10
Complex Method,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,SyncCollectionToTrakt,Cyclomatic complexity of the method is 35
Complex Method,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,ReconSyncTraktEpisode,Cyclomatic complexity of the method is 15
Long Parameter List,Shoko.Server,AniDBHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDBHelper.cs,Init,The method has 5 parameters. Parameters: userName' password' serverName' serverPort' clientPort
Long Parameter List,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,SetWatchedStatusOnSeries,The method has 5 parameters. Parameters: animeSeriesID' watchedStatus' maxEpisodeNumber' episodeType' userID
Long Parameter List,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,SetDefaultImage,The method has 5 parameters. Parameters: isDefault' animeID' imageID' imageType' imageSizeType
Long Parameter List,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,LinkAniDBTrakt,The method has 7 parameters. Parameters: animeID' aniEpType' aniEpNumber' traktID' seasonNumber' traktEpNumber' crossRef_AniDB_TraktV2ID
Long Parameter List,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,RemoveLinkAniDBTrakt,The method has 6 parameters. Parameters: animeID' aniEpType' aniEpNumber' traktID' traktSeasonNumber' traktEpNumber
Long Parameter List,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,LinkAniDBMAL,The method has 5 parameters. Parameters: animeID' malID' malTitle' epType' epNumber
Long Parameter List,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,LinkAniDBMALUpdated,The method has 7 parameters. Parameters: animeID' malID' malTitle' oldEpType' oldEpNumber' newEpType' newEpNumber
Long Parameter List,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetFilesByGroupAndResolution,The method has 6 parameters. Parameters: animeID' relGroupName' resolution' videoSource' videoBitDepth' userID
Long Parameter List,Shoko.Server,UnhandledExceptionManager,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\UnhandledExceptionManager.cs,BitBlt,The method has 9 parameters. Parameters: hDestDC' x' y' nWidth' nHeight' hSrcDC' xSrc' ySrc' dwRop
Long Parameter List,AniDBAPI.Commands,AniDBCommand_UpdateFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_UpdateFile.cs,Init,The method has 5 parameters. Parameters: fileData' watched' watchedDate' isEdit' fileState
Long Parameter List,Shoko.Server.Commands,CommandRequest_TvDBSearchAnime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\TvDB\CommandRequest_TvDBSearchAnime.cs,AddCrossRef_AniDB_TvDBV2,The method has 5 parameters. Parameters: animeID' anistart' tvdbID' tvdbSeason' title
Long Parameter List,Shoko.Server.Commands,CommandRequest_WebCacheDeleteXRefAniDBTrakt,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\WebCache\CommandRequest_WebCacheDeleteXRefAniDBTrakt.cs,CommandRequest_WebCacheDeleteXRefAniDBTrakt,The method has 6 parameters. Parameters: animeID' aniDBStartEpisodeType' aniDBStartEpisodeNumber' traktID' traktSeasonNumber' traktStartEpisodeNumber
Long Parameter List,Shoko.Server.Commands,CommandRequest_WebCacheDeleteXRefAniDBTvDB,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\WebCache\CommandRequest_WebCacheDeleteXRefAniDBTvDB.cs,CommandRequest_WebCacheDeleteXRefAniDBTvDB,The method has 6 parameters. Parameters: animeID' aniDBStartEpisodeType' aniDBStartEpisodeNumber' tvDBID' tvDBSeasonNumber' tvDBStartEpisodeNumber
Long Parameter List,Shoko.Server.API,APIHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\APIHelper.cs,ConstructSearchUrl,The method has 5 parameters. Parameters: ctx' limit' query' searchTag' short_url
Long Parameter List,Shoko.Server.API,APIHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\APIHelper.cs,ConstructVideoLocalStream,The method has 5 parameters. Parameters: ctx' userid' vid' name' autowatch
Long Parameter List,Shoko.Server.API.v1.Implementations,ShokoServiceImplementationPlex,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementationPlex.cs,GetMetadata,The method has 5 parameters. Parameters: userId' type' id' historyinfo' filterid
Long Parameter List,Shoko.Server.API.v2.Models.common,Group,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Models\common\Group.cs,GenerateFromAnimeGroup,The method has 11 parameters. Parameters: ctx' ag' uid' nocast' notag' level' all' filterid' allpic' pic' tagfilter
Long Parameter List,Shoko.Server.API.v2.Models.common,Filter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Models\common\Filter.cs,GenerateFromGroupFilter,The method has 10 parameters. Parameters: ctx' gf' uid' nocast' notag' level' all' allpic' pic' tagfilter
Long Parameter List,Shoko.Server.API.v2.Models.common,Filters,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Models\common\Filters.cs,GenerateFromGroupFilter,The method has 10 parameters. Parameters: ctx' gf' uid' nocast' notag' all' level' allpic' pic' tagfilter
Long Parameter List,Shoko.Server.API.v2.Models.common,SearchResult,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Models\common\SearchResult.cs,GenerateFromAnimeSeries,The method has 11 parameters. Parameters: ctx' ser' uid' nocast' notag' level' all' match' allpic' pic' tagfilter
Long Parameter List,Shoko.Server.API.v2.Models.common,Serie,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Models\common\Serie.cs,GenerateFromVideoLocal,The method has 10 parameters. Parameters: ctx' vl' uid' nocast' notag' level' all' allpics' pic' tagfilter
Long Parameter List,Shoko.Server.API.v2.Models.common,Serie,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Models\common\Serie.cs,GenerateFromAnimeSeries,The method has 10 parameters. Parameters: ctx' ser' uid' nocast' notag' level' all' allpics' pic' tagfilter
Long Parameter List,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,GetAllEpisodes,The method has 5 parameters. Parameters: uid' limit' offset' level' all
Long Parameter List,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,GetSeriesByFolder,The method has 10 parameters. Parameters: id' uid' nocast' notag' level' all' limit' allpic' pic' tagfilter
Long Parameter List,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,GetSerieFromEpisode,The method has 9 parameters. Parameters: id' uid' nocast' notag' level' all' allpic' pic' tagfilter
Long Parameter List,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,GetAllSeries,The method has 9 parameters. Parameters: nocast' limit' offset' notag' level' all' allpic' pic' tagfilter
Long Parameter List,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,GetSerieById,The method has 8 parameters. Parameters: series_id' nocast' notag' level' all' allpic' pic' tagfilter
Long Parameter List,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,Search,The method has 14 parameters. Parameters: query' limit' limit_tag' offset' tagSearch' uid' nocast' notag' level' all' fuzzy' allpic' pic' tagfilter
Long Parameter List,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,StartsWith,The method has 10 parameters. Parameters: query' limit' uid' nocast' notag' level' all' allpic' pic' tagfilter
Long Parameter List,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,GetAllFilters,The method has 8 parameters. Parameters: uid' nocast' notag' level' all' allpic' pic' tagfilter
Long Parameter List,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,GetFilter,The method has 9 parameters. Parameters: id' uid' nocast' notag' level' all' allpic' pic' tagfilter
Long Parameter List,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,GetAllGroups,The method has 8 parameters. Parameters: uid' nocast' notag' level' all' allpics' pic' tagfilter
Long Parameter List,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,GetGroup,The method has 10 parameters. Parameters: id' uid' nocast' notag' level' all' filterid' allpics' pic' tagfilter
Long Parameter List,Shoko.Server.Commands.TvDB,CommandRequest_LinkAniDBTvDB,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\TvDB\CommandRequest_LinkAniDBTvDB.cs,CommandRequest_LinkAniDBTvDB,The method has 8 parameters. Parameters: animeID' aniEpType' aniEpNumber' tvDBID' tvSeasonNumber' tvEpNumber' excludeFromWebCache' additiveLink
Long Parameter List,Shoko.Server.Databases,SQLite,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Databases\SQLite.cs,DropColumns,The method has 5 parameters. Parameters: db' tableName' colsToRemove' createcommand' indexcommands
Long Parameter List,Shoko.Server.FileHelper,FileHashHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\FileHashHelper.cs,GetHashInfo,The method has 6 parameters. Parameters: fileName' forceRefresh' hashProgress' getCRC32' getMD5' getSHA1
Long Parameter List,Shoko.Server.FileHelper,Hasher,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\Hasher.cs,CalculateHashes_callback_dll,The method has 6 parameters. Parameters: szFileName' hash' lpHashProgressFunc' getCRC32' getMD5' getSHA1
Long Parameter List,Shoko.Server.FileHelper,Hasher,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\Hasher.cs,CalculateHashes_dll,The method has 6 parameters. Parameters: strFileName' hash' HashProgress' getCRC32' getMD5' getSHA1
Long Parameter List,Shoko.Server.FileHelper,Hasher,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\Hasher.cs,CalculateHashes,The method has 5 parameters. Parameters: strPath' onHashProgress' getCRC32' getMD5' getSHA1
Long Parameter List,Shoko.Server.FileHelper,Hasher,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\Hasher.cs,CalculateHashes_here,The method has 5 parameters. Parameters: strPath' onHashProgress' getCRC32' getMD5' getSHA1
Long Parameter List,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,FF,The method has 6 parameters. Parameters: a' b' c' d' x' s
Long Parameter List,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,GG,The method has 6 parameters. Parameters: a' b' c' d' x' s
Long Parameter List,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,HH,The method has 6 parameters. Parameters: a' b' c' d' x' s
Long Parameter List,Shoko.Server.Models,SVR_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AniDB_Anime.cs,GetRelatedAnimeRecursive,The method has 5 parameters. Parameters: session' animeID' relList' relListIDs' searchedIDs
Long Parameter List,Shoko.Server.Models,SVR_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AniDB_Anime.cs,PopulateAndSaveFromHTTP,The method has 11 parameters. Parameters: session' animeInfo' eps' titles' cats' tags' chars' rels' sims' recs' downloadRelations
Long Parameter List,Shoko.Server.Models,SVR_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AniDB_Anime.cs,GenerateContract,The method has 6 parameters. Parameters: titles' defaultImages' characters' movDbFanart' tvDbFanart' tvDbBanners
Long Parameter List,Shoko.Server.Models,SVR_AnimeEpisode,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeEpisode.cs,ToggleWatchedStatus,The method has 5 parameters. Parameters: watched' updateOnline' watchedDate' userID' syncTrakt
Long Parameter List,Shoko.Server.Models,SVR_AnimeEpisode,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeEpisode.cs,ToggleWatchedStatus,The method has 6 parameters. Parameters: watched' updateOnline' watchedDate' updateStats' userID' syncTrakt
Long Parameter List,Shoko.Server.Models,SVR_AnimeGroup,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeGroup.cs,BatchUpdateStats,The method has 5 parameters. Parameters: animeGroups' watchedStats' missingEpsStats' createdGroupUsers' updatedGroupUsers
Long Parameter List,Shoko.Server.Models,SVR_VideoLocal,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_VideoLocal.cs,ToggleWatchedStatus,The method has 7 parameters. Parameters: watched' updateOnline' watchedDate' updateStats' userID' syncTrakt' updateWatchedDate
Long Parameter List,Shoko.Server.Providers.TvDB,TvDBApiHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TvDB\TvDBApiHelper.cs,LinkAniDBTvDB,The method has 8 parameters. Parameters: animeID' aniEpType' aniEpNumber' tvDBID' tvSeasonNumber' tvEpNumber' excludeFromWebCache' additiveLink
Long Parameter List,Shoko.Server.Providers.TvDB,TvDBApiHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TvDB\TvDBApiHelper.cs,RemoveLinkAniDBTvDB,The method has 6 parameters. Parameters: animeID' aniEpType' aniEpNumber' tvDBID' tvSeasonNumber' tvEpNumber
Long Parameter List,Shoko.Server.Renamer,LegacyRenamer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Renamer\LegacyRenamer.cs,ProcessNumericalOperators,The method has 6 parameters. Parameters: test' notCondition' greaterThan' greaterThanEqual' lessThan' lessThanEqual
Long Parameter List,Shoko.Server.Renamer,LegacyRenamer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Renamer\LegacyRenamer.cs,EvaluateTestI,The method has 5 parameters. Parameters: test' vid' aniFile' episodes' anime
Long Parameter List,Shoko.Server.Renamer,LegacyRenamer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Renamer\LegacyRenamer.cs,PerformActionOnFileName,The method has 6 parameters. Parameters: newFileName' action' vid' aniFile' episodes' anime
Long Parameter List,Shoko.Server.Renamer,LegacyRenamer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Renamer\LegacyRenamer.cs,PerformActionOnFileNameADD,The method has 6 parameters. Parameters: newFileName' action' vid' aniFile' episodes' anime
Long Parameter List,Shoko.Server.Renamer,LegacyRenamer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Renamer\LegacyRenamer.cs,EvaluateTest,The method has 5 parameters. Parameters: line' vid' aniFile' episodes' anime
Long Parameter List,Shoko.Server.Renamer,LegacyRenamer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Renamer\LegacyRenamer.cs,EvaluateTest,The method has 6 parameters. Parameters: testChar' testCondition' vid' aniFile' episodes' anime
Long Parameter List,Shoko.Server.Repositories.Cached,CrossRef_AniDB_TvDBV2Repository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\CrossRef_AniDB_TvDBV2Repository.cs,GetByTvDBID,The method has 6 parameters. Parameters: id' season' episodeNumber' animeID' aniEpType' aniEpisodeNumber
Long Parameter List,Shoko.Server.Repositories.Cached,AnimeSeriesRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\AnimeSeriesRepository.cs,Save,The method has 5 parameters. Parameters: obj' updateGroups' onlyupdatestats' skipgroupfilters' alsoupdateepisodes
Long Parameter List,Shoko.Server.Repositories.Direct,CrossRef_AniDB_TraktV2Repository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Direct\CrossRef_AniDB_TraktV2Repository.cs,GetByTraktID,The method has 7 parameters. Parameters: session' id' season' episodeNumber' animeID' aniEpType' aniEpisodeNumber
Long Parameter List,Shoko.Server.Repositories.Direct,CrossRef_AniDB_TraktV2Repository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Direct\CrossRef_AniDB_TraktV2Repository.cs,GetByTraktID,The method has 6 parameters. Parameters: id' season' episodeNumber' animeID' aniEpType' aniEpisodeNumber
Long Parameter List,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,FindInBuffer,The method has 6 parameters. Parameters: atom' start' max' buffer' pos' posmax
Long Parameter List,MediaInfoLib,MediaInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\MediaInfoDLL.cs,MediaInfo_GetI,The method has 5 parameters. Parameters: Handle' StreamKind' StreamNumber' Parameter' KindOfInfo
Long Parameter List,MediaInfoLib,MediaInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\MediaInfoDLL.cs,MediaInfoA_GetI,The method has 5 parameters. Parameters: Handle' StreamKind' StreamNumber' Parameter' KindOfInfo
Long Parameter List,MediaInfoLib,MediaInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\MediaInfoDLL.cs,MediaInfo_Get,The method has 6 parameters. Parameters: Handle' StreamKind' StreamNumber' Parameter' KindOfInfo' KindOfSearch
Long Parameter List,MediaInfoLib,MediaInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\MediaInfoDLL.cs,MediaInfoA_Get,The method has 6 parameters. Parameters: Handle' StreamKind' StreamNumber' Parameter' KindOfInfo' KindOfSearch
Long Parameter List,MediaInfoLib,MediaInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\MediaInfoDLL.cs,Get,The method has 5 parameters. Parameters: StreamKind' StreamNumber' Parameter' KindOfInfo' KindOfSearch
Long Parameter List,Shoko.Server.PlexAndKodi,HttpExtensions,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\HttpExtensions.cs,ServerUrl,The method has 5 parameters. Parameters: prov' port' path' externalip' forcescheme
Long Parameter List,Shoko.Server.PlexAndKodi,IProvider,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\IProvider.cs,NewMediaContainer,The method has 5 parameters. Parameters: type' title' allowsync' nocache' info
Long Parameter List,Shoko.Server.PlexAndKodi,CommonImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\CommonImplementation.cs,GetMetadata,The method has 7 parameters. Parameters: prov' UserId' type' Id' historyinfo' nocast' filter
Long Parameter List,Shoko.Server.PlexAndKodi,CommonImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\CommonImplementation.cs,Search,The method has 6 parameters. Parameters: prov' UserId' lim' query' searchTag' nocast
Long Parameter List,Shoko.Server.PlexAndKodi,CommonImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\CommonImplementation.cs,GetItemsFromGroup,The method has 6 parameters. Parameters: prov' userid' GroupId' info' nocast' filterID
Long Parameter List,Shoko.Server.PlexAndKodi,CommonImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\CommonImplementation.cs,VoteAnime,The method has 5 parameters. Parameters: prov' userid' objid' vvalue' vt
Long Parameter List,Shoko.Server.PlexAndKodi,CommonImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\CommonImplementation.cs,TraktScrobble,The method has 5 parameters. Parameters: prov' animeId' typeTrakt' progressTrakt' status
Long Parameter List,Shoko.Server.PlexAndKodi,CommonImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\CommonImplementation.cs,GetItemsFromSerie,The method has 5 parameters. Parameters: prov' userid' SerieId' info' nocast
Long Parameter List,Shoko.Server.PlexAndKodi,CommonImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\CommonImplementation.cs,GetGroupsOrSubFiltersFromFilter,The method has 5 parameters. Parameters: prov' userid' GroupFilterId' info' nocast
Long Parameter List,Shoko.Server.PlexAndKodi,Extensions,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Extensions.cs,ConstructSearchUrl,The method has 5 parameters. Parameters: prov' userid' limit' query' searchTag
Long Parameter List,Shoko.Server.PlexAndKodi,Extensions,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Extensions.cs,Add,The method has 6 parameters. Parameters: l' prov' m' info' noimage' noart
Long Parameter List,Shoko.Server.PlexAndKodi,Extensions,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Extensions.cs,EppAdd,The method has 5 parameters. Parameters: l' prov' m' info' noimage
Long Parameter List,Shoko.Server.PlexAndKodi,Extensions,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Extensions.cs,EppAdd,The method has 5 parameters. Parameters: l' prov' m' info' noimage
Long Parameter List,Shoko.Server.PlexAndKodi,Extensions,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Extensions.cs,Add,The method has 5 parameters. Parameters: l' prov' m' info' noimage
Long Parameter List,Shoko.Server.PlexAndKodi,Helper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Helper.cs,ConstructVideoLocalStream,The method has 5 parameters. Parameters: prov' userid' vid' name' autowatch
Long Parameter List,Shoko.Server.PlexAndKodi,Helper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Helper.cs,AddCrossRef_AniDB_TvDBV2,The method has 5 parameters. Parameters: animeID' anistart' tvdbID' tvdbSeason' title
Long Parameter List,Shoko.Server.PlexAndKodi,Helper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Helper.cs,MayReplaceVideo,The method has 6 parameters. Parameters: v1' ser' cserie' userid' all' serie
Long Parameter List,Shoko.Server.PlexAndKodi,Helper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Helper.cs,GenerateFromSeries,The method has 5 parameters. Parameters: cserie' ser' anidb' userid' session
Long Parameter List,Shoko.Server.PlexAndKodi,Helper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Helper.cs,FillSerie,The method has 6 parameters. Parameters: p' aser' eps' anidb' ser' userid
Long Parameter List,Shoko.Server.PlexAndKodi.Plex,PlexProvider,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Plex\PlexProvider.cs,NewMediaContainer,The method has 5 parameters. Parameters: type' title' allowsync' nocache' info
Long Parameter List,Shoko.Server.Tasks,ContractExtractor,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Tasks\ContractExtractor.cs,CreateEntryNameProjection,The method has 6 parameters. Parameters: prefix1' keyCol1' prefix2' keyCol2' prefix3' keyCol3
Long Parameter List,Shoko.Server.LZ4,CompressionHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\CompressionHelper.cs,Encode,The method has 6 parameters. Parameters: input' inputOffset' inputLength' output' outputOffset' outputLength
Long Parameter List,Shoko.Server.LZ4,CompressionHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\CompressionHelper.cs,Decode,The method has 7 parameters. Parameters: input' inputOffset' inputLength' output' outputOffset' outputLength' knowouputlength
Long Parameter List,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,CheckArguments,The method has 6 parameters. Parameters: input' inputOffset' inputLength' output' outputOffset' outputLength
Long Parameter List,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,BlockCopy,The method has 5 parameters. Parameters: src' src_0' dst' dst_0' len
Long Parameter List,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,WildCopy,The method has 5 parameters. Parameters: src' src_0' dst' dst_0' dst_end
Long Parameter List,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Encode32,The method has 6 parameters. Parameters: input' inputOffset' inputLength' output' outputOffset' outputLength
Long Parameter List,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Encode64,The method has 6 parameters. Parameters: input' inputOffset' inputLength' output' outputOffset' outputLength
Long Parameter List,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Decode32,The method has 7 parameters. Parameters: input' inputOffset' inputLength' output' outputOffset' outputLength' knownOutputLength
Long Parameter List,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Decode64,The method has 7 parameters. Parameters: input' inputOffset' inputLength' output' outputOffset' outputLength' knownOutputLength
Long Parameter List,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4HC_Create,The method has 6 parameters. Parameters: src' src_0' src_len' dst' dst_0' dst_len
Long Parameter List,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressHC_32,The method has 6 parameters. Parameters: input' inputOffset' inputLength' output' outputOffset' outputLength
Long Parameter List,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Encode32HC,The method has 6 parameters. Parameters: input' inputOffset' inputLength' output' outputOffset' outputLength
Long Parameter List,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressHC_64,The method has 6 parameters. Parameters: input' inputOffset' inputLength' output' outputOffset' outputLength
Long Parameter List,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Encode64HC,The method has 6 parameters. Parameters: input' inputOffset' inputLength' output' outputOffset' outputLength
Long Parameter List,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe32,The method has 7 parameters. Parameters: hash_table' src' dst' src_0' dst_0' src_len' dst_maxlen
Long Parameter List,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe32,The method has 7 parameters. Parameters: hash_table' src' dst' src_0' dst_0' src_len' dst_maxlen
Long Parameter List,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe32,The method has 5 parameters. Parameters: src' dst' src_0' dst_0' dst_len
Long Parameter List,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe32,The method has 6 parameters. Parameters: src' dst' src_0' dst_0' src_len' dst_maxlen
Long Parameter List,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4HC_InsertAndGetWiderMatch_32,The method has 6 parameters. Parameters: ctx' src_p' startLimit' longest' matchpos' startpos
Long Parameter List,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_encodeSequence_32,The method has 7 parameters. Parameters: ctx' src_p' dst_p' src_anchor' matchLength' src_ref' dst_end
Long Parameter List,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe64,The method has 7 parameters. Parameters: hash_table' src' dst' src_0' dst_0' src_len' dst_maxlen
Long Parameter List,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe64,The method has 7 parameters. Parameters: hash_table' src' dst' src_0' dst_0' src_len' dst_maxlen
Long Parameter List,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe64,The method has 5 parameters. Parameters: src' dst' src_0' dst_0' dst_len
Long Parameter List,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe64,The method has 6 parameters. Parameters: src' dst' src_0' dst_0' src_len' dst_maxlen
Long Parameter List,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4HC_InsertAndGetWiderMatch_64,The method has 6 parameters. Parameters: ctx' src_p' startLimit' longest' matchpos' startpos
Long Parameter List,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_encodeSequence_64,The method has 6 parameters. Parameters: ctx' src_p' dst_p' src_anchor' matchLength' src_ref
Long Parameter List,Shoko.Server.PlexAndKodi.Kodi,KodiProvider,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Kodi\KodiProvider.cs,NewMediaContainer,The method has 5 parameters. Parameters: type' title' allowsync' nocache' info
Long Parameter List,Shoko.Server.Providers.Azure,AzureWebAPI,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\Azure\AzureWebAPI.cs,Delete_CrossRefAniDBTvDB,The method has 6 parameters. Parameters: animeID' aniDBStartEpisodeType' aniDBStartEpisodeNumber' tvDBID' tvDBSeasonNumber' tvDBStartEpisodeNumber
Long Parameter List,Shoko.Server.Providers.Azure,AzureWebAPI,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\Azure\AzureWebAPI.cs,Delete_CrossRefAniDBTrakt,The method has 6 parameters. Parameters: animeID' aniDBStartEpisodeType' aniDBStartEpisodeNumber' traktID' traktSeasonNumber' traktStartEpisodeNumber
Long Parameter List,Shoko.Server.Providers.MyAnimeList,MALHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\MyAnimeList\MALHelper.cs,LinkAniDBMAL,The method has 6 parameters. Parameters: animeID' malID' malTitle' epType' epNumber' fromWebCache
Long Parameter List,Shoko.Server.Providers.MyAnimeList,MALHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\MyAnimeList\MALHelper.cs,AddAnime,The method has 6 parameters. Parameters: animeId' lastEpisodeWatched' status' score' downloadedEps' fanSubs
Long Parameter List,Shoko.Server.Providers.MyAnimeList,MALHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\MyAnimeList\MALHelper.cs,ModifyAnime,The method has 6 parameters. Parameters: animeId' lastEpisodeWatched' status' score' downloadedEps' fanSubs
Long Parameter List,Shoko.Server.Providers.MyAnimeList,MALHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\MyAnimeList\MALHelper.cs,UpdateAnime,The method has 6 parameters. Parameters: animeId' lastEpisodeWatched' status' score' downloadedEps' fanSubs
Long Parameter List,Shoko.Server.Providers.TraktTV.Contracts,TraktV2ScrobbleEpisode,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\Contracts\TraktV2ScrobbleEpisode.cs,Init,The method has 5 parameters. Parameters: progressVal' traktId' slugId' season' episodeNumber
Long Parameter List,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,SendData,The method has 5 parameters. Parameters: uri' json' verb' headers' webResponse
Long Parameter List,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,LinkAniDBTrakt,The method has 7 parameters. Parameters: animeID' aniEpType' aniEpNumber' traktID' seasonNumber' traktEpNumber' excludeFromWebCache
Long Parameter List,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,LinkAniDBTrakt,The method has 8 parameters. Parameters: session' animeID' aniEpType' aniEpNumber' traktID' seasonNumber' traktEpNumber' excludeFromWebCache
Long Parameter List,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,RemoveLinkAniDBTrakt,The method has 6 parameters. Parameters: animeID' aniEpType' aniEpNumber' traktID' seasonNumber' traktEpNumber
Long Parameter List,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,GetTraktEpisodeIdV2,The method has 5 parameters. Parameters: anime' ep' traktID' season' epNumber
Long Parameter List,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,GetTraktEpisodeIdV2,The method has 5 parameters. Parameters: traktSummary' ep' traktID' season' epNumber
Long Parameter List,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,SyncEpisodeToTrakt,The method has 5 parameters. Parameters: syncType' slug' season' epNumber' epDate
Long Parameter List,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,ReconSyncTraktEpisode,The method has 6 parameters. Parameters: ser' ep' traktUsers' collected' watched' sendNow
Long Parameter List,Shoko.Server.Providers.TraktTV,EpisodeSyncDetails,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,EpisodeSyncDetails,The method has 5 parameters. Parameters: syncType' slug' season' epNumber' epDate
Long Identifier,Shoko.Server,ServerInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\UI\ServerInfo.cs,,The length of the parameter waitingOnResponseAniDBUDPString is 31.
Long Identifier,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,,The length of the parameter NOTCOMPRESSIBLE_DETECTIONLEVEL is 30.
Long Statement,Shoko.Server,AniDBHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDBHelper.cs,GetMyListFileStatus,The length of the statement  "                var vids = aniFile.EpisodeIDs.SelectMany(a => RepoFactory.VideoLocal.GetByAniDBEpisodeID(a)).Where(a => a != null).ToList(); " is 124.
Long Statement,Shoko.Server,AniDBHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDBHelper.cs,AddFileToMyList,The length of the statement  "            if (ev == enHelperActivityType.FileAlreadyExists && cmdAddFile.FileData != null && ServerSettings.AniDB_MyList_ReadWatched) " is 123.
Long Statement,Shoko.Server,AniDBHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDBHelper.cs,ValidAniDBCredentials,The length of the statement  "                //OnAniDBStatusEvent(new AniDBStatusEventArgs(enHelperActivityType.OtherError' "ERROR: Please enter valid AniDB credentials via Configuration first")); " is 151.
Long Statement,Shoko.Server,AniDBHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDBHelper.cs,BindToLocalPort,The length of the statement  "            // Dont send Expect 100 requests. These requests arnt always supported by remote internet devices' in which case can cause failure. " is 131.
Long Statement,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,LinkAniDBTvDB,The length of the statement  "                // we don't need to proactively remove the link here anymore' as all links are removed when it is not marked as additive " is 120.
Long Statement,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,LinkAniDBMAL,The length of the statement  "                    //return string.Format("Not using MAL link as this Anime ID ({0}) is already in use by {1}/{2}/{3} ({4})"' animeID' xrefTemp.MALID' epType' epNumber' xrefTemp.MALTitle); " is 169.
Long Statement,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,RenameFilePreview,The length of the statement  "                    ret.NewFileName = RenameFileHelper.GetRenamer(Shoko.Models.Constants.Renamer.TempFileName)?.GetFileName(vid.GetBestVideoLocalPlace()); " is 134.
Long Statement,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetMissingEpisodes,The length of the statement  "                            $"{gvq.GroupNameShort} - {gvq.Resolution}/{gvq.VideoSource}/{gvq.VideoBitDepth}bit ({gvq.NormalEpisodeNumberSummary})"); " is 120.
Long Statement,Shoko.Server,RenameFileHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Renamer\RenameFileHelper.cs,InitialiseRenamers,The length of the statement  "                        logger.Warn($"[RENAMER] Warning Duplicate renamer key \"{key}\" of types {implementation}@{implementation.GetAssemblyPath()} and {ScriptImplementations[key]}@{ScriptImplementations[key].GetAssemblyPath()}"); " is 207.
Long Statement,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,StartUpServer,The length of the statement  "            // First check if we have a settings.json in case migration had issues as otherwise might clear out existing old configurations " is 127.
Long Statement,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,UninstallJMMServer,The length of the statement  "            if (Utils.IsRunningOnMono()) return; //This will be handled by the OS or user' as we cannot reliably learn what package management system they use. " is 147.
Long Statement,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,UninstallJMMServer,The length of the statement  "                        @"HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\{898530ED-CFC7-4744-B2B8-A8D98A2FA06C}_is1"' " is 129.
Long Statement,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,WorkerFileEvents_DoWork,The length of the statement  "                            // The reason for this is that when a directory is moved into a source directory (from the same drive) we will only recieve " is 123.
Long Statement,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,WorkerFileEvents_DoWork,The length of the statement  "                            // a create event will fire for the directory and each file contained within it (As they are all treated as separate operations) " is 128.
Long Statement,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,SendToAzure,The length of the statement  "                "9516'6719'9606'8751'7453'6969'7821'7738'6694'6854'6101'8267'9398'9369'7395'7687'7345'8748'6350'6437'6408'7824'6334'8976'4651'7329'6433'8750'9498'8306'6919'8598'6355'6084'6775'8482'6089'7441'7541'7130'9013'6299'6983'7740'6329'6401'9459'8458'8800'7290'8859'6957'8503'6057'7758'7086'7943'8007'8349'6858'7776'7194'8807'6822'8058'7274'6818'9309'9488'7564'9593'8906'6155'7191'7267'7861'7109'9617'7954'7944'6359'7877'7701'7447'8736'7260'8492'9107'9578'6843'7190'9036'7614'6404'6018'8895'6234'6855'7041'7504'6847'6889'7092'8672'9452'9086'8770'4515'8103'8100'8122'9441'7025'8403'6335'9607'8559'7193'7273'7553'6242'7108'7052'6171'9634'7846'8471'7772'7557'9597'7827'6039'6712'7784'7830'8330'6902'6187'8431'8258'7956'7373'8083'8130'7535'8003'8237'7153'8170'7439'8094'9332'6539'6773'6812'7220'7703'7406'7670'7876'8497'8407'7299'9299'7583'7825'7556'6950'8127'7147'7747'9009'6044'6393'6864'7616'9567'8612'6705'7139'7070'6804'7901'8133'7817'6596'6553'8073'6718'8303'7782'8724'6972'8671'6907'8030'7030'7141'6878'8036'8231'7594'6813'7920'7841'7922'7095'6927'6754'6936'7427'7497'9251'7253'8140'9601'6735'7160'7538'6893'7203'7346'6797'6516'8500'8245'8440'7863'7467'7975'8808'6277'6481'6733'8790'7117'7063'6924'8293'6208'6882'6892"; " is 1212.
Long Statement,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,ProcessFileTest,The length of the statement  "            //CommandRequest_HashFile cr_hashfile = new CommandRequest_HashFile(@"M:\[ Anime Test ]\[HorribleSubs] Dragon Crisis! - 02 [720p].mkv"' false); " is 143.
Long Statement,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,ProcessFileTest,The length of the statement  "            //CommandRequest_ProcessFile cr_procfile = new CommandRequest_ProcessFile(@"M:\[ Anime Test ]\[Doki] Saki - 01 (720x480 h264 DVD AAC) [DC73ACB9].mkv"); " is 151.
Long Statement,Shoko.Server,MigrationDirectory,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\MigrationDirectory.cs,SafeMigrate,The length of the statement  "                Utils.ShowErrorMessage("Migration ERROR"'$"We are unable to move the directory '{From}' to '{To}'' please move the directory with explorer"); " is 141.
Long Statement,Shoko.Server,AVDumpHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utilities\AVDumpHelper.cs,DumpFile_Mono,The length of the statement  "                $@"{avdumpDestination} --Auth={ServerSettings.AniDB_Username}:{ServerSettings.AniDB_AVDumpKey} --LPort={ServerSettings.AniDB_AVDumpClientPort} --PrintEd2kLink -t {fileName}"; " is 174.
Long Statement,Shoko.Server,ServerSettings,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ServerSettings.cs,LoadSettingsFromFile,The length of the statement  "                            @"HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\{898530ED-CFC7-4744-B2B8-A8D98A2FA06C}_is1"' " is 129.
Long Statement,Shoko.Server,ServerSettings,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ServerSettings.cs,LoadSettingsFromFile,The length of the statement  "                                    appSettings["FileQualityFilterPreferences"] = JsonConvert.SerializeObject(FileQualityFilter.Settings' Formatting.None' new StringEnumConverter()); " is 146.
Long Statement,Shoko.Server,ServerSettings,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ServerSettings.cs,LoadSettingsFromFile,The length of the statement  "                                appSettings["FileQualityFilterPreferences"] = JsonConvert.SerializeObject(FileQualityFilter.Settings' Formatting.None' new StringEnumConverter()); " is 146.
Long Statement,Shoko.Server,ServerSettings,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ServerSettings.cs,LoadSettingsFromFile,The length of the statement  "                                appSettings["FileQualityFilterPreferences"] = JsonConvert.SerializeObject(FileQualityFilter.Settings' Formatting.None' new StringEnumConverter()); " is 146.
Long Statement,Shoko.Server,ServerSettings,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ServerSettings.cs,LoadSettingsFromFile,The length of the statement  "                            appSettings["FileQualityFilterPreferences"] = JsonConvert.SerializeObject(FileQualityFilter.Settings' Formatting.None' new StringEnumConverter()); " is 146.
Long Statement,Shoko.Server,ServerSettings,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ServerSettings.cs,LoadLegacySettingsFromFile,The length of the statement  "                        @"HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\{898530ED-CFC7-4744-B2B8-A8D98A2FA06C}_is1"' " is 129.
Long Statement,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,GrantAccess,The length of the statement  "                            logger.Error("Unable to set Everyone permissions to '" + path + "' directory' or subdirectories' please chkdsk or set everyone permissions at hand."); " is 150.
Long Statement,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,Tail,The length of the statement  "                1; //The index of the last line read from the buffer.  Everything > this index was read earlier than everything <= this indes " is 125.
Long Statement,AniDBAPI,Raw_AniDB_Episode,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Episode.cs,ProcessEpisodeSource,The length of the statement  "            // 5. 02 ** episode number    Returned 'epno' includes special character (only if special) and padding (only if normal). Special characters are S(special)' C(credits)' T(trailer)' P(parody)' O(other) " is 199.
Long Statement,AniDBAPI,Raw_AniDB_Episode,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Episode.cs,GetValidatedEpisodeNumber,The length of the statement  "            // string socketResponse = "220 FILE226237|3651|48951|3|63249613|feaf5388f7c0c5a38cd8d5e243c2c6e7|de3f16d8|high|DTV|MP3 CBR|128|XviD|894|640x360|avi|1420||1145836800|04'07|The Boredom of Suzumiya Haruhi|Suzumiya Haruhi no Taikutsu|x|802|48|a.f.k.|a.f.k."; " is 255.
Long Statement,AniDBAPI,APIUtils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Utils.cs,DownloadWebBinary,The length of the statement  "                // this is true for instance for EVERY thailand internet connection (also needs to be set for banners/episodethumbs and any other http request we send) " is 151.
Long Statement,AniDBAPI.Commands,AniDBCommand_GetCreatorInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetCreatorInfo.cs,Process,The length of the statement  "                    // 245 CREATOR 200|?????|Suwabe Jun`ichi|1|17015.jpg||http://www.haikyo.or.jp/PROFILE/man/11470.html|Junichi_Suwabe|%E8%AB%8F%E8%A8%AA%E9%83%A8%E9%A0%86%E4%B8%80|1236300570 " is 172.
Long Statement,AniDBAPI.Commands,AniDBCommand_GetFileInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetFileInfo.cs,Init,The length of the statement  "            // 220 FILE572794|6107|99294|2723|c646d82a184a33f4e4f98af39f29a044|8452c4bf|high|HDTV|Vorbis (Ogg Vorbis)|148|H264/AVC|1773|1280x720|mkv|1470||1239494400|2|The Day It Began|Hajimari no Hi|712|14|Eclipse Productions|Eclipse " is 222.
Long Statement,AniDBAPI.Commands,AniDBHTTPCommand_GetMyList,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBHTTPCommand_GetMyList.cs,WriteAnimeMyListToFile,The length of the statement  "            //string fileName = string.Format("MyList_{0}_{1}.xml"' DateTime.Now.ToString("yyyyMMdd")' DateTime.Now.ToString("HHmmss")); " is 124.
Long Statement,Shoko.Server.Commands,CommandRequest_HashFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_HashFile.cs,ProcessFile_LocalInfo,The length of the statement  "                    var hashes = FileHashHelper.GetHashInfo(FileName.Replace("/"' $"{System.IO.Path.DirectorySeparatorChar}")' true' ShokoServer.OnHashProgress' " is 140.
Long Statement,Shoko.Server.Commands,CommandRequest_HashFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_HashFile.cs,FillMissingHashes,The length of the statement  "                Hashes hashes = FileHashHelper.GetHashInfo(FileName.Replace("/"' $"{System.IO.Path.DirectorySeparatorChar}")' true' ShokoServer.OnHashProgress' " is 143.
Long Statement,Shoko.Server.Commands,CommandRequest_LinkFileManually,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_LinkFileManually.cs,ProcessCommand,The length of the statement  "            CommandRequest_WebCacheSendXRefFileEpisode cr = new CommandRequest_WebCacheSendXRefFileEpisode(xref.CrossRef_File_EpisodeID); " is 125.
Long Statement,Shoko.Server.Commands,CommandHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\CommandHelper.cs,LoadCommands,The length of the statement  "            CommandRequestImpls = new Dictionary<CommandRequestType' ReflectionUtils.ObjectActivator<CommandRequestImplementation>>(); " is 122.
Long Statement,Shoko.Server.Commands,CommandHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\CommandHelper.cs,LoadCommands,The length of the statement  "            IEnumerable<Type> types = AppDomain.CurrentDomain.GetAssemblies().SelectMany(a => a.GetTypes()).Where(a => a.GetCustomAttribute<CommandAttribute>() != null); " is 157.
Long Statement,Shoko.Server.Commands,CommandHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\CommandHelper.cs,LoadCommands,The length of the statement  "                    logger.Warn($"Duplicate command of type {attr}' this should never happen without a code error' please report this to the devs."); " is 129.
Long Statement,Shoko.Server.Commands,CommandRequestImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\CommandRequestImplementation.cs,TryGetProperty,The length of the statement  "                //BaseConfig.MyAnimeLog.Write("Error in XMLService.TryGetProperty: {0}-{1}"' Utils.GetParentMethodName()' ex.ToString()); " is 121.
Long Statement,Shoko.Server.Commands,CommandRequest_DeleteFileFromMyList,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\AniDB\CommandRequest_DeleteFileFromMyList.cs,ProcessCommand,The length of the statement  "                            CommandRequest_TraktCollectionEpisode cmdSyncTrakt = new CommandRequest_TraktCollectionEpisode(aep.AnimeEpisodeID' TraktSyncAction.Remove); " is 139.
Long Statement,Shoko.Server.Commands,CommandRequest_GetUpdated,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\AniDB\CommandRequest_GetUpdated.cs,ProcessCommand,The length of the statement  "                        $"{Utils.FormatSecondsToDisplayTime(int.Parse((webUpdateTimeNew - webUpdateTime).ToString()))} since last UPDATED command"); " is 124.
Long Statement,Shoko.Server.Commands,CommandRequest_SyncMyList,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\AniDB\CommandRequest_SyncMyList.cs,ProcessCommand,The length of the statement  "                        logger.Info($"MYLISTDIFF:: File {vl.FileName} - Local Status = {localStatus}' AniDB Status = {myitem.IsWatched} --- {action}"); " is 127.
Long Statement,Shoko.Server.Commands,CommandRequest_SyncMyList,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\AniDB\CommandRequest_SyncMyList.cs,ProcessCommand,The length of the statement  "                logger.Info($"Process MyList: {totalItems} Items' {missingFiles} Added' {filesToRemove.Count} Deleted' {watchedItems} Watched' {modifiedItems} Modified"); " is 154.
Long Statement,Shoko.Server.Commands,CommandRequest_TraktSearchAnime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Trakt\CommandRequest_TraktSearchAnime.cs,ProcessCommand,The length of the statement  "                        if (!string.Equals(title.TitleType' Shoko.Models.Constants.AnimeTitleType.Official' StringComparison.InvariantCultureIgnoreCase)) " is 129.
Long Statement,Shoko.Server.Commands,CommandRequest_TvDBSearchAnime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\TvDB\CommandRequest_TvDBSearchAnime.cs,ProcessCommand,The length of the statement  "                            if (!title.TitleType.Equals(Shoko.Models.Constants.AnimeTitleType.Official' StringComparison.InvariantCultureIgnoreCase)) " is 121.
Long Statement,Shoko.Server.API,StatusCodeHandler,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\Bootstrapper.cs,HandlesStatusCode,The length of the statement  "            return statusCode == HttpStatusCode.NotFound && (context?.ResolvedRoute?.Description?.Path?.StartsWith("/webui/") ?? false); " is 124.
Long Statement,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,GetSerie,The length of the statement  "            return GetSerieById(para.id' para.nocast != 0' para.notag != 0' para.level' para.all != 0' para.allpics != 0' para.pic' para.tagfilter); " is 136.
Long Statement,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,SeriesToday,The length of the statement  "                para.notag == 1' para.level' para.all == 1' para.allpics == 1' para.pic' para.tagfilter)).OrderBy(a => a.name).ToList(); " is 120.
Long Statement,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,SearchForSerie,The length of the statement  "                    para.nocast != 0' para.notag != 0' para.level' para.all != 0' para.fuzzy != 0' para.allpics != 0' para.pic' para.tagfilter); " is 124.
Long Statement,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,GetSerieFromEpisode,The length of the statement  "                return Serie.GenerateFromAnimeSeries(Context' aep.GetAnimeSeries()' uid' nocast' notag' level' all' allpic' pic' tagfilter); " is 124.
Long Statement,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,GetAllSeries,The length of the statement  "                    allseries.Add(Serie.GenerateFromAnimeSeries(Context' asi' user.JMMUserID' nocast' notag' level' all' allpic' pic' tagfilter)); " is 126.
Long Statement,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,GetFilters,The length of the statement  "                return GetAllFilters(user.JMMUserID' para.nocast != 0' para.notag != 0' para.level' para.all != 0' para.allpics != 0' para.pic' para.tagfilter); " is 144.
Long Statement,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,GetFilters,The length of the statement  "            return GetFilter(para.id' user.JMMUserID' para.nocast != 0' para.notag != 0' para.level' para.all != 0' para.allpics != 0' para.pic' para.tagfilter); " is 149.
Long Statement,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,GetGroups,The length of the statement  "                return GetAllGroups(user.JMMUserID' para.nocast != 0' para.notag != 0' para.level' para.all != 0' para.allpics != 0' para.pic' para.tagfilter); " is 143.
Long Statement,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,GetGroup,The length of the statement  "                Group gr = Group.GenerateFromAnimeGroup(Context' ag' uid' nocast' notag' level' all' filterid' allpics' pic' tagfilter); " is 120.
Long Statement,Shoko.Server.API.v2.Modules,Init,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Init.cs,GetAniDB,The length of the statement  "                    "The ports are not set as integers. Set them and try again.\n\rThe default values are:\n\rAniDB Client Port: 4556\n\rAniDB AVDump Client Port: 4557"); " is 150.
Long Statement,Shoko.Server.API.v2.Modules,PlexWebhook,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\PlexWebhook.cs,TraktScrobble,The length of the statement  "            float per = 100 * (metadata.ViewOffset / (float)vl.Duration); //this will be nice if plex would ever give me the duration' so I don't have to guess it. " is 151.
Long Statement,Shoko.Server.API.v2.Modules,PlexWebhook,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\PlexWebhook.cs,TraktScrobble,The length of the statement  "            ScrobblePlayingType scrobbleType = episode.PlexContract.IsMovie ? ScrobblePlayingType.movie : ScrobblePlayingType.episode; " is 122.
Long Statement,Shoko.Server.API.v2.Modules,PlexWebhook,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\PlexWebhook.cs,Scrobble,The length of the statement  "                logger.Info($"Unable to determine who \"{data.Account.Title}\" is in Shoko' make sure this is set under user settings in Desktop"); " is 131.
Long Statement,Shoko.Server.Databases,DatabaseFixes,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Databases\DatabaseFixes.cs,PopulateAniDBEpisodeDescriptions,The length of the statement  "                        $"There was an error Populating AniDB_Episode Descriptions for AniDB_Anime {animeID}' Update the Series' AniDB Info for a full stack: {e.Message}"); " is 148.
Long Statement,Shoko.Server.Databases,MySQL,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Databases\MySQL.cs,GetConnectionString,The length of the statement  "                $"Server={ServerSettings.MySQL_Hostname};Database={ServerSettings.MySQL_SchemaName};User ID={ServerSettings.MySQL_Username};Password={ServerSettings.MySQL_Password};Default Command Timeout=3600"; " is 195.
Long Statement,Shoko.Server.Databases,MySQL,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Databases\MySQL.cs,DatabaseAlreadyExists,The length of the statement  "                    $"Server={ServerSettings.MySQL_Hostname};User ID={ServerSettings.MySQL_Username};Password={ServerSettings.MySQL_Password}"; " is 123.
Long Statement,Shoko.Server.Databases,MySQL,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Databases\MySQL.cs,CreateDatabase,The length of the statement  "                    $"Server={ServerSettings.MySQL_Hostname};User ID={ServerSettings.MySQL_Username};Password={ServerSettings.MySQL_Password}"; " is 123.
Long Statement,Shoko.Server.Databases,MySQL,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Databases\MySQL.cs,CreateAndUpdateSchema,The length of the statement  "                    $"select count(*) from information_schema.tables where table_schema='{ServerSettings.MySQL_SchemaName}' and table_name = 'Versions'"); " is 134.
Long Statement,Shoko.Server.Databases,MySQL,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Databases\MySQL.cs,CreateAndUpdateSchema,The length of the statement  "                        $"select count(*) from information_schema.tables where table_schema='{ServerSettings.MySQL_SchemaName}' and table_name = 'versions'"); " is 134.
Long Statement,Shoko.Server.Databases,MySQL,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Databases\MySQL.cs,CreateAndUpdateSchema,The length of the statement  "                    $"select count(*) from information_schema.columns where table_schema='{ServerSettings.MySQL_SchemaName}' and table_name = 'Versions' and column_name = 'VersionRevision'"); " is 171.
Long Statement,Shoko.Server.Databases,SQLite,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Databases\SQLite.cs,DropAniDB_AnimeAllCategories,The length of the statement  "                    "CREATE TABLE AniDB_Anime ( AniDB_AnimeID INTEGER PRIMARY KEY AUTOINCREMENT' AnimeID int NOT NULL' EpisodeCount int NOT NULL' AirDate timestamp NULL' EndDate timestamp NULL' URL text NULL' Picname text NULL' BeginYear int NOT NULL' EndYear int NOT NULL' AnimeType int NOT NULL' MainTitle text NOT NULL' AllTitles text NOT NULL' AllTags text NOT NULL' Description text NOT NULL' EpisodeCountNormal int NOT NULL' EpisodeCountSpecial int NOT NULL' Rating int NOT NULL' VoteCount int NOT NULL' TempRating int NOT NULL' TempVoteCount int NOT NULL' AvgReviewRating int NOT NULL' ReviewCount int NOT NULL' DateTimeUpdated timestamp NOT NULL' DateTimeDescUpdated timestamp NOT NULL' ImageEnabled int NOT NULL' AwardList text NOT NULL' Restricted int NOT NULL' AnimePlanetID int NULL' ANNID int NULL' AllCinemaID int NULL' AnimeNfo int NULL' LatestEpisodeNumber int NULL' DisableExternalLinksFlag int NULL );"; " is 901.
Long Statement,Shoko.Server.Databases,SQLite,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Databases\SQLite.cs,DropVideolocalColumns,The length of the statement  "                    "CREATE TABLE VideoLocal ( VideoLocalID INTEGER PRIMARY KEY AUTOINCREMENT' Hash text NOT NULL' CRC32 text NULL' MD5 text NULL' SHA1 text NULL' HashSource int NOT NULL' FileSize INTEGER NOT NULL' IsIgnored int NOT NULL' DateTimeUpdated timestamp NOT NULL' FileName text NOT NULL DEFAULT ''' VideoCodec text NOT NULL DEFAULT ''' VideoBitrate text NOT NULL DEFAULT '''VideoBitDepth text NOT NULL DEFAULT '''VideoFrameRate text NOT NULL DEFAULT '''VideoResolution text NOT NULL DEFAULT '''AudioCodec text NOT NULL DEFAULT '''AudioBitrate text NOT NULL DEFAULT '''Duration INTEGER NOT NULL DEFAULT 0'DateTimeCreated timestamp NULL' IsVariation int NULL'MediaVersion int NOT NULL DEFAULT 0'MediaBlob BLOB NULL'MediaSize int NOT NULL DEFAULT 0 );"; " is 741.
Long Statement,Shoko.Server.Databases,SQLite,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Databases\SQLite.cs,DropTvDB_EpisodeFirstAiredColumn,The length of the statement  "                    "CREATE TABLE TvDB_Episode ( TvDB_EpisodeID INTEGER PRIMARY KEY AUTOINCREMENT' Id int NOT NULL' SeriesID int NOT NULL' SeasonID int NOT NULL' SeasonNumber int NOT NULL' EpisodeNumber int NOT NULL' EpisodeName text' Overview text' Filename text' EpImgFlag int NOT NULL' AbsoluteNumber int' AirsAfterSeason int' AirsBeforeEpisode int' AirsBeforeSeason int' AirDate timestamp' Rating int)"; " is 387.
Long Statement,Shoko.Server.Databases,SQLite,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Databases\SQLite.cs,AlterVideoLocalUser,The length of the statement  "                    "CREATE TABLE VideoLocal_User ( VideoLocal_UserID INTEGER PRIMARY KEY AUTOINCREMENT' JMMUserID int NOT NULL' VideoLocalID int NOT NULL' WatchedDate timestamp NULL' ResumePosition bigint NOT NULL DEFAULT 0); "; " is 209.
Long Statement,Shoko.Server.Databases,SQLServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Databases\SQLServer.cs,GetConnectionString,The length of the statement  "                $"Server={ServerSettings.DatabaseServer};Database={ServerSettings.DatabaseName};UID={ServerSettings.DatabaseUsername};PWD={ServerSettings.DatabasePassword};"; " is 158.
Long Statement,Shoko.Server.Databases,SQLServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Databases\SQLServer.cs,DatabaseAlreadyExists,The length of the statement  "                    $"Server={ServerSettings.DatabaseServer};User ID={ServerSettings.DatabaseUsername};Password={ServerSettings.DatabasePassword};database={"master"}") " is 147.
Long Statement,Shoko.Server.Databases,SQLServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Databases\SQLServer.cs,CreateAndUpdateSchema,The length of the statement  "                                   "SELECT count(*) FROM INFORMATION_SCHEMA.COLUMNS WHERE [TABLE_NAME] = 'Versions' and [COLUMN_NAME]='VersionRevision'") == " is 121.
Long Statement,Shoko.Server.FileHelper,Hasher,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\Hasher.cs,CalculateHashes,The length of the statement  "                    if (!Utils.IsLinux) filename = strPath.StartsWith(@"\\") ? strPath : @"\\?\" + strPath; //only prepend non-UNC paths (or paths that have this already) " is 150.
Long Statement,Shoko.Server.Models,SVR_VideoLocal_Place,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_VideoLocal_Place.cs,RenameFile,The length of the statement  "            var renamer = string.IsNullOrEmpty(scriptName) ? RenameFileHelper.GetRenamer() : RenameFileHelper.GetRenamer(scriptName); " is 121.
Long Statement,Shoko.Server.Models,SVR_VideoLocal_Place,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_VideoLocal_Place.cs,FillVideoInfoFromMedia,The length of the statement  "            info.VideoCodec = !string.IsNullOrEmpty(m.VideoCodec) ? m.VideoCodec : m.Parts.SelectMany(a => a.Streams).FirstOrDefault(a => a.StreamType == "1")?.CodecID ?? string.Empty; " is 172.
Long Statement,Shoko.Server.Models,SVR_VideoLocal_Place,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_VideoLocal_Place.cs,FillVideoInfoFromMedia,The length of the statement  "            info.AudioCodec = !string.IsNullOrEmpty(m.AudioCodec) ? m.AudioCodec : m.Parts.SelectMany(a => a.Streams).FirstOrDefault(a => a.StreamType == "2")?.CodecID ?? string.Empty; " is 172.
Long Statement,Shoko.Server.Models,SVR_VideoLocal_Place,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_VideoLocal_Place.cs,RefreshMediaInfo,The length of the statement  "                logger.Error($"Unable to read the media information of file {FullServerPath ?? VideoLocal_Place_ID.ToString()} ERROR: {e}"); " is 124.
Long Statement,Shoko.Server.Models,SVR_VideoLocal_Place,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_VideoLocal_Place.cs,RenameAndMoveAsRequired,The length of the statement  "            Utilities.LinuxFS.SetLinuxPermissions(this.FullServerPath' ServerSettings.Linux_UID' ServerSettings.Linux_GID' ServerSettings.Linux_Permission); " is 144.
Long Statement,Shoko.Server.Models,SVR_VideoLocal_Place,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_VideoLocal_Place.cs,MoveFileIfRequired,The length of the statement  "                (var destImpl' string newFolderPath) = RenameFileHelper.GetRenamerWithFallback()?.GetDestinationFolder(this) ?? (null' null); " is 125.
Long Statement,Shoko.Server.Models,SVR_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AniDB_Anime.cs,CreateRelations,The length of the statement  "                    //CommandRequest_GetAnimeHTTP cr_anime = new CommandRequest_GetAnimeHTTP(rawrel.RelatedAnimeID' false' downloadRelations); " is 122.
Long Statement,Shoko.Server.Models,SVR_AnimeSeries,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeSeries.cs,GetAnimeEpisodesNormalCountWithVideoLocal,The length of the statement  "                            "Select count(*) FROM AnimeEpisode as aepi' AniDB_Episode as epi WHERE aepi.AniDB_EpisodeID = epi.EpisodeID AND epi.EpisodeType=1 AND (select count(*) from VideoLocal as vl' CrossRef_File_Episode as xref where vl.Hash = xref.Hash and xref.EpisodeID = epi.EpisodeID) > 0 AND aepi.AnimeSeriesID = :animeid") " is 305.
Long Statement,Shoko.Server.Models,SVR_AnimeSeries,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeSeries.cs,GetAnimeNumberOfEpisodeTypes,The length of the statement  "                            "Select count(distinct epi.EpisodeType) FROM AnimeEpisode as aepi' AniDB_Episode as epi WHERE aepi.AniDB_EpisodeID = epi.EpisodeID AND epi.EpisodeType=1 AND (select count(*) from VideoLocal as vl' CrossRef_File_Episode as xref where vl.Hash = xref.Hash and xref.EpisodeID = epi.EpisodeID) > 0 AND aepi.AnimeSeriesID = :animeid") " is 328.
Long Statement,Shoko.Server.Models,SVR_AnimeSeries,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeSeries.cs,GetAnimeEpisodesCountWithVideoLocal,The length of the statement  "                            "Select count(*) FROM AnimeEpisode as aepi' AniDB_Episode as epi WHERE aepi.AniDB_EpisodeID = epi.EpisodeID AND (select count(*) from VideoLocal as vl' CrossRef_File_Episode as xref where vl.Hash = xref.Hash and xref.EpisodeID = epi.EpisodeID) > 0 AND aepi.AnimeSeriesID = :animeid") " is 283.
Long Statement,Shoko.Server.Models,SVR_AnimeSeries,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeSeries.cs,GetConditionTypesChanged,The length of the statement  "            if (oldcontract?.AniDBAnime?.Stat_AllSeasons == null || !oldcontract.AniDBAnime.Stat_AllSeasons.SetEquals(newcontract.AniDBAnime.Stat_AllSeasons)) " is 146.
Long Statement,Shoko.Server.Models,SVR_GroupFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_GroupFilter.cs,CalculateGroupsAndSeries,The length of the statement  "                        .Error("While calculating group filters' an AnimeSeries without a group was found: " + (ser?.GetSeriesName() ?? id.ToString())); " is 128.
Long Statement,Shoko.Server.Models,SVR_GroupFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_GroupFilter.cs,EvaluateContract,The length of the statement  "                    gf.SeriesIds[user] = gf.GroupsIds[user].SelectMany(a => RepoFactory.AnimeGroup.GetByID(a)?.GetAllSeries()?.Select(b => b?.AnimeSeriesID ?? -1)) " is 143.
Long Statement,Shoko.Server.Models,SVR_GroupFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_GroupFilter.cs,EvaluateConditions,The length of the statement  "                    if ((gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include || gfc.GetConditionOperatorEnum() == GroupFilterOperator.In) && " is 130.
Long Statement,Shoko.Server.Models,SVR_GroupFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_GroupFilter.cs,EvaluateConditions,The length of the statement  "                    if ((gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude || gfc.GetConditionOperatorEnum() == GroupFilterOperator.NotIn) && " is 133.
Long Statement,Shoko.Server.Providers.TvDB,TvDBApiHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TvDB\TvDBApiHelper.cs,SearchSeriesAsync,The length of the statement  "                    $"TvDB returned an error code: {exception.StatusCode}\n        {exception.Message}\n        when searching for {criteria}"); " is 124.
Long Statement,Shoko.Server.Providers.TvDB,TvDBApiHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TvDB\TvDBApiHelper.cs,LinkAniDBTvDB,The length of the statement  "                $"Adding TvDB Link: AniDB(ID:{animeID}|Type:{aniEpType}|Number:{aniEpNumber}) -> TvDB(ID:{tvDBID}|Season:{tvSeasonNumber}|Number:{tvEpNumber})"); " is 145.
Long Statement,Shoko.Server.Providers.TvDB,TvDBRateLimiter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TvDB\TvDBRateLimiter.cs,EnsureRate,The length of the statement  "                logger.Trace($"TvDBRateLimiter#{InstanceID}: Time since last request is {delay} ms' throttling for {currentDelay} ms."); " is 120.
Long Statement,Shoko.Server.Renamer,LegacyRenamer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Renamer\LegacyRenamer.cs,EvaluateTestD,The length of the statement  "                return notCondition ? aniFile.Languages.All(lan => !lan.LanguageName.Trim().Equals(test.Trim()' StringComparison.InvariantCultureIgnoreCase)) : aniFile.Languages.Any(lan => lan.LanguageName.Trim().Equals(test.Trim()' StringComparison.InvariantCultureIgnoreCase)); " is 263.
Long Statement,Shoko.Server.Renamer,LegacyRenamer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Renamer\LegacyRenamer.cs,GetDestinationFolder,The length of the statement  "                if (!fldr.CloudID.HasValue && !video.ImportFolder.ImportFolderLocation.StartsWith(Path.GetPathRoot(fldr.ImportFolderLocation))) " is 127.
Long Statement,Shoko.Server.Repositories.Cached,AnimeEpisodeRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\AnimeEpisodeRepository.cs,GetByAniDBEpisodeID,The length of the statement  "                //AniDB_Episode may not unique for the series' Example with Toriko Episode 1 and One Piece 492' same AniDBEpisodeID in two shows. " is 129.
Long Statement,Shoko.Server.Repositories.Cached,AnimeEpisodeRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\AnimeEpisodeRepository.cs,GetEpisodesWithMultipleFiles,The length of the statement  "                    @"SELECT ani.EpisodeID FROM VideoLocal AS vl JOIN CrossRef_File_Episode ani ON vl.Hash = ani.Hash WHERE vl.IsVariation = 0 AND vl.Hash != '' GROUP BY ani.EpisodeID HAVING COUNT(ani.EpisodeID) > 1"; " is 197.
Long Statement,Shoko.Server.Repositories.Cached,AnimeEpisodeRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\AnimeEpisodeRepository.cs,GetEpisodesWithMultipleFiles,The length of the statement  "                    @"SELECT ani.EpisodeID FROM VideoLocal AS vl JOIN CrossRef_File_Episode ani ON vl.Hash = ani.Hash WHERE vl.Hash != '' GROUP BY ani.EpisodeID HAVING COUNT(ani.EpisodeID) > 1"; " is 174.
Long Statement,Shoko.Server.Repositories,AniDB_AnimeRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\AniDB_AnimeRepository.cs,GetDefaultImagesByAnime,The length of the statement  "                    WHERE defImg.AnimeID IN (:animeIds) AND defImg.ImageParentType IN (:tvdbBannerType' :tvdbCoverType' :tvdbFanartType' :movdbPosterType' :movdbFanartType)") " is 154.
Long Statement,Shoko.Server.PlexAndKodi,HttpExtensions,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\HttpExtensions.cs,GetOptions,The length of the statement  "                "accept' x-plex-token' x-plex-client-identifier' x-plex-username' x-plex-product' x-plex-device' x-plex-platform' x-plex-platform-version' x-plex-version' x-plex-device-name"); " is 176.
Long Statement,Shoko.Server.PlexAndKodi,CommonImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\CommonImplementation.cs,Search,The length of the statement  "            //List<AniDB_Anime> animes = searchTag ? RepoFactory.AniDB_Anime.SearchByTag(query) : RepoFactory.AniDB_Anime.SearchByName(query); " is 130.
Long Statement,Shoko.Server.PlexAndKodi,Extensions,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Extensions.cs,ConstructFakeIosThumb,The length of the statement  "                    return Helper.ServerUrl(prov.ServicePort' prov.ServiceAddress + "/Metadata/" + userid + "/" + (int)JMMType.FakeIosThumb + "/" + r + "/0"); " is 138.
Long Statement,Shoko.Server.PlexAndKodi,Extensions,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Extensions.cs,ConstructFakeIosThumb,The length of the statement  "            catch { return Helper.ServerUrl(prov.ServicePort' prov.ServiceAddress + "/Metadata/" + userid + "/" + (int)JMMType.FakeIosThumb + "/" + r + "/0"); } " is 148.
Long Statement,Shoko.Server.PlexAndKodi,Helper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Helper.cs,GenerateVideoFromAnimeEpisode,The length of the statement  "                                        $"{anime}:  Episode {aep.EpisodeNumber} - {aep.EnglishName} did not match an episode to its TvDB Link. Please check the TvDB links for it."); " is 141.
Long Statement,Shoko.Server.Tasks,AutoAnimeGroupCalculator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Tasks\AutoAnimeGroupCalculator.cs,ShouldConsiderAnimeRelation,The length of the statement  "            // Are we configured to do a fuzzy title test for this particular relation type? If not' then the relation is immediately allowed " is 129.
Long Statement,Shoko.Server.Tasks,AnimeGroupCreator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Tasks\AnimeGroupCreator.cs,CreateTempAnimeGroup,The length of the statement  "            // We won't use AnimeGroupRepository.Save because we don't need to perform all the extra stuff since this is for temporary use only " is 131.
Long Statement,Shoko.Server.Tasks,AnimeGroupCreator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Tasks\AnimeGroupCreator.cs,UpdateAnimeSeriesContractsAndSave,The length of the statement  "            // Update batches of AnimeSeries contracts in parallel. Each parallel branch requires it's own session since NHibernate sessions aren't thread safe. " is 148.
Long Statement,Shoko.Server.Tasks,AnimeGroupCreator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Tasks\AnimeGroupCreator.cs,UpdateAnimeSeriesContractsAndSave,The length of the statement  "            // The reason we're doing this in parallel is because updating contacts does a reasonable amount of work (including LZ4 compression) " is 132.
Long Statement,Shoko.Server.Tasks,AnimeGroupCreator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Tasks\AnimeGroupCreator.cs,UpdateAnimeGroupsAndTheirContracts,The length of the statement  "            // Update batches of AnimeGroup contracts in parallel. Each parallel branch requires it's own session since NHibernate sessions aren't thread safe. " is 147.
Long Statement,Shoko.Server.Tasks,AnimeGroupCreator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Tasks\AnimeGroupCreator.cs,UpdateAnimeGroupsAndTheirContracts,The length of the statement  "            // The reason we're doing this in parallel is because updating contacts does a reasonable amount of work (including LZ4 compression) " is 132.
Long Statement,Shoko.Server.Tasks,AnimeGroupCreator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Tasks\AnimeGroupCreator.cs,UpdateAnimeGroupsAndTheirContracts,The length of the statement  "                    // We shouldn't need to keep track of updates to AnimeGroup_Users in the below call' because they should have all been deleted' " is 127.
Long Statement,Shoko.Server.Tasks,AnimeGroupCreator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Tasks\AnimeGroupCreator.cs,UpdateAnimeGroupsAndTheirContracts,The length of the statement  "            // NOTE: There are situations in which UpdatePlexKodiContracts will cause database database writes to occur' so we can't " is 120.
Long Statement,Shoko.Server.Tasks,AnimeGroupCreator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Tasks\AnimeGroupCreator.cs,UpdateGroupFilters,The length of the statement  "            Dictionary<int' ILookup<int' int>> seriesForTagGroupFilter = _groupFilterRepo.CalculateAnimeSeriesPerTagGroupFilter(session); " is 125.
Long Statement,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe32,The length of the statement  "			if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0) " is 121.
Long Statement,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe32,The length of the statement  "					if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals) " is 217.
Long Statement,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe64,The length of the statement  "			if (src_p == src_end) goto _output_error; // A correctly formed null-compressed LZ4 must have at least one byte (token=0) " is 121.
Long Statement,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe64,The length of the statement  "					if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals) " is 217.
Long Statement,Shoko.Server.Commands.MAL,CommandRequest_MALDownloadStatusFromMAL,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\MAL\CommandRequest_MALDownloadStatusFromMAL.cs,ProcessCommand,The length of the statement  "                            if (usrRec != null && usrRec.WatchedDate.HasValue) ep.ToggleWatchedStatus(false' true' DateTime.Now' user.JMMUserID' false); " is 124.
Long Statement,Shoko.Server.Utilities,SubStream,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utilities\SubStream.cs,Read,The length of the statement  "            _writer.WriteLine("POSITION: " + oldpos.ToString("X8") + " OFFSET: " + offset.ToString("X8") + " NeedCount: " + count.ToString("X8")); " is 134.
Long Statement,UPnP,NAT,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utilities\UPnP.cs,SOAPRequest,The length of the statement  "                         "<s:Envelope xmlns:s=\"http://schemas.xmlsoap.org/soap/envelope/\" s:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\">" + " is 132.
Long Statement,Shoko.Server.Providers.MyAnimeList,MALHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\MyAnimeList\MALHelper.cs,UpdateMALSeries,The length of the statement  "                // MAL Equivalent = AniDB Normal Eps 1 - 25 / Code Geass: Hangyaku no Lelouch R2 / hxxp://myanimelist.net/anime/2904/Code_Geass:_Hangyaku_no_Lelouch_R2 " is 151.
Long Statement,Shoko.Server.Providers.MyAnimeList,MALHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\MyAnimeList\MALHelper.cs,UpdateMALSeries,The length of the statement  "                // MAL Equivalent = AniDB Special Eps 1 - 9 / Code Geass: Hangyaku no Lelouch R2 Picture Drama / hxxp://myanimelist.net/anime/5163/Code_Geass:_Hangyaku_no_Lelouch_R2_Picture_Drama " is 179.
Long Statement,Shoko.Server.Providers.MyAnimeList,MALHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\MyAnimeList\MALHelper.cs,UpdateMALSeries,The length of the statement  "                // MAL Equivalent = AniDB Special Eps 9 - 18 / Code Geass: Hangyaku no Lelouch R2: Flash Specials / hxxp://myanimelist.net/anime/9591/Code_Geass:_Hangyaku_no_Lelouch_R2:_Flash_Specials " is 184.
Long Statement,Shoko.Server.Providers.MyAnimeList,MALHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\MyAnimeList\MALHelper.cs,UpdateMALSeries,The length of the statement  "                // MAL Equivalent = AniDB Special Eps 20 / Code Geass: Hangyaku no Lelouch - Kiseki no Birthday Picture Drama / hxxp://myanimelist.net/anime/8728/Code_Geass:_Hangyaku_no_Lelouch_-_Kiseki_no_Birthday_Picture_Drama " is 212.
Long Statement,Shoko.Server.Providers.MyAnimeList,MALHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\MyAnimeList\MALHelper.cs,UpdateMALSeries,The length of the statement  "                        if ((ServerSettings.MAL_NeverDecreaseWatchedNums && lastWatchedEpNumberMAL > 0) && lastWatchedEpNumber <= lastWatchedEpNumberMAL) " is 129.
Long Statement,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,ReconSyncTraktEpisode,The length of the statement  "                logger.Trace($"Sync Check Status:  AniDB: {ser.AniDB_ID} - {ep.EpisodeTypeEnum} - {ep.AniDB_EpisodeID} - Collection: {localCollection} - Watched: {localWatched}"); " is 163.
Long Statement,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,ReconSyncTraktEpisode,The length of the statement  "                logger.Trace($"Sync Check Status:  Trakt: {traktShowID} - S:{season} - EP:{epNumber} - Collection: {onlineCollection} - Watched: {onlineWatched}"); " is 147.
Long Statement,LeanWork.IO.FileSystem,BufferingFileSystemWatcher,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utilities\LeanWork\IO\FileSystem\BufferingFileSystemWatcher.cs,BufferEvent,The length of the statement  "                var ex = new EventQueueOverflowException($"Event queue size {_fileSystemEventBuffer.BoundedCapacity} events exceeded."); " is 120.
Long Statement,LeanWork.IO.FileSystem,BufferingFileSystemWatcher,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utilities\LeanWork\IO\FileSystem\BufferingFileSystemWatcher.cs,BufferRenameEvent,The length of the statement  "                var ex = new EventQueueOverflowException($"Event queue size {_fileSystemEventBuffer.BoundedCapacity} events exceeded."); " is 120.
Complex Conditional,Shoko.Server,AniDBHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDBHelper.cs,LogoutTimer_Elapsed,The conditional expression  "tsAniDBUDP.TotalSeconds >= Constants.PingFrequency &&                      tsPing.TotalSeconds >= Constants.PingFrequency &&                      !IsBanned && !ExtendPauseSecs.HasValue"  is complex.
Complex Conditional,Shoko.Server,AniDBHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDBHelper.cs,ValidAniDBCredentials,The conditional expression  "string.IsNullOrEmpty(userName) || string.IsNullOrEmpty(password) ||                  string.IsNullOrEmpty(serverName)                  || string.IsNullOrEmpty(serverPort) || string.IsNullOrEmpty(clientPort)"  is complex.
Complex Conditional,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,SaveImportFolder,The conditional expression  "contract.CloudID == imf.CloudID && imf.IsDropDestination == 1 &&                              (contract.ImportFolderID == 0 || contract.ImportFolderID != imf.ImportFolderID)"  is complex.
Complex Conditional,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetFilesByGroupAndResolution,The conditional expression  "groupMatches && sourceMatches && thisBitDepth == videoBitDepth &&                          resolution.Equals(vidResInfo' StringComparison.InvariantCultureIgnoreCase)"  is complex.
Complex Conditional,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,CompareChapterTo,The conditional expression  "(newAniFile?.IsChaptered == 1 || newFile.Media.Chaptered) &&                  !(oldAniFile?.IsChaptered == 1 || oldFile.Media.Chaptered)"  is complex.
Complex Conditional,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,CompareChapterTo,The conditional expression  "!(newAniFile?.IsChaptered == 1 || newFile.Media.Chaptered) &&                  (oldAniFile?.IsChaptered == 1 || oldFile.Media.Chaptered)"  is complex.
Complex Conditional,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,CompareVideoCodecTo,The conditional expression  "(newLocal.VideoBitDepth.Equals("8") || newLocal.VideoBitDepth.Equals("10")) &&                      (oldLocal.VideoBitDepth.Equals("8") || oldLocal.VideoBitDepth.Equals("10"))"  is complex.
Complex Conditional,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,GetResolutionInternal,The conditional expression  "res == null || res.Length != 2 || res[0] == "0" && res[1] == "0""  is complex.
Complex Conditional,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,GetResolutionInternal,The conditional expression  "res == null || res.Length != 2 || res[0] == "0" && res[1] == "0""  is complex.
Complex Conditional,Shoko.Server,TagFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utilities\TagFilter.cs,ProcessTags,The conditional expression  "tag.StartsWith("plot") || tag.EndsWith(" dies") || tag.EndsWith(" end") ||                          tag.EndsWith(" ending")"  is complex.
Complex Conditional,Shoko.Server,ShokoServiceImplementationStream,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementationStream.cs,StreamFromIFile,The conditional expression  "r.User != null && autowatch.HasValue && autowatch.Value && r.VideoLocal != null"  is complex.
Complex Conditional,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The conditional expression  "(commandType == enAniDBCommandType.Login) && (byReceivedAdd[0] == 0xFE) &&                          (byReceivedAdd[1] == 0xFF) &&                          (byReceivedAdd[3] == 53) && (byReceivedAdd[5] != 53) &&                          !Encoding.EncodingName.ToLower().StartsWith("unicode") && (changeencoding != null) &&                          changeencoding.EncodingName.ToLower().StartsWith("unicode")"  is complex.
Complex Conditional,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The conditional expression  "ResponseCode == 600 || ResponseCode == 601 || ResponseCode == 602 || ResponseCode == 604"  is complex.
Complex Conditional,Shoko.Server.Commands,CommandRequest_GetReleaseGroupStatus,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\AniDB\CommandRequest_GetReleaseGroupStatus.cs,ProcessCommand,The conditional expression  "ServerSettings.AniDB_DownloadReleaseGroups && grpCol != null && grpCol.Groups != null &&                      grpCol.Groups.Count > 0"  is complex.
Complex Conditional,Shoko.Server.API.v2.Models.common,Serie,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Models\common\Serie.cs,CompareTo,The conditional expression  "!string.IsNullOrEmpty(a.air) && !a.air.Equals(DateTime.MinValue.ToString("dd-MM-yyyy")) &&                  !string.IsNullOrEmpty(air) && !air.Equals(DateTime.MinValue.ToString("dd-MM-yyyy"))"  is complex.
Complex Conditional,Shoko.Server.API.v2.Modules,Core,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Core.cs,SetAniDB,The conditional expression  "!String.IsNullOrEmpty(cred.login) && cred.login != string.Empty && !String.IsNullOrEmpty(cred.password) &&                  cred.password != string.Empty"  is complex.
Complex Conditional,Shoko.Server.API.v2.Modules,Core,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Core.cs,SetMAL,The conditional expression  "!String.IsNullOrEmpty(cred.login) && cred.login != string.Empty && !String.IsNullOrEmpty(cred.password) &&                  cred.password != string.Empty"  is complex.
Complex Conditional,Shoko.Server.Extensions,ModelProviders,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Extensions\ModelProviders.cs,Populate,The conditional expression  "rawSim.AnimeID <= 0 || rawSim.Approval < 0 || rawSim.SimilarAnimeID <= 0 || rawSim.Total < 0"  is complex.
Complex Conditional,Shoko.Server.Extensions,ModelProviders,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Extensions\ModelProviders.cs,Populate,The conditional expression  "rawTitle.AnimeID <= 0 || string.IsNullOrEmpty(rawTitle.Title) ||                  string.IsNullOrEmpty(rawTitle.Language) || string.IsNullOrEmpty(rawTitle.TitleType)"  is complex.
Complex Conditional,Shoko.Server.Databases,BaseDatabase<T>,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Databases\BaseDatabase.cs,ExecuteCommand,The conditional expression  "cmd.Version != 0 && cmd.Revision != 0 && AllVersions.ContainsKey(cmd.Version.ToString()) &&                  AllVersions[cmd.Version.ToString()].ContainsKey(cmd.Revision.ToString())"  is complex.
Complex Conditional,Shoko.Server.Models,SVR_AnimeEpisode,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeEpisode.cs,SaveWatchedStatus,The conditional expression  "epUserRecord?.WatchedDate != null && watchedDate != null &&                      epUserRecord.WatchedDate.Equals(watchedDate.Value) ||                      (epUserRecord?.WatchedDate == null && watchedDate == null)"  is complex.
Complex Conditional,Shoko.Server.Models,SVR_AnimeGroup,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeGroup.cs,GetConditionTypesChanged,The conditional expression  "oldcontract == null ||                  (oldcontract.MissingEpisodeCount > 0 || oldcontract.MissingEpisodeCountGroups > 0) !=                  (newcontract.MissingEpisodeCount > 0 || newcontract.MissingEpisodeCountGroups > 0)"  is complex.
Complex Conditional,Shoko.Server.Models,SVR_AnimeGroup,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeGroup.cs,BatchUpdateContracts,The conditional expression  "series.EndDate != null && series.EndDate.Value < now                              && series.MissingEpisodeCount == 0 && series.MissingEpisodeCountGroups == 0"  is complex.
Complex Conditional,Shoko.Server.Models,SVR_AnimeSeries,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeSeries.cs,GetSeriesName,The conditional expression  "tvdbs != null && tvdbs.Count > 0 && !string.IsNullOrEmpty(tvdbs[0].SeriesName) &&                          !tvdbs[0].SeriesName.ToUpper().Contains("**DUPLICATE")"  is complex.
Complex Conditional,Shoko.Server.Models,SVR_AnimeSeries,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeSeries.cs,GetSeriesNameFromContract,The conditional expression  "con.TvDB_Series != null && con.TvDB_Series.Count > 0 &&                  !string.IsNullOrEmpty(con.TvDB_Series[0].SeriesName) &&                  !con.TvDB_Series[0].SeriesName.ToUpper().Contains("**DUPLICATE")"  is complex.
Complex Conditional,Shoko.Server.Models,SVR_AnimeSeries,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeSeries.cs,GetConditionTypesChanged,The conditional expression  "oldcontract == null ||                  (oldcontract.AniDBAnime.AniDBAnime.EndDate.HasValue &&                   oldcontract.AniDBAnime.AniDBAnime.EndDate.Value < DateTime.Now &&                   !(oldcontract.MissingEpisodeCount > 0 ||                     oldcontract.MissingEpisodeCountGroups > 0)) !=                  (newcontract.AniDBAnime.AniDBAnime.EndDate.HasValue &&                   newcontract.AniDBAnime.AniDBAnime.EndDate.Value < DateTime.Now &&                   !(newcontract.MissingEpisodeCount > 0 || newcontract.MissingEpisodeCountGroups > 0))"  is complex.
Complex Conditional,Shoko.Server.Models,SVR_AnimeSeries,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeSeries.cs,GetConditionTypesChanged,The conditional expression  "oldcontract == null ||                  (oldcontract.MissingEpisodeCount > 0 || oldcontract.MissingEpisodeCountGroups > 0) !=                  (newcontract.MissingEpisodeCount > 0 || newcontract.MissingEpisodeCountGroups > 0)"  is complex.
Complex Conditional,Shoko.Server.Models,SVR_AnimeSeries,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeSeries.cs,GetConditionTypesChanged,The conditional expression  "oldcontract == null ||                  ((oldcontract.CrossRefAniDBTvDBV2 == null || oldcontract.CrossRefAniDBTvDBV2.Count == 0) !=                   (newcontract.CrossRefAniDBTvDBV2 == null || newcontract.CrossRefAniDBTvDBV2.Count == 0))"  is complex.
Complex Conditional,Shoko.Server.Models,SVR_AnimeSeries,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeSeries.cs,GetConditionTypesChanged,The conditional expression  "oldcontract == null ||                  ((oldcontract.CrossRefAniDBMAL == null || oldcontract.CrossRefAniDBMAL.Count == 0) !=                   (newcontract.CrossRefAniDBMAL == null || newcontract.CrossRefAniDBMAL.Count == 0))"  is complex.
Complex Conditional,Shoko.Server.Models,SVR_AnimeSeries,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeSeries.cs,GetConditionTypesChanged,The conditional expression  "oldcontract == null ||                  ((oldcontract.CrossRefAniDBMovieDB == null) &&                   (oldcontract.CrossRefAniDBTvDBV2 == null || oldcontract.CrossRefAniDBTvDBV2.Count == 0) !=                   ((newcontract.CrossRefAniDBMovieDB == null) &&                    (newcontract.CrossRefAniDBTvDBV2 == null || newcontract.CrossRefAniDBTvDBV2.Count == 0)))"  is complex.
Complex Conditional,Shoko.Server.Models,SVR_AnimeSeries,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeSeries.cs,GetConditionTypesChanged,The conditional expression  "oldcontract == null ||                  oldcontract.AniDBAnime.AniDBAnime.VoteCount != newcontract.AniDBAnime.AniDBAnime.VoteCount ||                  oldcontract.AniDBAnime.AniDBAnime.TempVoteCount != newcontract.AniDBAnime.AniDBAnime.TempVoteCount ||                  oldcontract.AniDBAnime.AniDBAnime.Rating != newcontract.AniDBAnime.AniDBAnime.Rating ||                  oldcontract.AniDBAnime.AniDBAnime.TempRating != newcontract.AniDBAnime.AniDBAnime.TempRating"  is complex.
Complex Conditional,Shoko.Server.Models,SVR_AnimeSeries,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeSeries.cs,GetConditionTypesChanged,The conditional expression  "oldcontract == null ||                  (oldcontract.AniDBAnime.AniDBAnime.EndDate.HasValue &&                   oldcontract.AniDBAnime.AniDBAnime.EndDate.Value < DateTime.Now) !=                  (newcontract.AniDBAnime.AniDBAnime.EndDate.HasValue &&                   newcontract.AniDBAnime.AniDBAnime.EndDate.Value < DateTime.Now)"  is complex.
Complex Conditional,Shoko.Server.Models,SVR_AnimeSeries,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeSeries.cs,GetConditionTypesChanged,The conditional expression  "oldcontract == null ||                  ((oldcontract.AniDBAnime.UserVote != null) &&                   (oldcontract.AniDBAnime.UserVote.VoteType == (int) AniDBVoteType.Anime)) !=                  ((newcontract.AniDBAnime.UserVote != null) &&                   (newcontract.AniDBAnime.UserVote.VoteType == (int) AniDBVoteType.Anime))"  is complex.
Complex Conditional,Shoko.Server.Models,SVR_VideoLocal,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_VideoLocal.cs,ToggleWatchedStatus,The conditional expression  "(watched && ServerSettings.AniDB_MyList_SetWatched) ||                          (!watched && ServerSettings.AniDB_MyList_SetUnwatched)"  is complex.
Complex Conditional,Shoko.Server.Repositories.Cached,GroupFilterRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\GroupFilterRepository.cs,PostProcess,The conditional expression  "gf.GroupsIdsVersion < SVR_GroupFilter.GROUPFILTER_VERSION ||                      gf.GroupConditionsVersion < SVR_GroupFilter.GROUPCONDITIONS_VERSION ||                      gf.SeriesIdsVersion < SVR_GroupFilter.SERIEFILTER_VERSION ||                      gf.GroupConditionsVersion < SVR_GroupFilter.GROUPCONDITIONS_VERSION"  is complex.
Complex Conditional,Shoko.Server.Repositories.Cached,VideoLocalRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\VideoLocalRepository.cs,PopulateIndexes,The conditional expression  "l.MD5 == null || l.SHA1 == null || l.Hash == null || l.FileName == null"  is complex.
Complex Conditional,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,TranslateVideoStream,The conditional expression  "!string.IsNullOrEmpty(s.Level) && (s.Level == "31") && (s.Cabac == null || s.Cabac == "0")"  is complex.
Complex Conditional,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,TranslateAudioStream,The conditional expression  "(fprofile.ToLower() != "layer 3") && (fprofile.ToLower() != "dolby digital") &&                      (fprofile.ToLower() != "pro") &&                      (fprofile.ToLower() != "layer 2")"  is complex.
Complex Conditional,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,TranslateAudioStream,The conditional expression  "!string.IsNullOrEmpty(fset) && (fset == "Little / Signed") && (s.Codec == "pcm") && (bitdepth == 16)"  is complex.
Complex Conditional,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,TranslateAudioStream,The conditional expression  "!string.IsNullOrEmpty(fset) && (fset == "Big / Signed") && (s.Codec == "pcm") && (bitdepth == 16)"  is complex.
Complex Conditional,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,TranslateAudioStream,The conditional expression  "!string.IsNullOrEmpty(fset) && (fset == "Little / Unsigned") && (s.Codec == "pcm") &&                       (bitdepth == 8)"  is complex.
Complex Conditional,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The conditional expression  "(buffer[4] == 'f') && (buffer[5] == 'r') && (buffer[6] == 'e') && (buffer[7] == 'e')"  is complex.
Complex Conditional,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The conditional expression  "(buffer[4] == 'm') && (buffer[5] == 'o') && (buffer[6] == 'o') && (buffer[7] == 'v')"  is complex.
Complex Conditional,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,FindInBuffer,The conditional expression  "(buffer[start + 4] == atom[0]) && (buffer[start + 5] == atom[1]) &&                      (buffer[start + 6] == atom[2]) &&                      (buffer[start + 7] == atom[3])"  is complex.
Complex Conditional,Shoko.Server.PlexAndKodi,BaseObject,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\BaseObject.cs,GetStream,The conditional expression  "prov.AddEpisodeNumberToTitlesOnUnsupportedClients && (isios || isandroid) && a.Type == "episode""  is complex.
Complex Conditional,Shoko.Server.PlexAndKodi.Plex,PlexDeviceInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Plex\PlexDeviceInfo.cs,PlexDeviceInfo,The conditional expression  "(product != null && product.ToUpperInvariant().Contains("IOS")) ||                  (platform != null && platform.ToUpperInvariant().Contains("IOS"))"  is complex.
Complex Conditional,Shoko.Server.PlexAndKodi.Plex,PlexDeviceInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Plex\PlexDeviceInfo.cs,PlexDeviceInfo,The conditional expression  "(product != null && product.ToUpperInvariant().Contains("ANDROID")) ||                       (platform != null && platform.ToUpperInvariant().Contains("ANDROID"))"  is complex.
Complex Conditional,Shoko.Server.PlexAndKodi.Plex,PlexDeviceInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Plex\PlexDeviceInfo.cs,PlexDeviceInfo,The conditional expression  "(product != null && product.ToUpperInvariant().Contains("PLEX MEDIA PLAYER")) ||                       (platform != null && platform.ToUpperInvariant().Contains("KONVERGO"))"  is complex.
Complex Conditional,Shoko.Server.PlexAndKodi.Plex,PlexDeviceInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Plex\PlexDeviceInfo.cs,PlexDeviceInfo,The conditional expression  "(product != null && product.ToUpperInvariant().Contains("KODI")) ||                       (platform != null && platform.ToUpperInvariant().Contains("KODI"))"  is complex.
Complex Conditional,Shoko.Server.PlexAndKodi.Plex,PlexDeviceInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Plex\PlexDeviceInfo.cs,ToString,The conditional expression  "Device == null && Product == null && Version == null && Platform == null"  is complex.
Complex Conditional,Shoko.Server.Tasks,AutoAnimeGroupCalculator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Tasks\AutoAnimeGroupCalculator.cs,ShouldConsiderAnimeRelation,The conditional expression  "(_exclusions & AutoGroupExclude.Movie) == AutoGroupExclude.Movie &&                  (rel.FromType == AnimeType.Movie || rel.ToType == AnimeType.Movie)                  || (_exclusions & AutoGroupExclude.Ova) == AutoGroupExclude.Ova &&                  (rel.FromType == AnimeType.OVA || rel.ToType == AnimeType.OVA)"  is complex.
Empty Catch Block,Shoko.Server,AniDBHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDBHelper.cs,LogoutTimer_Elapsed,The method has an empty catch block.
Empty Catch Block,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetVideoLocalsForAnime,The method has an empty catch block.
Empty Catch Block,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,LinkAniDBMAL,The method has an empty catch block.
Empty Catch Block,Shoko.Server,Importer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\Importer.cs,SyncHashes,The method has an empty catch block.
Empty Catch Block,Shoko.Server,Importer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\Importer.cs,DeleteImportFolder,The method has an empty catch block.
Empty Catch Block,Shoko.Server,RenameFileHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Renamer\RenameFileHelper.cs,InitialiseRenamers,The method has an empty catch block.
Empty Catch Block,Shoko.Server,RenameFileHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Renamer\RenameFileHelper.cs,InitialiseRenamers,The method has an empty catch block.
Empty Catch Block,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,CheckBlockedFiles,The method has an empty catch block.
Empty Catch Block,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,GenerateAzureList,The method has an empty catch block.
Empty Catch Block,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,SendToAzure,The method has an empty catch block.
Empty Catch Block,Shoko.Server,ServerSettings,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ServerSettings.cs,LoadSettingsFromFile,The method has an empty catch block.
Empty Catch Block,Shoko.Server,ServerSettings,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ServerSettings.cs,GetNameValueCollectionSection,The method has an empty catch block.
Empty Catch Block,Shoko.Server,UnhandledExceptionManager,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\UnhandledExceptionManager.cs,GenericExceptionHandler,The method has an empty catch block.
Empty Catch Block,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,ExecuteCommandSync,The method has an empty catch block.
Empty Catch Block,Shoko.Server.Commands,CommandRequest_MovieDBSearchAnime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\MovieDB\CommandRequest_MovieDBSearchAnime.cs,ProcessCommand,The method has an empty catch block.
Empty Catch Block,Shoko.Server.Commands,CommandProcessorGeneral,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\CommandProcessorGeneral.cs,WorkerCommands_DoWork,The method has an empty catch block.
Empty Catch Block,Shoko.Server.Commands,CommandProcessorHasher,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\CommandProcessorHasher.cs,WorkerCommands_DoWork,The method has an empty catch block.
Empty Catch Block,Shoko.Server.Commands,CommandProcessorImages,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\CommandProcessorImages.cs,WorkerCommands_DoWork,The method has an empty catch block.
Empty Catch Block,Shoko.Server.Commands,CommandRequestImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\CommandRequestImplementation.cs,TryGetProperty,The method has an empty catch block.
Empty Catch Block,Shoko.Server.Commands,CommandRequest_TvDBSearchAnime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\TvDB\CommandRequest_TvDBSearchAnime.cs,ProcessCommand,The method has an empty catch block.
Empty Catch Block,Shoko.Server.API,Bootstrapper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\Bootstrapper.cs,RequestStartup,The method has an empty catch block.
Empty Catch Block,Shoko.Server.API,StatusCodeHandler,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\Bootstrapper.cs,Handle,The method has an empty catch block.
Empty Catch Block,Shoko.Server.API.v2.Modules,Core,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Core.cs,SetSetting,The method has an empty catch block.
Empty Catch Block,Shoko.Server.API.v2.Modules,Init,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Init.cs,SetSetting,The method has an empty catch block.
Empty Catch Block,Shoko.Server.Extensions,ModelProviders,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Extensions\ModelProviders.cs,TryGetProperty,The method has an empty catch block.
Empty Catch Block,Shoko.Server.Databases,BaseDatabase<T>,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Databases\BaseDatabase.cs,GetDatabaseBackupName,The method has an empty catch block.
Empty Catch Block,Shoko.Server.Databases,MySQL,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Databases\MySQL.cs,TestConnection,The method has an empty catch block.
Empty Catch Block,Shoko.Server.Databases,SQLServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Databases\SQLServer.cs,TestConnection,The method has an empty catch block.
Empty Catch Block,Shoko.Server.Providers.TvDB,TvDBApiHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TvDB\TvDBApiHelper.cs,GetSeriesImagesAsync,The method has an empty catch block.
Empty Catch Block,Shoko.Server.Repositories.Cached,AnimeSeriesRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\AnimeSeriesRepository.cs,RegenerateDb,The method has an empty catch block.
Empty Catch Block,Shoko.Server.Repositories.Cached,VideoLocalRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\VideoLocalRepository.cs,RegenerateDb,The method has an empty catch block.
Empty Catch Block,Shoko.Server.Repositories.Cached,VideoLocalRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\VideoLocalRepository.cs,RegenerateDb,The method has an empty catch block.
Empty Catch Block,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The method has an empty catch block.
Empty Catch Block,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The method has an empty catch block.
Empty Catch Block,Shoko.Server.PlexAndKodi,CommonImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\CommonImplementation.cs,GetItemsFromPlaylist,The method has an empty catch block.
Empty Catch Block,Shoko.Server.PlexAndKodi,CommonImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\CommonImplementation.cs,GetUnsort,The method has an empty catch block.
Empty Catch Block,Shoko.Server.PlexAndKodi,CommonImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\CommonImplementation.cs,GetFromEpisode,The method has an empty catch block.
Empty Catch Block,Shoko.Server.PlexAndKodi,CommonImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\CommonImplementation.cs,GetItemsFromSerie,The method has an empty catch block.
Empty Catch Block,Shoko.Server.PlexAndKodi,Helper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Helper.cs,MayReplaceVideo,The method has an empty catch block.
Empty Catch Block,Shoko.Server.Commands.MAL,CommandRequest_MALSearchAnime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\MAL\CommandRequest_MALSearchAnime.cs,ProcessCommand,The method has an empty catch block.
Empty Catch Block,Shoko.Server.Utilities,LogReader,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utilities\LogReader.cs,Read,The method has an empty catch block.
Empty Catch Block,Shoko.Server.Providers.Azure,AzureWebAPI,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\Azure\AzureWebAPI.cs,GetDataXML,The method has an empty catch block.
Empty Catch Block,Shoko.Server.Providers.Azure,AzureWebAPI,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\Azure\AzureWebAPI.cs,GetUserInfoData,The method has an empty catch block.
Empty Catch Block,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,SendData,The method has an empty catch block.
Empty Catch Block,LeanWork.IO.FileSystem,BufferingFileSystemWatcher,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utilities\LeanWork\IO\FileSystem\BufferingFileSystemWatcher.cs,RaiseBufferedEventsUntilCancelled,The method has an empty catch block.
Empty Catch Block,LeanWork.IO.FileSystem,RecoveringFileSystemWatcher,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utilities\LeanWork\IO\FileSystem\RecoveringFileSystemWatcher.cs,ReStartIfNeccessary,The method has an empty catch block.
Magic Number,Shoko.Server,AniDBHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDBHelper.cs,Init,The following statement contains a magic number: logoutTimer.Interval = 5000;
Magic Number,Shoko.Server,AniDBHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDBHelper.cs,Login,The following statement contains a magic number: Thread.Sleep(2200);
Magic Number,Shoko.Server,AniDBHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDBHelper.cs,GetAnimeInfoHTTP,The following statement contains a magic number: if (anime != null && update != null)              {                  TimeSpan ts = DateTime.Now - update.UpdatedAt;                  if (ts.TotalHours < 4) animeRecentlyUpdated = true;              }
Magic Number,Shoko.Server,AniDBHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDBHelper.cs,BindToLocalPort,The following statement contains a magic number: try              {                  IPHostEntry localHostEntry = Dns.GetHostEntry(Dns.GetHostName());                      logger.Info("-------- Local IP Addresses --------");                  localIpEndPoint = new IPEndPoint(IPAddress.Any' Convert.ToInt32(clientPort));                  logger.Info("-------- End Local IP Addresses --------");                    soUdp.Bind(localIpEndPoint);                  soUdp.ReceiveTimeout = 30000; // 30 seconds                    logger.Info("BindToLocalPort: Bound to local address: {0} - Port: {1} ({2})"'                      localIpEndPoint'                      clientPort'                      localIpEndPoint.AddressFamily);                    return true;              }              catch (Exception ex)              {                  logger.Error(ex' $"Could not bind to local port: {ex}");                  return false;              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,AssociateMultipleFiles,The following statement contains a magic number: try              {                  SVR_AnimeSeries ser = RepoFactory.AnimeSeries.GetByID(animeSeriesID);                  if (ser == null)                      return "Could not find anime series record";                    int epNumber = startingEpisodeNumber;                  int total = startingEpisodeNumber + videoLocalIDs.Count - 1;                  int count = 1;                    foreach (int videoLocalID in videoLocalIDs)                  {                      SVR_VideoLocal vid = RepoFactory.VideoLocal.GetByID(videoLocalID);                      if (vid == null)                          return "Could not find video local record";                      if (vid.Hash == null)                          return "Could not associate a cloud file without hash' hash it locally first";                        List<AniDB_Episode> anieps =                          RepoFactory.AniDB_Episode.GetByAnimeIDAndEpisodeNumber(ser.AniDB_ID' epNumber);                      if (anieps.Count == 0)                          return "Could not find the AniDB episode record";                        AniDB_Episode aniep = anieps[0];                        SVR_AnimeEpisode ep = RepoFactory.AnimeEpisode.GetByAniDBEpisodeID(aniep.EpisodeID);                      if (ep == null)                          return "Could not find episode record";                        var com = new CommandRequest_LinkFileManually(videoLocalID' ep.AnimeEpisodeID);                      if (singleEpisode)                      {                          com.Percentage = (int) Math.Round((double) count / total * 100);                      }                      com.Save();                        count++;                      if (!singleEpisode) epNumber++;                  }              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,VoteAnime,The following statement contains a magic number: if (voteValue > 0)                  iVoteValue = (int) (voteValue * 100);              else                  iVoteValue = (int) voteValue;
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,CreateSeriesFromAnime,The following statement contains a magic number: try              {                  if (animeGroupID.HasValue && animeGroupID.Value > 0)                  {                      SVR_AnimeGroup grp = RepoFactory.AnimeGroup.GetByID(animeGroupID.Value);                      if (grp == null)                      {                          response.ErrorMessage = "Could not find the specified group";                          return response;                      }                  }                    // make sure a series doesn't already exists for this anime                  SVR_AnimeSeries ser = RepoFactory.AnimeSeries.GetByAnimeID(animeID);                  if (ser != null && !forceOverwrite)                  {                      response.ErrorMessage = "A series already exists for this anime";                      return response;                  }                    // make sure the anime exists first                  SVR_AniDB_Anime anime = RepoFactory.AniDB_Anime.GetByAnimeID(animeID);                    AniDB_AnimeUpdate update = RepoFactory.AniDB_AnimeUpdate.GetByAnimeID(animeID);                  bool animeRecentlyUpdated = false;                    if (update != null)                  {                      TimeSpan ts = DateTime.Now - update.UpdatedAt;                      if (ts.TotalHours < 4) animeRecentlyUpdated = true;                  }                    // even if we are missing episode info' don't get data  more than once every 4 hours                  // this is to prevent banning                  if (!animeRecentlyUpdated)                  {                      logger.Debug("Getting Anime record from AniDB....");                      anime = ShokoService.AnidbProcessor.GetAnimeInfoHTTP(animeID' true'                          ServerSettings.AutoGroupSeries || ServerSettings.AniDB_DownloadRelatedAnime);                  }                    if (anime == null)                  {                      response.ErrorMessage = "Could not get anime information from AniDB";                      return response;                  }                    logger.Debug("Creating groups' series and episodes....");                  if (ser == null) ser = anime.CreateAnimeSeriesAndGroup(animeGroupID);                    ser.CreateAnimeEpisodes();                    // check if we have any group status data for this associated anime                  // if not we will download it now                  if (RepoFactory.AniDB_GroupStatus.GetByAnimeID(anime.AnimeID).Count == 0)                  {                      CommandRequest_GetReleaseGroupStatus cmdStatus =                          new CommandRequest_GetReleaseGroupStatus(anime.AnimeID' false);                      cmdStatus.Save();                  }                    // update stats                  RepoFactory.AnimeSeries.Save(ser' false' false);                    foreach (SVR_AnimeGroup grp in ser.AllGroupsAbove)                  {                      RepoFactory.AnimeGroup.Save(grp' true' false);                  }                    response.Result = ser.GetUserContract(userID);                  return response;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());                  response.ErrorMessage = ex.Message;              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,SaveUser,The following statement contains a magic number: try              {                  bool existingUser = false;                  bool updateStats = false;                  bool updateGf = false;                  SVR_JMMUser jmmUser = null;                  if (user.JMMUserID != 0)                  {                      jmmUser = RepoFactory.JMMUser.GetByID(user.JMMUserID);                      if (jmmUser == null) return "User not found";                      existingUser = true;                  }                  else                  {                      jmmUser = new SVR_JMMUser();                      updateStats = true;                      updateGf = true;                  }                    if (existingUser && jmmUser.IsAniDBUser != user.IsAniDBUser)                      updateStats = true;                    string hcat = string.Join("'"' user.HideCategories);                  if (jmmUser.HideCategories != hcat)                      updateGf = true;                  jmmUser.HideCategories = hcat;                  jmmUser.IsAniDBUser = user.IsAniDBUser;                  jmmUser.IsTraktUser = user.IsTraktUser;                  jmmUser.IsAdmin = user.IsAdmin;                  jmmUser.Username = user.Username;                  jmmUser.CanEditServerSettings = user.CanEditServerSettings;                  jmmUser.PlexUsers = string.Join("'"' user.PlexUsers);                  jmmUser.PlexToken = user.PlexToken;                  if (string.IsNullOrEmpty(user.Password))                  {                      jmmUser.Password = string.Empty;                  }                  else                  {                      // Additional check for hashed password' if not hashed we hash it                      if (user.Password.Length < 64)                          jmmUser.Password = Digest.Hash(user.Password);                      else                          jmmUser.Password = user.Password;                  }                    // make sure that at least one user is an admin                  if (jmmUser.IsAdmin == 0)                  {                      bool adminExists = false;                      IReadOnlyList<SVR_JMMUser> users = RepoFactory.JMMUser.GetAll();                      foreach (SVR_JMMUser userOld in users)                      {                          if (userOld.IsAdmin == 1)                          {                              if (existingUser)                              {                                  if (userOld.JMMUserID != jmmUser.JMMUserID) adminExists = true;                              }                              else                              {                                  //one admin account is needed                                  adminExists = true;                                  break;                              }                          }                      }                        if (!adminExists) return "At least one user must be an administrator";                  }                    RepoFactory.JMMUser.Save(jmmUser' updateGf);                    // update stats                  if (updateStats)                  {                      foreach (SVR_AnimeSeries ser in RepoFactory.AnimeSeries.GetAll())                          ser.QueueUpdateStats();                  }              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());                  return ex.Message;              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetAllChanges,The following statement contains a magic number: try              {                  List<Changes<int>> changes = ChangeTracker<int>.GetChainedChanges(new List<ChangeTracker<int>>                  {                      RepoFactory.GroupFilter.GetChangeTracker()'                      RepoFactory.AnimeGroup.GetChangeTracker()'                      RepoFactory.AnimeGroup_User.GetChangeTracker(userID)'                      RepoFactory.AnimeSeries.GetChangeTracker()'                      RepoFactory.AnimeSeries_User.GetChangeTracker(userID)                  }' date);                  c.Filters = new CL_Changes<CL_GroupFilter>                  {                      ChangedItems = changes[0]                      .ChangedItems.Select(a => RepoFactory.GroupFilter.GetByID(a).ToClient())                      .Where(a => a != null)                      .ToList()'                      RemovedItems = changes[0].RemovedItems.ToList()'                      LastChange = changes[0].LastChange                  };                    //Add Group Filter that one of his child changed.                  bool end;                  do                  {                      end = true;                      foreach (CL_GroupFilter ag in c.Filters.ChangedItems                          .Where(a => a.ParentGroupFilterID.HasValue && a.ParentGroupFilterID.Value != 0)                          .ToList())                      {                          if (!c.Filters.ChangedItems.Any(a => a.GroupFilterID == ag.ParentGroupFilterID.Value))                          {                              end = false;                              CL_GroupFilter cag = RepoFactory.GroupFilter.GetByID(ag.ParentGroupFilterID.Value)                                  .ToClient();                              if (cag != null)                                  c.Filters.ChangedItems.Add(cag);                          }                      }                  } while (!end);                    c.Groups = new CL_Changes<CL_AnimeGroup_User>();                  changes[1].ChangedItems.UnionWith(changes[2].ChangedItems);                  changes[1].ChangedItems.UnionWith(changes[2].RemovedItems);                  if (changes[2].LastChange > changes[1].LastChange)                      changes[1].LastChange = changes[2].LastChange;                  c.Groups.ChangedItems = changes[1]                      .ChangedItems.Select(a => RepoFactory.AnimeGroup.GetByID(a))                      .Where(a => a != null)                      .Select(a => a.GetUserContract(userID))                      .ToList();                      c.Groups.RemovedItems = changes[1].RemovedItems.ToList();                  c.Groups.LastChange = changes[1].LastChange;                  c.Series = new CL_Changes<CL_AnimeSeries_User>();                  changes[3].ChangedItems.UnionWith(changes[4].ChangedItems);                  changes[3].ChangedItems.UnionWith(changes[4].RemovedItems);                  if (changes[4].LastChange > changes[3].LastChange)                      changes[3].LastChange = changes[4].LastChange;                  c.Series.ChangedItems = changes[3]                      .ChangedItems.Select(a => RepoFactory.AnimeSeries.GetByID(a))                      .Where(a => a != null)                      .Select(a => a.GetUserContract(userID))                      .ToList();                  c.Series.RemovedItems = changes[3].RemovedItems.ToList();                  c.Series.LastChange = changes[3].LastChange;                  c.LastChange = c.Filters.LastChange;                  if (c.Groups.LastChange > c.LastChange)                      c.LastChange = c.Groups.LastChange;                  if (c.Series.LastChange > c.LastChange)                      c.LastChange = c.Series.LastChange;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetAllChanges,The following statement contains a magic number: try              {                  List<Changes<int>> changes = ChangeTracker<int>.GetChainedChanges(new List<ChangeTracker<int>>                  {                      RepoFactory.GroupFilter.GetChangeTracker()'                      RepoFactory.AnimeGroup.GetChangeTracker()'                      RepoFactory.AnimeGroup_User.GetChangeTracker(userID)'                      RepoFactory.AnimeSeries.GetChangeTracker()'                      RepoFactory.AnimeSeries_User.GetChangeTracker(userID)                  }' date);                  c.Filters = new CL_Changes<CL_GroupFilter>                  {                      ChangedItems = changes[0]                      .ChangedItems.Select(a => RepoFactory.GroupFilter.GetByID(a).ToClient())                      .Where(a => a != null)                      .ToList()'                      RemovedItems = changes[0].RemovedItems.ToList()'                      LastChange = changes[0].LastChange                  };                    //Add Group Filter that one of his child changed.                  bool end;                  do                  {                      end = true;                      foreach (CL_GroupFilter ag in c.Filters.ChangedItems                          .Where(a => a.ParentGroupFilterID.HasValue && a.ParentGroupFilterID.Value != 0)                          .ToList())                      {                          if (!c.Filters.ChangedItems.Any(a => a.GroupFilterID == ag.ParentGroupFilterID.Value))                          {                              end = false;                              CL_GroupFilter cag = RepoFactory.GroupFilter.GetByID(ag.ParentGroupFilterID.Value)                                  .ToClient();                              if (cag != null)                                  c.Filters.ChangedItems.Add(cag);                          }                      }                  } while (!end);                    c.Groups = new CL_Changes<CL_AnimeGroup_User>();                  changes[1].ChangedItems.UnionWith(changes[2].ChangedItems);                  changes[1].ChangedItems.UnionWith(changes[2].RemovedItems);                  if (changes[2].LastChange > changes[1].LastChange)                      changes[1].LastChange = changes[2].LastChange;                  c.Groups.ChangedItems = changes[1]                      .ChangedItems.Select(a => RepoFactory.AnimeGroup.GetByID(a))                      .Where(a => a != null)                      .Select(a => a.GetUserContract(userID))                      .ToList();                      c.Groups.RemovedItems = changes[1].RemovedItems.ToList();                  c.Groups.LastChange = changes[1].LastChange;                  c.Series = new CL_Changes<CL_AnimeSeries_User>();                  changes[3].ChangedItems.UnionWith(changes[4].ChangedItems);                  changes[3].ChangedItems.UnionWith(changes[4].RemovedItems);                  if (changes[4].LastChange > changes[3].LastChange)                      changes[3].LastChange = changes[4].LastChange;                  c.Series.ChangedItems = changes[3]                      .ChangedItems.Select(a => RepoFactory.AnimeSeries.GetByID(a))                      .Where(a => a != null)                      .Select(a => a.GetUserContract(userID))                      .ToList();                  c.Series.RemovedItems = changes[3].RemovedItems.ToList();                  c.Series.LastChange = changes[3].LastChange;                  c.LastChange = c.Filters.LastChange;                  if (c.Groups.LastChange > c.LastChange)                      c.LastChange = c.Groups.LastChange;                  if (c.Series.LastChange > c.LastChange)                      c.LastChange = c.Series.LastChange;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetAllChanges,The following statement contains a magic number: try              {                  List<Changes<int>> changes = ChangeTracker<int>.GetChainedChanges(new List<ChangeTracker<int>>                  {                      RepoFactory.GroupFilter.GetChangeTracker()'                      RepoFactory.AnimeGroup.GetChangeTracker()'                      RepoFactory.AnimeGroup_User.GetChangeTracker(userID)'                      RepoFactory.AnimeSeries.GetChangeTracker()'                      RepoFactory.AnimeSeries_User.GetChangeTracker(userID)                  }' date);                  c.Filters = new CL_Changes<CL_GroupFilter>                  {                      ChangedItems = changes[0]                      .ChangedItems.Select(a => RepoFactory.GroupFilter.GetByID(a).ToClient())                      .Where(a => a != null)                      .ToList()'                      RemovedItems = changes[0].RemovedItems.ToList()'                      LastChange = changes[0].LastChange                  };                    //Add Group Filter that one of his child changed.                  bool end;                  do                  {                      end = true;                      foreach (CL_GroupFilter ag in c.Filters.ChangedItems                          .Where(a => a.ParentGroupFilterID.HasValue && a.ParentGroupFilterID.Value != 0)                          .ToList())                      {                          if (!c.Filters.ChangedItems.Any(a => a.GroupFilterID == ag.ParentGroupFilterID.Value))                          {                              end = false;                              CL_GroupFilter cag = RepoFactory.GroupFilter.GetByID(ag.ParentGroupFilterID.Value)                                  .ToClient();                              if (cag != null)                                  c.Filters.ChangedItems.Add(cag);                          }                      }                  } while (!end);                    c.Groups = new CL_Changes<CL_AnimeGroup_User>();                  changes[1].ChangedItems.UnionWith(changes[2].ChangedItems);                  changes[1].ChangedItems.UnionWith(changes[2].RemovedItems);                  if (changes[2].LastChange > changes[1].LastChange)                      changes[1].LastChange = changes[2].LastChange;                  c.Groups.ChangedItems = changes[1]                      .ChangedItems.Select(a => RepoFactory.AnimeGroup.GetByID(a))                      .Where(a => a != null)                      .Select(a => a.GetUserContract(userID))                      .ToList();                      c.Groups.RemovedItems = changes[1].RemovedItems.ToList();                  c.Groups.LastChange = changes[1].LastChange;                  c.Series = new CL_Changes<CL_AnimeSeries_User>();                  changes[3].ChangedItems.UnionWith(changes[4].ChangedItems);                  changes[3].ChangedItems.UnionWith(changes[4].RemovedItems);                  if (changes[4].LastChange > changes[3].LastChange)                      changes[3].LastChange = changes[4].LastChange;                  c.Series.ChangedItems = changes[3]                      .ChangedItems.Select(a => RepoFactory.AnimeSeries.GetByID(a))                      .Where(a => a != null)                      .Select(a => a.GetUserContract(userID))                      .ToList();                  c.Series.RemovedItems = changes[3].RemovedItems.ToList();                  c.Series.LastChange = changes[3].LastChange;                  c.LastChange = c.Filters.LastChange;                  if (c.Groups.LastChange > c.LastChange)                      c.LastChange = c.Groups.LastChange;                  if (c.Series.LastChange > c.LastChange)                      c.LastChange = c.Series.LastChange;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetAllChanges,The following statement contains a magic number: try              {                  List<Changes<int>> changes = ChangeTracker<int>.GetChainedChanges(new List<ChangeTracker<int>>                  {                      RepoFactory.GroupFilter.GetChangeTracker()'                      RepoFactory.AnimeGroup.GetChangeTracker()'                      RepoFactory.AnimeGroup_User.GetChangeTracker(userID)'                      RepoFactory.AnimeSeries.GetChangeTracker()'                      RepoFactory.AnimeSeries_User.GetChangeTracker(userID)                  }' date);                  c.Filters = new CL_Changes<CL_GroupFilter>                  {                      ChangedItems = changes[0]                      .ChangedItems.Select(a => RepoFactory.GroupFilter.GetByID(a).ToClient())                      .Where(a => a != null)                      .ToList()'                      RemovedItems = changes[0].RemovedItems.ToList()'                      LastChange = changes[0].LastChange                  };                    //Add Group Filter that one of his child changed.                  bool end;                  do                  {                      end = true;                      foreach (CL_GroupFilter ag in c.Filters.ChangedItems                          .Where(a => a.ParentGroupFilterID.HasValue && a.ParentGroupFilterID.Value != 0)                          .ToList())                      {                          if (!c.Filters.ChangedItems.Any(a => a.GroupFilterID == ag.ParentGroupFilterID.Value))                          {                              end = false;                              CL_GroupFilter cag = RepoFactory.GroupFilter.GetByID(ag.ParentGroupFilterID.Value)                                  .ToClient();                              if (cag != null)                                  c.Filters.ChangedItems.Add(cag);                          }                      }                  } while (!end);                    c.Groups = new CL_Changes<CL_AnimeGroup_User>();                  changes[1].ChangedItems.UnionWith(changes[2].ChangedItems);                  changes[1].ChangedItems.UnionWith(changes[2].RemovedItems);                  if (changes[2].LastChange > changes[1].LastChange)                      changes[1].LastChange = changes[2].LastChange;                  c.Groups.ChangedItems = changes[1]                      .ChangedItems.Select(a => RepoFactory.AnimeGroup.GetByID(a))                      .Where(a => a != null)                      .Select(a => a.GetUserContract(userID))                      .ToList();                      c.Groups.RemovedItems = changes[1].RemovedItems.ToList();                  c.Groups.LastChange = changes[1].LastChange;                  c.Series = new CL_Changes<CL_AnimeSeries_User>();                  changes[3].ChangedItems.UnionWith(changes[4].ChangedItems);                  changes[3].ChangedItems.UnionWith(changes[4].RemovedItems);                  if (changes[4].LastChange > changes[3].LastChange)                      changes[3].LastChange = changes[4].LastChange;                  c.Series.ChangedItems = changes[3]                      .ChangedItems.Select(a => RepoFactory.AnimeSeries.GetByID(a))                      .Where(a => a != null)                      .Select(a => a.GetUserContract(userID))                      .ToList();                  c.Series.RemovedItems = changes[3].RemovedItems.ToList();                  c.Series.LastChange = changes[3].LastChange;                  c.LastChange = c.Filters.LastChange;                  if (c.Groups.LastChange > c.LastChange)                      c.LastChange = c.Groups.LastChange;                  if (c.Series.LastChange > c.LastChange)                      c.LastChange = c.Series.LastChange;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetAllChanges,The following statement contains a magic number: try              {                  List<Changes<int>> changes = ChangeTracker<int>.GetChainedChanges(new List<ChangeTracker<int>>                  {                      RepoFactory.GroupFilter.GetChangeTracker()'                      RepoFactory.AnimeGroup.GetChangeTracker()'                      RepoFactory.AnimeGroup_User.GetChangeTracker(userID)'                      RepoFactory.AnimeSeries.GetChangeTracker()'                      RepoFactory.AnimeSeries_User.GetChangeTracker(userID)                  }' date);                  c.Filters = new CL_Changes<CL_GroupFilter>                  {                      ChangedItems = changes[0]                      .ChangedItems.Select(a => RepoFactory.GroupFilter.GetByID(a).ToClient())                      .Where(a => a != null)                      .ToList()'                      RemovedItems = changes[0].RemovedItems.ToList()'                      LastChange = changes[0].LastChange                  };                    //Add Group Filter that one of his child changed.                  bool end;                  do                  {                      end = true;                      foreach (CL_GroupFilter ag in c.Filters.ChangedItems                          .Where(a => a.ParentGroupFilterID.HasValue && a.ParentGroupFilterID.Value != 0)                          .ToList())                      {                          if (!c.Filters.ChangedItems.Any(a => a.GroupFilterID == ag.ParentGroupFilterID.Value))                          {                              end = false;                              CL_GroupFilter cag = RepoFactory.GroupFilter.GetByID(ag.ParentGroupFilterID.Value)                                  .ToClient();                              if (cag != null)                                  c.Filters.ChangedItems.Add(cag);                          }                      }                  } while (!end);                    c.Groups = new CL_Changes<CL_AnimeGroup_User>();                  changes[1].ChangedItems.UnionWith(changes[2].ChangedItems);                  changes[1].ChangedItems.UnionWith(changes[2].RemovedItems);                  if (changes[2].LastChange > changes[1].LastChange)                      changes[1].LastChange = changes[2].LastChange;                  c.Groups.ChangedItems = changes[1]                      .ChangedItems.Select(a => RepoFactory.AnimeGroup.GetByID(a))                      .Where(a => a != null)                      .Select(a => a.GetUserContract(userID))                      .ToList();                      c.Groups.RemovedItems = changes[1].RemovedItems.ToList();                  c.Groups.LastChange = changes[1].LastChange;                  c.Series = new CL_Changes<CL_AnimeSeries_User>();                  changes[3].ChangedItems.UnionWith(changes[4].ChangedItems);                  changes[3].ChangedItems.UnionWith(changes[4].RemovedItems);                  if (changes[4].LastChange > changes[3].LastChange)                      changes[3].LastChange = changes[4].LastChange;                  c.Series.ChangedItems = changes[3]                      .ChangedItems.Select(a => RepoFactory.AnimeSeries.GetByID(a))                      .Where(a => a != null)                      .Select(a => a.GetUserContract(userID))                      .ToList();                  c.Series.RemovedItems = changes[3].RemovedItems.ToList();                  c.Series.LastChange = changes[3].LastChange;                  c.LastChange = c.Filters.LastChange;                  if (c.Groups.LastChange > c.LastChange)                      c.LastChange = c.Groups.LastChange;                  if (c.Series.LastChange > c.LastChange)                      c.LastChange = c.Series.LastChange;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetAllChanges,The following statement contains a magic number: try              {                  List<Changes<int>> changes = ChangeTracker<int>.GetChainedChanges(new List<ChangeTracker<int>>                  {                      RepoFactory.GroupFilter.GetChangeTracker()'                      RepoFactory.AnimeGroup.GetChangeTracker()'                      RepoFactory.AnimeGroup_User.GetChangeTracker(userID)'                      RepoFactory.AnimeSeries.GetChangeTracker()'                      RepoFactory.AnimeSeries_User.GetChangeTracker(userID)                  }' date);                  c.Filters = new CL_Changes<CL_GroupFilter>                  {                      ChangedItems = changes[0]                      .ChangedItems.Select(a => RepoFactory.GroupFilter.GetByID(a).ToClient())                      .Where(a => a != null)                      .ToList()'                      RemovedItems = changes[0].RemovedItems.ToList()'                      LastChange = changes[0].LastChange                  };                    //Add Group Filter that one of his child changed.                  bool end;                  do                  {                      end = true;                      foreach (CL_GroupFilter ag in c.Filters.ChangedItems                          .Where(a => a.ParentGroupFilterID.HasValue && a.ParentGroupFilterID.Value != 0)                          .ToList())                      {                          if (!c.Filters.ChangedItems.Any(a => a.GroupFilterID == ag.ParentGroupFilterID.Value))                          {                              end = false;                              CL_GroupFilter cag = RepoFactory.GroupFilter.GetByID(ag.ParentGroupFilterID.Value)                                  .ToClient();                              if (cag != null)                                  c.Filters.ChangedItems.Add(cag);                          }                      }                  } while (!end);                    c.Groups = new CL_Changes<CL_AnimeGroup_User>();                  changes[1].ChangedItems.UnionWith(changes[2].ChangedItems);                  changes[1].ChangedItems.UnionWith(changes[2].RemovedItems);                  if (changes[2].LastChange > changes[1].LastChange)                      changes[1].LastChange = changes[2].LastChange;                  c.Groups.ChangedItems = changes[1]                      .ChangedItems.Select(a => RepoFactory.AnimeGroup.GetByID(a))                      .Where(a => a != null)                      .Select(a => a.GetUserContract(userID))                      .ToList();                      c.Groups.RemovedItems = changes[1].RemovedItems.ToList();                  c.Groups.LastChange = changes[1].LastChange;                  c.Series = new CL_Changes<CL_AnimeSeries_User>();                  changes[3].ChangedItems.UnionWith(changes[4].ChangedItems);                  changes[3].ChangedItems.UnionWith(changes[4].RemovedItems);                  if (changes[4].LastChange > changes[3].LastChange)                      changes[3].LastChange = changes[4].LastChange;                  c.Series.ChangedItems = changes[3]                      .ChangedItems.Select(a => RepoFactory.AnimeSeries.GetByID(a))                      .Where(a => a != null)                      .Select(a => a.GetUserContract(userID))                      .ToList();                  c.Series.RemovedItems = changes[3].RemovedItems.ToList();                  c.Series.LastChange = changes[3].LastChange;                  c.LastChange = c.Filters.LastChange;                  if (c.Groups.LastChange > c.LastChange)                      c.LastChange = c.Groups.LastChange;                  if (c.Series.LastChange > c.LastChange)                      c.LastChange = c.Series.LastChange;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetAllChanges,The following statement contains a magic number: try              {                  List<Changes<int>> changes = ChangeTracker<int>.GetChainedChanges(new List<ChangeTracker<int>>                  {                      RepoFactory.GroupFilter.GetChangeTracker()'                      RepoFactory.AnimeGroup.GetChangeTracker()'                      RepoFactory.AnimeGroup_User.GetChangeTracker(userID)'                      RepoFactory.AnimeSeries.GetChangeTracker()'                      RepoFactory.AnimeSeries_User.GetChangeTracker(userID)                  }' date);                  c.Filters = new CL_Changes<CL_GroupFilter>                  {                      ChangedItems = changes[0]                      .ChangedItems.Select(a => RepoFactory.GroupFilter.GetByID(a).ToClient())                      .Where(a => a != null)                      .ToList()'                      RemovedItems = changes[0].RemovedItems.ToList()'                      LastChange = changes[0].LastChange                  };                    //Add Group Filter that one of his child changed.                  bool end;                  do                  {                      end = true;                      foreach (CL_GroupFilter ag in c.Filters.ChangedItems                          .Where(a => a.ParentGroupFilterID.HasValue && a.ParentGroupFilterID.Value != 0)                          .ToList())                      {                          if (!c.Filters.ChangedItems.Any(a => a.GroupFilterID == ag.ParentGroupFilterID.Value))                          {                              end = false;                              CL_GroupFilter cag = RepoFactory.GroupFilter.GetByID(ag.ParentGroupFilterID.Value)                                  .ToClient();                              if (cag != null)                                  c.Filters.ChangedItems.Add(cag);                          }                      }                  } while (!end);                    c.Groups = new CL_Changes<CL_AnimeGroup_User>();                  changes[1].ChangedItems.UnionWith(changes[2].ChangedItems);                  changes[1].ChangedItems.UnionWith(changes[2].RemovedItems);                  if (changes[2].LastChange > changes[1].LastChange)                      changes[1].LastChange = changes[2].LastChange;                  c.Groups.ChangedItems = changes[1]                      .ChangedItems.Select(a => RepoFactory.AnimeGroup.GetByID(a))                      .Where(a => a != null)                      .Select(a => a.GetUserContract(userID))                      .ToList();                      c.Groups.RemovedItems = changes[1].RemovedItems.ToList();                  c.Groups.LastChange = changes[1].LastChange;                  c.Series = new CL_Changes<CL_AnimeSeries_User>();                  changes[3].ChangedItems.UnionWith(changes[4].ChangedItems);                  changes[3].ChangedItems.UnionWith(changes[4].RemovedItems);                  if (changes[4].LastChange > changes[3].LastChange)                      changes[3].LastChange = changes[4].LastChange;                  c.Series.ChangedItems = changes[3]                      .ChangedItems.Select(a => RepoFactory.AnimeSeries.GetByID(a))                      .Where(a => a != null)                      .Select(a => a.GetUserContract(userID))                      .ToList();                  c.Series.RemovedItems = changes[3].RemovedItems.ToList();                  c.Series.LastChange = changes[3].LastChange;                  c.LastChange = c.Filters.LastChange;                  if (c.Groups.LastChange > c.LastChange)                      c.LastChange = c.Groups.LastChange;                  if (c.Series.LastChange > c.LastChange)                      c.LastChange = c.Series.LastChange;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetAllChanges,The following statement contains a magic number: try              {                  List<Changes<int>> changes = ChangeTracker<int>.GetChainedChanges(new List<ChangeTracker<int>>                  {                      RepoFactory.GroupFilter.GetChangeTracker()'                      RepoFactory.AnimeGroup.GetChangeTracker()'                      RepoFactory.AnimeGroup_User.GetChangeTracker(userID)'                      RepoFactory.AnimeSeries.GetChangeTracker()'                      RepoFactory.AnimeSeries_User.GetChangeTracker(userID)                  }' date);                  c.Filters = new CL_Changes<CL_GroupFilter>                  {                      ChangedItems = changes[0]                      .ChangedItems.Select(a => RepoFactory.GroupFilter.GetByID(a).ToClient())                      .Where(a => a != null)                      .ToList()'                      RemovedItems = changes[0].RemovedItems.ToList()'                      LastChange = changes[0].LastChange                  };                    //Add Group Filter that one of his child changed.                  bool end;                  do                  {                      end = true;                      foreach (CL_GroupFilter ag in c.Filters.ChangedItems                          .Where(a => a.ParentGroupFilterID.HasValue && a.ParentGroupFilterID.Value != 0)                          .ToList())                      {                          if (!c.Filters.ChangedItems.Any(a => a.GroupFilterID == ag.ParentGroupFilterID.Value))                          {                              end = false;                              CL_GroupFilter cag = RepoFactory.GroupFilter.GetByID(ag.ParentGroupFilterID.Value)                                  .ToClient();                              if (cag != null)                                  c.Filters.ChangedItems.Add(cag);                          }                      }                  } while (!end);                    c.Groups = new CL_Changes<CL_AnimeGroup_User>();                  changes[1].ChangedItems.UnionWith(changes[2].ChangedItems);                  changes[1].ChangedItems.UnionWith(changes[2].RemovedItems);                  if (changes[2].LastChange > changes[1].LastChange)                      changes[1].LastChange = changes[2].LastChange;                  c.Groups.ChangedItems = changes[1]                      .ChangedItems.Select(a => RepoFactory.AnimeGroup.GetByID(a))                      .Where(a => a != null)                      .Select(a => a.GetUserContract(userID))                      .ToList();                      c.Groups.RemovedItems = changes[1].RemovedItems.ToList();                  c.Groups.LastChange = changes[1].LastChange;                  c.Series = new CL_Changes<CL_AnimeSeries_User>();                  changes[3].ChangedItems.UnionWith(changes[4].ChangedItems);                  changes[3].ChangedItems.UnionWith(changes[4].RemovedItems);                  if (changes[4].LastChange > changes[3].LastChange)                      changes[3].LastChange = changes[4].LastChange;                  c.Series.ChangedItems = changes[3]                      .ChangedItems.Select(a => RepoFactory.AnimeSeries.GetByID(a))                      .Where(a => a != null)                      .Select(a => a.GetUserContract(userID))                      .ToList();                  c.Series.RemovedItems = changes[3].RemovedItems.ToList();                  c.Series.LastChange = changes[3].LastChange;                  c.LastChange = c.Filters.LastChange;                  if (c.Groups.LastChange > c.LastChange)                      c.LastChange = c.Groups.LastChange;                  if (c.Series.LastChange > c.LastChange)                      c.LastChange = c.Series.LastChange;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetAllChanges,The following statement contains a magic number: try              {                  List<Changes<int>> changes = ChangeTracker<int>.GetChainedChanges(new List<ChangeTracker<int>>                  {                      RepoFactory.GroupFilter.GetChangeTracker()'                      RepoFactory.AnimeGroup.GetChangeTracker()'                      RepoFactory.AnimeGroup_User.GetChangeTracker(userID)'                      RepoFactory.AnimeSeries.GetChangeTracker()'                      RepoFactory.AnimeSeries_User.GetChangeTracker(userID)                  }' date);                  c.Filters = new CL_Changes<CL_GroupFilter>                  {                      ChangedItems = changes[0]                      .ChangedItems.Select(a => RepoFactory.GroupFilter.GetByID(a).ToClient())                      .Where(a => a != null)                      .ToList()'                      RemovedItems = changes[0].RemovedItems.ToList()'                      LastChange = changes[0].LastChange                  };                    //Add Group Filter that one of his child changed.                  bool end;                  do                  {                      end = true;                      foreach (CL_GroupFilter ag in c.Filters.ChangedItems                          .Where(a => a.ParentGroupFilterID.HasValue && a.ParentGroupFilterID.Value != 0)                          .ToList())                      {                          if (!c.Filters.ChangedItems.Any(a => a.GroupFilterID == ag.ParentGroupFilterID.Value))                          {                              end = false;                              CL_GroupFilter cag = RepoFactory.GroupFilter.GetByID(ag.ParentGroupFilterID.Value)                                  .ToClient();                              if (cag != null)                                  c.Filters.ChangedItems.Add(cag);                          }                      }                  } while (!end);                    c.Groups = new CL_Changes<CL_AnimeGroup_User>();                  changes[1].ChangedItems.UnionWith(changes[2].ChangedItems);                  changes[1].ChangedItems.UnionWith(changes[2].RemovedItems);                  if (changes[2].LastChange > changes[1].LastChange)                      changes[1].LastChange = changes[2].LastChange;                  c.Groups.ChangedItems = changes[1]                      .ChangedItems.Select(a => RepoFactory.AnimeGroup.GetByID(a))                      .Where(a => a != null)                      .Select(a => a.GetUserContract(userID))                      .ToList();                      c.Groups.RemovedItems = changes[1].RemovedItems.ToList();                  c.Groups.LastChange = changes[1].LastChange;                  c.Series = new CL_Changes<CL_AnimeSeries_User>();                  changes[3].ChangedItems.UnionWith(changes[4].ChangedItems);                  changes[3].ChangedItems.UnionWith(changes[4].RemovedItems);                  if (changes[4].LastChange > changes[3].LastChange)                      changes[3].LastChange = changes[4].LastChange;                  c.Series.ChangedItems = changes[3]                      .ChangedItems.Select(a => RepoFactory.AnimeSeries.GetByID(a))                      .Where(a => a != null)                      .Select(a => a.GetUserContract(userID))                      .ToList();                  c.Series.RemovedItems = changes[3].RemovedItems.ToList();                  c.Series.LastChange = changes[3].LastChange;                  c.LastChange = c.Filters.LastChange;                  if (c.Groups.LastChange > c.LastChange)                      c.LastChange = c.Groups.LastChange;                  if (c.Series.LastChange > c.LastChange)                      c.LastChange = c.Series.LastChange;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetAllChanges,The following statement contains a magic number: try              {                  List<Changes<int>> changes = ChangeTracker<int>.GetChainedChanges(new List<ChangeTracker<int>>                  {                      RepoFactory.GroupFilter.GetChangeTracker()'                      RepoFactory.AnimeGroup.GetChangeTracker()'                      RepoFactory.AnimeGroup_User.GetChangeTracker(userID)'                      RepoFactory.AnimeSeries.GetChangeTracker()'                      RepoFactory.AnimeSeries_User.GetChangeTracker(userID)                  }' date);                  c.Filters = new CL_Changes<CL_GroupFilter>                  {                      ChangedItems = changes[0]                      .ChangedItems.Select(a => RepoFactory.GroupFilter.GetByID(a).ToClient())                      .Where(a => a != null)                      .ToList()'                      RemovedItems = changes[0].RemovedItems.ToList()'                      LastChange = changes[0].LastChange                  };                    //Add Group Filter that one of his child changed.                  bool end;                  do                  {                      end = true;                      foreach (CL_GroupFilter ag in c.Filters.ChangedItems                          .Where(a => a.ParentGroupFilterID.HasValue && a.ParentGroupFilterID.Value != 0)                          .ToList())                      {                          if (!c.Filters.ChangedItems.Any(a => a.GroupFilterID == ag.ParentGroupFilterID.Value))                          {                              end = false;                              CL_GroupFilter cag = RepoFactory.GroupFilter.GetByID(ag.ParentGroupFilterID.Value)                                  .ToClient();                              if (cag != null)                                  c.Filters.ChangedItems.Add(cag);                          }                      }                  } while (!end);                    c.Groups = new CL_Changes<CL_AnimeGroup_User>();                  changes[1].ChangedItems.UnionWith(changes[2].ChangedItems);                  changes[1].ChangedItems.UnionWith(changes[2].RemovedItems);                  if (changes[2].LastChange > changes[1].LastChange)                      changes[1].LastChange = changes[2].LastChange;                  c.Groups.ChangedItems = changes[1]                      .ChangedItems.Select(a => RepoFactory.AnimeGroup.GetByID(a))                      .Where(a => a != null)                      .Select(a => a.GetUserContract(userID))                      .ToList();                      c.Groups.RemovedItems = changes[1].RemovedItems.ToList();                  c.Groups.LastChange = changes[1].LastChange;                  c.Series = new CL_Changes<CL_AnimeSeries_User>();                  changes[3].ChangedItems.UnionWith(changes[4].ChangedItems);                  changes[3].ChangedItems.UnionWith(changes[4].RemovedItems);                  if (changes[4].LastChange > changes[3].LastChange)                      changes[3].LastChange = changes[4].LastChange;                  c.Series.ChangedItems = changes[3]                      .ChangedItems.Select(a => RepoFactory.AnimeSeries.GetByID(a))                      .Where(a => a != null)                      .Select(a => a.GetUserContract(userID))                      .ToList();                  c.Series.RemovedItems = changes[3].RemovedItems.ToList();                  c.Series.LastChange = changes[3].LastChange;                  c.LastChange = c.Filters.LastChange;                  if (c.Groups.LastChange > c.LastChange)                      c.LastChange = c.Groups.LastChange;                  if (c.Series.LastChange > c.LastChange)                      c.LastChange = c.Series.LastChange;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetAllChanges,The following statement contains a magic number: try              {                  List<Changes<int>> changes = ChangeTracker<int>.GetChainedChanges(new List<ChangeTracker<int>>                  {                      RepoFactory.GroupFilter.GetChangeTracker()'                      RepoFactory.AnimeGroup.GetChangeTracker()'                      RepoFactory.AnimeGroup_User.GetChangeTracker(userID)'                      RepoFactory.AnimeSeries.GetChangeTracker()'                      RepoFactory.AnimeSeries_User.GetChangeTracker(userID)                  }' date);                  c.Filters = new CL_Changes<CL_GroupFilter>                  {                      ChangedItems = changes[0]                      .ChangedItems.Select(a => RepoFactory.GroupFilter.GetByID(a).ToClient())                      .Where(a => a != null)                      .ToList()'                      RemovedItems = changes[0].RemovedItems.ToList()'                      LastChange = changes[0].LastChange                  };                    //Add Group Filter that one of his child changed.                  bool end;                  do                  {                      end = true;                      foreach (CL_GroupFilter ag in c.Filters.ChangedItems                          .Where(a => a.ParentGroupFilterID.HasValue && a.ParentGroupFilterID.Value != 0)                          .ToList())                      {                          if (!c.Filters.ChangedItems.Any(a => a.GroupFilterID == ag.ParentGroupFilterID.Value))                          {                              end = false;                              CL_GroupFilter cag = RepoFactory.GroupFilter.GetByID(ag.ParentGroupFilterID.Value)                                  .ToClient();                              if (cag != null)                                  c.Filters.ChangedItems.Add(cag);                          }                      }                  } while (!end);                    c.Groups = new CL_Changes<CL_AnimeGroup_User>();                  changes[1].ChangedItems.UnionWith(changes[2].ChangedItems);                  changes[1].ChangedItems.UnionWith(changes[2].RemovedItems);                  if (changes[2].LastChange > changes[1].LastChange)                      changes[1].LastChange = changes[2].LastChange;                  c.Groups.ChangedItems = changes[1]                      .ChangedItems.Select(a => RepoFactory.AnimeGroup.GetByID(a))                      .Where(a => a != null)                      .Select(a => a.GetUserContract(userID))                      .ToList();                      c.Groups.RemovedItems = changes[1].RemovedItems.ToList();                  c.Groups.LastChange = changes[1].LastChange;                  c.Series = new CL_Changes<CL_AnimeSeries_User>();                  changes[3].ChangedItems.UnionWith(changes[4].ChangedItems);                  changes[3].ChangedItems.UnionWith(changes[4].RemovedItems);                  if (changes[4].LastChange > changes[3].LastChange)                      changes[3].LastChange = changes[4].LastChange;                  c.Series.ChangedItems = changes[3]                      .ChangedItems.Select(a => RepoFactory.AnimeSeries.GetByID(a))                      .Where(a => a != null)                      .Select(a => a.GetUserContract(userID))                      .ToList();                  c.Series.RemovedItems = changes[3].RemovedItems.ToList();                  c.Series.LastChange = changes[3].LastChange;                  c.LastChange = c.Filters.LastChange;                  if (c.Groups.LastChange > c.LastChange)                      c.LastChange = c.Groups.LastChange;                  if (c.Series.LastChange > c.LastChange)                      c.LastChange = c.Series.LastChange;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetAllChanges,The following statement contains a magic number: try              {                  List<Changes<int>> changes = ChangeTracker<int>.GetChainedChanges(new List<ChangeTracker<int>>                  {                      RepoFactory.GroupFilter.GetChangeTracker()'                      RepoFactory.AnimeGroup.GetChangeTracker()'                      RepoFactory.AnimeGroup_User.GetChangeTracker(userID)'                      RepoFactory.AnimeSeries.GetChangeTracker()'                      RepoFactory.AnimeSeries_User.GetChangeTracker(userID)                  }' date);                  c.Filters = new CL_Changes<CL_GroupFilter>                  {                      ChangedItems = changes[0]                      .ChangedItems.Select(a => RepoFactory.GroupFilter.GetByID(a).ToClient())                      .Where(a => a != null)                      .ToList()'                      RemovedItems = changes[0].RemovedItems.ToList()'                      LastChange = changes[0].LastChange                  };                    //Add Group Filter that one of his child changed.                  bool end;                  do                  {                      end = true;                      foreach (CL_GroupFilter ag in c.Filters.ChangedItems                          .Where(a => a.ParentGroupFilterID.HasValue && a.ParentGroupFilterID.Value != 0)                          .ToList())                      {                          if (!c.Filters.ChangedItems.Any(a => a.GroupFilterID == ag.ParentGroupFilterID.Value))                          {                              end = false;                              CL_GroupFilter cag = RepoFactory.GroupFilter.GetByID(ag.ParentGroupFilterID.Value)                                  .ToClient();                              if (cag != null)                                  c.Filters.ChangedItems.Add(cag);                          }                      }                  } while (!end);                    c.Groups = new CL_Changes<CL_AnimeGroup_User>();                  changes[1].ChangedItems.UnionWith(changes[2].ChangedItems);                  changes[1].ChangedItems.UnionWith(changes[2].RemovedItems);                  if (changes[2].LastChange > changes[1].LastChange)                      changes[1].LastChange = changes[2].LastChange;                  c.Groups.ChangedItems = changes[1]                      .ChangedItems.Select(a => RepoFactory.AnimeGroup.GetByID(a))                      .Where(a => a != null)                      .Select(a => a.GetUserContract(userID))                      .ToList();                      c.Groups.RemovedItems = changes[1].RemovedItems.ToList();                  c.Groups.LastChange = changes[1].LastChange;                  c.Series = new CL_Changes<CL_AnimeSeries_User>();                  changes[3].ChangedItems.UnionWith(changes[4].ChangedItems);                  changes[3].ChangedItems.UnionWith(changes[4].RemovedItems);                  if (changes[4].LastChange > changes[3].LastChange)                      changes[3].LastChange = changes[4].LastChange;                  c.Series.ChangedItems = changes[3]                      .ChangedItems.Select(a => RepoFactory.AnimeSeries.GetByID(a))                      .Where(a => a != null)                      .Select(a => a.GetUserContract(userID))                      .ToList();                  c.Series.RemovedItems = changes[3].RemovedItems.ToList();                  c.Series.LastChange = changes[3].LastChange;                  c.LastChange = c.Filters.LastChange;                  if (c.Groups.LastChange > c.LastChange)                      c.LastChange = c.Groups.LastChange;                  if (c.Series.LastChange > c.LastChange)                      c.LastChange = c.Series.LastChange;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetAllChanges,The following statement contains a magic number: try              {                  List<Changes<int>> changes = ChangeTracker<int>.GetChainedChanges(new List<ChangeTracker<int>>                  {                      RepoFactory.GroupFilter.GetChangeTracker()'                      RepoFactory.AnimeGroup.GetChangeTracker()'                      RepoFactory.AnimeGroup_User.GetChangeTracker(userID)'                      RepoFactory.AnimeSeries.GetChangeTracker()'                      RepoFactory.AnimeSeries_User.GetChangeTracker(userID)                  }' date);                  c.Filters = new CL_Changes<CL_GroupFilter>                  {                      ChangedItems = changes[0]                      .ChangedItems.Select(a => RepoFactory.GroupFilter.GetByID(a).ToClient())                      .Where(a => a != null)                      .ToList()'                      RemovedItems = changes[0].RemovedItems.ToList()'                      LastChange = changes[0].LastChange                  };                    //Add Group Filter that one of his child changed.                  bool end;                  do                  {                      end = true;                      foreach (CL_GroupFilter ag in c.Filters.ChangedItems                          .Where(a => a.ParentGroupFilterID.HasValue && a.ParentGroupFilterID.Value != 0)                          .ToList())                      {                          if (!c.Filters.ChangedItems.Any(a => a.GroupFilterID == ag.ParentGroupFilterID.Value))                          {                              end = false;                              CL_GroupFilter cag = RepoFactory.GroupFilter.GetByID(ag.ParentGroupFilterID.Value)                                  .ToClient();                              if (cag != null)                                  c.Filters.ChangedItems.Add(cag);                          }                      }                  } while (!end);                    c.Groups = new CL_Changes<CL_AnimeGroup_User>();                  changes[1].ChangedItems.UnionWith(changes[2].ChangedItems);                  changes[1].ChangedItems.UnionWith(changes[2].RemovedItems);                  if (changes[2].LastChange > changes[1].LastChange)                      changes[1].LastChange = changes[2].LastChange;                  c.Groups.ChangedItems = changes[1]                      .ChangedItems.Select(a => RepoFactory.AnimeGroup.GetByID(a))                      .Where(a => a != null)                      .Select(a => a.GetUserContract(userID))                      .ToList();                      c.Groups.RemovedItems = changes[1].RemovedItems.ToList();                  c.Groups.LastChange = changes[1].LastChange;                  c.Series = new CL_Changes<CL_AnimeSeries_User>();                  changes[3].ChangedItems.UnionWith(changes[4].ChangedItems);                  changes[3].ChangedItems.UnionWith(changes[4].RemovedItems);                  if (changes[4].LastChange > changes[3].LastChange)                      changes[3].LastChange = changes[4].LastChange;                  c.Series.ChangedItems = changes[3]                      .ChangedItems.Select(a => RepoFactory.AnimeSeries.GetByID(a))                      .Where(a => a != null)                      .Select(a => a.GetUserContract(userID))                      .ToList();                  c.Series.RemovedItems = changes[3].RemovedItems.ToList();                  c.Series.LastChange = changes[3].LastChange;                  c.LastChange = c.Filters.LastChange;                  if (c.Groups.LastChange > c.LastChange)                      c.LastChange = c.Groups.LastChange;                  if (c.Series.LastChange > c.LastChange)                      c.LastChange = c.Series.LastChange;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetAllChanges,The following statement contains a magic number: try              {                  List<Changes<int>> changes = ChangeTracker<int>.GetChainedChanges(new List<ChangeTracker<int>>                  {                      RepoFactory.GroupFilter.GetChangeTracker()'                      RepoFactory.AnimeGroup.GetChangeTracker()'                      RepoFactory.AnimeGroup_User.GetChangeTracker(userID)'                      RepoFactory.AnimeSeries.GetChangeTracker()'                      RepoFactory.AnimeSeries_User.GetChangeTracker(userID)                  }' date);                  c.Filters = new CL_Changes<CL_GroupFilter>                  {                      ChangedItems = changes[0]                      .ChangedItems.Select(a => RepoFactory.GroupFilter.GetByID(a).ToClient())                      .Where(a => a != null)                      .ToList()'                      RemovedItems = changes[0].RemovedItems.ToList()'                      LastChange = changes[0].LastChange                  };                    //Add Group Filter that one of his child changed.                  bool end;                  do                  {                      end = true;                      foreach (CL_GroupFilter ag in c.Filters.ChangedItems                          .Where(a => a.ParentGroupFilterID.HasValue && a.ParentGroupFilterID.Value != 0)                          .ToList())                      {                          if (!c.Filters.ChangedItems.Any(a => a.GroupFilterID == ag.ParentGroupFilterID.Value))                          {                              end = false;                              CL_GroupFilter cag = RepoFactory.GroupFilter.GetByID(ag.ParentGroupFilterID.Value)                                  .ToClient();                              if (cag != null)                                  c.Filters.ChangedItems.Add(cag);                          }                      }                  } while (!end);                    c.Groups = new CL_Changes<CL_AnimeGroup_User>();                  changes[1].ChangedItems.UnionWith(changes[2].ChangedItems);                  changes[1].ChangedItems.UnionWith(changes[2].RemovedItems);                  if (changes[2].LastChange > changes[1].LastChange)                      changes[1].LastChange = changes[2].LastChange;                  c.Groups.ChangedItems = changes[1]                      .ChangedItems.Select(a => RepoFactory.AnimeGroup.GetByID(a))                      .Where(a => a != null)                      .Select(a => a.GetUserContract(userID))                      .ToList();                      c.Groups.RemovedItems = changes[1].RemovedItems.ToList();                  c.Groups.LastChange = changes[1].LastChange;                  c.Series = new CL_Changes<CL_AnimeSeries_User>();                  changes[3].ChangedItems.UnionWith(changes[4].ChangedItems);                  changes[3].ChangedItems.UnionWith(changes[4].RemovedItems);                  if (changes[4].LastChange > changes[3].LastChange)                      changes[3].LastChange = changes[4].LastChange;                  c.Series.ChangedItems = changes[3]                      .ChangedItems.Select(a => RepoFactory.AnimeSeries.GetByID(a))                      .Where(a => a != null)                      .Select(a => a.GetUserContract(userID))                      .ToList();                  c.Series.RemovedItems = changes[3].RemovedItems.ToList();                  c.Series.LastChange = changes[3].LastChange;                  c.LastChange = c.Filters.LastChange;                  if (c.Groups.LastChange > c.LastChange)                      c.LastChange = c.Groups.LastChange;                  if (c.Series.LastChange > c.LastChange)                      c.LastChange = c.Series.LastChange;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetAllChanges,The following statement contains a magic number: try              {                  List<Changes<int>> changes = ChangeTracker<int>.GetChainedChanges(new List<ChangeTracker<int>>                  {                      RepoFactory.GroupFilter.GetChangeTracker()'                      RepoFactory.AnimeGroup.GetChangeTracker()'                      RepoFactory.AnimeGroup_User.GetChangeTracker(userID)'                      RepoFactory.AnimeSeries.GetChangeTracker()'                      RepoFactory.AnimeSeries_User.GetChangeTracker(userID)                  }' date);                  c.Filters = new CL_Changes<CL_GroupFilter>                  {                      ChangedItems = changes[0]                      .ChangedItems.Select(a => RepoFactory.GroupFilter.GetByID(a).ToClient())                      .Where(a => a != null)                      .ToList()'                      RemovedItems = changes[0].RemovedItems.ToList()'                      LastChange = changes[0].LastChange                  };                    //Add Group Filter that one of his child changed.                  bool end;                  do                  {                      end = true;                      foreach (CL_GroupFilter ag in c.Filters.ChangedItems                          .Where(a => a.ParentGroupFilterID.HasValue && a.ParentGroupFilterID.Value != 0)                          .ToList())                      {                          if (!c.Filters.ChangedItems.Any(a => a.GroupFilterID == ag.ParentGroupFilterID.Value))                          {                              end = false;                              CL_GroupFilter cag = RepoFactory.GroupFilter.GetByID(ag.ParentGroupFilterID.Value)                                  .ToClient();                              if (cag != null)                                  c.Filters.ChangedItems.Add(cag);                          }                      }                  } while (!end);                    c.Groups = new CL_Changes<CL_AnimeGroup_User>();                  changes[1].ChangedItems.UnionWith(changes[2].ChangedItems);                  changes[1].ChangedItems.UnionWith(changes[2].RemovedItems);                  if (changes[2].LastChange > changes[1].LastChange)                      changes[1].LastChange = changes[2].LastChange;                  c.Groups.ChangedItems = changes[1]                      .ChangedItems.Select(a => RepoFactory.AnimeGroup.GetByID(a))                      .Where(a => a != null)                      .Select(a => a.GetUserContract(userID))                      .ToList();                      c.Groups.RemovedItems = changes[1].RemovedItems.ToList();                  c.Groups.LastChange = changes[1].LastChange;                  c.Series = new CL_Changes<CL_AnimeSeries_User>();                  changes[3].ChangedItems.UnionWith(changes[4].ChangedItems);                  changes[3].ChangedItems.UnionWith(changes[4].RemovedItems);                  if (changes[4].LastChange > changes[3].LastChange)                      changes[3].LastChange = changes[4].LastChange;                  c.Series.ChangedItems = changes[3]                      .ChangedItems.Select(a => RepoFactory.AnimeSeries.GetByID(a))                      .Where(a => a != null)                      .Select(a => a.GetUserContract(userID))                      .ToList();                  c.Series.RemovedItems = changes[3].RemovedItems.ToList();                  c.Series.LastChange = changes[3].LastChange;                  c.LastChange = c.Filters.LastChange;                  if (c.Groups.LastChange > c.LastChange)                      c.LastChange = c.Groups.LastChange;                  if (c.Series.LastChange > c.LastChange)                      c.LastChange = c.Series.LastChange;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,SaveServerSettings,The following statement contains a magic number: try              {                  // validate the settings                  bool anidbSettingsChanged = false;                  if (contractIn.AniDB_ClientPort != ServerSettings.AniDB_ClientPort)                  {                      anidbSettingsChanged = true;                      int.TryParse(contractIn.AniDB_ClientPort' out int cport);                      if (cport <= 0)                      {                          contract.ErrorMessage = "AniDB Client Port must be numeric and greater than 0" +                                                  Environment.NewLine;                      }                  }                    if (contractIn.AniDB_ServerPort != ServerSettings.AniDB_ServerPort)                  {                      anidbSettingsChanged = true;                      int.TryParse(contractIn.AniDB_ServerPort' out int sport);                      if (sport <= 0)                      {                          contract.ErrorMessage = "AniDB Server Port must be numeric and greater than 0" +                                                  Environment.NewLine;                      }                  }                    if (contractIn.AniDB_Username != ServerSettings.AniDB_Username)                  {                      anidbSettingsChanged = true;                      if (string.IsNullOrEmpty(contractIn.AniDB_Username))                      {                          contract.ErrorMessage = "AniDB User Name must have a value" + Environment.NewLine;                      }                  }                    if (contractIn.AniDB_Password != ServerSettings.AniDB_Password)                  {                      anidbSettingsChanged = true;                      if (string.IsNullOrEmpty(contractIn.AniDB_Password))                      {                          contract.ErrorMessage = "AniDB Password must have a value" + Environment.NewLine;                      }                  }                    if (contractIn.AniDB_ServerAddress != ServerSettings.AniDB_ServerAddress)                  {                      anidbSettingsChanged = true;                      if (string.IsNullOrEmpty(contractIn.AniDB_ServerAddress))                      {                          contract.ErrorMessage = "AniDB Server Address must have a value" + Environment.NewLine;                      }                  }                    if (contract.ErrorMessage.Length > 0) return contract;                    ServerSettings.AniDB_ClientPort = contractIn.AniDB_ClientPort;                  ServerSettings.AniDB_Password = contractIn.AniDB_Password;                  ServerSettings.AniDB_ServerAddress = contractIn.AniDB_ServerAddress;                  ServerSettings.AniDB_ServerPort = contractIn.AniDB_ServerPort;                  ServerSettings.AniDB_Username = contractIn.AniDB_Username;                  ServerSettings.AniDB_AVDumpClientPort = contractIn.AniDB_AVDumpClientPort;                  ServerSettings.AniDB_AVDumpKey = contractIn.AniDB_AVDumpKey;                    ServerSettings.AniDB_DownloadRelatedAnime = contractIn.AniDB_DownloadRelatedAnime;                  ServerSettings.AniDB_DownloadReleaseGroups = contractIn.AniDB_DownloadReleaseGroups;                  ServerSettings.AniDB_DownloadReviews = contractIn.AniDB_DownloadReviews;                  ServerSettings.AniDB_DownloadSimilarAnime = contractIn.AniDB_DownloadSimilarAnime;                    ServerSettings.AniDB_MyList_AddFiles = contractIn.AniDB_MyList_AddFiles;                  ServerSettings.AniDB_MyList_ReadUnwatched = contractIn.AniDB_MyList_ReadUnwatched;                  ServerSettings.AniDB_MyList_ReadWatched = contractIn.AniDB_MyList_ReadWatched;                  ServerSettings.AniDB_MyList_SetUnwatched = contractIn.AniDB_MyList_SetUnwatched;                  ServerSettings.AniDB_MyList_SetWatched = contractIn.AniDB_MyList_SetWatched;                  ServerSettings.AniDB_MyList_StorageState = (AniDBFile_State) contractIn.AniDB_MyList_StorageState;                  ServerSettings.AniDB_MyList_DeleteType = (AniDBFileDeleteType) contractIn.AniDB_MyList_DeleteType;                    ServerSettings.AniDB_MyList_UpdateFrequency =                      (ScheduledUpdateFrequency) contractIn.AniDB_MyList_UpdateFrequency;                  ServerSettings.AniDB_Calendar_UpdateFrequency =                      (ScheduledUpdateFrequency) contractIn.AniDB_Calendar_UpdateFrequency;                  ServerSettings.AniDB_Anime_UpdateFrequency =                      (ScheduledUpdateFrequency) contractIn.AniDB_Anime_UpdateFrequency;                  ServerSettings.AniDB_MyListStats_UpdateFrequency =                      (ScheduledUpdateFrequency) contractIn.AniDB_MyListStats_UpdateFrequency;                  ServerSettings.AniDB_File_UpdateFrequency =                      (ScheduledUpdateFrequency) contractIn.AniDB_File_UpdateFrequency;                    ServerSettings.AniDB_DownloadCharacters = contractIn.AniDB_DownloadCharacters;                  ServerSettings.AniDB_DownloadCreators = contractIn.AniDB_DownloadCreators;                    // Web Cache                  ServerSettings.WebCache_Address = contractIn.WebCache_Address;                  ServerSettings.WebCache_Anonymous = contractIn.WebCache_Anonymous;                  ServerSettings.WebCache_XRefFileEpisode_Get = contractIn.WebCache_XRefFileEpisode_Get;                  ServerSettings.WebCache_XRefFileEpisode_Send = contractIn.WebCache_XRefFileEpisode_Send;                  ServerSettings.WebCache_TvDB_Get = contractIn.WebCache_TvDB_Get;                  ServerSettings.WebCache_TvDB_Send = contractIn.WebCache_TvDB_Send;                  ServerSettings.WebCache_Trakt_Get = contractIn.WebCache_Trakt_Get;                  ServerSettings.WebCache_Trakt_Send = contractIn.WebCache_Trakt_Send;                  ServerSettings.WebCache_MAL_Get = contractIn.WebCache_MAL_Get;                  ServerSettings.WebCache_MAL_Send = contractIn.WebCache_MAL_Send;                  ServerSettings.WebCache_UserInfo = contractIn.WebCache_UserInfo;                    // TvDB                  ServerSettings.TvDB_AutoLink = contractIn.TvDB_AutoLink;                  ServerSettings.TvDB_AutoFanart = contractIn.TvDB_AutoFanart;                  ServerSettings.TvDB_AutoFanartAmount = contractIn.TvDB_AutoFanartAmount;                  ServerSettings.TvDB_AutoPosters = contractIn.TvDB_AutoPosters;                  ServerSettings.TvDB_AutoPostersAmount = contractIn.TvDB_AutoPostersAmount;                  ServerSettings.TvDB_AutoWideBanners = contractIn.TvDB_AutoWideBanners;                  ServerSettings.TvDB_AutoWideBannersAmount = contractIn.TvDB_AutoWideBannersAmount;                  ServerSettings.TvDB_UpdateFrequency = (ScheduledUpdateFrequency) contractIn.TvDB_UpdateFrequency;                  ServerSettings.TvDB_Language = contractIn.TvDB_Language;                    // MovieDB                  ServerSettings.MovieDB_AutoFanart = contractIn.MovieDB_AutoFanart;                  ServerSettings.MovieDB_AutoFanartAmount = contractIn.MovieDB_AutoFanartAmount;                  ServerSettings.MovieDB_AutoPosters = contractIn.MovieDB_AutoPosters;                  ServerSettings.MovieDB_AutoPostersAmount = contractIn.MovieDB_AutoPostersAmount;                    // Import settings                  ServerSettings.VideoExtensions = contractIn.VideoExtensions;                  ServerSettings.Import_UseExistingFileWatchedStatus = contractIn.Import_UseExistingFileWatchedStatus;                  ServerSettings.AutoGroupSeries = contractIn.AutoGroupSeries;                  ServerSettings.AutoGroupSeriesUseScoreAlgorithm = contractIn.AutoGroupSeriesUseScoreAlgorithm;                  ServerSettings.AutoGroupSeriesRelationExclusions = contractIn.AutoGroupSeriesRelationExclusions;                  ServerSettings.FileQualityFilterEnabled = contractIn.FileQualityFilterEnabled;                  if (!string.IsNullOrEmpty(contractIn.FileQualityFilterPreferences))                      ServerSettings.FileQualityFilterPreferences = contractIn.FileQualityFilterPreferences;                  ServerSettings.RunImportOnStart = contractIn.RunImportOnStart;                  ServerSettings.ScanDropFoldersOnStart = contractIn.ScanDropFoldersOnStart;                  ServerSettings.Hash_CRC32 = contractIn.Hash_CRC32;                  ServerSettings.Hash_MD5 = contractIn.Hash_MD5;                  ServerSettings.Hash_SHA1 = contractIn.Hash_SHA1;                    // Language                  ServerSettings.LanguagePreference = contractIn.LanguagePreference;                  ServerSettings.LanguageUseSynonyms = contractIn.LanguageUseSynonyms;                  ServerSettings.EpisodeTitleSource = (DataSourceType) contractIn.EpisodeTitleSource;                  ServerSettings.SeriesDescriptionSource = (DataSourceType) contractIn.SeriesDescriptionSource;                  ServerSettings.SeriesNameSource = (DataSourceType) contractIn.SeriesNameSource;                    // Trakt                  ServerSettings.Trakt_IsEnabled = contractIn.Trakt_IsEnabled;                  ServerSettings.Trakt_AuthToken = contractIn.Trakt_AuthToken;                  ServerSettings.Trakt_RefreshToken = contractIn.Trakt_RefreshToken;                  ServerSettings.Trakt_TokenExpirationDate = contractIn.Trakt_TokenExpirationDate;                  ServerSettings.Trakt_UpdateFrequency = (ScheduledUpdateFrequency) contractIn.Trakt_UpdateFrequency;                  ServerSettings.Trakt_SyncFrequency = (ScheduledUpdateFrequency) contractIn.Trakt_SyncFrequency;                    // MAL                  ServerSettings.MAL_AutoLink = contractIn.MAL_AutoLink;                  ServerSettings.MAL_Username = contractIn.MAL_Username;                  ServerSettings.MAL_Password = contractIn.MAL_Password;                  ServerSettings.MAL_UpdateFrequency = (ScheduledUpdateFrequency) contractIn.MAL_UpdateFrequency;                  ServerSettings.MAL_NeverDecreaseWatchedNums = contractIn.MAL_NeverDecreaseWatchedNums;                    //Plex                  ServerSettings.Plex_Server = contractIn.Plex_ServerHost;                  ServerSettings.Plex_Libraries = contractIn.Plex_Sections.Length > 0                      ? contractIn.Plex_Sections.Split(''').Select(int.Parse).ToArray()                      : new int[0];                      if (anidbSettingsChanged)                  {                      ShokoService.AnidbProcessor.ForceLogout();                      ShokoService.AnidbProcessor.CloseConnections();                        Thread.Sleep(1000);                      ShokoService.AnidbProcessor.Init(ServerSettings.AniDB_Username' ServerSettings.AniDB_Password'                          ServerSettings.AniDB_ServerAddress'                          ServerSettings.AniDB_ServerPort' ServerSettings.AniDB_ClientPort);                  }              }              catch (Exception ex)              {                  logger.Error(ex' "Save server settings exception:\n " + ex.ToString());                  contract.ErrorMessage = ex.Message;              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,ClearHasherQueue,The following statement contains a magic number: try              {                  ShokoService.CmdProcessorHasher.Stop();                    // wait until the queue stops                  while (ShokoService.CmdProcessorHasher.ProcessingCommands || ShokoService.CmdProcessorHasher.IsWorkerBusy)                  {                      Thread.Sleep(200);                  }                  Thread.Sleep(200);                    RepoFactory.CommandRequest.Delete(RepoFactory.CommandRequest.GetAllCommandRequestHasher());                    ShokoService.CmdProcessorHasher.Init();              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,ClearHasherQueue,The following statement contains a magic number: try              {                  ShokoService.CmdProcessorHasher.Stop();                    // wait until the queue stops                  while (ShokoService.CmdProcessorHasher.ProcessingCommands || ShokoService.CmdProcessorHasher.IsWorkerBusy)                  {                      Thread.Sleep(200);                  }                  Thread.Sleep(200);                    RepoFactory.CommandRequest.Delete(RepoFactory.CommandRequest.GetAllCommandRequestHasher());                    ShokoService.CmdProcessorHasher.Init();              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,ClearImagesQueue,The following statement contains a magic number: try              {                  ShokoService.CmdProcessorImages.Stop();                    // wait until the queue stops                  while (ShokoService.CmdProcessorImages.ProcessingCommands || ShokoService.CmdProcessorImages.IsWorkerBusy)                  {                      Thread.Sleep(200);                  }                  Thread.Sleep(200);                    RepoFactory.CommandRequest.Delete(RepoFactory.CommandRequest.GetAllCommandRequestImages());                  ShokoService.CmdProcessorImages.Init();              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,ClearImagesQueue,The following statement contains a magic number: try              {                  ShokoService.CmdProcessorImages.Stop();                    // wait until the queue stops                  while (ShokoService.CmdProcessorImages.ProcessingCommands || ShokoService.CmdProcessorImages.IsWorkerBusy)                  {                      Thread.Sleep(200);                  }                  Thread.Sleep(200);                    RepoFactory.CommandRequest.Delete(RepoFactory.CommandRequest.GetAllCommandRequestImages());                  ShokoService.CmdProcessorImages.Init();              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,ClearGeneralQueue,The following statement contains a magic number: try              {                  ShokoService.CmdProcessorGeneral.Stop();                    // wait until the queue stops                  while (ShokoService.CmdProcessorGeneral.ProcessingCommands || ShokoService.CmdProcessorGeneral.IsWorkerBusy)                  {                      Thread.Sleep(200);                  }                  Thread.Sleep(200);                    RepoFactory.CommandRequest.Delete(RepoFactory.CommandRequest.GetAllCommandRequestGeneral());                  ShokoService.CmdProcessorGeneral.Init();              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,ClearGeneralQueue,The following statement contains a magic number: try              {                  ShokoService.CmdProcessorGeneral.Stop();                    // wait until the queue stops                  while (ShokoService.CmdProcessorGeneral.ProcessingCommands || ShokoService.CmdProcessorGeneral.IsWorkerBusy)                  {                      Thread.Sleep(200);                  }                  Thread.Sleep(200);                    RepoFactory.CommandRequest.Delete(RepoFactory.CommandRequest.GetAllCommandRequestGeneral());                  ShokoService.CmdProcessorGeneral.Init();              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,TestAniDBConnection,The following statement contains a magic number: try              {                  log += "Disposing..." + Environment.NewLine;                  ShokoService.AnidbProcessor.ForceLogout();                  ShokoService.AnidbProcessor.CloseConnections();                  Thread.Sleep(1000);                    log += "Init..." + Environment.NewLine;                  ShokoService.AnidbProcessor.Init(ServerSettings.AniDB_Username' ServerSettings.AniDB_Password'                      ServerSettings.AniDB_ServerAddress'                      ServerSettings.AniDB_ServerPort' ServerSettings.AniDB_ClientPort);                    log += "Login..." + Environment.NewLine;                  if (ShokoService.AnidbProcessor.Login())                  {                      log += "Login Success!" + Environment.NewLine;                      log += "Logout..." + Environment.NewLine;                      ShokoService.AnidbProcessor.ForceLogout();                      log += "Logged out" + Environment.NewLine;                  }                  else                  {                      log += "Login FAILED!" + Environment.NewLine;                  }                    return log;              }              catch (Exception ex)              {                  log += ex.Message + Environment.NewLine;              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetAnimeForMonth,The following statement contains a magic number: try              {                  SVR_JMMUser user = RepoFactory.JMMUser.GetByID(jmmuserID);                  if (user == null) return animeList;                    DateTime startDate = new DateTime(year' month' 1' 0' 0' 0);                  DateTime endDate = startDate.AddMonths(1);                  endDate = endDate.AddMinutes(-10);                    List<SVR_AniDB_Anime> animes = RepoFactory.AniDB_Anime.GetForDate(startDate' endDate);                  foreach (SVR_AniDB_Anime anime in animes)                  {                      if (anime?.Contract?.AniDBAnime == null)                          continue;                      if (!user.GetHideCategories().FindInEnumerable(anime.Contract.AniDBAnime.GetAllTags()))                          animeList.Add(anime.Contract.AniDBAnime);                  }              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetRecommendations,The following statement contains a magic number: try              {                  SVR_JMMUser juser = RepoFactory.JMMUser.GetByID(userID);                  if (juser == null) return recs;                    // get all the anime the user has chosen to ignore                  int ignoreType = 1;                  switch (recommendationType)                  {                      case 1:                          ignoreType = 1;                          break;                      case 2:                          ignoreType = 2;                          break;                  }                  List<IgnoreAnime> ignored = RepoFactory.IgnoreAnime.GetByUserAndType(userID' ignoreType);                  Dictionary<int' IgnoreAnime> dictIgnored = new Dictionary<int' IgnoreAnime>();                  foreach (IgnoreAnime ign in ignored)                      dictIgnored[ign.AnimeID] = ign;                      // find all the series which the user has rated                  List<AniDB_Vote> allVotes = RepoFactory.AniDB_Vote.GetAll()                      .OrderByDescending(a => a.VoteValue)                      .ToList();                  if (allVotes.Count == 0) return recs;                      Dictionary<int' CL_Recommendation> dictRecs = new Dictionary<int' CL_Recommendation>();                    List<AniDB_Vote> animeVotes = new List<AniDB_Vote>();                  foreach (AniDB_Vote vote in allVotes)                  {                      if (vote.VoteType != (int) AniDBVoteType.Anime &&                          vote.VoteType != (int) AniDBVoteType.AnimeTemp)                          continue;                        if (dictIgnored.ContainsKey(vote.EntityID)) continue;                        // check if the user has this anime                      SVR_AniDB_Anime anime = RepoFactory.AniDB_Anime.GetByAnimeID(vote.EntityID);                      if (anime == null) continue;                        // get similar anime                      List<AniDB_Anime_Similar> simAnime = anime.GetSimilarAnime()                          .OrderByDescending(a => a.GetApprovalPercentage())                          .ToList();                      // sort by the highest approval                        foreach (AniDB_Anime_Similar link in simAnime)                      {                          if (dictIgnored.ContainsKey(link.SimilarAnimeID)) continue;                            SVR_AniDB_Anime animeLink = RepoFactory.AniDB_Anime.GetByAnimeID(link.SimilarAnimeID);                          if (animeLink != null)                              if (!juser.AllowedAnime(animeLink)) continue;                            // don't recommend to watch anime that the user doesn't have                          if (animeLink == null && recommendationType == 1) continue;                            // don't recommend to watch series that the user doesn't have                          SVR_AnimeSeries ser = RepoFactory.AnimeSeries.GetByAnimeID(link.SimilarAnimeID);                          if (ser == null && recommendationType == 1) continue;                              if (ser != null)                          {                              // don't recommend to watch series that the user has already started watching                              AnimeSeries_User userRecord = ser.GetUserRecord(userID);                              if (userRecord != null)                              {                                  if (userRecord.WatchedEpisodeCount > 0 && recommendationType == 1) continue;                              }                                // don't recommend to download anime that the user has files for                              if (ser.LatestLocalEpisodeNumber > 0 && recommendationType == 2) continue;                          }                            CL_Recommendation rec = new CL_Recommendation                          {                              BasedOnAnimeID = anime.AnimeID'                              RecommendedAnimeID = link.SimilarAnimeID                          };                            // if we don't have the anime locally. lets assume the anime has a high rating                          decimal animeRating = 850;                          if (animeLink != null) animeRating = animeLink.GetAniDBRating();                            rec.Score =                              CalculateRecommendationScore(vote.VoteValue' link.GetApprovalPercentage()' animeRating);                          rec.BasedOnVoteValue = vote.VoteValue;                          rec.RecommendedApproval = link.GetApprovalPercentage();                            // check if we have added this recommendation before                          // this might happen where animes are recommended based on different votes                          // and could end up with different scores                          if (dictRecs.ContainsKey(rec.RecommendedAnimeID))                          {                              if (rec.Score < dictRecs[rec.RecommendedAnimeID].Score) continue;                          }                            rec.Recommended_AniDB_Anime = null;                          if (animeLink != null)                              rec.Recommended_AniDB_Anime = animeLink.Contract.AniDBAnime;                            rec.BasedOn_AniDB_Anime = anime.Contract.AniDBAnime;                            rec.Recommended_AnimeSeries = null;                          if (ser != null)                              rec.Recommended_AnimeSeries = ser.GetUserContract(userID);                            SVR_AnimeSeries serBasedOn = RepoFactory.AnimeSeries.GetByAnimeID(anime.AnimeID);                          if (serBasedOn == null) continue;                            rec.BasedOn_AnimeSeries = serBasedOn.GetUserContract(userID);                            dictRecs[rec.RecommendedAnimeID] = rec;                      }                  }                    List<CL_Recommendation> tempRecs = new List<CL_Recommendation>();                  foreach (CL_Recommendation rec in dictRecs.Values)                      tempRecs.Add(rec);                    // sort by the highest score                    int numRecs = 0;                  foreach (CL_Recommendation rec in tempRecs.OrderByDescending(a => a.Score))                  {                      if (numRecs == maxResults) break;                      recs.Add(rec);                      numRecs++;                  }                    if (recs.Count == 0) return recs;                    return recs;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());                  return recs;              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetRecommendations,The following statement contains a magic number: try              {                  SVR_JMMUser juser = RepoFactory.JMMUser.GetByID(userID);                  if (juser == null) return recs;                    // get all the anime the user has chosen to ignore                  int ignoreType = 1;                  switch (recommendationType)                  {                      case 1:                          ignoreType = 1;                          break;                      case 2:                          ignoreType = 2;                          break;                  }                  List<IgnoreAnime> ignored = RepoFactory.IgnoreAnime.GetByUserAndType(userID' ignoreType);                  Dictionary<int' IgnoreAnime> dictIgnored = new Dictionary<int' IgnoreAnime>();                  foreach (IgnoreAnime ign in ignored)                      dictIgnored[ign.AnimeID] = ign;                      // find all the series which the user has rated                  List<AniDB_Vote> allVotes = RepoFactory.AniDB_Vote.GetAll()                      .OrderByDescending(a => a.VoteValue)                      .ToList();                  if (allVotes.Count == 0) return recs;                      Dictionary<int' CL_Recommendation> dictRecs = new Dictionary<int' CL_Recommendation>();                    List<AniDB_Vote> animeVotes = new List<AniDB_Vote>();                  foreach (AniDB_Vote vote in allVotes)                  {                      if (vote.VoteType != (int) AniDBVoteType.Anime &&                          vote.VoteType != (int) AniDBVoteType.AnimeTemp)                          continue;                        if (dictIgnored.ContainsKey(vote.EntityID)) continue;                        // check if the user has this anime                      SVR_AniDB_Anime anime = RepoFactory.AniDB_Anime.GetByAnimeID(vote.EntityID);                      if (anime == null) continue;                        // get similar anime                      List<AniDB_Anime_Similar> simAnime = anime.GetSimilarAnime()                          .OrderByDescending(a => a.GetApprovalPercentage())                          .ToList();                      // sort by the highest approval                        foreach (AniDB_Anime_Similar link in simAnime)                      {                          if (dictIgnored.ContainsKey(link.SimilarAnimeID)) continue;                            SVR_AniDB_Anime animeLink = RepoFactory.AniDB_Anime.GetByAnimeID(link.SimilarAnimeID);                          if (animeLink != null)                              if (!juser.AllowedAnime(animeLink)) continue;                            // don't recommend to watch anime that the user doesn't have                          if (animeLink == null && recommendationType == 1) continue;                            // don't recommend to watch series that the user doesn't have                          SVR_AnimeSeries ser = RepoFactory.AnimeSeries.GetByAnimeID(link.SimilarAnimeID);                          if (ser == null && recommendationType == 1) continue;                              if (ser != null)                          {                              // don't recommend to watch series that the user has already started watching                              AnimeSeries_User userRecord = ser.GetUserRecord(userID);                              if (userRecord != null)                              {                                  if (userRecord.WatchedEpisodeCount > 0 && recommendationType == 1) continue;                              }                                // don't recommend to download anime that the user has files for                              if (ser.LatestLocalEpisodeNumber > 0 && recommendationType == 2) continue;                          }                            CL_Recommendation rec = new CL_Recommendation                          {                              BasedOnAnimeID = anime.AnimeID'                              RecommendedAnimeID = link.SimilarAnimeID                          };                            // if we don't have the anime locally. lets assume the anime has a high rating                          decimal animeRating = 850;                          if (animeLink != null) animeRating = animeLink.GetAniDBRating();                            rec.Score =                              CalculateRecommendationScore(vote.VoteValue' link.GetApprovalPercentage()' animeRating);                          rec.BasedOnVoteValue = vote.VoteValue;                          rec.RecommendedApproval = link.GetApprovalPercentage();                            // check if we have added this recommendation before                          // this might happen where animes are recommended based on different votes                          // and could end up with different scores                          if (dictRecs.ContainsKey(rec.RecommendedAnimeID))                          {                              if (rec.Score < dictRecs[rec.RecommendedAnimeID].Score) continue;                          }                            rec.Recommended_AniDB_Anime = null;                          if (animeLink != null)                              rec.Recommended_AniDB_Anime = animeLink.Contract.AniDBAnime;                            rec.BasedOn_AniDB_Anime = anime.Contract.AniDBAnime;                            rec.Recommended_AnimeSeries = null;                          if (ser != null)                              rec.Recommended_AnimeSeries = ser.GetUserContract(userID);                            SVR_AnimeSeries serBasedOn = RepoFactory.AnimeSeries.GetByAnimeID(anime.AnimeID);                          if (serBasedOn == null) continue;                            rec.BasedOn_AnimeSeries = serBasedOn.GetUserContract(userID);                            dictRecs[rec.RecommendedAnimeID] = rec;                      }                  }                    List<CL_Recommendation> tempRecs = new List<CL_Recommendation>();                  foreach (CL_Recommendation rec in dictRecs.Values)                      tempRecs.Add(rec);                    // sort by the highest score                    int numRecs = 0;                  foreach (CL_Recommendation rec in tempRecs.OrderByDescending(a => a.Score))                  {                      if (numRecs == maxResults) break;                      recs.Add(rec);                      numRecs++;                  }                    if (recs.Count == 0) return recs;                    return recs;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());                  return recs;              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetRecommendations,The following statement contains a magic number: try              {                  SVR_JMMUser juser = RepoFactory.JMMUser.GetByID(userID);                  if (juser == null) return recs;                    // get all the anime the user has chosen to ignore                  int ignoreType = 1;                  switch (recommendationType)                  {                      case 1:                          ignoreType = 1;                          break;                      case 2:                          ignoreType = 2;                          break;                  }                  List<IgnoreAnime> ignored = RepoFactory.IgnoreAnime.GetByUserAndType(userID' ignoreType);                  Dictionary<int' IgnoreAnime> dictIgnored = new Dictionary<int' IgnoreAnime>();                  foreach (IgnoreAnime ign in ignored)                      dictIgnored[ign.AnimeID] = ign;                      // find all the series which the user has rated                  List<AniDB_Vote> allVotes = RepoFactory.AniDB_Vote.GetAll()                      .OrderByDescending(a => a.VoteValue)                      .ToList();                  if (allVotes.Count == 0) return recs;                      Dictionary<int' CL_Recommendation> dictRecs = new Dictionary<int' CL_Recommendation>();                    List<AniDB_Vote> animeVotes = new List<AniDB_Vote>();                  foreach (AniDB_Vote vote in allVotes)                  {                      if (vote.VoteType != (int) AniDBVoteType.Anime &&                          vote.VoteType != (int) AniDBVoteType.AnimeTemp)                          continue;                        if (dictIgnored.ContainsKey(vote.EntityID)) continue;                        // check if the user has this anime                      SVR_AniDB_Anime anime = RepoFactory.AniDB_Anime.GetByAnimeID(vote.EntityID);                      if (anime == null) continue;                        // get similar anime                      List<AniDB_Anime_Similar> simAnime = anime.GetSimilarAnime()                          .OrderByDescending(a => a.GetApprovalPercentage())                          .ToList();                      // sort by the highest approval                        foreach (AniDB_Anime_Similar link in simAnime)                      {                          if (dictIgnored.ContainsKey(link.SimilarAnimeID)) continue;                            SVR_AniDB_Anime animeLink = RepoFactory.AniDB_Anime.GetByAnimeID(link.SimilarAnimeID);                          if (animeLink != null)                              if (!juser.AllowedAnime(animeLink)) continue;                            // don't recommend to watch anime that the user doesn't have                          if (animeLink == null && recommendationType == 1) continue;                            // don't recommend to watch series that the user doesn't have                          SVR_AnimeSeries ser = RepoFactory.AnimeSeries.GetByAnimeID(link.SimilarAnimeID);                          if (ser == null && recommendationType == 1) continue;                              if (ser != null)                          {                              // don't recommend to watch series that the user has already started watching                              AnimeSeries_User userRecord = ser.GetUserRecord(userID);                              if (userRecord != null)                              {                                  if (userRecord.WatchedEpisodeCount > 0 && recommendationType == 1) continue;                              }                                // don't recommend to download anime that the user has files for                              if (ser.LatestLocalEpisodeNumber > 0 && recommendationType == 2) continue;                          }                            CL_Recommendation rec = new CL_Recommendation                          {                              BasedOnAnimeID = anime.AnimeID'                              RecommendedAnimeID = link.SimilarAnimeID                          };                            // if we don't have the anime locally. lets assume the anime has a high rating                          decimal animeRating = 850;                          if (animeLink != null) animeRating = animeLink.GetAniDBRating();                            rec.Score =                              CalculateRecommendationScore(vote.VoteValue' link.GetApprovalPercentage()' animeRating);                          rec.BasedOnVoteValue = vote.VoteValue;                          rec.RecommendedApproval = link.GetApprovalPercentage();                            // check if we have added this recommendation before                          // this might happen where animes are recommended based on different votes                          // and could end up with different scores                          if (dictRecs.ContainsKey(rec.RecommendedAnimeID))                          {                              if (rec.Score < dictRecs[rec.RecommendedAnimeID].Score) continue;                          }                            rec.Recommended_AniDB_Anime = null;                          if (animeLink != null)                              rec.Recommended_AniDB_Anime = animeLink.Contract.AniDBAnime;                            rec.BasedOn_AniDB_Anime = anime.Contract.AniDBAnime;                            rec.Recommended_AnimeSeries = null;                          if (ser != null)                              rec.Recommended_AnimeSeries = ser.GetUserContract(userID);                            SVR_AnimeSeries serBasedOn = RepoFactory.AnimeSeries.GetByAnimeID(anime.AnimeID);                          if (serBasedOn == null) continue;                            rec.BasedOn_AnimeSeries = serBasedOn.GetUserContract(userID);                            dictRecs[rec.RecommendedAnimeID] = rec;                      }                  }                    List<CL_Recommendation> tempRecs = new List<CL_Recommendation>();                  foreach (CL_Recommendation rec in dictRecs.Values)                      tempRecs.Add(rec);                    // sort by the highest score                    int numRecs = 0;                  foreach (CL_Recommendation rec in tempRecs.OrderByDescending(a => a.Score))                  {                      if (numRecs == maxResults) break;                      recs.Add(rec);                      numRecs++;                  }                    if (recs.Count == 0) return recs;                    return recs;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());                  return recs;              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetRecommendations,The following statement contains a magic number: try              {                  SVR_JMMUser juser = RepoFactory.JMMUser.GetByID(userID);                  if (juser == null) return recs;                    // get all the anime the user has chosen to ignore                  int ignoreType = 1;                  switch (recommendationType)                  {                      case 1:                          ignoreType = 1;                          break;                      case 2:                          ignoreType = 2;                          break;                  }                  List<IgnoreAnime> ignored = RepoFactory.IgnoreAnime.GetByUserAndType(userID' ignoreType);                  Dictionary<int' IgnoreAnime> dictIgnored = new Dictionary<int' IgnoreAnime>();                  foreach (IgnoreAnime ign in ignored)                      dictIgnored[ign.AnimeID] = ign;                      // find all the series which the user has rated                  List<AniDB_Vote> allVotes = RepoFactory.AniDB_Vote.GetAll()                      .OrderByDescending(a => a.VoteValue)                      .ToList();                  if (allVotes.Count == 0) return recs;                      Dictionary<int' CL_Recommendation> dictRecs = new Dictionary<int' CL_Recommendation>();                    List<AniDB_Vote> animeVotes = new List<AniDB_Vote>();                  foreach (AniDB_Vote vote in allVotes)                  {                      if (vote.VoteType != (int) AniDBVoteType.Anime &&                          vote.VoteType != (int) AniDBVoteType.AnimeTemp)                          continue;                        if (dictIgnored.ContainsKey(vote.EntityID)) continue;                        // check if the user has this anime                      SVR_AniDB_Anime anime = RepoFactory.AniDB_Anime.GetByAnimeID(vote.EntityID);                      if (anime == null) continue;                        // get similar anime                      List<AniDB_Anime_Similar> simAnime = anime.GetSimilarAnime()                          .OrderByDescending(a => a.GetApprovalPercentage())                          .ToList();                      // sort by the highest approval                        foreach (AniDB_Anime_Similar link in simAnime)                      {                          if (dictIgnored.ContainsKey(link.SimilarAnimeID)) continue;                            SVR_AniDB_Anime animeLink = RepoFactory.AniDB_Anime.GetByAnimeID(link.SimilarAnimeID);                          if (animeLink != null)                              if (!juser.AllowedAnime(animeLink)) continue;                            // don't recommend to watch anime that the user doesn't have                          if (animeLink == null && recommendationType == 1) continue;                            // don't recommend to watch series that the user doesn't have                          SVR_AnimeSeries ser = RepoFactory.AnimeSeries.GetByAnimeID(link.SimilarAnimeID);                          if (ser == null && recommendationType == 1) continue;                              if (ser != null)                          {                              // don't recommend to watch series that the user has already started watching                              AnimeSeries_User userRecord = ser.GetUserRecord(userID);                              if (userRecord != null)                              {                                  if (userRecord.WatchedEpisodeCount > 0 && recommendationType == 1) continue;                              }                                // don't recommend to download anime that the user has files for                              if (ser.LatestLocalEpisodeNumber > 0 && recommendationType == 2) continue;                          }                            CL_Recommendation rec = new CL_Recommendation                          {                              BasedOnAnimeID = anime.AnimeID'                              RecommendedAnimeID = link.SimilarAnimeID                          };                            // if we don't have the anime locally. lets assume the anime has a high rating                          decimal animeRating = 850;                          if (animeLink != null) animeRating = animeLink.GetAniDBRating();                            rec.Score =                              CalculateRecommendationScore(vote.VoteValue' link.GetApprovalPercentage()' animeRating);                          rec.BasedOnVoteValue = vote.VoteValue;                          rec.RecommendedApproval = link.GetApprovalPercentage();                            // check if we have added this recommendation before                          // this might happen where animes are recommended based on different votes                          // and could end up with different scores                          if (dictRecs.ContainsKey(rec.RecommendedAnimeID))                          {                              if (rec.Score < dictRecs[rec.RecommendedAnimeID].Score) continue;                          }                            rec.Recommended_AniDB_Anime = null;                          if (animeLink != null)                              rec.Recommended_AniDB_Anime = animeLink.Contract.AniDBAnime;                            rec.BasedOn_AniDB_Anime = anime.Contract.AniDBAnime;                            rec.Recommended_AnimeSeries = null;                          if (ser != null)                              rec.Recommended_AnimeSeries = ser.GetUserContract(userID);                            SVR_AnimeSeries serBasedOn = RepoFactory.AnimeSeries.GetByAnimeID(anime.AnimeID);                          if (serBasedOn == null) continue;                            rec.BasedOn_AnimeSeries = serBasedOn.GetUserContract(userID);                            dictRecs[rec.RecommendedAnimeID] = rec;                      }                  }                    List<CL_Recommendation> tempRecs = new List<CL_Recommendation>();                  foreach (CL_Recommendation rec in dictRecs.Values)                      tempRecs.Add(rec);                    // sort by the highest score                    int numRecs = 0;                  foreach (CL_Recommendation rec in tempRecs.OrderByDescending(a => a.Score))                  {                      if (numRecs == maxResults) break;                      recs.Add(rec);                      numRecs++;                  }                    if (recs.Count == 0) return recs;                    return recs;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());                  return recs;              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,CalculateRecommendationScore,The following statement contains a magic number: if (approvalPercentage > 90) score = score + 100;
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,CalculateRecommendationScore,The following statement contains a magic number: if (approvalPercentage > 90) score = score + 100;
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,CalculateRecommendationScore,The following statement contains a magic number: if (approvalPercentage > 80) score = score + 100;
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,CalculateRecommendationScore,The following statement contains a magic number: if (approvalPercentage > 80) score = score + 100;
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,CalculateRecommendationScore,The following statement contains a magic number: if (approvalPercentage > 70) score = score + 100;
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,CalculateRecommendationScore,The following statement contains a magic number: if (approvalPercentage > 70) score = score + 100;
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,CalculateRecommendationScore,The following statement contains a magic number: if (approvalPercentage > 60) score = score + 100;
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,CalculateRecommendationScore,The following statement contains a magic number: if (approvalPercentage > 60) score = score + 100;
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,CalculateRecommendationScore,The following statement contains a magic number: if (approvalPercentage > 50) score = score + 100;
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,CalculateRecommendationScore,The following statement contains a magic number: if (approvalPercentage > 50) score = score + 100;
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,CalculateRecommendationScore,The following statement contains a magic number: if (animeRating > 900) score = score + 100;
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,CalculateRecommendationScore,The following statement contains a magic number: if (animeRating > 900) score = score + 100;
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,CalculateRecommendationScore,The following statement contains a magic number: if (animeRating > 800) score = score + 100;
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,CalculateRecommendationScore,The following statement contains a magic number: if (animeRating > 800) score = score + 100;
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,CalculateRecommendationScore,The following statement contains a magic number: if (animeRating > 700) score = score + 100;
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,CalculateRecommendationScore,The following statement contains a magic number: if (animeRating > 700) score = score + 100;
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,CalculateRecommendationScore,The following statement contains a magic number: if (animeRating > 600) score = score + 100;
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,CalculateRecommendationScore,The following statement contains a magic number: if (animeRating > 600) score = score + 100;
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,CalculateRecommendationScore,The following statement contains a magic number: if (animeRating > 500) score = score + 100;
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,CalculateRecommendationScore,The following statement contains a magic number: if (animeRating > 500) score = score + 100;
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,TraktScrobble,The following statement contains a magic number: try              {                  Providers.TraktTV.ScrobblePlayingStatus statusTraktV2 = Providers.TraktTV.ScrobblePlayingStatus.Start;                    switch (status)                  {                      case (int)Providers.TraktTV.ScrobblePlayingStatus.Start:                          statusTraktV2 = Providers.TraktTV.ScrobblePlayingStatus.Start;                          break;                      case (int)Providers.TraktTV.ScrobblePlayingStatus.Pause:                          statusTraktV2 = Providers.TraktTV.ScrobblePlayingStatus.Pause;                          break;                      case (int)Providers.TraktTV.ScrobblePlayingStatus.Stop:                          statusTraktV2 = Providers.TraktTV.ScrobblePlayingStatus.Stop;                          break;                  }                    bool isValidProgress = float.TryParse(progress.ToString()' out float progressTrakt);                    if (isValidProgress)                  {                      switch (type)                      {                          // Movie                          case (int) Providers.TraktTV.ScrobblePlayingType.movie:                              return Providers.TraktTV.TraktTVHelper.Scrobble(                                  Providers.TraktTV.ScrobblePlayingType.movie' animeId.ToString()'                                  statusTraktV2' progressTrakt);                          // TV episode                          case (int) Providers.TraktTV.ScrobblePlayingType.episode:                              return Providers.TraktTV.TraktTVHelper.Scrobble(                                  Providers.TraktTV.ScrobblePlayingType.episode'                                  animeId.ToString()' statusTraktV2' progressTrakt);                          default:                              return 500;                      }                  }                  else                  {                      return 500;                  }              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());                  return 500;              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,TraktScrobble,The following statement contains a magic number: try              {                  Providers.TraktTV.ScrobblePlayingStatus statusTraktV2 = Providers.TraktTV.ScrobblePlayingStatus.Start;                    switch (status)                  {                      case (int)Providers.TraktTV.ScrobblePlayingStatus.Start:                          statusTraktV2 = Providers.TraktTV.ScrobblePlayingStatus.Start;                          break;                      case (int)Providers.TraktTV.ScrobblePlayingStatus.Pause:                          statusTraktV2 = Providers.TraktTV.ScrobblePlayingStatus.Pause;                          break;                      case (int)Providers.TraktTV.ScrobblePlayingStatus.Stop:                          statusTraktV2 = Providers.TraktTV.ScrobblePlayingStatus.Stop;                          break;                  }                    bool isValidProgress = float.TryParse(progress.ToString()' out float progressTrakt);                    if (isValidProgress)                  {                      switch (type)                      {                          // Movie                          case (int) Providers.TraktTV.ScrobblePlayingType.movie:                              return Providers.TraktTV.TraktTVHelper.Scrobble(                                  Providers.TraktTV.ScrobblePlayingType.movie' animeId.ToString()'                                  statusTraktV2' progressTrakt);                          // TV episode                          case (int) Providers.TraktTV.ScrobblePlayingType.episode:                              return Providers.TraktTV.TraktTVHelper.Scrobble(                                  Providers.TraktTV.ScrobblePlayingType.episode'                                  animeId.ToString()' statusTraktV2' progressTrakt);                          default:                              return 500;                      }                  }                  else                  {                      return 500;                  }              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());                  return 500;              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,TraktScrobble,The following statement contains a magic number: try              {                  Providers.TraktTV.ScrobblePlayingStatus statusTraktV2 = Providers.TraktTV.ScrobblePlayingStatus.Start;                    switch (status)                  {                      case (int)Providers.TraktTV.ScrobblePlayingStatus.Start:                          statusTraktV2 = Providers.TraktTV.ScrobblePlayingStatus.Start;                          break;                      case (int)Providers.TraktTV.ScrobblePlayingStatus.Pause:                          statusTraktV2 = Providers.TraktTV.ScrobblePlayingStatus.Pause;                          break;                      case (int)Providers.TraktTV.ScrobblePlayingStatus.Stop:                          statusTraktV2 = Providers.TraktTV.ScrobblePlayingStatus.Stop;                          break;                  }                    bool isValidProgress = float.TryParse(progress.ToString()' out float progressTrakt);                    if (isValidProgress)                  {                      switch (type)                      {                          // Movie                          case (int) Providers.TraktTV.ScrobblePlayingType.movie:                              return Providers.TraktTV.TraktTVHelper.Scrobble(                                  Providers.TraktTV.ScrobblePlayingType.movie' animeId.ToString()'                                  statusTraktV2' progressTrakt);                          // TV episode                          case (int) Providers.TraktTV.ScrobblePlayingType.episode:                              return Providers.TraktTV.TraktTVHelper.Scrobble(                                  Providers.TraktTV.ScrobblePlayingType.episode'                                  animeId.ToString()' statusTraktV2' progressTrakt);                          default:                              return 500;                      }                  }                  else                  {                      return 500;                  }              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());                  return 500;              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,SearchForFiles,The following statement contains a magic number: try              {                  List<CL_VideoLocal> vids = new List<CL_VideoLocal>();                    FileSearchCriteria sType = (FileSearchCriteria) searchType;                      switch (sType)                  {                      case FileSearchCriteria.Name:                          List<SVR_VideoLocal> results1 = RepoFactory.VideoLocal.GetByName(searchCriteria.Trim());                          foreach (SVR_VideoLocal vid in results1)                              vids.Add(vid.ToClient(userID));                          break;                        case FileSearchCriteria.ED2KHash:                          SVR_VideoLocal vidl = RepoFactory.VideoLocal.GetByHash(searchCriteria.Trim());                          if (vidl != null)                              vids.Add(vidl.ToClient(userID));                          break;                        case FileSearchCriteria.Size:                          break;                        case FileSearchCriteria.LastOneHundred:                          int number = 100;                          if (!string.IsNullOrEmpty(searchCriteria))                          {                              if (int.TryParse(searchCriteria' out int temp)) number = temp;                          }                          List<SVR_VideoLocal> results2 = RepoFactory.VideoLocal.GetMostRecentlyAdded(number);                          foreach (SVR_VideoLocal vid in results2)                              vids.Add(vid.ToClient(userID));                          break;                  }                    return vids;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,RenameFilePreview,The following statement contains a magic number: try              {                  SVR_VideoLocal vid = RepoFactory.VideoLocal.GetByID(videoLocalID);                  if (vid == null)                  {                      ret.VideoLocal = null;                      ret.NewFileName = "ERROR: Could not find file record";                      ret.Success = false;                  }                  else                  {                      ret.VideoLocal = null;                      if (string.IsNullOrEmpty(vid?.GetBestVideoLocalPlace(true)?.FullServerPath))                      {                          ret.VideoLocal = null;                          ret.Success = false;                          ret.NewFileName = "ERROR: The file could not be found.";                          return ret;                      }                      ret.NewFileName = RenameFileHelper.GetRenamer(Shoko.Models.Constants.Renamer.TempFileName)?.GetFileName(vid.GetBestVideoLocalPlace());                        if (string.IsNullOrEmpty(ret.NewFileName))                      {                          ret.VideoLocal = null;                          ret.Success = false;                          ret.NewFileName = "ERROR: The file renamer returned a null or empty value.";                          return ret;                      }                        if (ret.NewFileName.StartsWith("*Error: "))                      {                          ret.VideoLocal = null;                          ret.Success = false;                          ret.NewFileName = "ERROR: " + ret.NewFileName.Substring(7);                          return ret;                      }                  }              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());                  ret.VideoLocal = null;                  ret.NewFileName = $"ERROR: {ex.Message}";                  ret.Success = false;              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,RenameAndMoveFile,The following statement contains a magic number: try              {                  SVR_VideoLocal vid = RepoFactory.VideoLocal.GetByID(videoLocalID);                  if (vid == null)                  {                      ret.VideoLocal = null;                      ret.NewFileName = "ERROR: Could not find file record";                      ret.Success = false;                      return ret;                  }                    ret.NewFileName = RenameFileHelper.GetRenamer(scriptName)?.GetFileName(vid);                    if (string.IsNullOrEmpty(ret.NewFileName))                  {                      ret.VideoLocal = null;                      ret.Success = false;                      ret.NewFileName = "ERROR: The file renamer returned a null or empty value.";                      return ret;                  }                    if (ret.NewFileName.StartsWith("*Error: "))                  {                      ret.VideoLocal = null;                      ret.Success = false;                      ret.NewFileName = "ERROR: " + ret.NewFileName.Substring(7);                      return ret;                  }                    if (vid.Places.Count <= 0)                  {                      ret.VideoLocal = null;                      ret.Success = false;                      ret.NewFileName = "ERROR: No Places were found for the VideoLocal. Run Remove Missing Files.";                      return ret;                  }                    int errorCount = 0;                  string errorString = string.Empty;                  string name = vid.FileName;                    foreach (SVR_VideoLocal_Place place in vid.Places)                  {                      if (move)                      {                          (string' string) resultString = place.MoveWithResultString(scriptName);                          if (!string.IsNullOrEmpty(resultString.Item2))                          {                              errorCount++;                              errorString = resultString.Item2;                              continue;                          }                          ret.NewDestination = resultString.Item1;                      }                        (bool' string' string) output = place.RenameFile(false' scriptName);                      string error = output.Item3;                      if (string.IsNullOrEmpty(error)) name = output.Item2;                      else                      {                          errorCount++;                          errorString = error;                      }                  }                  if (errorCount >= vid.Places.Count) // should never be greater but shit happens                  {                      ret.VideoLocal = null;                      ret.Success = false;                      ret.NewFileName = errorString;                      return ret;                  }                  vid.FileName = name;                  if (ret.VideoLocal == null)                      ret.VideoLocal = new CL_VideoLocal() {FileName = name' VideoLocalID = videoLocalID};                  else                      ret.VideoLocal.FileName = name;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());                  ret.VideoLocal = null;                  ret.NewFileName = $"ERROR: {ex.Message}";                  ret.Success = false;              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,DeleteDuplicateFile,The following statement contains a magic number: try              {                  DuplicateFile df = RepoFactory.DuplicateFile.GetByID(duplicateFileID);                  if (df == null) return "Database entry does not exist";                    if (fileNumber != 1 && fileNumber != 2) return string.Empty;                  SVR_VideoLocal_Place place;                  switch (fileNumber)                  {                      case 1:                          place =                              RepoFactory.VideoLocalPlace.GetByFilePathAndShareID(df.FilePathFile1'                                  df.ImportFolderIDFile1);                          break;                      case 2:                          place =                              RepoFactory.VideoLocalPlace.GetByFilePathAndShareID(df.FilePathFile2'                                  df.ImportFolderIDFile2);                          break;                      default:                          place = null;                          break;                  }                  if (place == null) return "Unable to get VideoLocal_Place";                    return place.RemoveAndDeleteFile().Item2;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());                  return ex.Message;              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,DeleteDuplicateFile,The following statement contains a magic number: try              {                  DuplicateFile df = RepoFactory.DuplicateFile.GetByID(duplicateFileID);                  if (df == null) return "Database entry does not exist";                    if (fileNumber != 1 && fileNumber != 2) return string.Empty;                  SVR_VideoLocal_Place place;                  switch (fileNumber)                  {                      case 1:                          place =                              RepoFactory.VideoLocalPlace.GetByFilePathAndShareID(df.FilePathFile1'                                  df.ImportFolderIDFile1);                          break;                      case 2:                          place =                              RepoFactory.VideoLocalPlace.GetByFilePathAndShareID(df.FilePathFile2'                                  df.ImportFolderIDFile2);                          break;                      default:                          place = null;                          break;                  }                  if (place == null) return "Unable to get VideoLocal_Place";                    return place.RemoveAndDeleteFile().Item2;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());                  return ex.Message;              }
Magic Number,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetFilesByGroupAndResolution,The following statement contains a magic number: try              {                  SVR_AniDB_Anime anime = RepoFactory.AniDB_Anime.GetByAnimeID(animeID);                  if (anime == null) return vids;                    foreach (SVR_VideoLocal vid in RepoFactory.VideoLocal.GetByAniDBAnimeID(animeID))                  {                      int thisBitDepth = 8;                        if (int.TryParse(vid.VideoBitDepth' out int bitDepth))                          thisBitDepth = bitDepth;                        List<SVR_AnimeEpisode> eps = vid.GetAnimeEpisodes();                      if (eps.Count == 0) continue;                        bool sourceMatches =                          videoSource.Equals(string.Intern("Manual Link")' StringComparison.InvariantCultureIgnoreCase) ||                          videoSource.Equals(string.Intern("unknown")' StringComparison.InvariantCultureIgnoreCase);                      bool groupMatches = relGroupName.Equals(Constants.NO_GROUP_INFO'                          StringComparison.InvariantCultureIgnoreCase);                      // get the anibd file info                      AniDB_File aniFile = vid.GetAniDBFile();                      if (aniFile != null)                      {                          videoSource = SimplifyVideoSource(videoSource);                          sourceMatches = videoSource.Equals(SimplifyVideoSource(aniFile.File_Source)'                                              StringComparison.InvariantCultureIgnoreCase) || !sourceMatches &&                                          aniFile.File_Source.Contains(string.Intern("unknown")'                                              StringComparison.InvariantCultureIgnoreCase) &&                                          videoSource.Equals(string.Intern("unknown")'                                              StringComparison.InvariantCultureIgnoreCase);                          groupMatches =                              relGroupName.Equals(aniFile.Anime_GroupName' StringComparison.InvariantCultureIgnoreCase) ||                              relGroupName.Equals(aniFile.Anime_GroupNameShort'                                  StringComparison.InvariantCultureIgnoreCase);                          if (aniFile.Anime_GroupName.Contains("unknown") ||                              aniFile.Anime_GroupNameShort.Contains("unknown"))                              groupMatches = relGroupName.Equals(Constants.NO_GROUP_INFO'                                  StringComparison.InvariantCultureIgnoreCase);                      }                      // Sometimes' especially with older files' the info doesn't quite match for resution                      string vidResInfo = vid.VideoResolution;                        // match based on group / video sorce / video res                      if (groupMatches && sourceMatches && thisBitDepth == videoBitDepth &&                          resolution.Equals(vidResInfo' StringComparison.InvariantCultureIgnoreCase))                      {                          vids.Add(vid.ToClientDetailed(userID));                      }                  }                  return vids;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());                  return vids;              }
Magic Number,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,FileQualityFilter,The following statement contains a magic number: ResolutionArea = new Dictionary<int' string>              {                  {3840 * 2160' "2160p"}'                  {2560 * 1440' "1440p"}'                  {1920 * 1080' "1080p"}'                  {1280 * 720' "720p"}'                  {1024 * 576' "576p"}'                  {853 * 480' "480p"}              };
Magic Number,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,FileQualityFilter,The following statement contains a magic number: ResolutionArea = new Dictionary<int' string>              {                  {3840 * 2160' "2160p"}'                  {2560 * 1440' "1440p"}'                  {1920 * 1080' "1080p"}'                  {1280 * 720' "720p"}'                  {1024 * 576' "576p"}'                  {853 * 480' "480p"}              };
Magic Number,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,FileQualityFilter,The following statement contains a magic number: ResolutionArea = new Dictionary<int' string>              {                  {3840 * 2160' "2160p"}'                  {2560 * 1440' "1440p"}'                  {1920 * 1080' "1080p"}'                  {1280 * 720' "720p"}'                  {1024 * 576' "576p"}'                  {853 * 480' "480p"}              };
Magic Number,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,FileQualityFilter,The following statement contains a magic number: ResolutionArea = new Dictionary<int' string>              {                  {3840 * 2160' "2160p"}'                  {2560 * 1440' "1440p"}'                  {1920 * 1080' "1080p"}'                  {1280 * 720' "720p"}'                  {1024 * 576' "576p"}'                  {853 * 480' "480p"}              };
Magic Number,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,FileQualityFilter,The following statement contains a magic number: ResolutionArea = new Dictionary<int' string>              {                  {3840 * 2160' "2160p"}'                  {2560 * 1440' "1440p"}'                  {1920 * 1080' "1080p"}'                  {1280 * 720' "720p"}'                  {1024 * 576' "576p"}'                  {853 * 480' "480p"}              };
Magic Number,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,FileQualityFilter,The following statement contains a magic number: ResolutionArea = new Dictionary<int' string>              {                  {3840 * 2160' "2160p"}'                  {2560 * 1440' "1440p"}'                  {1920 * 1080' "1080p"}'                  {1280 * 720' "720p"}'                  {1024 * 576' "576p"}'                  {853 * 480' "480p"}              };
Magic Number,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,FileQualityFilter,The following statement contains a magic number: ResolutionArea = new Dictionary<int' string>              {                  {3840 * 2160' "2160p"}'                  {2560 * 1440' "1440p"}'                  {1920 * 1080' "1080p"}'                  {1280 * 720' "720p"}'                  {1024 * 576' "576p"}'                  {853 * 480' "480p"}              };
Magic Number,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,FileQualityFilter,The following statement contains a magic number: ResolutionArea = new Dictionary<int' string>              {                  {3840 * 2160' "2160p"}'                  {2560 * 1440' "1440p"}'                  {1920 * 1080' "1080p"}'                  {1280 * 720' "720p"}'                  {1024 * 576' "576p"}'                  {853 * 480' "480p"}              };
Magic Number,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,FileQualityFilter,The following statement contains a magic number: ResolutionArea = new Dictionary<int' string>              {                  {3840 * 2160' "2160p"}'                  {2560 * 1440' "1440p"}'                  {1920 * 1080' "1080p"}'                  {1280 * 720' "720p"}'                  {1024 * 576' "576p"}'                  {853 * 480' "480p"}              };
Magic Number,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,FileQualityFilter,The following statement contains a magic number: ResolutionArea = new Dictionary<int' string>              {                  {3840 * 2160' "2160p"}'                  {2560 * 1440' "1440p"}'                  {1920 * 1080' "1080p"}'                  {1280 * 720' "720p"}'                  {1024 * 576' "576p"}'                  {853 * 480' "480p"}              };
Magic Number,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,FileQualityFilter,The following statement contains a magic number: ResolutionArea = new Dictionary<int' string>              {                  {3840 * 2160' "2160p"}'                  {2560 * 1440' "1440p"}'                  {1920 * 1080' "1080p"}'                  {1280 * 720' "720p"}'                  {1024 * 576' "576p"}'                  {853 * 480' "480p"}              };
Magic Number,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,FileQualityFilter,The following statement contains a magic number: ResolutionArea = new Dictionary<int' string>              {                  {3840 * 2160' "2160p"}'                  {2560 * 1440' "1440p"}'                  {1920 * 1080' "1080p"}'                  {1280 * 720' "720p"}'                  {1024 * 576' "576p"}'                  {853 * 480' "480p"}              };
Magic Number,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,FileQualityFilter,The following statement contains a magic number: ResolutionAreaOld = new Dictionary<int' string>              {                  {720 * 576' "576p"}'                  {720 * 480' "480p"}'                  {480 * 360' "360p"}'                  {320 * 240' "240p"}              };
Magic Number,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,FileQualityFilter,The following statement contains a magic number: ResolutionAreaOld = new Dictionary<int' string>              {                  {720 * 576' "576p"}'                  {720 * 480' "480p"}'                  {480 * 360' "360p"}'                  {320 * 240' "240p"}              };
Magic Number,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,FileQualityFilter,The following statement contains a magic number: ResolutionAreaOld = new Dictionary<int' string>              {                  {720 * 576' "576p"}'                  {720 * 480' "480p"}'                  {480 * 360' "360p"}'                  {320 * 240' "240p"}              };
Magic Number,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,FileQualityFilter,The following statement contains a magic number: ResolutionAreaOld = new Dictionary<int' string>              {                  {720 * 576' "576p"}'                  {720 * 480' "480p"}'                  {480 * 360' "360p"}'                  {320 * 240' "240p"}              };
Magic Number,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,FileQualityFilter,The following statement contains a magic number: ResolutionAreaOld = new Dictionary<int' string>              {                  {720 * 576' "576p"}'                  {720 * 480' "480p"}'                  {480 * 360' "360p"}'                  {320 * 240' "240p"}              };
Magic Number,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,FileQualityFilter,The following statement contains a magic number: ResolutionAreaOld = new Dictionary<int' string>              {                  {720 * 576' "576p"}'                  {720 * 480' "480p"}'                  {480 * 360' "360p"}'                  {320 * 240' "240p"}              };
Magic Number,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,FileQualityFilter,The following statement contains a magic number: ResolutionAreaOld = new Dictionary<int' string>              {                  {720 * 576' "576p"}'                  {720 * 480' "480p"}'                  {480 * 360' "360p"}'                  {320 * 240' "240p"}              };
Magic Number,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,FileQualityFilter,The following statement contains a magic number: ResolutionAreaOld = new Dictionary<int' string>              {                  {720 * 576' "576p"}'                  {720 * 480' "480p"}'                  {480 * 360' "360p"}'                  {320 * 240' "240p"}              };
Magic Number,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,GetResolution,The following statement contains a magic number: if (parts.Length != 2) return null;
Magic Number,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,GetResolution,The following statement contains a magic number: const double sixteenNine = 1.777778;
Magic Number,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,GetResolution,The following statement contains a magic number: const double fourThirds = 1.333333;
Magic Number,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,GetResolutionInternal,The following statement contains a magic number: if (res == null || res.Length != 2 || res[0] == "0" && res[1] == "0")              {                  var stream = videoLocal?.Media?.Parts?.SelectMany(a => a.Streams)                      .FirstOrDefault(a => a.StreamType == "1");                  if (stream != null)                      res = new[] {stream.Width' stream.Height};              }
Magic Number,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,GetResolutionInternal,The following statement contains a magic number: if (res == null || res.Length != 2 || res[0] == "0" && res[1] == "0") return null;
Magic Number,Shoko.Server,Importer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\Importer.cs,RunImport_GetImages,The following statement contains a magic number: foreach (SVR_AniDB_Anime anime in RepoFactory.AniDB_Anime.GetAll())              {                  if (anime.AnimeID == 8580)                      Console.Write("");                    if (string.IsNullOrEmpty(anime.PosterPath)) continue;                    bool fileExists = File.Exists(anime.PosterPath);                  if (!fileExists)                  {                      CommandRequest_DownloadImage cmd = new CommandRequest_DownloadImage(anime.AnimeID'                          ImageEntityType.AniDB_Cover'                          false);                      cmd.Save();                  }              }
Magic Number,Shoko.Server,Importer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\Importer.cs,RunImport_GetImages,The following statement contains a magic number: if (ServerSettings.AniDB_DownloadCharacters)              {                  foreach (AniDB_Character chr in RepoFactory.AniDB_Character.GetAll())                  {                      if (chr.CharID == 75250)                      {                          Console.WriteLine("test");                      }                        if (string.IsNullOrEmpty(chr.GetPosterPath())) continue;                      bool fileExists = File.Exists(chr.GetPosterPath());                      if (!fileExists)                      {                          CommandRequest_DownloadImage cmd = new CommandRequest_DownloadImage(chr.CharID'                              ImageEntityType.AniDB_Character' false);                          cmd.Save();                      }                  }              }
Magic Number,Shoko.Server,Importer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\Importer.cs,SendUserInfoUpdate,The following statement contains a magic number: if (sched != null)              {                  // if we have run this in the last 6 hours and are not forcing it' then exit                  TimeSpan tsLastRun = DateTime.Now - sched.LastUpdate;                  if (tsLastRun.TotalHours < 6)                  {                      if (!forceRefresh) return;                  }              }
Magic Number,Shoko.Server,Importer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\Importer.cs,CheckForTraktTokenUpdate,The following statement contains a magic number: try              {                  if (!ServerSettings.Trakt_IsEnabled) return;                  // by updating the Trakt token regularly' the user won't need to authorize again                  int freqHours = 24; // we need to update this daily                    ScheduledUpdate sched =                      RepoFactory.ScheduledUpdate.GetByUpdateType((int) ScheduledUpdateType.TraktToken);                  if (sched != null)                  {                      // if we have run this in the last xxx hours and are not forcing it' then exit                      TimeSpan tsLastRun = DateTime.Now - sched.LastUpdate;                      logger.Trace("Last Trakt Token Update: {0} minutes ago"' tsLastRun.TotalMinutes);                      if (tsLastRun.TotalHours < freqHours)                      {                          if (!forceRefresh) return;                      }                  }                    TraktTVHelper.RefreshAuthToken();                  if (sched == null)                  {                      sched = new ScheduledUpdate                      {                          UpdateType = (int)ScheduledUpdateType.TraktToken'                          UpdateDetails = string.Empty                      };                  }                  sched.LastUpdate = DateTime.Now;                  RepoFactory.ScheduledUpdate.Save(sched);              }              catch (Exception ex)              {                  logger.Error(ex' "Error in CheckForTraktTokenUpdate: " + ex.ToString());              }
Magic Number,Shoko.Server,Importer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\Importer.cs,UpdateAniDBTitles,The following statement contains a magic number: int freqHours = 100;
Magic Number,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,WorkerFileEvents_DoWork,The following statement contains a magic number: foreach (FileSystemEventArgs evt in queueFileEvents)              {                  try                  {                      // this is a message to stop processing                      if (evt == null)                      {                          return;                      }                      if (evt.ChangeType == WatcherChangeTypes.Created || evt.ChangeType == WatcherChangeTypes.Renamed)                      {                          if (evt.FullPath.StartsWith("|CLOUD|"))                          {                              int shareid = int.Parse(evt.Name);                              Importer.RunImport_ImportFolderNewFiles(RepoFactory.ImportFolder.GetByID(shareid));                          }                          else                          {                              // When the path that was created represents a directory we need to manually get the contained files to add.                              // The reason for this is that when a directory is moved into a source directory (from the same drive) we will only recieve                              // an event for the directory and not the contained files. However' if the folder is copied from a different drive then                              // a create event will fire for the directory and each file contained within it (As they are all treated as separate operations)                                // This is faster and doesn't throw on weird paths. I've had some UTF-16/UTF-32 paths cause serious issues                              if (Directory.Exists(evt.FullPath)) // filter out invalid events                              {                                  logger.Info("New folder detected: {0}: {1}"' evt.FullPath' evt.ChangeType);                                    string[] files = Directory.GetFiles(evt.FullPath' "*.*"' SearchOption.AllDirectories);                                    foreach (string file in files)                                  {                                      if (FileHashHelper.IsVideo(file))                                      {                                          logger.Info("Found file {0} under folder {1}"' file' evt.FullPath);                                            CommandRequest_HashFile cmd = new CommandRequest_HashFile(file' false);                                          cmd.Save();                                      }                                  }                              }                              else if (File.Exists(evt.FullPath))                              {                                  logger.Info("New file detected: {0}: {1}"' evt.FullPath' evt.ChangeType);                                    if (FileHashHelper.IsVideo(evt.FullPath))                                  {                                      logger.Info("Found file {0}"' evt.FullPath);                                        CommandRequest_HashFile cmd = new CommandRequest_HashFile(evt.FullPath' false);                                      cmd.Save();                                  }                              }                              // else it was deleted before we got here                          }                      }                      if (queueFileEvents.Contains(evt))                      {                          queueFileEvents.Remove(evt);                      }                  }                  catch (Exception ex)                  {                      logger.Error(ex' "FSEvents_DoWork file: {0}\n{1}"' evt.Name' ex);                      if (queueFileEvents.Contains(evt))                      {                          queueFileEvents.Remove(evt);                      }                      Thread.Sleep(1000);                  }              }
Magic Number,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,StartCloudWatchTimer,The following statement contains a magic number: cloudWatchTimer = new Timer              {                  AutoReset = true'                  Interval = ServerSettings.CloudWatcherTime * 60 * 1000              };
Magic Number,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,StartCloudWatchTimer,The following statement contains a magic number: cloudWatchTimer = new Timer              {                  AutoReset = true'                  Interval = ServerSettings.CloudWatcherTime * 60 * 1000              };
Magic Number,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,StartLogRotatorTimer,The following statement contains a magic number: LogRotatorTimer = new Timer              {                  AutoReset = true'                  // 86400000 = 24h                  Interval = 86400000              };
Magic Number,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,WorkerSetupDB_DoWork,The following statement contains a magic number: try              {                  ServerState.Instance.ServerOnline = false;                  ServerState.Instance.ServerStarting = true;                  ServerState.Instance.StartupFailed = false;                  ServerState.Instance.StartupFailedMessage = string.Empty;                  ServerState.Instance.CurrentSetupStatus = Resources.Server_Cleaning;                    StopWatchingFiles();                    AniDBDispose();                  SetupAniDBProcessor();                    ShokoService.CmdProcessorGeneral.Stop();                  ShokoService.CmdProcessorHasher.Stop();                  ShokoService.CmdProcessorImages.Stop();                      // wait until the queue count is 0                  // ie the cancel has actuall worked                  while (true)                  {                      if (ShokoService.CmdProcessorGeneral.QueueCount == 0 &&                          ShokoService.CmdProcessorHasher.QueueCount == 0 &&                          ShokoService.CmdProcessorImages.QueueCount == 0) break;                      Thread.Sleep(250);                  }                    if (autoUpdateTimer != null) autoUpdateTimer.Enabled = false;                  if (autoUpdateTimerShort != null) autoUpdateTimerShort.Enabled = false;                    DatabaseFactory.CloseSessionFactory();                    ServerState.Instance.CurrentSetupStatus = Resources.Server_Initializing;                  Thread.Sleep(1000);                    ServerState.Instance.CurrentSetupStatus = Resources.Server_DatabaseSetup;                    logger.Info("Setting up database...");                  if (!DatabaseFactory.InitDB(out string errorMessage))                  {                      ServerState.Instance.DatabaseAvailable = false;                        if (string.IsNullOrEmpty(ServerSettings.DatabaseType))                          ServerState.Instance.CurrentSetupStatus =                              Resources.Server_DatabaseConfig;                      e.Result = false;                      ServerState.Instance.StartupFailed = true;                      ServerState.Instance.StartupFailedMessage = errorMessage;                      return;                  }                    ServerState.Instance.DatabaseAvailable = true;                    logger.Info("Initializing Session Factory...");                    Scanner.Instance.Init();                      //init session factory                  ServerState.Instance.CurrentSetupStatus = Resources.Server_InitializingSession;                  ISessionFactory temp = DatabaseFactory.SessionFactory;                      ServerState.Instance.CurrentSetupStatus = Resources.Server_InitializingQueue;                  ShokoService.CmdProcessorGeneral.Init();                  ShokoService.CmdProcessorHasher.Init();                  ShokoService.CmdProcessorImages.Init();                      // timer for automatic updates                  autoUpdateTimer = new Timer                  {                      AutoReset = true'                      Interval = 5 * 60 * 1000 // 5 * 60 seconds (5 minutes)                  };                  autoUpdateTimer.Elapsed += AutoUpdateTimer_Elapsed;                  autoUpdateTimer.Start();                    // timer for automatic updates                  autoUpdateTimerShort = new Timer                  {                      AutoReset = true'                      Interval = 5 * 1000 // 5 seconds' later we set it to 30 seconds                  };                  autoUpdateTimerShort.Elapsed += AutoUpdateTimerShort_Elapsed;                  autoUpdateTimerShort.Start();                    ServerState.Instance.CurrentSetupStatus = Resources.Server_InitializingFile;                    StartFileWorker();                    StartWatchingFiles();                    DownloadAllImages();                    IReadOnlyList<SVR_ImportFolder> folders = RepoFactory.ImportFolder.GetAll();                    if (ServerSettings.ScanDropFoldersOnStart) ScanDropFolders();                  if (ServerSettings.RunImportOnStart && folders.Count > 0) RunImport();                    ServerState.Instance.ServerOnline = true;                  workerSetupDB.ReportProgress(100);                    StartTime = DateTime.Now;                    e.Result = true;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());                  ServerState.Instance.CurrentSetupStatus = ex.Message;                  ServerState.Instance.StartupFailed = true;                  ServerState.Instance.StartupFailedMessage = $"Startup Failed: {ex}";                  e.Result = false;              }
Magic Number,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,WorkerSetupDB_DoWork,The following statement contains a magic number: try              {                  ServerState.Instance.ServerOnline = false;                  ServerState.Instance.ServerStarting = true;                  ServerState.Instance.StartupFailed = false;                  ServerState.Instance.StartupFailedMessage = string.Empty;                  ServerState.Instance.CurrentSetupStatus = Resources.Server_Cleaning;                    StopWatchingFiles();                    AniDBDispose();                  SetupAniDBProcessor();                    ShokoService.CmdProcessorGeneral.Stop();                  ShokoService.CmdProcessorHasher.Stop();                  ShokoService.CmdProcessorImages.Stop();                      // wait until the queue count is 0                  // ie the cancel has actuall worked                  while (true)                  {                      if (ShokoService.CmdProcessorGeneral.QueueCount == 0 &&                          ShokoService.CmdProcessorHasher.QueueCount == 0 &&                          ShokoService.CmdProcessorImages.QueueCount == 0) break;                      Thread.Sleep(250);                  }                    if (autoUpdateTimer != null) autoUpdateTimer.Enabled = false;                  if (autoUpdateTimerShort != null) autoUpdateTimerShort.Enabled = false;                    DatabaseFactory.CloseSessionFactory();                    ServerState.Instance.CurrentSetupStatus = Resources.Server_Initializing;                  Thread.Sleep(1000);                    ServerState.Instance.CurrentSetupStatus = Resources.Server_DatabaseSetup;                    logger.Info("Setting up database...");                  if (!DatabaseFactory.InitDB(out string errorMessage))                  {                      ServerState.Instance.DatabaseAvailable = false;                        if (string.IsNullOrEmpty(ServerSettings.DatabaseType))                          ServerState.Instance.CurrentSetupStatus =                              Resources.Server_DatabaseConfig;                      e.Result = false;                      ServerState.Instance.StartupFailed = true;                      ServerState.Instance.StartupFailedMessage = errorMessage;                      return;                  }                    ServerState.Instance.DatabaseAvailable = true;                    logger.Info("Initializing Session Factory...");                    Scanner.Instance.Init();                      //init session factory                  ServerState.Instance.CurrentSetupStatus = Resources.Server_InitializingSession;                  ISessionFactory temp = DatabaseFactory.SessionFactory;                      ServerState.Instance.CurrentSetupStatus = Resources.Server_InitializingQueue;                  ShokoService.CmdProcessorGeneral.Init();                  ShokoService.CmdProcessorHasher.Init();                  ShokoService.CmdProcessorImages.Init();                      // timer for automatic updates                  autoUpdateTimer = new Timer                  {                      AutoReset = true'                      Interval = 5 * 60 * 1000 // 5 * 60 seconds (5 minutes)                  };                  autoUpdateTimer.Elapsed += AutoUpdateTimer_Elapsed;                  autoUpdateTimer.Start();                    // timer for automatic updates                  autoUpdateTimerShort = new Timer                  {                      AutoReset = true'                      Interval = 5 * 1000 // 5 seconds' later we set it to 30 seconds                  };                  autoUpdateTimerShort.Elapsed += AutoUpdateTimerShort_Elapsed;                  autoUpdateTimerShort.Start();                    ServerState.Instance.CurrentSetupStatus = Resources.Server_InitializingFile;                    StartFileWorker();                    StartWatchingFiles();                    DownloadAllImages();                    IReadOnlyList<SVR_ImportFolder> folders = RepoFactory.ImportFolder.GetAll();                    if (ServerSettings.ScanDropFoldersOnStart) ScanDropFolders();                  if (ServerSettings.RunImportOnStart && folders.Count > 0) RunImport();                    ServerState.Instance.ServerOnline = true;                  workerSetupDB.ReportProgress(100);                    StartTime = DateTime.Now;                    e.Result = true;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());                  ServerState.Instance.CurrentSetupStatus = ex.Message;                  ServerState.Instance.StartupFailed = true;                  ServerState.Instance.StartupFailedMessage = $"Startup Failed: {ex}";                  e.Result = false;              }
Magic Number,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,WorkerSetupDB_DoWork,The following statement contains a magic number: try              {                  ServerState.Instance.ServerOnline = false;                  ServerState.Instance.ServerStarting = true;                  ServerState.Instance.StartupFailed = false;                  ServerState.Instance.StartupFailedMessage = string.Empty;                  ServerState.Instance.CurrentSetupStatus = Resources.Server_Cleaning;                    StopWatchingFiles();                    AniDBDispose();                  SetupAniDBProcessor();                    ShokoService.CmdProcessorGeneral.Stop();                  ShokoService.CmdProcessorHasher.Stop();                  ShokoService.CmdProcessorImages.Stop();                      // wait until the queue count is 0                  // ie the cancel has actuall worked                  while (true)                  {                      if (ShokoService.CmdProcessorGeneral.QueueCount == 0 &&                          ShokoService.CmdProcessorHasher.QueueCount == 0 &&                          ShokoService.CmdProcessorImages.QueueCount == 0) break;                      Thread.Sleep(250);                  }                    if (autoUpdateTimer != null) autoUpdateTimer.Enabled = false;                  if (autoUpdateTimerShort != null) autoUpdateTimerShort.Enabled = false;                    DatabaseFactory.CloseSessionFactory();                    ServerState.Instance.CurrentSetupStatus = Resources.Server_Initializing;                  Thread.Sleep(1000);                    ServerState.Instance.CurrentSetupStatus = Resources.Server_DatabaseSetup;                    logger.Info("Setting up database...");                  if (!DatabaseFactory.InitDB(out string errorMessage))                  {                      ServerState.Instance.DatabaseAvailable = false;                        if (string.IsNullOrEmpty(ServerSettings.DatabaseType))                          ServerState.Instance.CurrentSetupStatus =                              Resources.Server_DatabaseConfig;                      e.Result = false;                      ServerState.Instance.StartupFailed = true;                      ServerState.Instance.StartupFailedMessage = errorMessage;                      return;                  }                    ServerState.Instance.DatabaseAvailable = true;                    logger.Info("Initializing Session Factory...");                    Scanner.Instance.Init();                      //init session factory                  ServerState.Instance.CurrentSetupStatus = Resources.Server_InitializingSession;                  ISessionFactory temp = DatabaseFactory.SessionFactory;                      ServerState.Instance.CurrentSetupStatus = Resources.Server_InitializingQueue;                  ShokoService.CmdProcessorGeneral.Init();                  ShokoService.CmdProcessorHasher.Init();                  ShokoService.CmdProcessorImages.Init();                      // timer for automatic updates                  autoUpdateTimer = new Timer                  {                      AutoReset = true'                      Interval = 5 * 60 * 1000 // 5 * 60 seconds (5 minutes)                  };                  autoUpdateTimer.Elapsed += AutoUpdateTimer_Elapsed;                  autoUpdateTimer.Start();                    // timer for automatic updates                  autoUpdateTimerShort = new Timer                  {                      AutoReset = true'                      Interval = 5 * 1000 // 5 seconds' later we set it to 30 seconds                  };                  autoUpdateTimerShort.Elapsed += AutoUpdateTimerShort_Elapsed;                  autoUpdateTimerShort.Start();                    ServerState.Instance.CurrentSetupStatus = Resources.Server_InitializingFile;                    StartFileWorker();                    StartWatchingFiles();                    DownloadAllImages();                    IReadOnlyList<SVR_ImportFolder> folders = RepoFactory.ImportFolder.GetAll();                    if (ServerSettings.ScanDropFoldersOnStart) ScanDropFolders();                  if (ServerSettings.RunImportOnStart && folders.Count > 0) RunImport();                    ServerState.Instance.ServerOnline = true;                  workerSetupDB.ReportProgress(100);                    StartTime = DateTime.Now;                    e.Result = true;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());                  ServerState.Instance.CurrentSetupStatus = ex.Message;                  ServerState.Instance.StartupFailed = true;                  ServerState.Instance.StartupFailedMessage = $"Startup Failed: {ex}";                  e.Result = false;              }
Magic Number,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,WorkerSetupDB_DoWork,The following statement contains a magic number: try              {                  ServerState.Instance.ServerOnline = false;                  ServerState.Instance.ServerStarting = true;                  ServerState.Instance.StartupFailed = false;                  ServerState.Instance.StartupFailedMessage = string.Empty;                  ServerState.Instance.CurrentSetupStatus = Resources.Server_Cleaning;                    StopWatchingFiles();                    AniDBDispose();                  SetupAniDBProcessor();                    ShokoService.CmdProcessorGeneral.Stop();                  ShokoService.CmdProcessorHasher.Stop();                  ShokoService.CmdProcessorImages.Stop();                      // wait until the queue count is 0                  // ie the cancel has actuall worked                  while (true)                  {                      if (ShokoService.CmdProcessorGeneral.QueueCount == 0 &&                          ShokoService.CmdProcessorHasher.QueueCount == 0 &&                          ShokoService.CmdProcessorImages.QueueCount == 0) break;                      Thread.Sleep(250);                  }                    if (autoUpdateTimer != null) autoUpdateTimer.Enabled = false;                  if (autoUpdateTimerShort != null) autoUpdateTimerShort.Enabled = false;                    DatabaseFactory.CloseSessionFactory();                    ServerState.Instance.CurrentSetupStatus = Resources.Server_Initializing;                  Thread.Sleep(1000);                    ServerState.Instance.CurrentSetupStatus = Resources.Server_DatabaseSetup;                    logger.Info("Setting up database...");                  if (!DatabaseFactory.InitDB(out string errorMessage))                  {                      ServerState.Instance.DatabaseAvailable = false;                        if (string.IsNullOrEmpty(ServerSettings.DatabaseType))                          ServerState.Instance.CurrentSetupStatus =                              Resources.Server_DatabaseConfig;                      e.Result = false;                      ServerState.Instance.StartupFailed = true;                      ServerState.Instance.StartupFailedMessage = errorMessage;                      return;                  }                    ServerState.Instance.DatabaseAvailable = true;                    logger.Info("Initializing Session Factory...");                    Scanner.Instance.Init();                      //init session factory                  ServerState.Instance.CurrentSetupStatus = Resources.Server_InitializingSession;                  ISessionFactory temp = DatabaseFactory.SessionFactory;                      ServerState.Instance.CurrentSetupStatus = Resources.Server_InitializingQueue;                  ShokoService.CmdProcessorGeneral.Init();                  ShokoService.CmdProcessorHasher.Init();                  ShokoService.CmdProcessorImages.Init();                      // timer for automatic updates                  autoUpdateTimer = new Timer                  {                      AutoReset = true'                      Interval = 5 * 60 * 1000 // 5 * 60 seconds (5 minutes)                  };                  autoUpdateTimer.Elapsed += AutoUpdateTimer_Elapsed;                  autoUpdateTimer.Start();                    // timer for automatic updates                  autoUpdateTimerShort = new Timer                  {                      AutoReset = true'                      Interval = 5 * 1000 // 5 seconds' later we set it to 30 seconds                  };                  autoUpdateTimerShort.Elapsed += AutoUpdateTimerShort_Elapsed;                  autoUpdateTimerShort.Start();                    ServerState.Instance.CurrentSetupStatus = Resources.Server_InitializingFile;                    StartFileWorker();                    StartWatchingFiles();                    DownloadAllImages();                    IReadOnlyList<SVR_ImportFolder> folders = RepoFactory.ImportFolder.GetAll();                    if (ServerSettings.ScanDropFoldersOnStart) ScanDropFolders();                  if (ServerSettings.RunImportOnStart && folders.Count > 0) RunImport();                    ServerState.Instance.ServerOnline = true;                  workerSetupDB.ReportProgress(100);                    StartTime = DateTime.Now;                    e.Result = true;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());                  ServerState.Instance.CurrentSetupStatus = ex.Message;                  ServerState.Instance.StartupFailed = true;                  ServerState.Instance.StartupFailedMessage = $"Startup Failed: {ex}";                  e.Result = false;              }
Magic Number,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,WorkerSetupDB_DoWork,The following statement contains a magic number: try              {                  ServerState.Instance.ServerOnline = false;                  ServerState.Instance.ServerStarting = true;                  ServerState.Instance.StartupFailed = false;                  ServerState.Instance.StartupFailedMessage = string.Empty;                  ServerState.Instance.CurrentSetupStatus = Resources.Server_Cleaning;                    StopWatchingFiles();                    AniDBDispose();                  SetupAniDBProcessor();                    ShokoService.CmdProcessorGeneral.Stop();                  ShokoService.CmdProcessorHasher.Stop();                  ShokoService.CmdProcessorImages.Stop();                      // wait until the queue count is 0                  // ie the cancel has actuall worked                  while (true)                  {                      if (ShokoService.CmdProcessorGeneral.QueueCount == 0 &&                          ShokoService.CmdProcessorHasher.QueueCount == 0 &&                          ShokoService.CmdProcessorImages.QueueCount == 0) break;                      Thread.Sleep(250);                  }                    if (autoUpdateTimer != null) autoUpdateTimer.Enabled = false;                  if (autoUpdateTimerShort != null) autoUpdateTimerShort.Enabled = false;                    DatabaseFactory.CloseSessionFactory();                    ServerState.Instance.CurrentSetupStatus = Resources.Server_Initializing;                  Thread.Sleep(1000);                    ServerState.Instance.CurrentSetupStatus = Resources.Server_DatabaseSetup;                    logger.Info("Setting up database...");                  if (!DatabaseFactory.InitDB(out string errorMessage))                  {                      ServerState.Instance.DatabaseAvailable = false;                        if (string.IsNullOrEmpty(ServerSettings.DatabaseType))                          ServerState.Instance.CurrentSetupStatus =                              Resources.Server_DatabaseConfig;                      e.Result = false;                      ServerState.Instance.StartupFailed = true;                      ServerState.Instance.StartupFailedMessage = errorMessage;                      return;                  }                    ServerState.Instance.DatabaseAvailable = true;                    logger.Info("Initializing Session Factory...");                    Scanner.Instance.Init();                      //init session factory                  ServerState.Instance.CurrentSetupStatus = Resources.Server_InitializingSession;                  ISessionFactory temp = DatabaseFactory.SessionFactory;                      ServerState.Instance.CurrentSetupStatus = Resources.Server_InitializingQueue;                  ShokoService.CmdProcessorGeneral.Init();                  ShokoService.CmdProcessorHasher.Init();                  ShokoService.CmdProcessorImages.Init();                      // timer for automatic updates                  autoUpdateTimer = new Timer                  {                      AutoReset = true'                      Interval = 5 * 60 * 1000 // 5 * 60 seconds (5 minutes)                  };                  autoUpdateTimer.Elapsed += AutoUpdateTimer_Elapsed;                  autoUpdateTimer.Start();                    // timer for automatic updates                  autoUpdateTimerShort = new Timer                  {                      AutoReset = true'                      Interval = 5 * 1000 // 5 seconds' later we set it to 30 seconds                  };                  autoUpdateTimerShort.Elapsed += AutoUpdateTimerShort_Elapsed;                  autoUpdateTimerShort.Start();                    ServerState.Instance.CurrentSetupStatus = Resources.Server_InitializingFile;                    StartFileWorker();                    StartWatchingFiles();                    DownloadAllImages();                    IReadOnlyList<SVR_ImportFolder> folders = RepoFactory.ImportFolder.GetAll();                    if (ServerSettings.ScanDropFoldersOnStart) ScanDropFolders();                  if (ServerSettings.RunImportOnStart && folders.Count > 0) RunImport();                    ServerState.Instance.ServerOnline = true;                  workerSetupDB.ReportProgress(100);                    StartTime = DateTime.Now;                    e.Result = true;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());                  ServerState.Instance.CurrentSetupStatus = ex.Message;                  ServerState.Instance.StartupFailed = true;                  ServerState.Instance.StartupFailedMessage = $"Startup Failed: {ex}";                  e.Result = false;              }
Magic Number,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,WorkerSetupDB_DoWork,The following statement contains a magic number: try              {                  ServerState.Instance.ServerOnline = false;                  ServerState.Instance.ServerStarting = true;                  ServerState.Instance.StartupFailed = false;                  ServerState.Instance.StartupFailedMessage = string.Empty;                  ServerState.Instance.CurrentSetupStatus = Resources.Server_Cleaning;                    StopWatchingFiles();                    AniDBDispose();                  SetupAniDBProcessor();                    ShokoService.CmdProcessorGeneral.Stop();                  ShokoService.CmdProcessorHasher.Stop();                  ShokoService.CmdProcessorImages.Stop();                      // wait until the queue count is 0                  // ie the cancel has actuall worked                  while (true)                  {                      if (ShokoService.CmdProcessorGeneral.QueueCount == 0 &&                          ShokoService.CmdProcessorHasher.QueueCount == 0 &&                          ShokoService.CmdProcessorImages.QueueCount == 0) break;                      Thread.Sleep(250);                  }                    if (autoUpdateTimer != null) autoUpdateTimer.Enabled = false;                  if (autoUpdateTimerShort != null) autoUpdateTimerShort.Enabled = false;                    DatabaseFactory.CloseSessionFactory();                    ServerState.Instance.CurrentSetupStatus = Resources.Server_Initializing;                  Thread.Sleep(1000);                    ServerState.Instance.CurrentSetupStatus = Resources.Server_DatabaseSetup;                    logger.Info("Setting up database...");                  if (!DatabaseFactory.InitDB(out string errorMessage))                  {                      ServerState.Instance.DatabaseAvailable = false;                        if (string.IsNullOrEmpty(ServerSettings.DatabaseType))                          ServerState.Instance.CurrentSetupStatus =                              Resources.Server_DatabaseConfig;                      e.Result = false;                      ServerState.Instance.StartupFailed = true;                      ServerState.Instance.StartupFailedMessage = errorMessage;                      return;                  }                    ServerState.Instance.DatabaseAvailable = true;                    logger.Info("Initializing Session Factory...");                    Scanner.Instance.Init();                      //init session factory                  ServerState.Instance.CurrentSetupStatus = Resources.Server_InitializingSession;                  ISessionFactory temp = DatabaseFactory.SessionFactory;                      ServerState.Instance.CurrentSetupStatus = Resources.Server_InitializingQueue;                  ShokoService.CmdProcessorGeneral.Init();                  ShokoService.CmdProcessorHasher.Init();                  ShokoService.CmdProcessorImages.Init();                      // timer for automatic updates                  autoUpdateTimer = new Timer                  {                      AutoReset = true'                      Interval = 5 * 60 * 1000 // 5 * 60 seconds (5 minutes)                  };                  autoUpdateTimer.Elapsed += AutoUpdateTimer_Elapsed;                  autoUpdateTimer.Start();                    // timer for automatic updates                  autoUpdateTimerShort = new Timer                  {                      AutoReset = true'                      Interval = 5 * 1000 // 5 seconds' later we set it to 30 seconds                  };                  autoUpdateTimerShort.Elapsed += AutoUpdateTimerShort_Elapsed;                  autoUpdateTimerShort.Start();                    ServerState.Instance.CurrentSetupStatus = Resources.Server_InitializingFile;                    StartFileWorker();                    StartWatchingFiles();                    DownloadAllImages();                    IReadOnlyList<SVR_ImportFolder> folders = RepoFactory.ImportFolder.GetAll();                    if (ServerSettings.ScanDropFoldersOnStart) ScanDropFolders();                  if (ServerSettings.RunImportOnStart && folders.Count > 0) RunImport();                    ServerState.Instance.ServerOnline = true;                  workerSetupDB.ReportProgress(100);                    StartTime = DateTime.Now;                    e.Result = true;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());                  ServerState.Instance.CurrentSetupStatus = ex.Message;                  ServerState.Instance.StartupFailed = true;                  ServerState.Instance.StartupFailedMessage = $"Startup Failed: {ex}";                  e.Result = false;              }
Magic Number,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,WorkerSetupDB_DoWork,The following statement contains a magic number: try              {                  ServerState.Instance.ServerOnline = false;                  ServerState.Instance.ServerStarting = true;                  ServerState.Instance.StartupFailed = false;                  ServerState.Instance.StartupFailedMessage = string.Empty;                  ServerState.Instance.CurrentSetupStatus = Resources.Server_Cleaning;                    StopWatchingFiles();                    AniDBDispose();                  SetupAniDBProcessor();                    ShokoService.CmdProcessorGeneral.Stop();                  ShokoService.CmdProcessorHasher.Stop();                  ShokoService.CmdProcessorImages.Stop();                      // wait until the queue count is 0                  // ie the cancel has actuall worked                  while (true)                  {                      if (ShokoService.CmdProcessorGeneral.QueueCount == 0 &&                          ShokoService.CmdProcessorHasher.QueueCount == 0 &&                          ShokoService.CmdProcessorImages.QueueCount == 0) break;                      Thread.Sleep(250);                  }                    if (autoUpdateTimer != null) autoUpdateTimer.Enabled = false;                  if (autoUpdateTimerShort != null) autoUpdateTimerShort.Enabled = false;                    DatabaseFactory.CloseSessionFactory();                    ServerState.Instance.CurrentSetupStatus = Resources.Server_Initializing;                  Thread.Sleep(1000);                    ServerState.Instance.CurrentSetupStatus = Resources.Server_DatabaseSetup;                    logger.Info("Setting up database...");                  if (!DatabaseFactory.InitDB(out string errorMessage))                  {                      ServerState.Instance.DatabaseAvailable = false;                        if (string.IsNullOrEmpty(ServerSettings.DatabaseType))                          ServerState.Instance.CurrentSetupStatus =                              Resources.Server_DatabaseConfig;                      e.Result = false;                      ServerState.Instance.StartupFailed = true;                      ServerState.Instance.StartupFailedMessage = errorMessage;                      return;                  }                    ServerState.Instance.DatabaseAvailable = true;                    logger.Info("Initializing Session Factory...");                    Scanner.Instance.Init();                      //init session factory                  ServerState.Instance.CurrentSetupStatus = Resources.Server_InitializingSession;                  ISessionFactory temp = DatabaseFactory.SessionFactory;                      ServerState.Instance.CurrentSetupStatus = Resources.Server_InitializingQueue;                  ShokoService.CmdProcessorGeneral.Init();                  ShokoService.CmdProcessorHasher.Init();                  ShokoService.CmdProcessorImages.Init();                      // timer for automatic updates                  autoUpdateTimer = new Timer                  {                      AutoReset = true'                      Interval = 5 * 60 * 1000 // 5 * 60 seconds (5 minutes)                  };                  autoUpdateTimer.Elapsed += AutoUpdateTimer_Elapsed;                  autoUpdateTimer.Start();                    // timer for automatic updates                  autoUpdateTimerShort = new Timer                  {                      AutoReset = true'                      Interval = 5 * 1000 // 5 seconds' later we set it to 30 seconds                  };                  autoUpdateTimerShort.Elapsed += AutoUpdateTimerShort_Elapsed;                  autoUpdateTimerShort.Start();                    ServerState.Instance.CurrentSetupStatus = Resources.Server_InitializingFile;                    StartFileWorker();                    StartWatchingFiles();                    DownloadAllImages();                    IReadOnlyList<SVR_ImportFolder> folders = RepoFactory.ImportFolder.GetAll();                    if (ServerSettings.ScanDropFoldersOnStart) ScanDropFolders();                  if (ServerSettings.RunImportOnStart && folders.Count > 0) RunImport();                    ServerState.Instance.ServerOnline = true;                  workerSetupDB.ReportProgress(100);                    StartTime = DateTime.Now;                    e.Result = true;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());                  ServerState.Instance.CurrentSetupStatus = ex.Message;                  ServerState.Instance.StartupFailed = true;                  ServerState.Instance.StartupFailedMessage = $"Startup Failed: {ex}";                  e.Result = false;              }
Magic Number,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,WorkerSetupDB_DoWork,The following statement contains a magic number: try              {                  ServerState.Instance.ServerOnline = false;                  ServerState.Instance.ServerStarting = true;                  ServerState.Instance.StartupFailed = false;                  ServerState.Instance.StartupFailedMessage = string.Empty;                  ServerState.Instance.CurrentSetupStatus = Resources.Server_Cleaning;                    StopWatchingFiles();                    AniDBDispose();                  SetupAniDBProcessor();                    ShokoService.CmdProcessorGeneral.Stop();                  ShokoService.CmdProcessorHasher.Stop();                  ShokoService.CmdProcessorImages.Stop();                      // wait until the queue count is 0                  // ie the cancel has actuall worked                  while (true)                  {                      if (ShokoService.CmdProcessorGeneral.QueueCount == 0 &&                          ShokoService.CmdProcessorHasher.QueueCount == 0 &&                          ShokoService.CmdProcessorImages.QueueCount == 0) break;                      Thread.Sleep(250);                  }                    if (autoUpdateTimer != null) autoUpdateTimer.Enabled = false;                  if (autoUpdateTimerShort != null) autoUpdateTimerShort.Enabled = false;                    DatabaseFactory.CloseSessionFactory();                    ServerState.Instance.CurrentSetupStatus = Resources.Server_Initializing;                  Thread.Sleep(1000);                    ServerState.Instance.CurrentSetupStatus = Resources.Server_DatabaseSetup;                    logger.Info("Setting up database...");                  if (!DatabaseFactory.InitDB(out string errorMessage))                  {                      ServerState.Instance.DatabaseAvailable = false;                        if (string.IsNullOrEmpty(ServerSettings.DatabaseType))                          ServerState.Instance.CurrentSetupStatus =                              Resources.Server_DatabaseConfig;                      e.Result = false;                      ServerState.Instance.StartupFailed = true;                      ServerState.Instance.StartupFailedMessage = errorMessage;                      return;                  }                    ServerState.Instance.DatabaseAvailable = true;                    logger.Info("Initializing Session Factory...");                    Scanner.Instance.Init();                      //init session factory                  ServerState.Instance.CurrentSetupStatus = Resources.Server_InitializingSession;                  ISessionFactory temp = DatabaseFactory.SessionFactory;                      ServerState.Instance.CurrentSetupStatus = Resources.Server_InitializingQueue;                  ShokoService.CmdProcessorGeneral.Init();                  ShokoService.CmdProcessorHasher.Init();                  ShokoService.CmdProcessorImages.Init();                      // timer for automatic updates                  autoUpdateTimer = new Timer                  {                      AutoReset = true'                      Interval = 5 * 60 * 1000 // 5 * 60 seconds (5 minutes)                  };                  autoUpdateTimer.Elapsed += AutoUpdateTimer_Elapsed;                  autoUpdateTimer.Start();                    // timer for automatic updates                  autoUpdateTimerShort = new Timer                  {                      AutoReset = true'                      Interval = 5 * 1000 // 5 seconds' later we set it to 30 seconds                  };                  autoUpdateTimerShort.Elapsed += AutoUpdateTimerShort_Elapsed;                  autoUpdateTimerShort.Start();                    ServerState.Instance.CurrentSetupStatus = Resources.Server_InitializingFile;                    StartFileWorker();                    StartWatchingFiles();                    DownloadAllImages();                    IReadOnlyList<SVR_ImportFolder> folders = RepoFactory.ImportFolder.GetAll();                    if (ServerSettings.ScanDropFoldersOnStart) ScanDropFolders();                  if (ServerSettings.RunImportOnStart && folders.Count > 0) RunImport();                    ServerState.Instance.ServerOnline = true;                  workerSetupDB.ReportProgress(100);                    StartTime = DateTime.Now;                    e.Result = true;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());                  ServerState.Instance.CurrentSetupStatus = ex.Message;                  ServerState.Instance.StartupFailed = true;                  ServerState.Instance.StartupFailedMessage = $"Startup Failed: {ex}";                  e.Result = false;              }
Magic Number,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,GenerateAzureList,The following statement contains a magic number: foreach (int animeID in shuffledList)              {                  i++;                  if (!string.IsNullOrEmpty(aids)) aids += "'";                  aids += animeID;                    if (i == 250)                  {                      logger.Info(aids);                      aids = string.Empty;                      i = 0;                  }              }
Magic Number,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,SendToAzureXML,The following statement contains a magic number: DateTime dt = DateTime.Now.AddYears(-2);
Magic Number,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,CheckForUpdatesNew,The following statement contains a magic number: try              {                  long verCurrent = 0;                  long verNew = 0;                    // get the latest version as according to the release                    // get the user's version                  Assembly a = Assembly.GetEntryAssembly();                  if (a == null)                  {                      logger.Error("Could not get current version");                      return;                  }                  AssemblyName an = a.GetName();                    //verNew = verInfo.versions.ServerVersionAbs;                    verNew =                      JMMAutoUpdatesHelper.ConvertToAbsoluteVersion(                          JMMAutoUpdatesHelper.GetLatestVersionNumber(ServerSettings.UpdateChannel))                      ;                  verCurrent = an.Version.Revision * 100 +                               an.Version.Build * 100 * 100 +                               an.Version.Minor * 100 * 100 * 100 +                               an.Version.Major * 100 * 100 * 100 * 100;                    if (forceShowForm || verNew > verCurrent)                  {                      UpdateAvailable?.Invoke(this' new UpdateEventArgs(verNew' verCurrent' forceShowForm));                  }              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,CheckForUpdatesNew,The following statement contains a magic number: try              {                  long verCurrent = 0;                  long verNew = 0;                    // get the latest version as according to the release                    // get the user's version                  Assembly a = Assembly.GetEntryAssembly();                  if (a == null)                  {                      logger.Error("Could not get current version");                      return;                  }                  AssemblyName an = a.GetName();                    //verNew = verInfo.versions.ServerVersionAbs;                    verNew =                      JMMAutoUpdatesHelper.ConvertToAbsoluteVersion(                          JMMAutoUpdatesHelper.GetLatestVersionNumber(ServerSettings.UpdateChannel))                      ;                  verCurrent = an.Version.Revision * 100 +                               an.Version.Build * 100 * 100 +                               an.Version.Minor * 100 * 100 * 100 +                               an.Version.Major * 100 * 100 * 100 * 100;                    if (forceShowForm || verNew > verCurrent)                  {                      UpdateAvailable?.Invoke(this' new UpdateEventArgs(verNew' verCurrent' forceShowForm));                  }              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,CheckForUpdatesNew,The following statement contains a magic number: try              {                  long verCurrent = 0;                  long verNew = 0;                    // get the latest version as according to the release                    // get the user's version                  Assembly a = Assembly.GetEntryAssembly();                  if (a == null)                  {                      logger.Error("Could not get current version");                      return;                  }                  AssemblyName an = a.GetName();                    //verNew = verInfo.versions.ServerVersionAbs;                    verNew =                      JMMAutoUpdatesHelper.ConvertToAbsoluteVersion(                          JMMAutoUpdatesHelper.GetLatestVersionNumber(ServerSettings.UpdateChannel))                      ;                  verCurrent = an.Version.Revision * 100 +                               an.Version.Build * 100 * 100 +                               an.Version.Minor * 100 * 100 * 100 +                               an.Version.Major * 100 * 100 * 100 * 100;                    if (forceShowForm || verNew > verCurrent)                  {                      UpdateAvailable?.Invoke(this' new UpdateEventArgs(verNew' verCurrent' forceShowForm));                  }              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,CheckForUpdatesNew,The following statement contains a magic number: try              {                  long verCurrent = 0;                  long verNew = 0;                    // get the latest version as according to the release                    // get the user's version                  Assembly a = Assembly.GetEntryAssembly();                  if (a == null)                  {                      logger.Error("Could not get current version");                      return;                  }                  AssemblyName an = a.GetName();                    //verNew = verInfo.versions.ServerVersionAbs;                    verNew =                      JMMAutoUpdatesHelper.ConvertToAbsoluteVersion(                          JMMAutoUpdatesHelper.GetLatestVersionNumber(ServerSettings.UpdateChannel))                      ;                  verCurrent = an.Version.Revision * 100 +                               an.Version.Build * 100 * 100 +                               an.Version.Minor * 100 * 100 * 100 +                               an.Version.Major * 100 * 100 * 100 * 100;                    if (forceShowForm || verNew > verCurrent)                  {                      UpdateAvailable?.Invoke(this' new UpdateEventArgs(verNew' verCurrent' forceShowForm));                  }              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,CheckForUpdatesNew,The following statement contains a magic number: try              {                  long verCurrent = 0;                  long verNew = 0;                    // get the latest version as according to the release                    // get the user's version                  Assembly a = Assembly.GetEntryAssembly();                  if (a == null)                  {                      logger.Error("Could not get current version");                      return;                  }                  AssemblyName an = a.GetName();                    //verNew = verInfo.versions.ServerVersionAbs;                    verNew =                      JMMAutoUpdatesHelper.ConvertToAbsoluteVersion(                          JMMAutoUpdatesHelper.GetLatestVersionNumber(ServerSettings.UpdateChannel))                      ;                  verCurrent = an.Version.Revision * 100 +                               an.Version.Build * 100 * 100 +                               an.Version.Minor * 100 * 100 * 100 +                               an.Version.Major * 100 * 100 * 100 * 100;                    if (forceShowForm || verNew > verCurrent)                  {                      UpdateAvailable?.Invoke(this' new UpdateEventArgs(verNew' verCurrent' forceShowForm));                  }              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,CheckForUpdatesNew,The following statement contains a magic number: try              {                  long verCurrent = 0;                  long verNew = 0;                    // get the latest version as according to the release                    // get the user's version                  Assembly a = Assembly.GetEntryAssembly();                  if (a == null)                  {                      logger.Error("Could not get current version");                      return;                  }                  AssemblyName an = a.GetName();                    //verNew = verInfo.versions.ServerVersionAbs;                    verNew =                      JMMAutoUpdatesHelper.ConvertToAbsoluteVersion(                          JMMAutoUpdatesHelper.GetLatestVersionNumber(ServerSettings.UpdateChannel))                      ;                  verCurrent = an.Version.Revision * 100 +                               an.Version.Build * 100 * 100 +                               an.Version.Minor * 100 * 100 * 100 +                               an.Version.Major * 100 * 100 * 100 * 100;                    if (forceShowForm || verNew > verCurrent)                  {                      UpdateAvailable?.Invoke(this' new UpdateEventArgs(verNew' verCurrent' forceShowForm));                  }              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,CheckForUpdatesNew,The following statement contains a magic number: try              {                  long verCurrent = 0;                  long verNew = 0;                    // get the latest version as according to the release                    // get the user's version                  Assembly a = Assembly.GetEntryAssembly();                  if (a == null)                  {                      logger.Error("Could not get current version");                      return;                  }                  AssemblyName an = a.GetName();                    //verNew = verInfo.versions.ServerVersionAbs;                    verNew =                      JMMAutoUpdatesHelper.ConvertToAbsoluteVersion(                          JMMAutoUpdatesHelper.GetLatestVersionNumber(ServerSettings.UpdateChannel))                      ;                  verCurrent = an.Version.Revision * 100 +                               an.Version.Build * 100 * 100 +                               an.Version.Minor * 100 * 100 * 100 +                               an.Version.Major * 100 * 100 * 100 * 100;                    if (forceShowForm || verNew > verCurrent)                  {                      UpdateAvailable?.Invoke(this' new UpdateEventArgs(verNew' verCurrent' forceShowForm));                  }              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,CheckForUpdatesNew,The following statement contains a magic number: try              {                  long verCurrent = 0;                  long verNew = 0;                    // get the latest version as according to the release                    // get the user's version                  Assembly a = Assembly.GetEntryAssembly();                  if (a == null)                  {                      logger.Error("Could not get current version");                      return;                  }                  AssemblyName an = a.GetName();                    //verNew = verInfo.versions.ServerVersionAbs;                    verNew =                      JMMAutoUpdatesHelper.ConvertToAbsoluteVersion(                          JMMAutoUpdatesHelper.GetLatestVersionNumber(ServerSettings.UpdateChannel))                      ;                  verCurrent = an.Version.Revision * 100 +                               an.Version.Build * 100 * 100 +                               an.Version.Minor * 100 * 100 * 100 +                               an.Version.Major * 100 * 100 * 100 * 100;                    if (forceShowForm || verNew > verCurrent)                  {                      UpdateAvailable?.Invoke(this' new UpdateEventArgs(verNew' verCurrent' forceShowForm));                  }              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,CheckForUpdatesNew,The following statement contains a magic number: try              {                  long verCurrent = 0;                  long verNew = 0;                    // get the latest version as according to the release                    // get the user's version                  Assembly a = Assembly.GetEntryAssembly();                  if (a == null)                  {                      logger.Error("Could not get current version");                      return;                  }                  AssemblyName an = a.GetName();                    //verNew = verInfo.versions.ServerVersionAbs;                    verNew =                      JMMAutoUpdatesHelper.ConvertToAbsoluteVersion(                          JMMAutoUpdatesHelper.GetLatestVersionNumber(ServerSettings.UpdateChannel))                      ;                  verCurrent = an.Version.Revision * 100 +                               an.Version.Build * 100 * 100 +                               an.Version.Minor * 100 * 100 * 100 +                               an.Version.Major * 100 * 100 * 100 * 100;                    if (forceShowForm || verNew > verCurrent)                  {                      UpdateAvailable?.Invoke(this' new UpdateEventArgs(verNew' verCurrent' forceShowForm));                  }              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,CheckForUpdatesNew,The following statement contains a magic number: try              {                  long verCurrent = 0;                  long verNew = 0;                    // get the latest version as according to the release                    // get the user's version                  Assembly a = Assembly.GetEntryAssembly();                  if (a == null)                  {                      logger.Error("Could not get current version");                      return;                  }                  AssemblyName an = a.GetName();                    //verNew = verInfo.versions.ServerVersionAbs;                    verNew =                      JMMAutoUpdatesHelper.ConvertToAbsoluteVersion(                          JMMAutoUpdatesHelper.GetLatestVersionNumber(ServerSettings.UpdateChannel))                      ;                  verCurrent = an.Version.Revision * 100 +                               an.Version.Build * 100 * 100 +                               an.Version.Minor * 100 * 100 * 100 +                               an.Version.Major * 100 * 100 * 100 * 100;                    if (forceShowForm || verNew > verCurrent)                  {                      UpdateAvailable?.Invoke(this' new UpdateEventArgs(verNew' verCurrent' forceShowForm));                  }              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,AutoUpdateTimerShort_Elapsed,The following statement contains a magic number: autoUpdateTimerShort.Interval = 30 * 1000;
Magic Number,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,AutoUpdateTimerShort_Elapsed,The following statement contains a magic number: autoUpdateTimerShort.Interval = 30 * 1000;
Magic Number,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,CheckForAdminMesages,The following statement contains a magic number: try              {                  TimeSpan lastUpdate = DateTime.Now - lastAdminMessage;                    if (lastUpdate.TotalHours > 5)                  {                      lastAdminMessage = DateTime.Now;                      ServerInfo.Instance.RefreshAdminMessages();                  }              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,AniDBDispose,The following statement contains a magic number: if (ShokoService.AnidbProcessor != null)              {                  ShokoService.AnidbProcessor.ForceLogout();                  ShokoService.AnidbProcessor.Dispose();                  Thread.Sleep(1000);              }
Magic Number,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,ReviewsTest,The following statement contains a magic number: CommandRequest_GetReviews cmd = new CommandRequest_GetReviews(7525' true);
Magic Number,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,ProcessFileTest,The following statement contains a magic number: CommandRequest_ProcessFile cr_procfile = new CommandRequest_ProcessFile(15350' false);
Magic Number,Shoko.Server,ShokoServer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ShokoServer.cs,CreateTestCommandRequests,The following statement contains a magic number: CommandRequest_GetAnimeHTTP cr_anime = new CommandRequest_GetAnimeHTTP(5415' false' true);
Magic Number,Shoko.Server,ShokoServiceImplementationImage,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementationImage.cs,ResizeToRatio,The following statement contains a magic number: if (newwidth < im.Width)                  x = (im.Width - newwidth) / 2;
Magic Number,Shoko.Server,ShokoServiceImplementationImage,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementationImage.cs,ResizeToRatio,The following statement contains a magic number: if (newheight < im.Height)                  y = (im.Height - newheight) / 2;
Magic Number,Shoko.Server,ShokoServiceImplementationImage,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementationImage.cs,GetSupportImage,The following statement contains a magic number: using (Graphics g = Graphics.FromImage(im2))              {                  g.InterpolationMode = nw >= im.Width                      ? InterpolationMode.HighQualityBilinear                      : InterpolationMode.HighQualityBicubic;                  g.PixelOffsetMode = PixelOffsetMode.HighQuality;                  g.SmoothingMode = SmoothingMode.HighQuality;                  g.Clear(Color.Transparent);                  Rectangle src = new Rectangle(0' 0' im.Width' im.Height);                  Rectangle dst = new Rectangle((int) ((nw - w) / 2)' (int) ((nh - h) / 2)' im.Width' im.Height);                  g.DrawImage(im' dst' src' GraphicsUnit.Pixel);              }
Magic Number,Shoko.Server,ShokoServiceImplementationImage,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementationImage.cs,GetSupportImage,The following statement contains a magic number: using (Graphics g = Graphics.FromImage(im2))              {                  g.InterpolationMode = nw >= im.Width                      ? InterpolationMode.HighQualityBilinear                      : InterpolationMode.HighQualityBicubic;                  g.PixelOffsetMode = PixelOffsetMode.HighQuality;                  g.SmoothingMode = SmoothingMode.HighQuality;                  g.Clear(Color.Transparent);                  Rectangle src = new Rectangle(0' 0' im.Width' im.Height);                  Rectangle dst = new Rectangle((int) ((nw - w) / 2)' (int) ((nh - h) / 2)' im.Width' im.Height);                  g.DrawImage(im' dst' src' GraphicsUnit.Pixel);              }
Magic Number,Shoko.Server,LogRotator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LogRotator.cs,GetDateTime,The following statement contains a magic number: filename = filename.Substring(0' filename.Length - 4);
Magic Number,Shoko.Server,MigrationDirectory,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\MigrationDirectory.cs,RecursiveDirSize,The following statement contains a magic number: size += 2048;
Magic Number,Shoko.Server,AVDumpHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utilities\AVDumpHelper.cs,CopyStream,The following statement contains a magic number: byte[] buffer = new byte[8 * 1024];
Magic Number,Shoko.Server,AVDumpHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utilities\AVDumpHelper.cs,CopyStream,The following statement contains a magic number: byte[] buffer = new byte[8 * 1024];
Magic Number,Shoko.Server,AVDumpHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utilities\AVDumpHelper.cs,DumpFile,The following statement contains a magic number: try              {                  if (!File.Exists(avdumpDestination) && !GetAndExtractAVDump())                      return "Could not find  or download AvDump2 CLI";                  if (string.IsNullOrEmpty(file))                      return "File path cannot be null";                  if (!File.Exists(file))                      return "Could not find Video File: " + file;                    //strCommandParameters are parameters to pass to program                  string fileName = (char) 34 + file + (char) 34;                    //Create process                  Process pProcess = new Process                  {                      StartInfo =                      {                          FileName = avdumpDestination'                          Arguments =                              $@" --Auth={ServerSettings.AniDB_Username}:{ServerSettings.AniDB_AVDumpKey} --LPort={                                      ServerSettings.AniDB_AVDumpClientPort                                  } --PrintEd2kLink -t {fileName}"'                          UseShellExecute = false'                          WindowStyle = ProcessWindowStyle.Hidden'                          RedirectStandardOutput = true'                          CreateNoWindow = true                      }                  };                    pProcess.Start();                  string strOutput = pProcess.StandardOutput.ReadToEnd();                    //Wait for process to finish                  pProcess.WaitForExit();                    return strOutput;              }              catch (Exception ex)              {                  LogManager.GetCurrentClassLogger().Error($"An error occurred while AVDumping the file \"file\":\n{ex}");                  return $"An error occurred while AVDumping the file:\n{ex}";              }
Magic Number,Shoko.Server,AVDumpHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utilities\AVDumpHelper.cs,DumpFile,The following statement contains a magic number: try              {                  if (!File.Exists(avdumpDestination) && !GetAndExtractAVDump())                      return "Could not find  or download AvDump2 CLI";                  if (string.IsNullOrEmpty(file))                      return "File path cannot be null";                  if (!File.Exists(file))                      return "Could not find Video File: " + file;                    //strCommandParameters are parameters to pass to program                  string fileName = (char) 34 + file + (char) 34;                    //Create process                  Process pProcess = new Process                  {                      StartInfo =                      {                          FileName = avdumpDestination'                          Arguments =                              $@" --Auth={ServerSettings.AniDB_Username}:{ServerSettings.AniDB_AVDumpKey} --LPort={                                      ServerSettings.AniDB_AVDumpClientPort                                  } --PrintEd2kLink -t {fileName}"'                          UseShellExecute = false'                          WindowStyle = ProcessWindowStyle.Hidden'                          RedirectStandardOutput = true'                          CreateNoWindow = true                      }                  };                    pProcess.Start();                  string strOutput = pProcess.StandardOutput.ReadToEnd();                    //Wait for process to finish                  pProcess.WaitForExit();                    return strOutput;              }              catch (Exception ex)              {                  LogManager.GetCurrentClassLogger().Error($"An error occurred while AVDumping the file \"file\":\n{ex}");                  return $"An error occurred while AVDumping the file:\n{ex}";              }
Magic Number,Shoko.Server,AVDumpHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utilities\AVDumpHelper.cs,DumpFile_Mono,The following statement contains a magic number: string fileName = (char)34 + file + (char)34;
Magic Number,Shoko.Server,AVDumpHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utilities\AVDumpHelper.cs,DumpFile_Mono,The following statement contains a magic number: string fileName = (char)34 + file + (char)34;
Magic Number,Shoko.Server,ShokoServiceImplementationMetro,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementationMetro.cs,SetTvDBInfo,The following statement contains a magic number: if (ep.GetEpisodeTypeEnum() == EpisodeType.Episode)              {                  if (tvSummary.CrossRefTvDBV2 != null && tvSummary.CrossRefTvDBV2.Count > 0)                  {                      // find the xref that is right                      // relies on the xref's being sorted by season number and then episode number (desc)                      List<CrossRef_AniDB_TvDBV2> tvDBCrossRef = tvSummary.CrossRefTvDBV2                          .OrderByDescending(a => a.AniDBStartEpisodeNumber)                          .ToList();                          bool foundStartingPoint = false;                      CrossRef_AniDB_TvDBV2 xrefBase = null;                      foreach (CrossRef_AniDB_TvDBV2 xrefTV in tvDBCrossRef)                      {                          if (xrefTV.AniDBStartEpisodeType != (int) EpisodeType.Episode) continue;                          if (ep.EpisodeNumber >= xrefTV.AniDBStartEpisodeNumber)                          {                              foundStartingPoint = true;                              xrefBase = xrefTV;                              break;                          }                      }                        // we have found the starting epiosde numbder from AniDB                      // now let's check that the TvDB Season and Episode Number exist                      if (foundStartingPoint)                      {                          Dictionary<int' int> dictTvDBSeasons = null;                          Dictionary<int' TvDB_Episode> dictTvDBEpisodes = null;                          foreach (TvDBDetails det in tvSummary.TvDetails.Values)                          {                              if (det.TvDBID == xrefBase.TvDBID)                              {                                  dictTvDBSeasons = det.DictTvDBSeasons;                                  dictTvDBEpisodes = det.DictTvDBEpisodes;                                  break;                              }                          }                            if (dictTvDBSeasons.ContainsKey(xrefBase.TvDBSeasonNumber))                          {                              int episodeNumber = dictTvDBSeasons[xrefBase.TvDBSeasonNumber] +                                                  (ep.EpisodeNumber + xrefBase.TvDBStartEpisodeNumber - 2) -                                                  (xrefBase.AniDBStartEpisodeNumber - 1);                              if (dictTvDBEpisodes.ContainsKey(episodeNumber))                              {                                  TvDB_Episode tvep = dictTvDBEpisodes[episodeNumber];                                  if (string.IsNullOrEmpty(tvep.Overview))                                      contract.EpisodeOverview = "Episode Overview Not Available";                                  else                                      contract.EpisodeOverview = tvep.Overview;                                    if (string.IsNullOrEmpty(tvep.GetFullImagePath()) ||                                      !File.Exists(tvep.GetFullImagePath()))                                  {                                      contract.ImageType = 0;                                      contract.ImageID = 0;                                  }                                  else                                  {                                      contract.ImageType = (int) ImageEntityType.TvDB_Episode;                                      contract.ImageID = tvep.TvDB_EpisodeID;                                  }                                    if (ServerSettings.EpisodeTitleSource == DataSourceType.TheTvDB &&                                      !string.IsNullOrEmpty(tvep.EpisodeName))                                      contract.EpisodeName = tvep.EpisodeName;                              }                          }                      }                  }              }
Magic Number,Shoko.Server,ShokoServiceImplementationMetro,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementationMetro.cs,SetTvDBInfo,The following statement contains a magic number: if (ep.GetEpisodeTypeEnum() == EpisodeType.Special)              {                  // find the xref that is right                  // relies on the xref's being sorted by season number and then episode number (desc)                    List<CrossRef_AniDB_TvDBV2> tvDBCrossRef = tvSummary.CrossRefTvDBV2                      .OrderByDescending(a => a.AniDBStartEpisodeNumber)                      .ToList();                    bool foundStartingPoint = false;                  CrossRef_AniDB_TvDBV2 xrefBase = null;                  foreach (CrossRef_AniDB_TvDBV2 xrefTV in tvDBCrossRef)                  {                      if (xrefTV.AniDBStartEpisodeType != (int) EpisodeType.Special) continue;                      if (ep.EpisodeNumber >= xrefTV.AniDBStartEpisodeNumber)                      {                          foundStartingPoint = true;                          xrefBase = xrefTV;                          break;                      }                  }                    if (tvSummary != null && tvSummary.CrossRefTvDBV2 != null && tvSummary.CrossRefTvDBV2.Count > 0)                  {                      // we have found the starting epiosde numbder from AniDB                      // now let's check that the TvDB Season and Episode Number exist                      if (foundStartingPoint)                      {                          Dictionary<int' int> dictTvDBSeasons = null;                          Dictionary<int' TvDB_Episode> dictTvDBEpisodes = null;                          foreach (TvDBDetails det in tvSummary.TvDetails.Values)                          {                              if (det.TvDBID == xrefBase.TvDBID)                              {                                  dictTvDBSeasons = det.DictTvDBSeasons;                                  dictTvDBEpisodes = det.DictTvDBEpisodes;                                  break;                              }                          }                            if (dictTvDBSeasons.ContainsKey(xrefBase.TvDBSeasonNumber))                          {                              int episodeNumber = dictTvDBSeasons[xrefBase.TvDBSeasonNumber] +                                                  (ep.EpisodeNumber + xrefBase.TvDBStartEpisodeNumber - 2) -                                                  (xrefBase.AniDBStartEpisodeNumber - 1);                              if (dictTvDBEpisodes.ContainsKey(episodeNumber))                              {                                  TvDB_Episode tvep = dictTvDBEpisodes[episodeNumber];                                  contract.EpisodeOverview = tvep.Overview;                                    if (string.IsNullOrEmpty(tvep.GetFullImagePath()) ||                                      !File.Exists(tvep.GetFullImagePath()))                                  {                                      contract.ImageType = 0;                                      contract.ImageID = 0;                                  }                                  else                                  {                                      contract.ImageType = (int) ImageEntityType.TvDB_Episode;                                      contract.ImageID = tvep.TvDB_EpisodeID;                                  }                                    if (ServerSettings.EpisodeTitleSource == DataSourceType.TheTvDB &&                                      !string.IsNullOrEmpty(tvep.EpisodeName))                                      contract.EpisodeName = tvep.EpisodeName;                              }                          }                      }                  }              }
Magic Number,Shoko.Server,ShokoServiceImplementationStream,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementationStream.cs,StreamFromIFile,The following statement contains a magic number: try              {                  Nancy.Request request = RestModule.CurrentModule.Request;                    FileSystemResult<Stream> fr = r.File.OpenRead();                  if (fr == null || !fr.IsOk)                  {                      return new StreamWithResponse(HttpStatusCode.InternalServerError'                          "Unable to open file '" + r.File.FullName + "': " + fr?.Error);                  }                  Stream org = fr.Result;                  long totalsize = org.Length;                  long start = 0;                  long end = totalsize - 1;                    string rangevalue = request.Headers["Range"].FirstOrDefault() ??                                      request.Headers["range"].FirstOrDefault();                  rangevalue = rangevalue?.Replace("bytes="' string.Empty);                  bool range = !string.IsNullOrEmpty(rangevalue);                    if (range)                  {                      // range: bytes=split[0]-split[1]                      string[] split = rangevalue.Split('-');                      if (split.Length == 2)                      {                          // bytes=-split[1] - tail of specified length                          if (string.IsNullOrEmpty(split[0]) && !string.IsNullOrEmpty(split[1]))                          {                              long e = long.Parse(split[1]);                              start = totalsize - e;                              end = totalsize - 1;                          }                          // bytes=split[0] - split[0] to end of file                          else if (!string.IsNullOrEmpty(split[0]) && string.IsNullOrEmpty(split[1]))                          {                              start = long.Parse(split[0]);                              end = totalsize - 1;                          }                          // bytes=split[0]-split[1] - specified beginning and end                          else if (!string.IsNullOrEmpty(split[0]) && !string.IsNullOrEmpty(split[1]))                          {                              start = long.Parse(split[0]);                              end = long.Parse(split[1]);                              if (start > totalsize - 1)                                  start = totalsize - 1;                              if (end > totalsize - 1)                                  end = totalsize - 1;                          }                      }                  }                  var outstream = new SubStream(org' start' end - start + 1);                  var resp = new StreamWithResponse {ContentType = r.Mime};                  resp.Headers.Add("Server"' ServerVersion);                  resp.Headers.Add("Connection"' "keep-alive");                  resp.Headers.Add("Accept-Ranges"' "bytes");                  resp.Headers.Add("Content-Range"' "bytes " + start + "-" + end + "/" + totalsize);                  resp.ContentLength = end - start + 1;                    resp.ResponseStatus = range ? HttpStatusCode.PartialContent : HttpStatusCode.OK;                    if (r.User != null && autowatch.HasValue && autowatch.Value && r.VideoLocal != null)                  {                      outstream.CrossPosition = (long) (totalsize * WatchedThreshold);                      outstream.CrossPositionCrossed +=                          (a) =>                          {                              Task.Factory.StartNew(() => { r.VideoLocal.ToggleWatchedStatus(true' r.User.JMMUserID); }'                                  new CancellationToken()'                                  TaskCreationOptions.LongRunning' TaskScheduler.Default);                          };                  }                  resp.Stream = outstream;                  return resp;              }              catch (Exception e)              {                  logger.Error("An error occurred while serving a file: " + e);                  var resp = new StreamWithResponse();                  resp.ResponseStatus = HttpStatusCode.InternalServerError;                  resp.ResponseDescription = e.Message;                  return resp;              }
Magic Number,Shoko.Server,Scanner,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Scanner.cs,CancelScan,The following statement contains a magic number: if (workerIntegrityScanner.IsBusy)              {                  cancelIntegrityCheck = true;                  while (workerIntegrityScanner.IsBusy)                  {                      Utils.DoEvents();                      Thread.Sleep(100);                  }                  cancelIntegrityCheck = false;              }
Magic Number,Shoko.Server,TimeUpdater<T;U>,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\TimeUpdater.cs,TimeUpdater,The following statement contains a magic number: timer = new Timer(UpdateStateWorker' null' seconds * 1000' seconds * 1000);
Magic Number,Shoko.Server,TimeUpdater<T;U>,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\TimeUpdater.cs,TimeUpdater,The following statement contains a magic number: timer = new Timer(UpdateStateWorker' null' seconds * 1000' seconds * 1000);
Magic Number,Shoko.Server,TimeUpdater<T;U>,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\TimeUpdater.cs,UpdateStateWorker,The following statement contains a magic number: if (par_updates.Count > 0)              {                  Dictionary<T' DateJoinU> procdic = new Dictionary<T' DateJoinU>();                  lock (stateLock)                  {                      foreach (T ser in updates.Keys.ToList())                      {                          if (par_updates.Contains(updates[ser]))                          {                              procdic.Add(ser' updates[ser]);                              updates.Remove(ser);                          }                      }                  }                  timer.Change(Timeout.Infinite' Timeout.Infinite);                  Task.Run(() =>                  {                      foreach (T ser in procdic.Keys)                      {                          DateJoinU p = procdic[ser];                          action(ser' p.Parameters);                      }                      timer.Change(timeout * 1000' timeout * 1000);                  });              }
Magic Number,Shoko.Server,TimeUpdater<T;U>,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\TimeUpdater.cs,UpdateStateWorker,The following statement contains a magic number: if (par_updates.Count > 0)              {                  Dictionary<T' DateJoinU> procdic = new Dictionary<T' DateJoinU>();                  lock (stateLock)                  {                      foreach (T ser in updates.Keys.ToList())                      {                          if (par_updates.Contains(updates[ser]))                          {                              procdic.Add(ser' updates[ser]);                              updates.Remove(ser);                          }                      }                  }                  timer.Change(Timeout.Infinite' Timeout.Infinite);                  Task.Run(() =>                  {                      foreach (T ser in procdic.Keys)                      {                          DateJoinU p = procdic[ser];                          action(ser' p.Parameters);                      }                      timer.Change(timeout * 1000' timeout * 1000);                  });              }
Magic Number,Shoko.Server,UnhandledExceptionManager,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\UnhandledExceptionManager.cs,AssemblyBuildDate,The following statement contains a magic number: if (blnForceFileDate)              {                  dtBuild = AssemblyFileTime(objAssembly);              }              else              {                  //dtBuild = ((DateTime)"01/01/2000").AddDays(objVersion.Build).AddSeconds(objVersion.Revision * 2);                  dtBuild =                      Convert.ToDateTime("01/01/2000")                          .AddDays(objVersion.Build)                          .AddSeconds(objVersion.Revision * 2);                  if (TimeZone.IsDaylightSavingTime(DateTime.Now'                      TimeZone.CurrentTimeZone.GetDaylightChanges(DateTime.Now.Year)))                  {                      dtBuild = dtBuild.AddHours(1);                  }                  if (dtBuild > DateTime.Now | objVersion.Build < 730 | objVersion.Revision == 0)                  {                      dtBuild = AssemblyFileTime(objAssembly);                  }              }
Magic Number,Shoko.Server,UnhandledExceptionManager,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\UnhandledExceptionManager.cs,AssemblyBuildDate,The following statement contains a magic number: if (blnForceFileDate)              {                  dtBuild = AssemblyFileTime(objAssembly);              }              else              {                  //dtBuild = ((DateTime)"01/01/2000").AddDays(objVersion.Build).AddSeconds(objVersion.Revision * 2);                  dtBuild =                      Convert.ToDateTime("01/01/2000")                          .AddDays(objVersion.Build)                          .AddSeconds(objVersion.Revision * 2);                  if (TimeZone.IsDaylightSavingTime(DateTime.Now'                      TimeZone.CurrentTimeZone.GetDaylightChanges(DateTime.Now.Year)))                  {                      dtBuild = dtBuild.AddHours(1);                  }                  if (dtBuild > DateTime.Now | objVersion.Build < 730 | objVersion.Revision == 0)                  {                      dtBuild = AssemblyFileTime(objAssembly);                  }              }
Magic Number,Shoko.Server,GroupFilterHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utilities\GroupFilterHelper.cs,GetDateAsString,The following statement contains a magic number: return aDate.Year.ToString().PadLeft(4' '0') +                     aDate.Month.ToString().PadLeft(2' '0') +                     aDate.Day.ToString().PadLeft(2' '0');
Magic Number,Shoko.Server,GroupFilterHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utilities\GroupFilterHelper.cs,GetDateAsString,The following statement contains a magic number: return aDate.Year.ToString().PadLeft(4' '0') +                     aDate.Month.ToString().PadLeft(2' '0') +                     aDate.Day.ToString().PadLeft(2' '0');
Magic Number,Shoko.Server,GroupFilterHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utilities\GroupFilterHelper.cs,GetDateAsString,The following statement contains a magic number: return aDate.Year.ToString().PadLeft(4' '0') +                     aDate.Month.ToString().PadLeft(2' '0') +                     aDate.Day.ToString().PadLeft(2' '0');
Magic Number,Shoko.Server,GroupFilterHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utilities\GroupFilterHelper.cs,GetDateFromString,The following statement contains a magic number: try              {                  int year = int.Parse(sDate.Substring(0' 4));                  int month = int.Parse(sDate.Substring(4' 2));                  int day = int.Parse(sDate.Substring(6' 2));                    return new DateTime(year' month' day);              }              catch              {                  return DateTime.Today;              }
Magic Number,Shoko.Server,GroupFilterHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utilities\GroupFilterHelper.cs,GetDateFromString,The following statement contains a magic number: try              {                  int year = int.Parse(sDate.Substring(0' 4));                  int month = int.Parse(sDate.Substring(4' 2));                  int day = int.Parse(sDate.Substring(6' 2));                    return new DateTime(year' month' day);              }              catch              {                  return DateTime.Today;              }
Magic Number,Shoko.Server,GroupFilterHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utilities\GroupFilterHelper.cs,GetDateFromString,The following statement contains a magic number: try              {                  int year = int.Parse(sDate.Substring(0' 4));                  int month = int.Parse(sDate.Substring(4' 2));                  int day = int.Parse(sDate.Substring(6' 2));                    return new DateTime(year' month' day);              }              catch              {                  return DateTime.Today;              }
Magic Number,Shoko.Server,GroupFilterHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utilities\GroupFilterHelper.cs,GetDateFromString,The following statement contains a magic number: try              {                  int year = int.Parse(sDate.Substring(0' 4));                  int month = int.Parse(sDate.Substring(4' 2));                  int day = int.Parse(sDate.Substring(6' 2));                    return new DateTime(year' month' day);              }              catch              {                  return DateTime.Today;              }
Magic Number,Shoko.Server,GroupFilterHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utilities\GroupFilterHelper.cs,GetDateFromString,The following statement contains a magic number: try              {                  int year = int.Parse(sDate.Substring(0' 4));                  int month = int.Parse(sDate.Substring(4' 2));                  int day = int.Parse(sDate.Substring(6' 2));                    return new DateTime(year' month' day);              }              catch              {                  return DateTime.Today;              }
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,GetParentMethodName,The following statement contains a magic number: StackFrame stackFrame = stackTrace.GetFrame(2);
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,GetCurrentUTCTime,The following statement contains a magic number: TimeSpan sp = dt.Subtract(new DateTime(1970' 1' 1' 0' 0' 0));
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,ReparseDescription,The following statement contains a magic number: while (vup.Contains("[URL") || vup.Contains("[/URL]"))              {                  int a = vup.IndexOf("[URL"' StringComparison.Ordinal);                  if (a >= 0)                  {                      int b = vup.IndexOf("]"' a + 1' StringComparison.Ordinal);                      if (b >= 0)                      {                          val = val.Substring(0' a) + val.Substring(b + 1);                          vup = val.ToUpper();                      }                  }                  a = vup.IndexOf("[/URL]"' StringComparison.Ordinal);                  if (a < 0) continue;                  val = val.Substring(0' a) + val.Substring(a + 6);                  vup = val.ToUpper();              }
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,ReparseDescription,The following statement contains a magic number: while (vup.Contains("HTTP:"))              {                  int a = vup.IndexOf("HTTP:"' StringComparison.Ordinal);                  if (a < 0) continue;                  int b = vup.IndexOf(" "' a + 1' StringComparison.Ordinal);                  if (b < 0) break;                  if (vup[b + 1] == '[')                  {                      int c = vup.IndexOf("]"' b + 1' StringComparison.Ordinal);                      val = val.Substring(0' a) + " " + val.Substring(b + 2' c - b - 2) + val.Substring(c + 1);                  }                  else                  {                      val = val.Substring(0' a) + val.Substring(b);                  }                  vup = val.ToUpper();              }
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,ReparseDescription,The following statement contains a magic number: while (vup.Contains("HTTP:"))              {                  int a = vup.IndexOf("HTTP:"' StringComparison.Ordinal);                  if (a < 0) continue;                  int b = vup.IndexOf(" "' a + 1' StringComparison.Ordinal);                  if (b < 0) break;                  if (vup[b + 1] == '[')                  {                      int c = vup.IndexOf("]"' b + 1' StringComparison.Ordinal);                      val = val.Substring(0' a) + " " + val.Substring(b + 2' c - b - 2) + val.Substring(c + 1);                  }                  else                  {                      val = val.Substring(0' a) + val.Substring(b);                  }                  vup = val.ToUpper();              }
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,FormatSecondsToDisplayTime,The following statement contains a magic number: if (t.Hours > 0)                  return $"{t.Hours}:{t.Minutes.ToString().PadLeft(2' '0')}:{t.Seconds.ToString().PadLeft(2' '0')}";
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,FormatSecondsToDisplayTime,The following statement contains a magic number: if (t.Hours > 0)                  return $"{t.Hours}:{t.Minutes.ToString().PadLeft(2' '0')}:{t.Seconds.ToString().PadLeft(2' '0')}";
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,FormatSecondsToDisplayTime,The following statement contains a magic number: return $"{t.Minutes}:{t.Seconds.ToString().PadLeft(2' '0')}";
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,FormatAniDBRating,The following statement contains a magic number: rat /= 100;
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,GetSortName,The following statement contains a magic number: if (newName.ToLower().StartsWith("the "' StringComparison.InvariantCultureIgnoreCase))                  newName = newName.Remove(0' 4);
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,GetSortName,The following statement contains a magic number: if (newName.ToLower().StartsWith("a "' StringComparison.InvariantCultureIgnoreCase))                  newName = newName.Remove(0' 2);
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,GetOSInfo,The following statement contains a magic number: if (os.Platform == PlatformID.Win32Windows)              {                  //This is a pre-NT version of Windows                  switch (vs.Minor)                  {                      case 0:                          operatingSystem = "95";                          break;                      case 10:                          if (vs.Revision.ToString() == "2222A")                              operatingSystem = "98SE";                          else                              operatingSystem = "98";                          break;                      case 90:                          operatingSystem = "Me";                          break;                  }              }              else if (os.Platform == PlatformID.Win32NT)              {                  switch (vs.Major)                  {                      case 3:                          operatingSystem = "NT 3.51";                          break;                      case 4:                          operatingSystem = "NT 4.0";                          break;                      case 5:                          if (vs.Minor == 0)                              operatingSystem = "2000";                          else                              operatingSystem = "XP";                          break;                      case 6:                          switch (vs.Minor)                          {                              case 0:                                  operatingSystem = "Vista / 2008 Server";                                  break;                              case 1:                                  operatingSystem = "7 / 2008 Server R2";                                  break;                              case 2:                                  operatingSystem = "8 / 2012 Server";                                  break;                              case 3:                                  operatingSystem = "8.1 / 2012 Server R2";                                  break;                              default:                                  operatingSystem = "Unknown";                                  break;                          }                          break;                  }              }
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,GetOSInfo,The following statement contains a magic number: if (os.Platform == PlatformID.Win32Windows)              {                  //This is a pre-NT version of Windows                  switch (vs.Minor)                  {                      case 0:                          operatingSystem = "95";                          break;                      case 10:                          if (vs.Revision.ToString() == "2222A")                              operatingSystem = "98SE";                          else                              operatingSystem = "98";                          break;                      case 90:                          operatingSystem = "Me";                          break;                  }              }              else if (os.Platform == PlatformID.Win32NT)              {                  switch (vs.Major)                  {                      case 3:                          operatingSystem = "NT 3.51";                          break;                      case 4:                          operatingSystem = "NT 4.0";                          break;                      case 5:                          if (vs.Minor == 0)                              operatingSystem = "2000";                          else                              operatingSystem = "XP";                          break;                      case 6:                          switch (vs.Minor)                          {                              case 0:                                  operatingSystem = "Vista / 2008 Server";                                  break;                              case 1:                                  operatingSystem = "7 / 2008 Server R2";                                  break;                              case 2:                                  operatingSystem = "8 / 2012 Server";                                  break;                              case 3:                                  operatingSystem = "8.1 / 2012 Server R2";                                  break;                              default:                                  operatingSystem = "Unknown";                                  break;                          }                          break;                  }              }
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,GetOSInfo,The following statement contains a magic number: if (os.Platform == PlatformID.Win32Windows)              {                  //This is a pre-NT version of Windows                  switch (vs.Minor)                  {                      case 0:                          operatingSystem = "95";                          break;                      case 10:                          if (vs.Revision.ToString() == "2222A")                              operatingSystem = "98SE";                          else                              operatingSystem = "98";                          break;                      case 90:                          operatingSystem = "Me";                          break;                  }              }              else if (os.Platform == PlatformID.Win32NT)              {                  switch (vs.Major)                  {                      case 3:                          operatingSystem = "NT 3.51";                          break;                      case 4:                          operatingSystem = "NT 4.0";                          break;                      case 5:                          if (vs.Minor == 0)                              operatingSystem = "2000";                          else                              operatingSystem = "XP";                          break;                      case 6:                          switch (vs.Minor)                          {                              case 0:                                  operatingSystem = "Vista / 2008 Server";                                  break;                              case 1:                                  operatingSystem = "7 / 2008 Server R2";                                  break;                              case 2:                                  operatingSystem = "8 / 2012 Server";                                  break;                              case 3:                                  operatingSystem = "8.1 / 2012 Server R2";                                  break;                              default:                                  operatingSystem = "Unknown";                                  break;                          }                          break;                  }              }
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,GetOSInfo,The following statement contains a magic number: if (os.Platform == PlatformID.Win32Windows)              {                  //This is a pre-NT version of Windows                  switch (vs.Minor)                  {                      case 0:                          operatingSystem = "95";                          break;                      case 10:                          if (vs.Revision.ToString() == "2222A")                              operatingSystem = "98SE";                          else                              operatingSystem = "98";                          break;                      case 90:                          operatingSystem = "Me";                          break;                  }              }              else if (os.Platform == PlatformID.Win32NT)              {                  switch (vs.Major)                  {                      case 3:                          operatingSystem = "NT 3.51";                          break;                      case 4:                          operatingSystem = "NT 4.0";                          break;                      case 5:                          if (vs.Minor == 0)                              operatingSystem = "2000";                          else                              operatingSystem = "XP";                          break;                      case 6:                          switch (vs.Minor)                          {                              case 0:                                  operatingSystem = "Vista / 2008 Server";                                  break;                              case 1:                                  operatingSystem = "7 / 2008 Server R2";                                  break;                              case 2:                                  operatingSystem = "8 / 2012 Server";                                  break;                              case 3:                                  operatingSystem = "8.1 / 2012 Server R2";                                  break;                              default:                                  operatingSystem = "Unknown";                                  break;                          }                          break;                  }              }
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,GetOSInfo,The following statement contains a magic number: if (os.Platform == PlatformID.Win32Windows)              {                  //This is a pre-NT version of Windows                  switch (vs.Minor)                  {                      case 0:                          operatingSystem = "95";                          break;                      case 10:                          if (vs.Revision.ToString() == "2222A")                              operatingSystem = "98SE";                          else                              operatingSystem = "98";                          break;                      case 90:                          operatingSystem = "Me";                          break;                  }              }              else if (os.Platform == PlatformID.Win32NT)              {                  switch (vs.Major)                  {                      case 3:                          operatingSystem = "NT 3.51";                          break;                      case 4:                          operatingSystem = "NT 4.0";                          break;                      case 5:                          if (vs.Minor == 0)                              operatingSystem = "2000";                          else                              operatingSystem = "XP";                          break;                      case 6:                          switch (vs.Minor)                          {                              case 0:                                  operatingSystem = "Vista / 2008 Server";                                  break;                              case 1:                                  operatingSystem = "7 / 2008 Server R2";                                  break;                              case 2:                                  operatingSystem = "8 / 2012 Server";                                  break;                              case 3:                                  operatingSystem = "8.1 / 2012 Server R2";                                  break;                              default:                                  operatingSystem = "Unknown";                                  break;                          }                          break;                  }              }
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,GetOSInfo,The following statement contains a magic number: if (os.Platform == PlatformID.Win32Windows)              {                  //This is a pre-NT version of Windows                  switch (vs.Minor)                  {                      case 0:                          operatingSystem = "95";                          break;                      case 10:                          if (vs.Revision.ToString() == "2222A")                              operatingSystem = "98SE";                          else                              operatingSystem = "98";                          break;                      case 90:                          operatingSystem = "Me";                          break;                  }              }              else if (os.Platform == PlatformID.Win32NT)              {                  switch (vs.Major)                  {                      case 3:                          operatingSystem = "NT 3.51";                          break;                      case 4:                          operatingSystem = "NT 4.0";                          break;                      case 5:                          if (vs.Minor == 0)                              operatingSystem = "2000";                          else                              operatingSystem = "XP";                          break;                      case 6:                          switch (vs.Minor)                          {                              case 0:                                  operatingSystem = "Vista / 2008 Server";                                  break;                              case 1:                                  operatingSystem = "7 / 2008 Server R2";                                  break;                              case 2:                                  operatingSystem = "8 / 2012 Server";                                  break;                              case 3:                                  operatingSystem = "8.1 / 2012 Server R2";                                  break;                              default:                                  operatingSystem = "Unknown";                                  break;                          }                          break;                  }              }
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,GetOSInfo,The following statement contains a magic number: if (os.Platform == PlatformID.Win32Windows)              {                  //This is a pre-NT version of Windows                  switch (vs.Minor)                  {                      case 0:                          operatingSystem = "95";                          break;                      case 10:                          if (vs.Revision.ToString() == "2222A")                              operatingSystem = "98SE";                          else                              operatingSystem = "98";                          break;                      case 90:                          operatingSystem = "Me";                          break;                  }              }              else if (os.Platform == PlatformID.Win32NT)              {                  switch (vs.Major)                  {                      case 3:                          operatingSystem = "NT 3.51";                          break;                      case 4:                          operatingSystem = "NT 4.0";                          break;                      case 5:                          if (vs.Minor == 0)                              operatingSystem = "2000";                          else                              operatingSystem = "XP";                          break;                      case 6:                          switch (vs.Minor)                          {                              case 0:                                  operatingSystem = "Vista / 2008 Server";                                  break;                              case 1:                                  operatingSystem = "7 / 2008 Server R2";                                  break;                              case 2:                                  operatingSystem = "8 / 2012 Server";                                  break;                              case 3:                                  operatingSystem = "8.1 / 2012 Server R2";                                  break;                              default:                                  operatingSystem = "Unknown";                                  break;                          }                          break;                  }              }
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,GetOSInfo,The following statement contains a magic number: if (os.Platform == PlatformID.Win32Windows)              {                  //This is a pre-NT version of Windows                  switch (vs.Minor)                  {                      case 0:                          operatingSystem = "95";                          break;                      case 10:                          if (vs.Revision.ToString() == "2222A")                              operatingSystem = "98SE";                          else                              operatingSystem = "98";                          break;                      case 90:                          operatingSystem = "Me";                          break;                  }              }              else if (os.Platform == PlatformID.Win32NT)              {                  switch (vs.Major)                  {                      case 3:                          operatingSystem = "NT 3.51";                          break;                      case 4:                          operatingSystem = "NT 4.0";                          break;                      case 5:                          if (vs.Minor == 0)                              operatingSystem = "2000";                          else                              operatingSystem = "XP";                          break;                      case 6:                          switch (vs.Minor)                          {                              case 0:                                  operatingSystem = "Vista / 2008 Server";                                  break;                              case 1:                                  operatingSystem = "7 / 2008 Server R2";                                  break;                              case 2:                                  operatingSystem = "8 / 2012 Server";                                  break;                              case 3:                                  operatingSystem = "8.1 / 2012 Server R2";                                  break;                              default:                                  operatingSystem = "Unknown";                                  break;                          }                          break;                  }              }
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,FormatByteSize,The following statement contains a magic number: StringBuilder sbBuffer = new StringBuilder(20);
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,FormatByteSize,The following statement contains a magic number: StrFormatByteSize(fileSize' sbBuffer' 20);
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,GetBytesReadable,The following statement contains a magic number: if (absolute_i >= 0x1000000000000000) // Exabyte              {                  suffix = "EB";                  readable = (i >> 50);              }              else if (absolute_i >= 0x4000000000000) // Petabyte              {                  suffix = "PB";                  readable = (i >> 40);              }              else if (absolute_i >= 0x10000000000) // Terabyte              {                  suffix = "TB";                  readable = (i >> 30);              }              else if (absolute_i >= 0x40000000) // Gigabyte              {                  suffix = "GB";                  readable = (i >> 20);              }              else if (absolute_i >= 0x100000) // Megabyte              {                  suffix = "MB";                  readable = (i >> 10);              }              else if (absolute_i >= 0x400) // Kilobyte              {                  suffix = "KB";                  readable = i;              }              else              {                  return i.ToString("0 B"); // Byte              }
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,GetBytesReadable,The following statement contains a magic number: if (absolute_i >= 0x1000000000000000) // Exabyte              {                  suffix = "EB";                  readable = (i >> 50);              }              else if (absolute_i >= 0x4000000000000) // Petabyte              {                  suffix = "PB";                  readable = (i >> 40);              }              else if (absolute_i >= 0x10000000000) // Terabyte              {                  suffix = "TB";                  readable = (i >> 30);              }              else if (absolute_i >= 0x40000000) // Gigabyte              {                  suffix = "GB";                  readable = (i >> 20);              }              else if (absolute_i >= 0x100000) // Megabyte              {                  suffix = "MB";                  readable = (i >> 10);              }              else if (absolute_i >= 0x400) // Kilobyte              {                  suffix = "KB";                  readable = i;              }              else              {                  return i.ToString("0 B"); // Byte              }
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,GetBytesReadable,The following statement contains a magic number: if (absolute_i >= 0x1000000000000000) // Exabyte              {                  suffix = "EB";                  readable = (i >> 50);              }              else if (absolute_i >= 0x4000000000000) // Petabyte              {                  suffix = "PB";                  readable = (i >> 40);              }              else if (absolute_i >= 0x10000000000) // Terabyte              {                  suffix = "TB";                  readable = (i >> 30);              }              else if (absolute_i >= 0x40000000) // Gigabyte              {                  suffix = "GB";                  readable = (i >> 20);              }              else if (absolute_i >= 0x100000) // Megabyte              {                  suffix = "MB";                  readable = (i >> 10);              }              else if (absolute_i >= 0x400) // Kilobyte              {                  suffix = "KB";                  readable = i;              }              else              {                  return i.ToString("0 B"); // Byte              }
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,GetBytesReadable,The following statement contains a magic number: if (absolute_i >= 0x1000000000000000) // Exabyte              {                  suffix = "EB";                  readable = (i >> 50);              }              else if (absolute_i >= 0x4000000000000) // Petabyte              {                  suffix = "PB";                  readable = (i >> 40);              }              else if (absolute_i >= 0x10000000000) // Terabyte              {                  suffix = "TB";                  readable = (i >> 30);              }              else if (absolute_i >= 0x40000000) // Gigabyte              {                  suffix = "GB";                  readable = (i >> 20);              }              else if (absolute_i >= 0x100000) // Megabyte              {                  suffix = "MB";                  readable = (i >> 10);              }              else if (absolute_i >= 0x400) // Kilobyte              {                  suffix = "KB";                  readable = i;              }              else              {                  return i.ToString("0 B"); // Byte              }
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,GetBytesReadable,The following statement contains a magic number: if (absolute_i >= 0x1000000000000000) // Exabyte              {                  suffix = "EB";                  readable = (i >> 50);              }              else if (absolute_i >= 0x4000000000000) // Petabyte              {                  suffix = "PB";                  readable = (i >> 40);              }              else if (absolute_i >= 0x10000000000) // Terabyte              {                  suffix = "TB";                  readable = (i >> 30);              }              else if (absolute_i >= 0x40000000) // Gigabyte              {                  suffix = "GB";                  readable = (i >> 20);              }              else if (absolute_i >= 0x100000) // Megabyte              {                  suffix = "MB";                  readable = (i >> 10);              }              else if (absolute_i >= 0x400) // Kilobyte              {                  suffix = "KB";                  readable = i;              }              else              {                  return i.ToString("0 B"); // Byte              }
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,GetBytesReadable,The following statement contains a magic number: readable = (readable / 1024);
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,GetScheduledHours,The following statement contains a magic number: switch (freq)              {                  case ScheduledUpdateFrequency.Daily:                      return 24;                  case ScheduledUpdateFrequency.HoursSix:                      return 6;                  case ScheduledUpdateFrequency.HoursTwelve:                      return 12;                  case ScheduledUpdateFrequency.WeekOne:                      return 24 * 7;                  case ScheduledUpdateFrequency.MonthOne:                      return 24 * 30;                  case ScheduledUpdateFrequency.Never:                      return int.MaxValue;              }
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,GetScheduledHours,The following statement contains a magic number: switch (freq)              {                  case ScheduledUpdateFrequency.Daily:                      return 24;                  case ScheduledUpdateFrequency.HoursSix:                      return 6;                  case ScheduledUpdateFrequency.HoursTwelve:                      return 12;                  case ScheduledUpdateFrequency.WeekOne:                      return 24 * 7;                  case ScheduledUpdateFrequency.MonthOne:                      return 24 * 30;                  case ScheduledUpdateFrequency.Never:                      return int.MaxValue;              }
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,GetScheduledHours,The following statement contains a magic number: switch (freq)              {                  case ScheduledUpdateFrequency.Daily:                      return 24;                  case ScheduledUpdateFrequency.HoursSix:                      return 6;                  case ScheduledUpdateFrequency.HoursTwelve:                      return 12;                  case ScheduledUpdateFrequency.WeekOne:                      return 24 * 7;                  case ScheduledUpdateFrequency.MonthOne:                      return 24 * 30;                  case ScheduledUpdateFrequency.Never:                      return int.MaxValue;              }
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,GetScheduledHours,The following statement contains a magic number: switch (freq)              {                  case ScheduledUpdateFrequency.Daily:                      return 24;                  case ScheduledUpdateFrequency.HoursSix:                      return 6;                  case ScheduledUpdateFrequency.HoursTwelve:                      return 12;                  case ScheduledUpdateFrequency.WeekOne:                      return 24 * 7;                  case ScheduledUpdateFrequency.MonthOne:                      return 24 * 30;                  case ScheduledUpdateFrequency.Never:                      return int.MaxValue;              }
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,GetScheduledHours,The following statement contains a magic number: switch (freq)              {                  case ScheduledUpdateFrequency.Daily:                      return 24;                  case ScheduledUpdateFrequency.HoursSix:                      return 6;                  case ScheduledUpdateFrequency.HoursTwelve:                      return 12;                  case ScheduledUpdateFrequency.WeekOne:                      return 24 * 7;                  case ScheduledUpdateFrequency.MonthOne:                      return 24 * 30;                  case ScheduledUpdateFrequency.Never:                      return int.MaxValue;              }
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,GetScheduledHours,The following statement contains a magic number: switch (freq)              {                  case ScheduledUpdateFrequency.Daily:                      return 24;                  case ScheduledUpdateFrequency.HoursSix:                      return 6;                  case ScheduledUpdateFrequency.HoursTwelve:                      return 12;                  case ScheduledUpdateFrequency.WeekOne:                      return 24 * 7;                  case ScheduledUpdateFrequency.MonthOne:                      return 24 * 30;                  case ScheduledUpdateFrequency.Never:                      return int.MaxValue;              }
Magic Number,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,GetScheduledHours,The following statement contains a magic number: switch (freq)              {                  case ScheduledUpdateFrequency.Daily:                      return 24;                  case ScheduledUpdateFrequency.HoursSix:                      return 6;                  case ScheduledUpdateFrequency.HoursTwelve:                      return 12;                  case ScheduledUpdateFrequency.WeekOne:                      return 24 * 7;                  case ScheduledUpdateFrequency.MonthOne:                      return 24 * 30;                  case ScheduledUpdateFrequency.Never:                      return int.MaxValue;              }
Magic Number,AniDBAPI,AniDBHTTPHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\AniDBHTTPHelper.cs,GetAnimeXMLFromAPI,The following statement contains a magic number: try              {                  string uri = string.Format(AnimeURL' animeID);                  //APIUtils.WriteToLog("GetAnimeXMLFromAPI: " + uri);                    Thread.CurrentThread.CurrentUICulture = CultureInfo.GetCultureInfo(ServerSettings.Culture);                    DateTime start = DateTime.Now;                  string msg = string.Format(Resources.AniDB_GettingAnimeXML' animeID);                  ShokoService.LogToSystem(Constants.DBLogType.APIAniDBHTTP' msg);                    rawXML = APIUtils.DownloadWebPage(uri);                    // Putting this here for no chance of error. It is ALWAYS created or updated when AniDB is called!                  var update = RepoFactory.AniDB_AnimeUpdate.GetByAnimeID(animeID);                  if (update == null)                      update = new AniDB_AnimeUpdate {AnimeID = animeID' UpdatedAt = DateTime.Now};                  else                      update.UpdatedAt = DateTime.Now;                  RepoFactory.AniDB_AnimeUpdate.Save(update);                    TimeSpan ts = DateTime.Now - start;                  string content = rawXML;                  if (content.Length > 100) content = content.Substring(0' 100);                  msg = string.Format(Resources.AniDB_GotAnimeXML' animeID' ts.TotalMilliseconds'                      content);                  ShokoService.LogToSystem(Constants.DBLogType.APIAniDBHTTP' msg);                    //APIUtils.WriteToLog("GetAnimeXMLFromAPI result: " + rawXML);                    if (rawXML.Trim().Length == 0) return null;                    XmlDocument docAnime = new XmlDocument();                  docAnime.LoadXml(rawXML);                    return docAnime;              }              catch (Exception ex)              {                  logger.Error(ex' "Error in AniDBHTTPHelper.GetAnimeXMLFromAPI: {0}");                  return null;              }
Magic Number,AniDBAPI,AniDBHTTPHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\AniDBHTTPHelper.cs,GetAnimeXMLFromAPI,The following statement contains a magic number: try              {                  string uri = string.Format(AnimeURL' animeID);                  //APIUtils.WriteToLog("GetAnimeXMLFromAPI: " + uri);                    Thread.CurrentThread.CurrentUICulture = CultureInfo.GetCultureInfo(ServerSettings.Culture);                    DateTime start = DateTime.Now;                  string msg = string.Format(Resources.AniDB_GettingAnimeXML' animeID);                  ShokoService.LogToSystem(Constants.DBLogType.APIAniDBHTTP' msg);                    rawXML = APIUtils.DownloadWebPage(uri);                    // Putting this here for no chance of error. It is ALWAYS created or updated when AniDB is called!                  var update = RepoFactory.AniDB_AnimeUpdate.GetByAnimeID(animeID);                  if (update == null)                      update = new AniDB_AnimeUpdate {AnimeID = animeID' UpdatedAt = DateTime.Now};                  else                      update.UpdatedAt = DateTime.Now;                  RepoFactory.AniDB_AnimeUpdate.Save(update);                    TimeSpan ts = DateTime.Now - start;                  string content = rawXML;                  if (content.Length > 100) content = content.Substring(0' 100);                  msg = string.Format(Resources.AniDB_GotAnimeXML' animeID' ts.TotalMilliseconds'                      content);                  ShokoService.LogToSystem(Constants.DBLogType.APIAniDBHTTP' msg);                    //APIUtils.WriteToLog("GetAnimeXMLFromAPI result: " + rawXML);                    if (rawXML.Trim().Length == 0) return null;                    XmlDocument docAnime = new XmlDocument();                  docAnime.LoadXml(rawXML);                    return docAnime;              }              catch (Exception ex)              {                  logger.Error(ex' "Error in AniDBHTTPHelper.GetAnimeXMLFromAPI: {0}");                  return null;              }
Magic Number,AniDBAPI,AniDBHTTPHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\AniDBHTTPHelper.cs,ProcessAnimeDetails,The following statement contains a magic number: foreach (XmlNode node in ratingItems)              {                  string name = node?.Name?.Trim().ToLower();                  if (string.IsNullOrEmpty(name)) continue;                  if (!int.TryParse(TryGetAttribute(node' "count")' out int iCount)) continue;                  if (!decimal.TryParse(node.InnerText.Trim()' style' culture' out decimal iRating)) continue;                  iRating = (int) Math.Round(iRating * 100);                    if (name.Equals("permanent"))                  {                      anime.VoteCount = iCount;                      anime.Rating = (int) iRating;                  }                  else if (name.Equals("temporary"))                  {                      anime.TempVoteCount = iCount;                      anime.TempRating = (int) iRating;                  }                  else if (name.Equals("review"))                  {                      anime.ReviewCount = iCount;                      anime.AvgReviewRating = (int) iRating;                  }              }
Magic Number,AniDBAPI,AniDBHTTPHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\AniDBHTTPHelper.cs,ConvertReltTypeTextToEnum,The following statement contains a magic number: if (relType.Trim().ToLower().Equals("prequel")) return 2;
Magic Number,AniDBAPI,AniDBHTTPHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\AniDBHTTPHelper.cs,ConvertReltTypeTextToEnum,The following statement contains a magic number: if (relType.Trim().ToLower().Equals("same setting")) return 11;
Magic Number,AniDBAPI,AniDBHTTPHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\AniDBHTTPHelper.cs,ConvertReltTypeTextToEnum,The following statement contains a magic number: if (relType.Trim().ToLower().Equals("alternative setting")) return 21;
Magic Number,AniDBAPI,AniDBHTTPHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\AniDBHTTPHelper.cs,ConvertReltTypeTextToEnum,The following statement contains a magic number: if (relType.Trim().ToLower().Equals("alternative version")) return 32;
Magic Number,AniDBAPI,AniDBHTTPHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\AniDBHTTPHelper.cs,ConvertReltTypeTextToEnum,The following statement contains a magic number: if (relType.Trim().ToLower().Equals("music video")) return 41;
Magic Number,AniDBAPI,AniDBHTTPHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\AniDBHTTPHelper.cs,ConvertReltTypeTextToEnum,The following statement contains a magic number: if (relType.Trim().ToLower().Equals("character")) return 42;
Magic Number,AniDBAPI,AniDBHTTPHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\AniDBHTTPHelper.cs,ConvertReltTypeTextToEnum,The following statement contains a magic number: if (relType.Trim().ToLower().Equals("side story")) return 51;
Magic Number,AniDBAPI,AniDBHTTPHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\AniDBHTTPHelper.cs,ConvertReltTypeTextToEnum,The following statement contains a magic number: if (relType.Trim().ToLower().Equals("parent story")) return 52;
Magic Number,AniDBAPI,AniDBHTTPHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\AniDBHTTPHelper.cs,ConvertReltTypeTextToEnum,The following statement contains a magic number: if (relType.Trim().ToLower().Equals("summary")) return 61;
Magic Number,AniDBAPI,AniDBHTTPHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\AniDBHTTPHelper.cs,ConvertReltTypeTextToEnum,The following statement contains a magic number: if (relType.Trim().ToLower().Equals("full story")) return 62;
Magic Number,AniDBAPI,AniDBHTTPHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\AniDBHTTPHelper.cs,ConvertReltTypeTextToEnum,The following statement contains a magic number: return 100;
Magic Number,AniDBAPI,CalendarCollection,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Calendar.cs,CalendarCollection,The following statement contains a magic number: if (sDetails.Length <= 2) return;
Magic Number,AniDBAPI,CalendarCollection,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Calendar.cs,CalendarCollection,The following statement contains a magic number: for (int i = 1; i < sDetails.Length - 1; i++)                  // first item will be the status command' and last will be empty              {                  //BaseConfig.MyAnimeLog.Write("s: {0}"' sDetails[i]);                    Calendar cal = new Calendar();                    string[] flds = sDetails[i].Substring(0).Split('|');                  cal.AnimeID = int.Parse(flds[0]);                  cal.ReleaseDateRaw = flds[1];                  cal.DateFlags = int.Parse(flds[2]);                  cal.ReleaseDate = AniDB.GetAniDBDateAsDate(flds[1]' cal.DateFlags);                    calendars.Add(cal);                    //BaseConfig.MyAnimeLog.Write("grp: {0}"' grp);              }
Magic Number,AniDBAPI,GroupStatusCollection,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\GroupStatusCollection.cs,GroupStatusCollection,The following statement contains a magic number: if (sDetails.Length <= 2) return;
Magic Number,AniDBAPI,GroupStatusCollection,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\GroupStatusCollection.cs,GroupStatusCollection,The following statement contains a magic number: for (int i = 1; i < sDetails.Length - 1; i++)                  // first item will be the status command' and last will be empty              {                  //BaseConfig.MyAnimeLog.Write("s: {0}"' sDetails[i]);                    Raw_AniDB_GroupStatus grp = new Raw_AniDB_GroupStatus { AnimeID = animeID };                  try                  {                      // {int group id}|{str group name}|{int completion state}|{int last episode number}|{int rating}|{int votes}|{str episode range}\n                      string[] flds = sDetails[i].Substring(0).Split('|');                      grp.GroupID = int.Parse(flds[0]);                      grp.GroupName = flds[1];                      grp.CompletionState = int.Parse(flds[2]);                      grp.LastEpisodeNumber = int.Parse(flds[3]);                      grp.Rating = int.Parse(flds[4]);                      grp.Votes = int.Parse(flds[5]);                      grp.EpisodeRange = flds[6];                      groups.Add(grp);                  }                  catch (Exception ex)                  {                      NLog.LogManager.GetCurrentClassLogger().Error(ex' ex.ToString());                  }                    //BaseConfig.MyAnimeLog.Write("grp: {0}"' grp);              }
Magic Number,AniDBAPI,GroupStatusCollection,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\GroupStatusCollection.cs,GroupStatusCollection,The following statement contains a magic number: for (int i = 1; i < sDetails.Length - 1; i++)                  // first item will be the status command' and last will be empty              {                  //BaseConfig.MyAnimeLog.Write("s: {0}"' sDetails[i]);                    Raw_AniDB_GroupStatus grp = new Raw_AniDB_GroupStatus { AnimeID = animeID };                  try                  {                      // {int group id}|{str group name}|{int completion state}|{int last episode number}|{int rating}|{int votes}|{str episode range}\n                      string[] flds = sDetails[i].Substring(0).Split('|');                      grp.GroupID = int.Parse(flds[0]);                      grp.GroupName = flds[1];                      grp.CompletionState = int.Parse(flds[2]);                      grp.LastEpisodeNumber = int.Parse(flds[3]);                      grp.Rating = int.Parse(flds[4]);                      grp.Votes = int.Parse(flds[5]);                      grp.EpisodeRange = flds[6];                      groups.Add(grp);                  }                  catch (Exception ex)                  {                      NLog.LogManager.GetCurrentClassLogger().Error(ex' ex.ToString());                  }                    //BaseConfig.MyAnimeLog.Write("grp: {0}"' grp);              }
Magic Number,AniDBAPI,GroupStatusCollection,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\GroupStatusCollection.cs,GroupStatusCollection,The following statement contains a magic number: for (int i = 1; i < sDetails.Length - 1; i++)                  // first item will be the status command' and last will be empty              {                  //BaseConfig.MyAnimeLog.Write("s: {0}"' sDetails[i]);                    Raw_AniDB_GroupStatus grp = new Raw_AniDB_GroupStatus { AnimeID = animeID };                  try                  {                      // {int group id}|{str group name}|{int completion state}|{int last episode number}|{int rating}|{int votes}|{str episode range}\n                      string[] flds = sDetails[i].Substring(0).Split('|');                      grp.GroupID = int.Parse(flds[0]);                      grp.GroupName = flds[1];                      grp.CompletionState = int.Parse(flds[2]);                      grp.LastEpisodeNumber = int.Parse(flds[3]);                      grp.Rating = int.Parse(flds[4]);                      grp.Votes = int.Parse(flds[5]);                      grp.EpisodeRange = flds[6];                      groups.Add(grp);                  }                  catch (Exception ex)                  {                      NLog.LogManager.GetCurrentClassLogger().Error(ex' ex.ToString());                  }                    //BaseConfig.MyAnimeLog.Write("grp: {0}"' grp);              }
Magic Number,AniDBAPI,GroupStatusCollection,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\GroupStatusCollection.cs,GroupStatusCollection,The following statement contains a magic number: for (int i = 1; i < sDetails.Length - 1; i++)                  // first item will be the status command' and last will be empty              {                  //BaseConfig.MyAnimeLog.Write("s: {0}"' sDetails[i]);                    Raw_AniDB_GroupStatus grp = new Raw_AniDB_GroupStatus { AnimeID = animeID };                  try                  {                      // {int group id}|{str group name}|{int completion state}|{int last episode number}|{int rating}|{int votes}|{str episode range}\n                      string[] flds = sDetails[i].Substring(0).Split('|');                      grp.GroupID = int.Parse(flds[0]);                      grp.GroupName = flds[1];                      grp.CompletionState = int.Parse(flds[2]);                      grp.LastEpisodeNumber = int.Parse(flds[3]);                      grp.Rating = int.Parse(flds[4]);                      grp.Votes = int.Parse(flds[5]);                      grp.EpisodeRange = flds[6];                      groups.Add(grp);                  }                  catch (Exception ex)                  {                      NLog.LogManager.GetCurrentClassLogger().Error(ex' ex.ToString());                  }                    //BaseConfig.MyAnimeLog.Write("grp: {0}"' grp);              }
Magic Number,AniDBAPI,GroupStatusCollection,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\GroupStatusCollection.cs,GroupStatusCollection,The following statement contains a magic number: for (int i = 1; i < sDetails.Length - 1; i++)                  // first item will be the status command' and last will be empty              {                  //BaseConfig.MyAnimeLog.Write("s: {0}"' sDetails[i]);                    Raw_AniDB_GroupStatus grp = new Raw_AniDB_GroupStatus { AnimeID = animeID };                  try                  {                      // {int group id}|{str group name}|{int completion state}|{int last episode number}|{int rating}|{int votes}|{str episode range}\n                      string[] flds = sDetails[i].Substring(0).Split('|');                      grp.GroupID = int.Parse(flds[0]);                      grp.GroupName = flds[1];                      grp.CompletionState = int.Parse(flds[2]);                      grp.LastEpisodeNumber = int.Parse(flds[3]);                      grp.Rating = int.Parse(flds[4]);                      grp.Votes = int.Parse(flds[5]);                      grp.EpisodeRange = flds[6];                      groups.Add(grp);                  }                  catch (Exception ex)                  {                      NLog.LogManager.GetCurrentClassLogger().Error(ex' ex.ToString());                  }                    //BaseConfig.MyAnimeLog.Write("grp: {0}"' grp);              }
Magic Number,AniDBAPI,Raw_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Anime.cs,Raw_AniDB_Anime,The following statement contains a magic number: string[] sDetails = sRecMessage.Substring(10).Split('|');
Magic Number,AniDBAPI,Raw_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Anime.cs,Raw_AniDB_Anime,The following statement contains a magic number: AnimeTypeRAW = AniDBAPILib.ProcessAniDBString(sDetails[2]);
Magic Number,AniDBAPI,Raw_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Anime.cs,Raw_AniDB_Anime,The following statement contains a magic number: RelatedAnimeIdsRAW = AniDBAPILib.ProcessAniDBString(sDetails[3]);
Magic Number,AniDBAPI,Raw_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Anime.cs,Raw_AniDB_Anime,The following statement contains a magic number: RelatedAnimeTypesRAW = AniDBAPILib.ProcessAniDBString(sDetails[4]);
Magic Number,AniDBAPI,Raw_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Anime.cs,Raw_AniDB_Anime,The following statement contains a magic number: EpisodeCount = AniDBAPILib.ProcessAniDBInt(sDetails[13]);
Magic Number,AniDBAPI,Raw_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Anime.cs,Raw_AniDB_Anime,The following statement contains a magic number: EpisodeCountNormal = AniDBAPILib.ProcessAniDBInt(sDetails[14]);
Magic Number,AniDBAPI,Raw_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Anime.cs,Raw_AniDB_Anime,The following statement contains a magic number: EpisodeCountSpecial = AniDBAPILib.ProcessAniDBInt(sDetails[15]);
Magic Number,AniDBAPI,Raw_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Anime.cs,Raw_AniDB_Anime,The following statement contains a magic number: int airDateSeconds = int.Parse(AniDBAPILib.ProcessAniDBString(sDetails[16]));
Magic Number,AniDBAPI,Raw_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Anime.cs,Raw_AniDB_Anime,The following statement contains a magic number: int endDateSeconds = int.Parse(AniDBAPILib.ProcessAniDBString(sDetails[17]));
Magic Number,AniDBAPI,Raw_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Anime.cs,Raw_AniDB_Anime,The following statement contains a magic number: URL = AniDBAPILib.ProcessAniDBString(sDetails[18]);
Magic Number,AniDBAPI,Raw_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Anime.cs,Raw_AniDB_Anime,The following statement contains a magic number: Picname = AniDBAPILib.ProcessAniDBString(sDetails[19]);
Magic Number,AniDBAPI,Raw_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Anime.cs,Raw_AniDB_Anime,The following statement contains a magic number: Rating = AniDBAPILib.ProcessAniDBInt(sDetails[21]);
Magic Number,AniDBAPI,Raw_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Anime.cs,Raw_AniDB_Anime,The following statement contains a magic number: VoteCount = AniDBAPILib.ProcessAniDBInt(sDetails[22]);
Magic Number,AniDBAPI,Raw_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Anime.cs,Raw_AniDB_Anime,The following statement contains a magic number: TempRating = AniDBAPILib.ProcessAniDBInt(sDetails[23]);
Magic Number,AniDBAPI,Raw_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Anime.cs,Raw_AniDB_Anime,The following statement contains a magic number: TempVoteCount = AniDBAPILib.ProcessAniDBInt(sDetails[24]);
Magic Number,AniDBAPI,Raw_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Anime.cs,Raw_AniDB_Anime,The following statement contains a magic number: AvgReviewRating = AniDBAPILib.ProcessAniDBInt(sDetails[25]);
Magic Number,AniDBAPI,Raw_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Anime.cs,Raw_AniDB_Anime,The following statement contains a magic number: ReviewCount = AniDBAPILib.ProcessAniDBInt(sDetails[26]);
Magic Number,AniDBAPI,Raw_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Anime.cs,Raw_AniDB_Anime,The following statement contains a magic number: AwardList = AniDBAPILib.ProcessAniDBString(sDetails[27]);
Magic Number,AniDBAPI,Raw_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Anime.cs,Raw_AniDB_Anime,The following statement contains a magic number: Restricted = AniDBAPILib.ProcessAniDBInt(sDetails[28]);
Magic Number,AniDBAPI,Raw_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Anime.cs,Raw_AniDB_Anime,The following statement contains a magic number: AnimePlanetID = AniDBAPILib.ProcessAniDBInt(sDetails[29]);
Magic Number,AniDBAPI,Raw_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Anime.cs,Raw_AniDB_Anime,The following statement contains a magic number: ANNID = AniDBAPILib.ProcessAniDBInt(sDetails[30]);
Magic Number,AniDBAPI,Raw_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Anime.cs,Raw_AniDB_Anime,The following statement contains a magic number: AllCinemaID = AniDBAPILib.ProcessAniDBInt(sDetails[31]);
Magic Number,AniDBAPI,Raw_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Anime.cs,Raw_AniDB_Anime,The following statement contains a magic number: AnimeNfoID = AniDBAPILib.ProcessAniDBString(sDetails[32]);
Magic Number,AniDBAPI,Raw_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Anime.cs,Raw_AniDB_Anime,The following statement contains a magic number: DateRecordUpdated = AniDBAPILib.ProcessAniDBString(sDetails[33]);
Magic Number,AniDBAPI,Raw_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Anime.cs,Raw_AniDB_Anime,The following statement contains a magic number: CharacterIDListRAW = AniDBAPILib.ProcessAniDBString(sDetails[34]);
Magic Number,AniDBAPI,Raw_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Anime.cs,Raw_AniDB_Anime,The following statement contains a magic number: ReviewIDListRAW = AniDBAPILib.ProcessAniDBString(sDetails[35]);
Magic Number,AniDBAPI,Raw_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Anime.cs,Raw_AniDB_Anime,The following statement contains a magic number: GenreRAW = sDetails[5];
Magic Number,AniDBAPI,Raw_AniDB_AnimeDesc,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_AnimeDesc.cs,Raw_AniDB_AnimeDesc,The following statement contains a magic number: string[] sDetails = sRecMessage.Substring(14).Split('|');
Magic Number,AniDBAPI,Raw_AniDB_AnimeDesc,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_AnimeDesc.cs,Raw_AniDB_AnimeDesc,The following statement contains a magic number: this.Description = AniDBAPILib.ProcessAniDBString(sDetails[2]);
Magic Number,AniDBAPI,Raw_AniDB_Character,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Character.cs,Raw_AniDB_Character,The following statement contains a magic number: string[] sDetails = sRecMessage.Substring(14).Split('|');
Magic Number,AniDBAPI,Raw_AniDB_Character,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Character.cs,Raw_AniDB_Character,The following statement contains a magic number: CharName = AniDBAPILib.ProcessAniDBString(sDetails[2].Trim());
Magic Number,AniDBAPI,Raw_AniDB_Character,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Character.cs,Raw_AniDB_Character,The following statement contains a magic number: PicName = AniDBAPILib.ProcessAniDBString(sDetails[3].Trim());
Magic Number,AniDBAPI,Raw_AniDB_Character,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Character.cs,Raw_AniDB_Character,The following statement contains a magic number: CreatorListRaw = AniDBAPILib.ProcessAniDBString(sDetails[4].Trim().Replace("'"' "|"));
Magic Number,AniDBAPI,Raw_AniDB_Creator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Creator.cs,Raw_AniDB_Creator,The following statement contains a magic number: string[] sDetails = sRecMessage.Substring(12).Split('|');
Magic Number,AniDBAPI,Raw_AniDB_Creator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Creator.cs,Raw_AniDB_Creator,The following statement contains a magic number: CreatorName = AniDBAPILib.ProcessAniDBString(sDetails[2].Trim());
Magic Number,AniDBAPI,Raw_AniDB_Creator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Creator.cs,Raw_AniDB_Creator,The following statement contains a magic number: CreatorType = AniDBAPILib.ProcessAniDBInt(AniDBAPILib.ProcessAniDBString(sDetails[3].Trim()));
Magic Number,AniDBAPI,Raw_AniDB_Creator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Creator.cs,Raw_AniDB_Creator,The following statement contains a magic number: PicName = AniDBAPILib.ProcessAniDBString(sDetails[4].Trim());
Magic Number,AniDBAPI,Raw_AniDB_Creator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Creator.cs,Raw_AniDB_Creator,The following statement contains a magic number: URLEnglish = AniDBAPILib.ProcessAniDBString(sDetails[5].Trim());
Magic Number,AniDBAPI,Raw_AniDB_Creator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Creator.cs,Raw_AniDB_Creator,The following statement contains a magic number: URLJapanese = AniDBAPILib.ProcessAniDBString(sDetails[6].Trim());
Magic Number,AniDBAPI,Raw_AniDB_Creator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Creator.cs,Raw_AniDB_Creator,The following statement contains a magic number: URLWikiEnglish = AniDBAPILib.ProcessAniDBString(sDetails[7].Trim());
Magic Number,AniDBAPI,Raw_AniDB_Creator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Creator.cs,Raw_AniDB_Creator,The following statement contains a magic number: URLWikiJapanese = AniDBAPILib.ProcessAniDBString(sDetails[8].Trim());
Magic Number,AniDBAPI,Raw_AniDB_Episode,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Episode.cs,ProcessEpisodeSource,The following statement contains a magic number: string[] sDetails = sRecMessage.Substring(12).Split('|');
Magic Number,AniDBAPI,Raw_AniDB_Episode,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Episode.cs,ProcessEpisodeSource,The following statement contains a magic number: int.TryParse(sDetails[2].Trim()' out int lMinutes);
Magic Number,AniDBAPI,Raw_AniDB_Episode,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Episode.cs,ProcessEpisodeSource,The following statement contains a magic number: int secs = lMinutes * 60;
Magic Number,AniDBAPI,Raw_AniDB_Episode,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Episode.cs,ProcessEpisodeSource,The following statement contains a magic number: string epno = GetValidatedEpisodeNumber(sDetails[5].Trim());
Magic Number,AniDBAPI,Raw_AniDB_Episode,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Episode.cs,ProcessEpisodeSource,The following statement contains a magic number: Rating = AniDBAPILib.ProcessAniDBInt(sDetails[3].Trim());
Magic Number,AniDBAPI,Raw_AniDB_Episode,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Episode.cs,ProcessEpisodeSource,The following statement contains a magic number: Votes = AniDBAPILib.ProcessAniDBInt(sDetails[4].Trim());
Magic Number,AniDBAPI,Raw_AniDB_Episode,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Episode.cs,ProcessEpisodeSource,The following statement contains a magic number: EnglishName = AniDBAPILib.ProcessAniDBString(sDetails[6].Trim())?.Replace('`'' '\'');
Magic Number,AniDBAPI,Raw_AniDB_Episode,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Episode.cs,ProcessEpisodeSource,The following statement contains a magic number: RomajiName = AniDBAPILib.ProcessAniDBString(sDetails[7].Trim())?.Replace('`'' '\'');
Magic Number,AniDBAPI,Raw_AniDB_Episode,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Episode.cs,ProcessEpisodeSource,The following statement contains a magic number: KanjiName = AniDBAPILib.ProcessAniDBString(sDetails[8].Trim())?.Replace('`'' '\'');
Magic Number,AniDBAPI,Raw_AniDB_Episode,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Episode.cs,ProcessEpisodeSource,The following statement contains a magic number: AirDate = AniDBAPILib.ProcessAniDBInt(sDetails[9].Trim());
Magic Number,AniDBAPI,Raw_AniDB_Episode,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Episode.cs,ProcessEpisodeSource,The following statement contains a magic number: int secs = lMinutes * 60;
Magic Number,AniDBAPI,Raw_AniDB_Episode,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Episode.cs,ProcessFileSource,The following statement contains a magic number: string[] sDetails = sRecMessage.Substring(9).Split('|');
Magic Number,AniDBAPI,Raw_AniDB_Episode,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Episode.cs,ProcessFileSource,The following statement contains a magic number: if (!int.TryParse(sDetails[2].Trim()' out int epid)) return;
Magic Number,AniDBAPI,Raw_AniDB_Episode,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Episode.cs,ProcessFileSource,The following statement contains a magic number: int.TryParse(sDetails[15].Trim()' out int lMinutes);
Magic Number,AniDBAPI,Raw_AniDB_Episode,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Episode.cs,ProcessFileSource,The following statement contains a magic number: int secs = lMinutes * 60;
Magic Number,AniDBAPI,Raw_AniDB_Episode,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Episode.cs,ProcessFileSource,The following statement contains a magic number: string epno = GetValidatedEpisodeNumber(sDetails[18].Trim());
Magic Number,AniDBAPI,Raw_AniDB_Episode,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Episode.cs,ProcessFileSource,The following statement contains a magic number: Rating = AniDBAPILib.ProcessAniDBInt(sDetails[22].Trim());
Magic Number,AniDBAPI,Raw_AniDB_Episode,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Episode.cs,ProcessFileSource,The following statement contains a magic number: Votes = AniDBAPILib.ProcessAniDBInt(sDetails[23].Trim());
Magic Number,AniDBAPI,Raw_AniDB_Episode,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Episode.cs,ProcessFileSource,The following statement contains a magic number: EnglishName = AniDBAPILib.ProcessAniDBString(sDetails[19].Trim())?.Replace('`'' '\'');
Magic Number,AniDBAPI,Raw_AniDB_Episode,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Episode.cs,ProcessFileSource,The following statement contains a magic number: RomajiName = AniDBAPILib.ProcessAniDBString(sDetails[20].Trim())?.Replace('`'' '\'');
Magic Number,AniDBAPI,Raw_AniDB_Episode,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Episode.cs,ProcessFileSource,The following statement contains a magic number: KanjiName = AniDBAPILib.ProcessAniDBString(sDetails[21].Trim())?.Replace('`'' '\'');
Magic Number,AniDBAPI,Raw_AniDB_Episode,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Episode.cs,ProcessFileSource,The following statement contains a magic number: AirDate = AniDBAPILib.ProcessAniDBInt(sDetails[17].Trim());
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: string[] sDetails = sRecMessage.Substring(9).Split('|');
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: this.FileSize = long.Parse(sDetails[8].Trim());
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: this.ED2KHash = AniDBAPILib.ProcessAniDBString(sDetails[9].Trim()).ToUpper();
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: this.MD5 = AniDBAPILib.ProcessAniDBString(sDetails[10].Trim()).ToUpper();
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: this.SHA1 = AniDBAPILib.ProcessAniDBString(sDetails[11].Trim()).ToUpper();
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: this.CRC = AniDBAPILib.ProcessAniDBString(sDetails[12].Trim()).ToUpper();
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: int state = int.Parse(sDetails[7].Trim());
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: if (state == 0 || state == 1)                  FileVersion = 1;              else              {                  AniDBFileFlags eFlags = (AniDBFileFlags) state;                  if (BitMaskHelper.IsSet(eFlags' AniDBFileFlags.FILE_ISV2)) FileVersion = 2;                  if (BitMaskHelper.IsSet(eFlags' AniDBFileFlags.FILE_ISV3)) FileVersion = 3;                  if (BitMaskHelper.IsSet(eFlags' AniDBFileFlags.FILE_ISV4)) FileVersion = 4;                  if (BitMaskHelper.IsSet(eFlags' AniDBFileFlags.FILE_ISV5)) FileVersion = 5;                    if (BitMaskHelper.IsSet(eFlags' AniDBFileFlags.FILE_CEN))                      IsCensored = 1;    	            IsChaptered = BitMaskHelper.IsSet(eFlags' AniDBFileFlags.FILE_CHAPTERED) ? 1 : 0;              }
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: if (state == 0 || state == 1)                  FileVersion = 1;              else              {                  AniDBFileFlags eFlags = (AniDBFileFlags) state;                  if (BitMaskHelper.IsSet(eFlags' AniDBFileFlags.FILE_ISV2)) FileVersion = 2;                  if (BitMaskHelper.IsSet(eFlags' AniDBFileFlags.FILE_ISV3)) FileVersion = 3;                  if (BitMaskHelper.IsSet(eFlags' AniDBFileFlags.FILE_ISV4)) FileVersion = 4;                  if (BitMaskHelper.IsSet(eFlags' AniDBFileFlags.FILE_ISV5)) FileVersion = 5;                    if (BitMaskHelper.IsSet(eFlags' AniDBFileFlags.FILE_CEN))                      IsCensored = 1;    	            IsChaptered = BitMaskHelper.IsSet(eFlags' AniDBFileFlags.FILE_CHAPTERED) ? 1 : 0;              }
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: if (state == 0 || state == 1)                  FileVersion = 1;              else              {                  AniDBFileFlags eFlags = (AniDBFileFlags) state;                  if (BitMaskHelper.IsSet(eFlags' AniDBFileFlags.FILE_ISV2)) FileVersion = 2;                  if (BitMaskHelper.IsSet(eFlags' AniDBFileFlags.FILE_ISV3)) FileVersion = 3;                  if (BitMaskHelper.IsSet(eFlags' AniDBFileFlags.FILE_ISV4)) FileVersion = 4;                  if (BitMaskHelper.IsSet(eFlags' AniDBFileFlags.FILE_ISV5)) FileVersion = 5;                    if (BitMaskHelper.IsSet(eFlags' AniDBFileFlags.FILE_CEN))                      IsCensored = 1;    	            IsChaptered = BitMaskHelper.IsSet(eFlags' AniDBFileFlags.FILE_CHAPTERED) ? 1 : 0;              }
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: if (state == 0 || state == 1)                  FileVersion = 1;              else              {                  AniDBFileFlags eFlags = (AniDBFileFlags) state;                  if (BitMaskHelper.IsSet(eFlags' AniDBFileFlags.FILE_ISV2)) FileVersion = 2;                  if (BitMaskHelper.IsSet(eFlags' AniDBFileFlags.FILE_ISV3)) FileVersion = 3;                  if (BitMaskHelper.IsSet(eFlags' AniDBFileFlags.FILE_ISV4)) FileVersion = 4;                  if (BitMaskHelper.IsSet(eFlags' AniDBFileFlags.FILE_ISV5)) FileVersion = 5;                    if (BitMaskHelper.IsSet(eFlags' AniDBFileFlags.FILE_CEN))                      IsCensored = 1;    	            IsChaptered = BitMaskHelper.IsSet(eFlags' AniDBFileFlags.FILE_CHAPTERED) ? 1 : 0;              }
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: if (int.TryParse(sDetails[6].Trim()' out int isdep))                  IsDeprecated = isdep == 0 ? 0 : 1;
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: EpisodesRAW = sDetails[2].Trim();
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: if (sDetails[5].Trim().Length > 0)              {                  string[] Eps = sDetails[5].Trim().Split('\'');                  if (Eps.Length > 0)                  {                      foreach (string ep in Eps)                      {                          string[] ep2 = ep.Split(''');                          if (ep2.Length > 0)                          {                              EpisodesRAW += "'" + ep2[0];                              if (!string.IsNullOrEmpty(OtherEpisodesRAW))                                  OtherEpisodesRAW += "'";                              OtherEpisodesRAW += ep2[0];                          }                          if (ep2.Length > 1)                              EpisodesPercentRAW += "'" + ep2[1];                          else                              EpisodesPercentRAW += "'100";                      }                  }              }
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: if (sDetails[5].Trim().Length > 0)              {                  string[] Eps = sDetails[5].Trim().Split('\'');                  if (Eps.Length > 0)                  {                      foreach (string ep in Eps)                      {                          string[] ep2 = ep.Split(''');                          if (ep2.Length > 0)                          {                              EpisodesRAW += "'" + ep2[0];                              if (!string.IsNullOrEmpty(OtherEpisodesRAW))                                  OtherEpisodesRAW += "'";                              OtherEpisodesRAW += ep2[0];                          }                          if (ep2.Length > 1)                              EpisodesPercentRAW += "'" + ep2[1];                          else                              EpisodesPercentRAW += "'100";                      }                  }              }
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: GroupID = int.Parse(sDetails[3].Trim());
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: File_Source = AniDBAPILib.ProcessAniDBString(sDetails[14].Trim());
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: File_AudioCodec = AniDBAPILib.ProcessAniDBString(sDetails[15].Trim());
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: File_VideoCodec = AniDBAPILib.ProcessAniDBString(sDetails[17].Trim());
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: File_VideoResolution = AniDBAPILib.ProcessAniDBString(sDetails[19].Trim());
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: File_FileExtension = AniDBAPILib.ProcessAniDBString(sDetails[20].Trim());
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: File_LengthSeconds = AniDBAPILib.ProcessAniDBInt(sDetails[23].Trim());
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: File_Description = AniDBAPILib.ProcessAniDBString(sDetails[24].Trim());
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: File_ReleaseDate = AniDBAPILib.ProcessAniDBInt(sDetails[25].Trim());
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: LanguagesRAW = AniDBAPILib.ProcessAniDBString(sDetails[21].Trim());
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: SubtitlesRAW = AniDBAPILib.ProcessAniDBString(sDetails[22].Trim());
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: FileName = AniDBAPILib.ProcessAniDBString(sDetails[26].Trim());
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: string mlState = sDetails[27].Trim();
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: string mlFileState = sDetails[28].Trim();
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: string mlViewed = sDetails[29].Trim();
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: string mlViewDate = sDetails[30].Trim();
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: string mlStorage = sDetails[31].Trim();
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: string mlSource = sDetails[32].Trim();
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: string mlOther = sDetails[33].Trim();
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: Anime_GroupName = AniDBAPILib.ProcessAniDBString(sDetails[40].Trim());
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: Anime_GroupNameShort = AniDBAPILib.ProcessAniDBString(sDetails[41].Trim());
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: Episode_Rating = AniDBAPILib.ProcessAniDBInt(sDetails[38].Trim());
Magic Number,AniDBAPI,Raw_AniDB_File,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_File.cs,Raw_AniDB_File,The following statement contains a magic number: Episode_Votes = AniDBAPILib.ProcessAniDBInt(sDetails[39].Trim());
Magic Number,AniDBAPI,Raw_AniDB_Group,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Group.cs,Raw_AniDB_Group,The following statement contains a magic number: string[] sDetails = sRecMessage.Substring(10).Split('|');
Magic Number,AniDBAPI,Raw_AniDB_Group,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Group.cs,Raw_AniDB_Group,The following statement contains a magic number: Votes = int.Parse(sDetails[2]);
Magic Number,AniDBAPI,Raw_AniDB_Group,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Group.cs,Raw_AniDB_Group,The following statement contains a magic number: AnimeCount = int.Parse(sDetails[3]);
Magic Number,AniDBAPI,Raw_AniDB_Group,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Group.cs,Raw_AniDB_Group,The following statement contains a magic number: FileCount = int.Parse(sDetails[4]);
Magic Number,AniDBAPI,Raw_AniDB_Group,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Group.cs,Raw_AniDB_Group,The following statement contains a magic number: GroupName = AniDBAPILib.ProcessAniDBString(sDetails[5]);
Magic Number,AniDBAPI,Raw_AniDB_Group,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Group.cs,Raw_AniDB_Group,The following statement contains a magic number: GroupNameShort = AniDBAPILib.ProcessAniDBString(sDetails[6]);
Magic Number,AniDBAPI,Raw_AniDB_Group,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Group.cs,Raw_AniDB_Group,The following statement contains a magic number: IRCChannel = AniDBAPILib.ProcessAniDBString(sDetails[7]);
Magic Number,AniDBAPI,Raw_AniDB_Group,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Group.cs,Raw_AniDB_Group,The following statement contains a magic number: IRCServer = AniDBAPILib.ProcessAniDBString(sDetails[8]);
Magic Number,AniDBAPI,Raw_AniDB_Group,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Group.cs,Raw_AniDB_Group,The following statement contains a magic number: URL = AniDBAPILib.ProcessAniDBString(sDetails[9]);
Magic Number,AniDBAPI,Raw_AniDB_Group,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Group.cs,Raw_AniDB_Group,The following statement contains a magic number: Picname = AniDBAPILib.ProcessAniDBString(sDetails[10]);
Magic Number,AniDBAPI,Raw_AniDB_MyListFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_MyListFile.cs,Raw_AniDB_MyListFile,The following statement contains a magic number: string[] sDetails = sRecMessage.Substring(11).Split('|');
Magic Number,AniDBAPI,Raw_AniDB_MyListFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_MyListFile.cs,Raw_AniDB_MyListFile,The following statement contains a magic number: this.EpisodeID = AniDBAPILib.ProcessAniDBInt(sDetails[2]);
Magic Number,AniDBAPI,Raw_AniDB_MyListFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_MyListFile.cs,Raw_AniDB_MyListFile,The following statement contains a magic number: this.AnimeID = AniDBAPILib.ProcessAniDBInt(sDetails[3]);
Magic Number,AniDBAPI,Raw_AniDB_MyListFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_MyListFile.cs,Raw_AniDB_MyListFile,The following statement contains a magic number: this.GroupID = AniDBAPILib.ProcessAniDBInt(sDetails[4]);
Magic Number,AniDBAPI,Raw_AniDB_MyListFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_MyListFile.cs,Raw_AniDB_MyListFile,The following statement contains a magic number: this.FileDate = AniDBAPILib.ProcessAniDBString(sDetails[5]);
Magic Number,AniDBAPI,Raw_AniDB_MyListFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_MyListFile.cs,Raw_AniDB_MyListFile,The following statement contains a magic number: this.State = AniDBAPILib.ProcessAniDBInt(sDetails[6]);
Magic Number,AniDBAPI,Raw_AniDB_MyListFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_MyListFile.cs,Raw_AniDB_MyListFile,The following statement contains a magic number: this.ViewDateUDP = AniDBAPILib.ProcessAniDBInt(sDetails[7]);
Magic Number,AniDBAPI,Raw_AniDB_MyListFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_MyListFile.cs,Raw_AniDB_MyListFile,The following statement contains a magic number: this.Storage = AniDBAPILib.ProcessAniDBString(sDetails[8]);
Magic Number,AniDBAPI,Raw_AniDB_MyListFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_MyListFile.cs,Raw_AniDB_MyListFile,The following statement contains a magic number: this.Source = AniDBAPILib.ProcessAniDBString(sDetails[9]);
Magic Number,AniDBAPI,Raw_AniDB_MyListFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_MyListFile.cs,Raw_AniDB_MyListFile,The following statement contains a magic number: this.Other = AniDBAPILib.ProcessAniDBString(sDetails[10]);
Magic Number,AniDBAPI,Raw_AniDB_MyListFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_MyListFile.cs,Raw_AniDB_MyListFile,The following statement contains a magic number: this.FileState = AniDBAPILib.ProcessAniDBInt(sDetails[11]);
Magic Number,AniDBAPI,Raw_AniDB_MyListFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_MyListFile.cs,Raw_AniDB_MyListFile,The following statement contains a magic number: if (ViewDateUDP > 0)              {                  DateTime utcDate = new DateTime(1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);                  utcDate = utcDate.AddSeconds(ViewDateUDP);                    WatchedDate = utcDate.ToLocalTime();              }
Magic Number,AniDBAPI,Raw_AniDB_MyListFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_MyListFile.cs,ProcessHTTPSource,The following statement contains a magic number: if (!string.IsNullOrEmpty(ViewDateHTTP) && ViewDateHTTP.Length > 17)              {                  try                  {                      // eg "2011-02-23T20:49:18+0000"                      /*int year = int.Parse(ViewDateHTTP.Trim().Substring(0' 4));                      int month = int.Parse(ViewDateHTTP.Trim().Substring(5' 2));                      int day = int.Parse(ViewDateHTTP.Trim().Substring(8' 2));                        int hour = int.Parse(ViewDateHTTP.Trim().Substring(11' 2));                      int minute = int.Parse(ViewDateHTTP.Trim().Substring(14' 2));                      int second = int.Parse(ViewDateHTTP.Trim().Substring(17' 2));                        DateTime utcDate = new DateTime(year' month' day' hour' minute' second' DateTimeKind.Utc);                      */                      if (!DateTime.TryParse(ViewDateHTTP' out DateTime utcDate))                      {                          logger.Error("Error processing View Date HTTP: " + ViewDateHTTP);                      }                      utcDate = utcDate.AddSeconds(ViewDateUDP);                        WatchedDate = utcDate.ToLocalTime();                  }                  catch (Exception ex)                  {                      logger.Error(ex' "Error processing View Date HTTP: " + ex.ToString());                  }              }
Magic Number,AniDBAPI,Raw_AniDB_NotifyAlert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_NotifyAlert.cs,Raw_AniDB_NotifyAlert,The following statement contains a magic number: string[] sDetails = sRecMessage.Substring(14).Split('|');
Magic Number,AniDBAPI,Raw_AniDB_NotifyAlert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_NotifyAlert.cs,Raw_AniDB_NotifyAlert,The following statement contains a magic number: alertCount = int.Parse(sDetails[2]);
Magic Number,AniDBAPI,Raw_AniDB_NotifyAlert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_NotifyAlert.cs,Raw_AniDB_NotifyAlert,The following statement contains a magic number: alertDate = AniDBAPILib.ProcessAniDBInt(sDetails[3]);
Magic Number,AniDBAPI,Raw_AniDB_NotifyAlert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_NotifyAlert.cs,Raw_AniDB_NotifyAlert,The following statement contains a magic number: relName = AniDBAPILib.ProcessAniDBString(sDetails[4]);
Magic Number,AniDBAPI,Raw_AniDB_NotifyAlert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_NotifyAlert.cs,Raw_AniDB_NotifyAlert,The following statement contains a magic number: string[] fids = sDetails[5].Split(''');
Magic Number,AniDBAPI,Raw_AniDB_NotifyList,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_NotifyList.cs,Raw_AniDB_NotifyList,The following statement contains a magic number: if (sDetails.Length <= 2) return;
Magic Number,AniDBAPI,Raw_AniDB_NotifyMessage,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_NotifyMessage.cs,Raw_AniDB_NotifyMessage,The following statement contains a magic number: string[] sDetails = sRecMessage.Substring(14).Split('|');
Magic Number,AniDBAPI,Raw_AniDB_NotifyMessage,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_NotifyMessage.cs,Raw_AniDB_NotifyMessage,The following statement contains a magic number: fromUserName = AniDBAPILib.ProcessAniDBString(sDetails[2]);
Magic Number,AniDBAPI,Raw_AniDB_NotifyMessage,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_NotifyMessage.cs,Raw_AniDB_NotifyMessage,The following statement contains a magic number: messageDate = AniDBAPILib.ProcessAniDBInt(sDetails[3]);
Magic Number,AniDBAPI,Raw_AniDB_NotifyMessage,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_NotifyMessage.cs,Raw_AniDB_NotifyMessage,The following statement contains a magic number: messageType = long.Parse(sDetails[4]);
Magic Number,AniDBAPI,Raw_AniDB_NotifyMessage,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_NotifyMessage.cs,Raw_AniDB_NotifyMessage,The following statement contains a magic number: title = AniDBAPILib.ProcessAniDBString(sDetails[5]);
Magic Number,AniDBAPI,Raw_AniDB_NotifyMessage,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_NotifyMessage.cs,Raw_AniDB_NotifyMessage,The following statement contains a magic number: body = AniDBAPILib.ProcessAniDBString(sDetails[6]);
Magic Number,AniDBAPI,Raw_AniDB_Review,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Review.cs,Raw_AniDB_Review,The following statement contains a magic number: string[] sDetails = sRecMessage.Substring(11).Split('|');
Magic Number,AniDBAPI,Raw_AniDB_Review,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Review.cs,Raw_AniDB_Review,The following statement contains a magic number: ReviewID = int.Parse(sDetails[3].Trim());
Magic Number,AniDBAPI,Raw_AniDB_Review,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Review.cs,Raw_AniDB_Review,The following statement contains a magic number: AuthorID = int.Parse(sDetails[4].Trim());
Magic Number,AniDBAPI,Raw_AniDB_Review,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Review.cs,Raw_AniDB_Review,The following statement contains a magic number: RatingAnimation = int.Parse(sDetails[5].Trim());
Magic Number,AniDBAPI,Raw_AniDB_Review,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Review.cs,Raw_AniDB_Review,The following statement contains a magic number: RatingSound = int.Parse(sDetails[6].Trim());
Magic Number,AniDBAPI,Raw_AniDB_Review,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Review.cs,Raw_AniDB_Review,The following statement contains a magic number: RatingStory = int.Parse(sDetails[7].Trim());
Magic Number,AniDBAPI,Raw_AniDB_Review,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Review.cs,Raw_AniDB_Review,The following statement contains a magic number: RatingCharacter = int.Parse(sDetails[8].Trim());
Magic Number,AniDBAPI,Raw_AniDB_Review,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Review.cs,Raw_AniDB_Review,The following statement contains a magic number: RatingValue = int.Parse(sDetails[9].Trim());
Magic Number,AniDBAPI,Raw_AniDB_Review,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Review.cs,Raw_AniDB_Review,The following statement contains a magic number: RatingEnjoyment = int.Parse(sDetails[10].Trim());
Magic Number,AniDBAPI,Raw_AniDB_Review,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Review.cs,Raw_AniDB_Review,The following statement contains a magic number: ReviewText = AniDBAPILib.ProcessAniDBString(sDetails[11].Trim());
Magic Number,AniDBAPI,Raw_AniDB_Vote,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Vote.cs,ProcessVoteFoundAnime,The following statement contains a magic number: string[] sDetails = sRecMessage.Substring(15).Split('|');
Magic Number,AniDBAPI,Raw_AniDB_Vote,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Vote.cs,ProcessVoteFoundEpisode,The following statement contains a magic number: string[] sDetails = sRecMessage.Substring(15).Split('|');
Magic Number,AniDBAPI,APIUtils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Utils.cs,DownloadWebPage,The following statement contains a magic number: try              {                  AniDbRateLimiter.Instance.EnsureRate();                    HttpWebRequest webReq = (HttpWebRequest) WebRequest.Create(url);                  webReq.Timeout = 20000; // 20 seconds                  webReq.Headers.Add(HttpRequestHeader.AcceptEncoding' "gzip'deflate");                  webReq.UserAgent = "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:40.0) Gecko/20100101 Firefox/40.1";                    webReq.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;                  HttpWebResponse WebResponse = (HttpWebResponse) webReq.GetResponse();                    Stream responseStream = WebResponse.GetResponseStream();                  String enco = WebResponse.CharacterSet;                  Encoding encoding = null;                  if (!String.IsNullOrEmpty(enco))                      encoding = Encoding.GetEncoding(WebResponse.CharacterSet);                  if (encoding == null)                      encoding = Encoding.Default;                  StreamReader Reader = new StreamReader(responseStream' encoding);                    string output = Reader.ReadToEnd();                    WebResponse.Close();                  responseStream.Close();                    return output;              }              catch (Exception ex)              {                  logger.Error(ex' "Error in APIUtils.DownloadWebPage: {0}");                  return string.Empty;              }
Magic Number,AniDBAPI,APIUtils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Utils.cs,DownloadWebBinary,The following statement contains a magic number: try              {                  AniDbRateLimiter.Instance.EnsureRate();                    HttpWebResponse response = null;                  HttpWebRequest webReq = (HttpWebRequest) WebRequest.Create(url);                  // Note: some network proxies require the useragent string to be set or they will deny the http request                  // this is true for instance for EVERY thailand internet connection (also needs to be set for banners/episodethumbs and any other http request we send)                  webReq.UserAgent = "Anime2MP";                  webReq.Timeout = 20000; // 20 seconds                  response = (HttpWebResponse) webReq.GetResponse();                    return response != null                       ? response.GetResponseStream()                       : null;              }              catch (Exception ex)              {                  logger.Error(ex' "Error in APIUtils.DownloadWebBinary: {0}");                  return null;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_AddFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_AddFile.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_AddFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_AddFile.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_AddFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_AddFile.cs,Process,The following statement contains a magic number: string sMsgType = socketResponse.Substring(0' 3);
Magic Number,AniDBAPI.Commands,AniDBCommand_AddFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_AddFile.cs,Process,The following statement contains a magic number: switch (sMsgType)              {                  case "210": return enHelperActivityType.FileAdded;                  case "310":                  {                      //file already exists: read 'watched' status                      string[] arrResult = socketResponse.Split('\n');                      if (arrResult.Length >= 2)                      {                          string[] arrStatus = arrResult[1].Split('|');                          int state = int.Parse(arrStatus[6]);                          State = (AniDBFile_State) state;                            int viewdate = int.Parse(arrStatus[7]);                          ReturnIsWatched = viewdate > 0;                            if (ReturnIsWatched)                          {                              DateTime utcDate = new DateTime(1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);                              utcDate = utcDate.AddSeconds(viewdate);                                WatchedDate = utcDate.ToLocalTime();                          }                          else                          {                              WatchedDate = null;                          }                      }                  }                      return enHelperActivityType.FileAlreadyExists;                  case "311": return enHelperActivityType.UpdatingFile;                  case "320": return enHelperActivityType.NoSuchFile;                  case "411": return enHelperActivityType.NoSuchFile;                  case "502": return enHelperActivityType.LoginFailed;                  case "501": return enHelperActivityType.LoginRequired;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_AddFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_AddFile.cs,Process,The following statement contains a magic number: switch (sMsgType)              {                  case "210": return enHelperActivityType.FileAdded;                  case "310":                  {                      //file already exists: read 'watched' status                      string[] arrResult = socketResponse.Split('\n');                      if (arrResult.Length >= 2)                      {                          string[] arrStatus = arrResult[1].Split('|');                          int state = int.Parse(arrStatus[6]);                          State = (AniDBFile_State) state;                            int viewdate = int.Parse(arrStatus[7]);                          ReturnIsWatched = viewdate > 0;                            if (ReturnIsWatched)                          {                              DateTime utcDate = new DateTime(1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);                              utcDate = utcDate.AddSeconds(viewdate);                                WatchedDate = utcDate.ToLocalTime();                          }                          else                          {                              WatchedDate = null;                          }                      }                  }                      return enHelperActivityType.FileAlreadyExists;                  case "311": return enHelperActivityType.UpdatingFile;                  case "320": return enHelperActivityType.NoSuchFile;                  case "411": return enHelperActivityType.NoSuchFile;                  case "502": return enHelperActivityType.LoginFailed;                  case "501": return enHelperActivityType.LoginRequired;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_AddFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_AddFile.cs,Process,The following statement contains a magic number: switch (sMsgType)              {                  case "210": return enHelperActivityType.FileAdded;                  case "310":                  {                      //file already exists: read 'watched' status                      string[] arrResult = socketResponse.Split('\n');                      if (arrResult.Length >= 2)                      {                          string[] arrStatus = arrResult[1].Split('|');                          int state = int.Parse(arrStatus[6]);                          State = (AniDBFile_State) state;                            int viewdate = int.Parse(arrStatus[7]);                          ReturnIsWatched = viewdate > 0;                            if (ReturnIsWatched)                          {                              DateTime utcDate = new DateTime(1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);                              utcDate = utcDate.AddSeconds(viewdate);                                WatchedDate = utcDate.ToLocalTime();                          }                          else                          {                              WatchedDate = null;                          }                      }                  }                      return enHelperActivityType.FileAlreadyExists;                  case "311": return enHelperActivityType.UpdatingFile;                  case "320": return enHelperActivityType.NoSuchFile;                  case "411": return enHelperActivityType.NoSuchFile;                  case "502": return enHelperActivityType.LoginFailed;                  case "501": return enHelperActivityType.LoginRequired;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_AddFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_AddFile.cs,Process,The following statement contains a magic number: switch (sMsgType)              {                  case "210": return enHelperActivityType.FileAdded;                  case "310":                  {                      //file already exists: read 'watched' status                      string[] arrResult = socketResponse.Split('\n');                      if (arrResult.Length >= 2)                      {                          string[] arrStatus = arrResult[1].Split('|');                          int state = int.Parse(arrStatus[6]);                          State = (AniDBFile_State) state;                            int viewdate = int.Parse(arrStatus[7]);                          ReturnIsWatched = viewdate > 0;                            if (ReturnIsWatched)                          {                              DateTime utcDate = new DateTime(1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);                              utcDate = utcDate.AddSeconds(viewdate);                                WatchedDate = utcDate.ToLocalTime();                          }                          else                          {                              WatchedDate = null;                          }                      }                  }                      return enHelperActivityType.FileAlreadyExists;                  case "311": return enHelperActivityType.UpdatingFile;                  case "320": return enHelperActivityType.NoSuchFile;                  case "411": return enHelperActivityType.NoSuchFile;                  case "502": return enHelperActivityType.LoginFailed;                  case "501": return enHelperActivityType.LoginRequired;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_DeleteFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_DeleteFile.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_DeleteFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_DeleteFile.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_DeleteFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_DeleteFile.cs,Process,The following statement contains a magic number: string sMsgType = socketResponse.Substring(0' 3);
Magic Number,AniDBAPI.Commands,AniDBCommand_GetAnimeDescription,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetAnimeDescription.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_GetAnimeDescription,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetAnimeDescription.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_GetAnimeDescription,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetAnimeDescription.cs,Process,The following statement contains a magic number: string sMsgType = socketResponse.Substring(0' 3);
Magic Number,AniDBAPI.Commands,AniDBCommand_GetAnimeInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetAnimeInfo.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_GetAnimeInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetAnimeInfo.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_GetAnimeInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetAnimeInfo.cs,Process,The following statement contains a magic number: string sMsgType = socketResponse.Substring(0' 3);
Magic Number,AniDBAPI.Commands,AniDBCommand_GetAnimeInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetAnimeInfo.cs,Init,The following statement contains a magic number: int aByte1 = 191;
Magic Number,AniDBAPI.Commands,AniDBCommand_GetAnimeInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetAnimeInfo.cs,Init,The following statement contains a magic number: int aByte2 = 252;
Magic Number,AniDBAPI.Commands,AniDBCommand_GetAnimeInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetAnimeInfo.cs,Init,The following statement contains a magic number: int aByte3 = 255;
Magic Number,AniDBAPI.Commands,AniDBCommand_GetAnimeInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetAnimeInfo.cs,Init,The following statement contains a magic number: int aByte4 = 255;
Magic Number,AniDBAPI.Commands,AniDBCommand_GetAnimeInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetAnimeInfo.cs,Init,The following statement contains a magic number: int aByte5 = 241;
Magic Number,AniDBAPI.Commands,AniDBCommand_GetAnimeInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetAnimeInfo.cs,Init,The following statement contains a magic number: int aByte6 = 136;
Magic Number,AniDBAPI.Commands,AniDBCommand_GetAnimeInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetAnimeInfo.cs,Init,The following statement contains a magic number: commandText += string.Format("&amask={0}{1}{2}{3}{4}{5}"' aByte1.ToString("X").PadLeft(2' '0')'                  aByte2.ToString("X").PadLeft(2' '0')'                  aByte3.ToString("X").PadLeft(2' '0')' aByte4.ToString("X").PadLeft(2' '0')'                  aByte5.ToString("X").PadLeft(2' '0')'                  aByte6.ToString("X").PadLeft(2' '0'));
Magic Number,AniDBAPI.Commands,AniDBCommand_GetAnimeInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetAnimeInfo.cs,Init,The following statement contains a magic number: commandText += string.Format("&amask={0}{1}{2}{3}{4}{5}"' aByte1.ToString("X").PadLeft(2' '0')'                  aByte2.ToString("X").PadLeft(2' '0')'                  aByte3.ToString("X").PadLeft(2' '0')' aByte4.ToString("X").PadLeft(2' '0')'                  aByte5.ToString("X").PadLeft(2' '0')'                  aByte6.ToString("X").PadLeft(2' '0'));
Magic Number,AniDBAPI.Commands,AniDBCommand_GetAnimeInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetAnimeInfo.cs,Init,The following statement contains a magic number: commandText += string.Format("&amask={0}{1}{2}{3}{4}{5}"' aByte1.ToString("X").PadLeft(2' '0')'                  aByte2.ToString("X").PadLeft(2' '0')'                  aByte3.ToString("X").PadLeft(2' '0')' aByte4.ToString("X").PadLeft(2' '0')'                  aByte5.ToString("X").PadLeft(2' '0')'                  aByte6.ToString("X").PadLeft(2' '0'));
Magic Number,AniDBAPI.Commands,AniDBCommand_GetAnimeInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetAnimeInfo.cs,Init,The following statement contains a magic number: commandText += string.Format("&amask={0}{1}{2}{3}{4}{5}"' aByte1.ToString("X").PadLeft(2' '0')'                  aByte2.ToString("X").PadLeft(2' '0')'                  aByte3.ToString("X").PadLeft(2' '0')' aByte4.ToString("X").PadLeft(2' '0')'                  aByte5.ToString("X").PadLeft(2' '0')'                  aByte6.ToString("X").PadLeft(2' '0'));
Magic Number,AniDBAPI.Commands,AniDBCommand_GetAnimeInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetAnimeInfo.cs,Init,The following statement contains a magic number: commandText += string.Format("&amask={0}{1}{2}{3}{4}{5}"' aByte1.ToString("X").PadLeft(2' '0')'                  aByte2.ToString("X").PadLeft(2' '0')'                  aByte3.ToString("X").PadLeft(2' '0')' aByte4.ToString("X").PadLeft(2' '0')'                  aByte5.ToString("X").PadLeft(2' '0')'                  aByte6.ToString("X").PadLeft(2' '0'));
Magic Number,AniDBAPI.Commands,AniDBCommand_GetAnimeInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetAnimeInfo.cs,Init,The following statement contains a magic number: commandText += string.Format("&amask={0}{1}{2}{3}{4}{5}"' aByte1.ToString("X").PadLeft(2' '0')'                  aByte2.ToString("X").PadLeft(2' '0')'                  aByte3.ToString("X").PadLeft(2' '0')' aByte4.ToString("X").PadLeft(2' '0')'                  aByte5.ToString("X").PadLeft(2' '0')'                  aByte6.ToString("X").PadLeft(2' '0'));
Magic Number,AniDBAPI.Commands,AniDBCommand_GetCalendar,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetCalendar.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_GetCalendar,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetCalendar.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_GetCalendar,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetCalendar.cs,Process,The following statement contains a magic number: string sMsgType = socketResponse.Substring(0' 3);
Magic Number,AniDBAPI.Commands,AniDBCommand_GetCharacterInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetCharacterInfo.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_GetCharacterInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetCharacterInfo.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_GetCharacterInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetCharacterInfo.cs,Process,The following statement contains a magic number: string sMsgType = socketResponse.Substring(0' 3);
Magic Number,AniDBAPI.Commands,AniDBCommand_GetCreatorInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetCreatorInfo.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_GetCreatorInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetCreatorInfo.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_GetCreatorInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetCreatorInfo.cs,Process,The following statement contains a magic number: string sMsgType = socketResponse.Substring(0' 3);
Magic Number,AniDBAPI.Commands,AniDBCommand_GetEpisodeInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetEpisodeInfo.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_GetEpisodeInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetEpisodeInfo.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_GetEpisodeInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetEpisodeInfo.cs,Process,The following statement contains a magic number: string sMsgType = socketResponse.Substring(0' 3);
Magic Number,AniDBAPI.Commands,AniDBCommand_GetFileInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetFileInfo.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_GetFileInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetFileInfo.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_GetFileInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetFileInfo.cs,Process,The following statement contains a magic number: string sMsgType = socketResponse.Substring(0' 3);
Magic Number,AniDBAPI.Commands,AniDBCommand_GetFileInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetFileInfo.cs,Init,The following statement contains a magic number: int fByte1 = 127;
Magic Number,AniDBAPI.Commands,AniDBCommand_GetFileInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetFileInfo.cs,Init,The following statement contains a magic number: int fByte2 = 248;
Magic Number,AniDBAPI.Commands,AniDBCommand_GetFileInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetFileInfo.cs,Init,The following statement contains a magic number: int fByte3 = 255;
Magic Number,AniDBAPI.Commands,AniDBCommand_GetFileInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetFileInfo.cs,Init,The following statement contains a magic number: int fByte4 = 249;
Magic Number,AniDBAPI.Commands,AniDBCommand_GetFileInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetFileInfo.cs,Init,The following statement contains a magic number: int fByte5 = 254;
Magic Number,AniDBAPI.Commands,AniDBCommand_GetFileInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetFileInfo.cs,Init,The following statement contains a magic number: int aByte3 = 252;
Magic Number,AniDBAPI.Commands,AniDBCommand_GetFileInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetFileInfo.cs,Init,The following statement contains a magic number: int aByte4 = 192;
Magic Number,AniDBAPI.Commands,AniDBCommand_GetFileInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetFileInfo.cs,Init,The following statement contains a magic number: commandText += string.Format("&fmask={0}{1}{2}{3}{4}"' fByte1.ToString("X").PadLeft(2' '0')'                  fByte2.ToString("X").PadLeft(2' '0')' fByte3.ToString("X").PadLeft(2' '0')'                  fByte4.ToString("X").PadLeft(2' '0')'                  fByte5.ToString("X").PadLeft(2' '0'));
Magic Number,AniDBAPI.Commands,AniDBCommand_GetFileInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetFileInfo.cs,Init,The following statement contains a magic number: commandText += string.Format("&fmask={0}{1}{2}{3}{4}"' fByte1.ToString("X").PadLeft(2' '0')'                  fByte2.ToString("X").PadLeft(2' '0')' fByte3.ToString("X").PadLeft(2' '0')'                  fByte4.ToString("X").PadLeft(2' '0')'                  fByte5.ToString("X").PadLeft(2' '0'));
Magic Number,AniDBAPI.Commands,AniDBCommand_GetFileInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetFileInfo.cs,Init,The following statement contains a magic number: commandText += string.Format("&fmask={0}{1}{2}{3}{4}"' fByte1.ToString("X").PadLeft(2' '0')'                  fByte2.ToString("X").PadLeft(2' '0')' fByte3.ToString("X").PadLeft(2' '0')'                  fByte4.ToString("X").PadLeft(2' '0')'                  fByte5.ToString("X").PadLeft(2' '0'));
Magic Number,AniDBAPI.Commands,AniDBCommand_GetFileInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetFileInfo.cs,Init,The following statement contains a magic number: commandText += string.Format("&fmask={0}{1}{2}{3}{4}"' fByte1.ToString("X").PadLeft(2' '0')'                  fByte2.ToString("X").PadLeft(2' '0')' fByte3.ToString("X").PadLeft(2' '0')'                  fByte4.ToString("X").PadLeft(2' '0')'                  fByte5.ToString("X").PadLeft(2' '0'));
Magic Number,AniDBAPI.Commands,AniDBCommand_GetFileInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetFileInfo.cs,Init,The following statement contains a magic number: commandText += string.Format("&fmask={0}{1}{2}{3}{4}"' fByte1.ToString("X").PadLeft(2' '0')'                  fByte2.ToString("X").PadLeft(2' '0')' fByte3.ToString("X").PadLeft(2' '0')'                  fByte4.ToString("X").PadLeft(2' '0')'                  fByte5.ToString("X").PadLeft(2' '0'));
Magic Number,AniDBAPI.Commands,AniDBCommand_GetFileInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetFileInfo.cs,Init,The following statement contains a magic number: commandText += string.Format("&amask={0}{1}{2}{3}"' aByte1.ToString("X").PadLeft(2' '0')'                  aByte2.ToString("X").PadLeft(2' '0')' aByte3.ToString("X").PadLeft(2' '0')'                  aByte4.ToString("X").PadLeft(2' '0'));
Magic Number,AniDBAPI.Commands,AniDBCommand_GetFileInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetFileInfo.cs,Init,The following statement contains a magic number: commandText += string.Format("&amask={0}{1}{2}{3}"' aByte1.ToString("X").PadLeft(2' '0')'                  aByte2.ToString("X").PadLeft(2' '0')' aByte3.ToString("X").PadLeft(2' '0')'                  aByte4.ToString("X").PadLeft(2' '0'));
Magic Number,AniDBAPI.Commands,AniDBCommand_GetFileInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetFileInfo.cs,Init,The following statement contains a magic number: commandText += string.Format("&amask={0}{1}{2}{3}"' aByte1.ToString("X").PadLeft(2' '0')'                  aByte2.ToString("X").PadLeft(2' '0')' aByte3.ToString("X").PadLeft(2' '0')'                  aByte4.ToString("X").PadLeft(2' '0'));
Magic Number,AniDBAPI.Commands,AniDBCommand_GetFileInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetFileInfo.cs,Init,The following statement contains a magic number: commandText += string.Format("&amask={0}{1}{2}{3}"' aByte1.ToString("X").PadLeft(2' '0')'                  aByte2.ToString("X").PadLeft(2' '0')' aByte3.ToString("X").PadLeft(2' '0')'                  aByte4.ToString("X").PadLeft(2' '0'));
Magic Number,AniDBAPI.Commands,AniDBCommand_GetGroupStatus,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetGroupStatus.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_GetGroupStatus,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetGroupStatus.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_GetGroupStatus,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetGroupStatus.cs,Process,The following statement contains a magic number: string sMsgType = socketResponse.Substring(0' 3);
Magic Number,AniDBAPI.Commands,AniDBCommand_GetMyListFileInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetMyListFileInfo.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_GetMyListFileInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetMyListFileInfo.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_GetMyListFileInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetMyListFileInfo.cs,Process,The following statement contains a magic number: string sMsgType = socketResponse.Substring(0' 3);
Magic Number,AniDBAPI.Commands,AniDBCommand_GetMyListStats,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetMyListStats.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_GetMyListStats,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetMyListStats.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_GetMyListStats,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetMyListStats.cs,Process,The following statement contains a magic number: string sMsgType = socketResponse.Substring(0' 3);
Magic Number,AniDBAPI.Commands,AniDBCommand_GetReview,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetReview.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_GetReview,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetReview.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_GetReview,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetReview.cs,Process,The following statement contains a magic number: string sMsgType = socketResponse.Substring(0' 3);
Magic Number,AniDBAPI.Commands,AniDBCommand_GetUpdated,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetUpdated.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_GetUpdated,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetUpdated.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_GetUpdated,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetUpdated.cs,Process,The following statement contains a magic number: string sMsgType = socketResponse.Substring(0' 3);
Magic Number,AniDBAPI.Commands,AniDBCommand_GetUpdated,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetUpdated.cs,Process,The following statement contains a magic number: switch (sMsgType)              {                  case "243":                  {                      // remove the header info                      string[] sDetails = socketResponse.Substring(0).Split('\n');                        if (sDetails.Length > 1)                      {                          // first item will be the status command so ignore                          // only concerned with the second line                            string[] flds = sDetails[1].Substring(0).Split('|');                          AniDBEntity = int.Parse(flds[0]);                          RecordCount = int.Parse(flds[1]);                          StartTime = flds[2];                          AnimeIDListRaw = flds[3].Trim();                          string[] aids = AnimeIDListRaw.Split(''');                          foreach (string sid in aids)                          {                              AnimeIDList.Add(int.Parse(sid));                          }                      }                        return enHelperActivityType.GotUpdated;                  }                  case "343": return enHelperActivityType.NoUpdates;                  case "501": return enHelperActivityType.LoginRequired;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_GetUpdated,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetUpdated.cs,Process,The following statement contains a magic number: switch (sMsgType)              {                  case "243":                  {                      // remove the header info                      string[] sDetails = socketResponse.Substring(0).Split('\n');                        if (sDetails.Length > 1)                      {                          // first item will be the status command so ignore                          // only concerned with the second line                            string[] flds = sDetails[1].Substring(0).Split('|');                          AniDBEntity = int.Parse(flds[0]);                          RecordCount = int.Parse(flds[1]);                          StartTime = flds[2];                          AnimeIDListRaw = flds[3].Trim();                          string[] aids = AnimeIDListRaw.Split(''');                          foreach (string sid in aids)                          {                              AnimeIDList.Add(int.Parse(sid));                          }                      }                        return enHelperActivityType.GotUpdated;                  }                  case "343": return enHelperActivityType.NoUpdates;                  case "501": return enHelperActivityType.LoginRequired;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_Login,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_Login.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_Login,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_Login.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_Login,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_Login.cs,Process,The following statement contains a magic number: string sMsgType = socketResponse.Substring(0' 3);
Magic Number,AniDBAPI.Commands,AniDBCommand_Login,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_Login.cs,Process,The following statement contains a magic number: string sMessage = socketResponse.Substring(4);
Magic Number,AniDBAPI.Commands,AniDBCommand_MarkFileAsDeleted,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_MarkFileAsDeleted.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_MarkFileAsDeleted,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_MarkFileAsDeleted.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_MarkFileAsDeleted,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_MarkFileAsDeleted.cs,Process,The following statement contains a magic number: string sMsgType = socketResponse.Substring(0' 3);
Magic Number,AniDBAPI.Commands,AniDBCommand_MarkFileAsExternal,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_MarkFileAsExternal.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_MarkFileAsExternal,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_MarkFileAsExternal.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_MarkFileAsExternal,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_MarkFileAsExternal.cs,Process,The following statement contains a magic number: string sMsgType = socketResponse.Substring(0' 3);
Magic Number,AniDBAPI.Commands,AniDBCommand_MarkFileAsUnknown,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_MarkFileAsUnknown.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_MarkFileAsUnknown,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_MarkFileAsUnknown.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_MarkFileAsUnknown,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_MarkFileAsUnknown.cs,Process,The following statement contains a magic number: string sMsgType = socketResponse.Substring(0' 3);
Magic Number,AniDBAPI.Commands,AniDBCommand_NotifyGet,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_NotifyGet.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_NotifyGet,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_NotifyGet.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_NotifyGet,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_NotifyGet.cs,Process,The following statement contains a magic number: string sMsgType = socketResponse.Substring(0' 3);
Magic Number,AniDBAPI.Commands,AniDBCommand_NotifyList,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_NotifyList.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_NotifyList,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_NotifyList.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_NotifyList,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_NotifyList.cs,Process,The following statement contains a magic number: string sMsgType = socketResponse.Substring(0' 3);
Magic Number,AniDBAPI.Commands,AniDBCommand_Ping,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_Ping.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_Ping,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_Ping.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_Ping,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_Ping.cs,Process,The following statement contains a magic number: string sMsgType = socketResponse.Substring(0' 3);
Magic Number,AniDBAPI.Commands,AniDBCommand_UpdateFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_UpdateFile.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_UpdateFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_UpdateFile.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_UpdateFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_UpdateFile.cs,Process,The following statement contains a magic number: string sMsgType = socketResponse.Substring(0' 3);
Magic Number,AniDBAPI.Commands,AniDBCommand_Vote,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_Vote.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_Vote,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_Vote.cs,Process,The following statement contains a magic number: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_Vote,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_Vote.cs,Process,The following statement contains a magic number: string sMsgType = socketResponse.Substring(0' 3);
Magic Number,AniDBAPI.Commands,AniDBCommand_Vote,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_Vote.cs,Init,The following statement contains a magic number: if (votevalue > 0)                  this.voteValue = (int) (votevalue * 100);              else                  this.voteValue = (int) votevalue;
Magic Number,AniDBAPI.Commands,AniDBCommand_Vote,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_Vote.cs,Init,The following statement contains a magic number: switch (voteType)              {                  case AniDBVoteType.Anime:                      iVoteType = 1;                      break;                  case AniDBVoteType.AnimeTemp:                      iVoteType = 2;                      break;                  case AniDBVoteType.Group:                      iVoteType = 3;                      break;                  case AniDBVoteType.Episode:                      iVoteType = 1;                      break;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_Vote,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_Vote.cs,Init,The following statement contains a magic number: switch (voteType)              {                  case AniDBVoteType.Anime:                      iVoteType = 1;                      break;                  case AniDBVoteType.AnimeTemp:                      iVoteType = 2;                      break;                  case AniDBVoteType.Group:                      iVoteType = 3;                      break;                  case AniDBVoteType.Episode:                      iVoteType = 1;                      break;              }
Magic Number,AniDBAPI.Commands,AniDBCommand_Vote,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_Vote.cs,InitEpisode,The following statement contains a magic number: if (votevalue > 0)                  this.voteValue = (int) (votevalue * 100);              else                  this.voteValue = (int) votevalue;
Magic Number,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The following statement contains a magic number: do              {                  if (part > 0)                  {                      mcommandText = mcommandText.Replace("part=" + (part - 1).ToString()' "part=" + part.ToString());                      AniDbRateLimiter.Instance.EnsureRate();                  }                  if (commandType != enAniDBCommandType.Login)                  {                      string msg = string.Format("UDP_COMMAND: {0}"' mcommandText);                      ShokoService.LogToSystem(Constants.DBLogType.APIAniDBUDP' msg);                  }                  else                  {                      //string msg = commandText.Replace(ShokoServer.settings.Username' "******");                      //msg = msg.Replace(ShokoServer.settings.Password' "******");                      //MyAnimeLog.Write("commandText: {0}"' msg);                  }                  bool repeatcmd;                  int received;                  Byte[] byReceivedAdd = new Byte[2000]; // max length should actually be 1400                  do                  {                      repeatcmd = false;                      // Send Message                      Byte[] SendByteAdd = Encoding.GetBytes(mcommandText.ToCharArray());                        try                      {                          ShokoService.LastAniDBMessage = DateTime.Now;                          ShokoService.LastAniDBUDPMessage = DateTime.Now;                          if (commandType != enAniDBCommandType.Ping)                              ShokoService.LastAniDBMessageNonPing = DateTime.Now;                          else                              ShokoService.LastAniDBPing = DateTime.Now;                            soUDP.SendTo(SendByteAdd' remoteIpEndPoint);                      }                      catch (Exception ex)                      {                          logger.Error(ex' ex.ToString());                          //MyAnimeLog.Write(ex.ToString());                          errorOccurred = true;                          errorMessage = ex.ToString();                      }                          // Receive Response                      received = 0;                      try                      {                          //MyAnimeLog.Write("soUDP.ReceiveTimeout = {0}"' soUDP.ReceiveTimeout.ToString());                              received = soUDP.ReceiveFrom(byReceivedAdd' ref RemotePoint);                          ShokoService.LastAniDBMessage = DateTime.Now;                          ShokoService.LastAniDBUDPMessage = DateTime.Now;                          if (commandType != enAniDBCommandType.Ping)                              ShokoService.LastAniDBMessageNonPing = DateTime.Now;                          else                              ShokoService.LastAniDBPing = DateTime.Now;                            //MyAnimeLog.Write("Buffer length = {0}"' received.ToString());                          if ((received > 2) && (byReceivedAdd[0] == 0) && (byReceivedAdd[1] == 0))                          {                              //deflate                              Byte[] buff = new byte[65536];                              Byte[] input = new byte[received - 2];                              Array.Copy(byReceivedAdd' 2' input' 0' received - 2);                              Inflater inf = new Inflater(false);                              inf.SetInput(input);                              inf.Inflate(buff);                              byReceivedAdd = buff;                              received = (int) inf.TotalOut;                          }                      }                      catch (SocketException sex)                      {                          // most likely we have timed out                          logger.Error(sex' sex.ToString());                          errorOccurred = true;                          errorMessage = sex.ToString();                      }                      catch (Exception ex)                      {                          logger.Error(ex' ex.ToString());                          errorOccurred = true;                          errorMessage = ex.ToString();                      }                      if ((commandType == enAniDBCommandType.Login) && (byReceivedAdd[0] == 0xFE) &&                          (byReceivedAdd[1] == 0xFF) &&                          (byReceivedAdd[3] == 53) && (byReceivedAdd[5] != 53) &&                          !Encoding.EncodingName.ToLower().StartsWith("unicode") && (changeencoding != null) &&                          changeencoding.EncodingName.ToLower().StartsWith("unicode"))                      {                          //Previous Session used utf-16 and was not logged out' AniDB was not yet issued a timeout.                          //AUTH command was not understand because it was encoded in ASCII.                          encoding = changeencoding;                          repeatcmd = true;                      }                  } while (repeatcmd);                    if (!errorOccurred)                  {                      if (changeencoding != null)                          encoding = changeencoding;                      System.Text.Encoding enco;                      if ((byReceivedAdd[0] == 0xFE) && (byReceivedAdd[1] == 0xFF))                          enco = encoding;                      else                          enco = Encoding.ASCII;                      decodedstring = enco.GetString(byReceivedAdd' 0' received);                        if (decodedstring[0] == 0xFEFF) // remove BOM                          decodedstring = decodedstring.Substring(1);                      if (commandType == enAniDBCommandType.GetAnimeDescription ||                          commandType == enAniDBCommandType.GetReview)                      {                          //Lets handle multipart                          part++;                          string[] sp1 = decodedstring.Split(new char[] {'\n'}' StringSplitOptions.RemoveEmptyEntries);                            if (sp1[0].StartsWith("233 ANIMEDESC") || sp1[0].StartsWith("233  ANIMEDESC"))                          {                              string[] sp2 = sp1[1].Split('|');                              fulldesc += sp2[2];                              maxpart = int.Parse(sp2[1]);                          }                            if (sp1[0].StartsWith("234 REVIEW") || sp1[0].StartsWith("234  REVIEW"))                          {                              string[] sp2 = sp1[1].Split('|');                                if (sp2.Length == 3)                                  fulldesc += sp2[2];                              else                              {                                  for (int i = 2; i < sp2.Length; i++)                                      fulldesc += "|" + sp2[i];                              }                                  maxpart = int.Parse(sp2[1]);                          }                          multipart = true;                          if (part == maxpart)                          {                              decodedstring = sp1[0] + "\n0|1|" + fulldesc + "\n";                              multipart = false;                          }                      }                  }              } while (multipart && !errorOccurred);
Magic Number,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The following statement contains a magic number: do              {                  if (part > 0)                  {                      mcommandText = mcommandText.Replace("part=" + (part - 1).ToString()' "part=" + part.ToString());                      AniDbRateLimiter.Instance.EnsureRate();                  }                  if (commandType != enAniDBCommandType.Login)                  {                      string msg = string.Format("UDP_COMMAND: {0}"' mcommandText);                      ShokoService.LogToSystem(Constants.DBLogType.APIAniDBUDP' msg);                  }                  else                  {                      //string msg = commandText.Replace(ShokoServer.settings.Username' "******");                      //msg = msg.Replace(ShokoServer.settings.Password' "******");                      //MyAnimeLog.Write("commandText: {0}"' msg);                  }                  bool repeatcmd;                  int received;                  Byte[] byReceivedAdd = new Byte[2000]; // max length should actually be 1400                  do                  {                      repeatcmd = false;                      // Send Message                      Byte[] SendByteAdd = Encoding.GetBytes(mcommandText.ToCharArray());                        try                      {                          ShokoService.LastAniDBMessage = DateTime.Now;                          ShokoService.LastAniDBUDPMessage = DateTime.Now;                          if (commandType != enAniDBCommandType.Ping)                              ShokoService.LastAniDBMessageNonPing = DateTime.Now;                          else                              ShokoService.LastAniDBPing = DateTime.Now;                            soUDP.SendTo(SendByteAdd' remoteIpEndPoint);                      }                      catch (Exception ex)                      {                          logger.Error(ex' ex.ToString());                          //MyAnimeLog.Write(ex.ToString());                          errorOccurred = true;                          errorMessage = ex.ToString();                      }                          // Receive Response                      received = 0;                      try                      {                          //MyAnimeLog.Write("soUDP.ReceiveTimeout = {0}"' soUDP.ReceiveTimeout.ToString());                              received = soUDP.ReceiveFrom(byReceivedAdd' ref RemotePoint);                          ShokoService.LastAniDBMessage = DateTime.Now;                          ShokoService.LastAniDBUDPMessage = DateTime.Now;                          if (commandType != enAniDBCommandType.Ping)                              ShokoService.LastAniDBMessageNonPing = DateTime.Now;                          else                              ShokoService.LastAniDBPing = DateTime.Now;                            //MyAnimeLog.Write("Buffer length = {0}"' received.ToString());                          if ((received > 2) && (byReceivedAdd[0] == 0) && (byReceivedAdd[1] == 0))                          {                              //deflate                              Byte[] buff = new byte[65536];                              Byte[] input = new byte[received - 2];                              Array.Copy(byReceivedAdd' 2' input' 0' received - 2);                              Inflater inf = new Inflater(false);                              inf.SetInput(input);                              inf.Inflate(buff);                              byReceivedAdd = buff;                              received = (int) inf.TotalOut;                          }                      }                      catch (SocketException sex)                      {                          // most likely we have timed out                          logger.Error(sex' sex.ToString());                          errorOccurred = true;                          errorMessage = sex.ToString();                      }                      catch (Exception ex)                      {                          logger.Error(ex' ex.ToString());                          errorOccurred = true;                          errorMessage = ex.ToString();                      }                      if ((commandType == enAniDBCommandType.Login) && (byReceivedAdd[0] == 0xFE) &&                          (byReceivedAdd[1] == 0xFF) &&                          (byReceivedAdd[3] == 53) && (byReceivedAdd[5] != 53) &&                          !Encoding.EncodingName.ToLower().StartsWith("unicode") && (changeencoding != null) &&                          changeencoding.EncodingName.ToLower().StartsWith("unicode"))                      {                          //Previous Session used utf-16 and was not logged out' AniDB was not yet issued a timeout.                          //AUTH command was not understand because it was encoded in ASCII.                          encoding = changeencoding;                          repeatcmd = true;                      }                  } while (repeatcmd);                    if (!errorOccurred)                  {                      if (changeencoding != null)                          encoding = changeencoding;                      System.Text.Encoding enco;                      if ((byReceivedAdd[0] == 0xFE) && (byReceivedAdd[1] == 0xFF))                          enco = encoding;                      else                          enco = Encoding.ASCII;                      decodedstring = enco.GetString(byReceivedAdd' 0' received);                        if (decodedstring[0] == 0xFEFF) // remove BOM                          decodedstring = decodedstring.Substring(1);                      if (commandType == enAniDBCommandType.GetAnimeDescription ||                          commandType == enAniDBCommandType.GetReview)                      {                          //Lets handle multipart                          part++;                          string[] sp1 = decodedstring.Split(new char[] {'\n'}' StringSplitOptions.RemoveEmptyEntries);                            if (sp1[0].StartsWith("233 ANIMEDESC") || sp1[0].StartsWith("233  ANIMEDESC"))                          {                              string[] sp2 = sp1[1].Split('|');                              fulldesc += sp2[2];                              maxpart = int.Parse(sp2[1]);                          }                            if (sp1[0].StartsWith("234 REVIEW") || sp1[0].StartsWith("234  REVIEW"))                          {                              string[] sp2 = sp1[1].Split('|');                                if (sp2.Length == 3)                                  fulldesc += sp2[2];                              else                              {                                  for (int i = 2; i < sp2.Length; i++)                                      fulldesc += "|" + sp2[i];                              }                                  maxpart = int.Parse(sp2[1]);                          }                          multipart = true;                          if (part == maxpart)                          {                              decodedstring = sp1[0] + "\n0|1|" + fulldesc + "\n";                              multipart = false;                          }                      }                  }              } while (multipart && !errorOccurred);
Magic Number,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The following statement contains a magic number: do              {                  if (part > 0)                  {                      mcommandText = mcommandText.Replace("part=" + (part - 1).ToString()' "part=" + part.ToString());                      AniDbRateLimiter.Instance.EnsureRate();                  }                  if (commandType != enAniDBCommandType.Login)                  {                      string msg = string.Format("UDP_COMMAND: {0}"' mcommandText);                      ShokoService.LogToSystem(Constants.DBLogType.APIAniDBUDP' msg);                  }                  else                  {                      //string msg = commandText.Replace(ShokoServer.settings.Username' "******");                      //msg = msg.Replace(ShokoServer.settings.Password' "******");                      //MyAnimeLog.Write("commandText: {0}"' msg);                  }                  bool repeatcmd;                  int received;                  Byte[] byReceivedAdd = new Byte[2000]; // max length should actually be 1400                  do                  {                      repeatcmd = false;                      // Send Message                      Byte[] SendByteAdd = Encoding.GetBytes(mcommandText.ToCharArray());                        try                      {                          ShokoService.LastAniDBMessage = DateTime.Now;                          ShokoService.LastAniDBUDPMessage = DateTime.Now;                          if (commandType != enAniDBCommandType.Ping)                              ShokoService.LastAniDBMessageNonPing = DateTime.Now;                          else                              ShokoService.LastAniDBPing = DateTime.Now;                            soUDP.SendTo(SendByteAdd' remoteIpEndPoint);                      }                      catch (Exception ex)                      {                          logger.Error(ex' ex.ToString());                          //MyAnimeLog.Write(ex.ToString());                          errorOccurred = true;                          errorMessage = ex.ToString();                      }                          // Receive Response                      received = 0;                      try                      {                          //MyAnimeLog.Write("soUDP.ReceiveTimeout = {0}"' soUDP.ReceiveTimeout.ToString());                              received = soUDP.ReceiveFrom(byReceivedAdd' ref RemotePoint);                          ShokoService.LastAniDBMessage = DateTime.Now;                          ShokoService.LastAniDBUDPMessage = DateTime.Now;                          if (commandType != enAniDBCommandType.Ping)                              ShokoService.LastAniDBMessageNonPing = DateTime.Now;                          else                              ShokoService.LastAniDBPing = DateTime.Now;                            //MyAnimeLog.Write("Buffer length = {0}"' received.ToString());                          if ((received > 2) && (byReceivedAdd[0] == 0) && (byReceivedAdd[1] == 0))                          {                              //deflate                              Byte[] buff = new byte[65536];                              Byte[] input = new byte[received - 2];                              Array.Copy(byReceivedAdd' 2' input' 0' received - 2);                              Inflater inf = new Inflater(false);                              inf.SetInput(input);                              inf.Inflate(buff);                              byReceivedAdd = buff;                              received = (int) inf.TotalOut;                          }                      }                      catch (SocketException sex)                      {                          // most likely we have timed out                          logger.Error(sex' sex.ToString());                          errorOccurred = true;                          errorMessage = sex.ToString();                      }                      catch (Exception ex)                      {                          logger.Error(ex' ex.ToString());                          errorOccurred = true;                          errorMessage = ex.ToString();                      }                      if ((commandType == enAniDBCommandType.Login) && (byReceivedAdd[0] == 0xFE) &&                          (byReceivedAdd[1] == 0xFF) &&                          (byReceivedAdd[3] == 53) && (byReceivedAdd[5] != 53) &&                          !Encoding.EncodingName.ToLower().StartsWith("unicode") && (changeencoding != null) &&                          changeencoding.EncodingName.ToLower().StartsWith("unicode"))                      {                          //Previous Session used utf-16 and was not logged out' AniDB was not yet issued a timeout.                          //AUTH command was not understand because it was encoded in ASCII.                          encoding = changeencoding;                          repeatcmd = true;                      }                  } while (repeatcmd);                    if (!errorOccurred)                  {                      if (changeencoding != null)                          encoding = changeencoding;                      System.Text.Encoding enco;                      if ((byReceivedAdd[0] == 0xFE) && (byReceivedAdd[1] == 0xFF))                          enco = encoding;                      else                          enco = Encoding.ASCII;                      decodedstring = enco.GetString(byReceivedAdd' 0' received);                        if (decodedstring[0] == 0xFEFF) // remove BOM                          decodedstring = decodedstring.Substring(1);                      if (commandType == enAniDBCommandType.GetAnimeDescription ||                          commandType == enAniDBCommandType.GetReview)                      {                          //Lets handle multipart                          part++;                          string[] sp1 = decodedstring.Split(new char[] {'\n'}' StringSplitOptions.RemoveEmptyEntries);                            if (sp1[0].StartsWith("233 ANIMEDESC") || sp1[0].StartsWith("233  ANIMEDESC"))                          {                              string[] sp2 = sp1[1].Split('|');                              fulldesc += sp2[2];                              maxpart = int.Parse(sp2[1]);                          }                            if (sp1[0].StartsWith("234 REVIEW") || sp1[0].StartsWith("234  REVIEW"))                          {                              string[] sp2 = sp1[1].Split('|');                                if (sp2.Length == 3)                                  fulldesc += sp2[2];                              else                              {                                  for (int i = 2; i < sp2.Length; i++)                                      fulldesc += "|" + sp2[i];                              }                                  maxpart = int.Parse(sp2[1]);                          }                          multipart = true;                          if (part == maxpart)                          {                              decodedstring = sp1[0] + "\n0|1|" + fulldesc + "\n";                              multipart = false;                          }                      }                  }              } while (multipart && !errorOccurred);
Magic Number,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The following statement contains a magic number: do              {                  if (part > 0)                  {                      mcommandText = mcommandText.Replace("part=" + (part - 1).ToString()' "part=" + part.ToString());                      AniDbRateLimiter.Instance.EnsureRate();                  }                  if (commandType != enAniDBCommandType.Login)                  {                      string msg = string.Format("UDP_COMMAND: {0}"' mcommandText);                      ShokoService.LogToSystem(Constants.DBLogType.APIAniDBUDP' msg);                  }                  else                  {                      //string msg = commandText.Replace(ShokoServer.settings.Username' "******");                      //msg = msg.Replace(ShokoServer.settings.Password' "******");                      //MyAnimeLog.Write("commandText: {0}"' msg);                  }                  bool repeatcmd;                  int received;                  Byte[] byReceivedAdd = new Byte[2000]; // max length should actually be 1400                  do                  {                      repeatcmd = false;                      // Send Message                      Byte[] SendByteAdd = Encoding.GetBytes(mcommandText.ToCharArray());                        try                      {                          ShokoService.LastAniDBMessage = DateTime.Now;                          ShokoService.LastAniDBUDPMessage = DateTime.Now;                          if (commandType != enAniDBCommandType.Ping)                              ShokoService.LastAniDBMessageNonPing = DateTime.Now;                          else                              ShokoService.LastAniDBPing = DateTime.Now;                            soUDP.SendTo(SendByteAdd' remoteIpEndPoint);                      }                      catch (Exception ex)                      {                          logger.Error(ex' ex.ToString());                          //MyAnimeLog.Write(ex.ToString());                          errorOccurred = true;                          errorMessage = ex.ToString();                      }                          // Receive Response                      received = 0;                      try                      {                          //MyAnimeLog.Write("soUDP.ReceiveTimeout = {0}"' soUDP.ReceiveTimeout.ToString());                              received = soUDP.ReceiveFrom(byReceivedAdd' ref RemotePoint);                          ShokoService.LastAniDBMessage = DateTime.Now;                          ShokoService.LastAniDBUDPMessage = DateTime.Now;                          if (commandType != enAniDBCommandType.Ping)                              ShokoService.LastAniDBMessageNonPing = DateTime.Now;                          else                              ShokoService.LastAniDBPing = DateTime.Now;                            //MyAnimeLog.Write("Buffer length = {0}"' received.ToString());                          if ((received > 2) && (byReceivedAdd[0] == 0) && (byReceivedAdd[1] == 0))                          {                              //deflate                              Byte[] buff = new byte[65536];                              Byte[] input = new byte[received - 2];                              Array.Copy(byReceivedAdd' 2' input' 0' received - 2);                              Inflater inf = new Inflater(false);                              inf.SetInput(input);                              inf.Inflate(buff);                              byReceivedAdd = buff;                              received = (int) inf.TotalOut;                          }                      }                      catch (SocketException sex)                      {                          // most likely we have timed out                          logger.Error(sex' sex.ToString());                          errorOccurred = true;                          errorMessage = sex.ToString();                      }                      catch (Exception ex)                      {                          logger.Error(ex' ex.ToString());                          errorOccurred = true;                          errorMessage = ex.ToString();                      }                      if ((commandType == enAniDBCommandType.Login) && (byReceivedAdd[0] == 0xFE) &&                          (byReceivedAdd[1] == 0xFF) &&                          (byReceivedAdd[3] == 53) && (byReceivedAdd[5] != 53) &&                          !Encoding.EncodingName.ToLower().StartsWith("unicode") && (changeencoding != null) &&                          changeencoding.EncodingName.ToLower().StartsWith("unicode"))                      {                          //Previous Session used utf-16 and was not logged out' AniDB was not yet issued a timeout.                          //AUTH command was not understand because it was encoded in ASCII.                          encoding = changeencoding;                          repeatcmd = true;                      }                  } while (repeatcmd);                    if (!errorOccurred)                  {                      if (changeencoding != null)                          encoding = changeencoding;                      System.Text.Encoding enco;                      if ((byReceivedAdd[0] == 0xFE) && (byReceivedAdd[1] == 0xFF))                          enco = encoding;                      else                          enco = Encoding.ASCII;                      decodedstring = enco.GetString(byReceivedAdd' 0' received);                        if (decodedstring[0] == 0xFEFF) // remove BOM                          decodedstring = decodedstring.Substring(1);                      if (commandType == enAniDBCommandType.GetAnimeDescription ||                          commandType == enAniDBCommandType.GetReview)                      {                          //Lets handle multipart                          part++;                          string[] sp1 = decodedstring.Split(new char[] {'\n'}' StringSplitOptions.RemoveEmptyEntries);                            if (sp1[0].StartsWith("233 ANIMEDESC") || sp1[0].StartsWith("233  ANIMEDESC"))                          {                              string[] sp2 = sp1[1].Split('|');                              fulldesc += sp2[2];                              maxpart = int.Parse(sp2[1]);                          }                            if (sp1[0].StartsWith("234 REVIEW") || sp1[0].StartsWith("234  REVIEW"))                          {                              string[] sp2 = sp1[1].Split('|');                                if (sp2.Length == 3)                                  fulldesc += sp2[2];                              else                              {                                  for (int i = 2; i < sp2.Length; i++)                                      fulldesc += "|" + sp2[i];                              }                                  maxpart = int.Parse(sp2[1]);                          }                          multipart = true;                          if (part == maxpart)                          {                              decodedstring = sp1[0] + "\n0|1|" + fulldesc + "\n";                              multipart = false;                          }                      }                  }              } while (multipart && !errorOccurred);
Magic Number,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The following statement contains a magic number: do              {                  if (part > 0)                  {                      mcommandText = mcommandText.Replace("part=" + (part - 1).ToString()' "part=" + part.ToString());                      AniDbRateLimiter.Instance.EnsureRate();                  }                  if (commandType != enAniDBCommandType.Login)                  {                      string msg = string.Format("UDP_COMMAND: {0}"' mcommandText);                      ShokoService.LogToSystem(Constants.DBLogType.APIAniDBUDP' msg);                  }                  else                  {                      //string msg = commandText.Replace(ShokoServer.settings.Username' "******");                      //msg = msg.Replace(ShokoServer.settings.Password' "******");                      //MyAnimeLog.Write("commandText: {0}"' msg);                  }                  bool repeatcmd;                  int received;                  Byte[] byReceivedAdd = new Byte[2000]; // max length should actually be 1400                  do                  {                      repeatcmd = false;                      // Send Message                      Byte[] SendByteAdd = Encoding.GetBytes(mcommandText.ToCharArray());                        try                      {                          ShokoService.LastAniDBMessage = DateTime.Now;                          ShokoService.LastAniDBUDPMessage = DateTime.Now;                          if (commandType != enAniDBCommandType.Ping)                              ShokoService.LastAniDBMessageNonPing = DateTime.Now;                          else                              ShokoService.LastAniDBPing = DateTime.Now;                            soUDP.SendTo(SendByteAdd' remoteIpEndPoint);                      }                      catch (Exception ex)                      {                          logger.Error(ex' ex.ToString());                          //MyAnimeLog.Write(ex.ToString());                          errorOccurred = true;                          errorMessage = ex.ToString();                      }                          // Receive Response                      received = 0;                      try                      {                          //MyAnimeLog.Write("soUDP.ReceiveTimeout = {0}"' soUDP.ReceiveTimeout.ToString());                              received = soUDP.ReceiveFrom(byReceivedAdd' ref RemotePoint);                          ShokoService.LastAniDBMessage = DateTime.Now;                          ShokoService.LastAniDBUDPMessage = DateTime.Now;                          if (commandType != enAniDBCommandType.Ping)                              ShokoService.LastAniDBMessageNonPing = DateTime.Now;                          else                              ShokoService.LastAniDBPing = DateTime.Now;                            //MyAnimeLog.Write("Buffer length = {0}"' received.ToString());                          if ((received > 2) && (byReceivedAdd[0] == 0) && (byReceivedAdd[1] == 0))                          {                              //deflate                              Byte[] buff = new byte[65536];                              Byte[] input = new byte[received - 2];                              Array.Copy(byReceivedAdd' 2' input' 0' received - 2);                              Inflater inf = new Inflater(false);                              inf.SetInput(input);                              inf.Inflate(buff);                              byReceivedAdd = buff;                              received = (int) inf.TotalOut;                          }                      }                      catch (SocketException sex)                      {                          // most likely we have timed out                          logger.Error(sex' sex.ToString());                          errorOccurred = true;                          errorMessage = sex.ToString();                      }                      catch (Exception ex)                      {                          logger.Error(ex' ex.ToString());                          errorOccurred = true;                          errorMessage = ex.ToString();                      }                      if ((commandType == enAniDBCommandType.Login) && (byReceivedAdd[0] == 0xFE) &&                          (byReceivedAdd[1] == 0xFF) &&                          (byReceivedAdd[3] == 53) && (byReceivedAdd[5] != 53) &&                          !Encoding.EncodingName.ToLower().StartsWith("unicode") && (changeencoding != null) &&                          changeencoding.EncodingName.ToLower().StartsWith("unicode"))                      {                          //Previous Session used utf-16 and was not logged out' AniDB was not yet issued a timeout.                          //AUTH command was not understand because it was encoded in ASCII.                          encoding = changeencoding;                          repeatcmd = true;                      }                  } while (repeatcmd);                    if (!errorOccurred)                  {                      if (changeencoding != null)                          encoding = changeencoding;                      System.Text.Encoding enco;                      if ((byReceivedAdd[0] == 0xFE) && (byReceivedAdd[1] == 0xFF))                          enco = encoding;                      else                          enco = Encoding.ASCII;                      decodedstring = enco.GetString(byReceivedAdd' 0' received);                        if (decodedstring[0] == 0xFEFF) // remove BOM                          decodedstring = decodedstring.Substring(1);                      if (commandType == enAniDBCommandType.GetAnimeDescription ||                          commandType == enAniDBCommandType.GetReview)                      {                          //Lets handle multipart                          part++;                          string[] sp1 = decodedstring.Split(new char[] {'\n'}' StringSplitOptions.RemoveEmptyEntries);                            if (sp1[0].StartsWith("233 ANIMEDESC") || sp1[0].StartsWith("233  ANIMEDESC"))                          {                              string[] sp2 = sp1[1].Split('|');                              fulldesc += sp2[2];                              maxpart = int.Parse(sp2[1]);                          }                            if (sp1[0].StartsWith("234 REVIEW") || sp1[0].StartsWith("234  REVIEW"))                          {                              string[] sp2 = sp1[1].Split('|');                                if (sp2.Length == 3)                                  fulldesc += sp2[2];                              else                              {                                  for (int i = 2; i < sp2.Length; i++)                                      fulldesc += "|" + sp2[i];                              }                                  maxpart = int.Parse(sp2[1]);                          }                          multipart = true;                          if (part == maxpart)                          {                              decodedstring = sp1[0] + "\n0|1|" + fulldesc + "\n";                              multipart = false;                          }                      }                  }              } while (multipart && !errorOccurred);
Magic Number,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The following statement contains a magic number: do              {                  if (part > 0)                  {                      mcommandText = mcommandText.Replace("part=" + (part - 1).ToString()' "part=" + part.ToString());                      AniDbRateLimiter.Instance.EnsureRate();                  }                  if (commandType != enAniDBCommandType.Login)                  {                      string msg = string.Format("UDP_COMMAND: {0}"' mcommandText);                      ShokoService.LogToSystem(Constants.DBLogType.APIAniDBUDP' msg);                  }                  else                  {                      //string msg = commandText.Replace(ShokoServer.settings.Username' "******");                      //msg = msg.Replace(ShokoServer.settings.Password' "******");                      //MyAnimeLog.Write("commandText: {0}"' msg);                  }                  bool repeatcmd;                  int received;                  Byte[] byReceivedAdd = new Byte[2000]; // max length should actually be 1400                  do                  {                      repeatcmd = false;                      // Send Message                      Byte[] SendByteAdd = Encoding.GetBytes(mcommandText.ToCharArray());                        try                      {                          ShokoService.LastAniDBMessage = DateTime.Now;                          ShokoService.LastAniDBUDPMessage = DateTime.Now;                          if (commandType != enAniDBCommandType.Ping)                              ShokoService.LastAniDBMessageNonPing = DateTime.Now;                          else                              ShokoService.LastAniDBPing = DateTime.Now;                            soUDP.SendTo(SendByteAdd' remoteIpEndPoint);                      }                      catch (Exception ex)                      {                          logger.Error(ex' ex.ToString());                          //MyAnimeLog.Write(ex.ToString());                          errorOccurred = true;                          errorMessage = ex.ToString();                      }                          // Receive Response                      received = 0;                      try                      {                          //MyAnimeLog.Write("soUDP.ReceiveTimeout = {0}"' soUDP.ReceiveTimeout.ToString());                              received = soUDP.ReceiveFrom(byReceivedAdd' ref RemotePoint);                          ShokoService.LastAniDBMessage = DateTime.Now;                          ShokoService.LastAniDBUDPMessage = DateTime.Now;                          if (commandType != enAniDBCommandType.Ping)                              ShokoService.LastAniDBMessageNonPing = DateTime.Now;                          else                              ShokoService.LastAniDBPing = DateTime.Now;                            //MyAnimeLog.Write("Buffer length = {0}"' received.ToString());                          if ((received > 2) && (byReceivedAdd[0] == 0) && (byReceivedAdd[1] == 0))                          {                              //deflate                              Byte[] buff = new byte[65536];                              Byte[] input = new byte[received - 2];                              Array.Copy(byReceivedAdd' 2' input' 0' received - 2);                              Inflater inf = new Inflater(false);                              inf.SetInput(input);                              inf.Inflate(buff);                              byReceivedAdd = buff;                              received = (int) inf.TotalOut;                          }                      }                      catch (SocketException sex)                      {                          // most likely we have timed out                          logger.Error(sex' sex.ToString());                          errorOccurred = true;                          errorMessage = sex.ToString();                      }                      catch (Exception ex)                      {                          logger.Error(ex' ex.ToString());                          errorOccurred = true;                          errorMessage = ex.ToString();                      }                      if ((commandType == enAniDBCommandType.Login) && (byReceivedAdd[0] == 0xFE) &&                          (byReceivedAdd[1] == 0xFF) &&                          (byReceivedAdd[3] == 53) && (byReceivedAdd[5] != 53) &&                          !Encoding.EncodingName.ToLower().StartsWith("unicode") && (changeencoding != null) &&                          changeencoding.EncodingName.ToLower().StartsWith("unicode"))                      {                          //Previous Session used utf-16 and was not logged out' AniDB was not yet issued a timeout.                          //AUTH command was not understand because it was encoded in ASCII.                          encoding = changeencoding;                          repeatcmd = true;                      }                  } while (repeatcmd);                    if (!errorOccurred)                  {                      if (changeencoding != null)                          encoding = changeencoding;                      System.Text.Encoding enco;                      if ((byReceivedAdd[0] == 0xFE) && (byReceivedAdd[1] == 0xFF))                          enco = encoding;                      else                          enco = Encoding.ASCII;                      decodedstring = enco.GetString(byReceivedAdd' 0' received);                        if (decodedstring[0] == 0xFEFF) // remove BOM                          decodedstring = decodedstring.Substring(1);                      if (commandType == enAniDBCommandType.GetAnimeDescription ||                          commandType == enAniDBCommandType.GetReview)                      {                          //Lets handle multipart                          part++;                          string[] sp1 = decodedstring.Split(new char[] {'\n'}' StringSplitOptions.RemoveEmptyEntries);                            if (sp1[0].StartsWith("233 ANIMEDESC") || sp1[0].StartsWith("233  ANIMEDESC"))                          {                              string[] sp2 = sp1[1].Split('|');                              fulldesc += sp2[2];                              maxpart = int.Parse(sp2[1]);                          }                            if (sp1[0].StartsWith("234 REVIEW") || sp1[0].StartsWith("234  REVIEW"))                          {                              string[] sp2 = sp1[1].Split('|');                                if (sp2.Length == 3)                                  fulldesc += sp2[2];                              else                              {                                  for (int i = 2; i < sp2.Length; i++)                                      fulldesc += "|" + sp2[i];                              }                                  maxpart = int.Parse(sp2[1]);                          }                          multipart = true;                          if (part == maxpart)                          {                              decodedstring = sp1[0] + "\n0|1|" + fulldesc + "\n";                              multipart = false;                          }                      }                  }              } while (multipart && !errorOccurred);
Magic Number,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The following statement contains a magic number: do              {                  if (part > 0)                  {                      mcommandText = mcommandText.Replace("part=" + (part - 1).ToString()' "part=" + part.ToString());                      AniDbRateLimiter.Instance.EnsureRate();                  }                  if (commandType != enAniDBCommandType.Login)                  {                      string msg = string.Format("UDP_COMMAND: {0}"' mcommandText);                      ShokoService.LogToSystem(Constants.DBLogType.APIAniDBUDP' msg);                  }                  else                  {                      //string msg = commandText.Replace(ShokoServer.settings.Username' "******");                      //msg = msg.Replace(ShokoServer.settings.Password' "******");                      //MyAnimeLog.Write("commandText: {0}"' msg);                  }                  bool repeatcmd;                  int received;                  Byte[] byReceivedAdd = new Byte[2000]; // max length should actually be 1400                  do                  {                      repeatcmd = false;                      // Send Message                      Byte[] SendByteAdd = Encoding.GetBytes(mcommandText.ToCharArray());                        try                      {                          ShokoService.LastAniDBMessage = DateTime.Now;                          ShokoService.LastAniDBUDPMessage = DateTime.Now;                          if (commandType != enAniDBCommandType.Ping)                              ShokoService.LastAniDBMessageNonPing = DateTime.Now;                          else                              ShokoService.LastAniDBPing = DateTime.Now;                            soUDP.SendTo(SendByteAdd' remoteIpEndPoint);                      }                      catch (Exception ex)                      {                          logger.Error(ex' ex.ToString());                          //MyAnimeLog.Write(ex.ToString());                          errorOccurred = true;                          errorMessage = ex.ToString();                      }                          // Receive Response                      received = 0;                      try                      {                          //MyAnimeLog.Write("soUDP.ReceiveTimeout = {0}"' soUDP.ReceiveTimeout.ToString());                              received = soUDP.ReceiveFrom(byReceivedAdd' ref RemotePoint);                          ShokoService.LastAniDBMessage = DateTime.Now;                          ShokoService.LastAniDBUDPMessage = DateTime.Now;                          if (commandType != enAniDBCommandType.Ping)                              ShokoService.LastAniDBMessageNonPing = DateTime.Now;                          else                              ShokoService.LastAniDBPing = DateTime.Now;                            //MyAnimeLog.Write("Buffer length = {0}"' received.ToString());                          if ((received > 2) && (byReceivedAdd[0] == 0) && (byReceivedAdd[1] == 0))                          {                              //deflate                              Byte[] buff = new byte[65536];                              Byte[] input = new byte[received - 2];                              Array.Copy(byReceivedAdd' 2' input' 0' received - 2);                              Inflater inf = new Inflater(false);                              inf.SetInput(input);                              inf.Inflate(buff);                              byReceivedAdd = buff;                              received = (int) inf.TotalOut;                          }                      }                      catch (SocketException sex)                      {                          // most likely we have timed out                          logger.Error(sex' sex.ToString());                          errorOccurred = true;                          errorMessage = sex.ToString();                      }                      catch (Exception ex)                      {                          logger.Error(ex' ex.ToString());                          errorOccurred = true;                          errorMessage = ex.ToString();                      }                      if ((commandType == enAniDBCommandType.Login) && (byReceivedAdd[0] == 0xFE) &&                          (byReceivedAdd[1] == 0xFF) &&                          (byReceivedAdd[3] == 53) && (byReceivedAdd[5] != 53) &&                          !Encoding.EncodingName.ToLower().StartsWith("unicode") && (changeencoding != null) &&                          changeencoding.EncodingName.ToLower().StartsWith("unicode"))                      {                          //Previous Session used utf-16 and was not logged out' AniDB was not yet issued a timeout.                          //AUTH command was not understand because it was encoded in ASCII.                          encoding = changeencoding;                          repeatcmd = true;                      }                  } while (repeatcmd);                    if (!errorOccurred)                  {                      if (changeencoding != null)                          encoding = changeencoding;                      System.Text.Encoding enco;                      if ((byReceivedAdd[0] == 0xFE) && (byReceivedAdd[1] == 0xFF))                          enco = encoding;                      else                          enco = Encoding.ASCII;                      decodedstring = enco.GetString(byReceivedAdd' 0' received);                        if (decodedstring[0] == 0xFEFF) // remove BOM                          decodedstring = decodedstring.Substring(1);                      if (commandType == enAniDBCommandType.GetAnimeDescription ||                          commandType == enAniDBCommandType.GetReview)                      {                          //Lets handle multipart                          part++;                          string[] sp1 = decodedstring.Split(new char[] {'\n'}' StringSplitOptions.RemoveEmptyEntries);                            if (sp1[0].StartsWith("233 ANIMEDESC") || sp1[0].StartsWith("233  ANIMEDESC"))                          {                              string[] sp2 = sp1[1].Split('|');                              fulldesc += sp2[2];                              maxpart = int.Parse(sp2[1]);                          }                            if (sp1[0].StartsWith("234 REVIEW") || sp1[0].StartsWith("234  REVIEW"))                          {                              string[] sp2 = sp1[1].Split('|');                                if (sp2.Length == 3)                                  fulldesc += sp2[2];                              else                              {                                  for (int i = 2; i < sp2.Length; i++)                                      fulldesc += "|" + sp2[i];                              }                                  maxpart = int.Parse(sp2[1]);                          }                          multipart = true;                          if (part == maxpart)                          {                              decodedstring = sp1[0] + "\n0|1|" + fulldesc + "\n";                              multipart = false;                          }                      }                  }              } while (multipart && !errorOccurred);
Magic Number,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The following statement contains a magic number: do              {                  if (part > 0)                  {                      mcommandText = mcommandText.Replace("part=" + (part - 1).ToString()' "part=" + part.ToString());                      AniDbRateLimiter.Instance.EnsureRate();                  }                  if (commandType != enAniDBCommandType.Login)                  {                      string msg = string.Format("UDP_COMMAND: {0}"' mcommandText);                      ShokoService.LogToSystem(Constants.DBLogType.APIAniDBUDP' msg);                  }                  else                  {                      //string msg = commandText.Replace(ShokoServer.settings.Username' "******");                      //msg = msg.Replace(ShokoServer.settings.Password' "******");                      //MyAnimeLog.Write("commandText: {0}"' msg);                  }                  bool repeatcmd;                  int received;                  Byte[] byReceivedAdd = new Byte[2000]; // max length should actually be 1400                  do                  {                      repeatcmd = false;                      // Send Message                      Byte[] SendByteAdd = Encoding.GetBytes(mcommandText.ToCharArray());                        try                      {                          ShokoService.LastAniDBMessage = DateTime.Now;                          ShokoService.LastAniDBUDPMessage = DateTime.Now;                          if (commandType != enAniDBCommandType.Ping)                              ShokoService.LastAniDBMessageNonPing = DateTime.Now;                          else                              ShokoService.LastAniDBPing = DateTime.Now;                            soUDP.SendTo(SendByteAdd' remoteIpEndPoint);                      }                      catch (Exception ex)                      {                          logger.Error(ex' ex.ToString());                          //MyAnimeLog.Write(ex.ToString());                          errorOccurred = true;                          errorMessage = ex.ToString();                      }                          // Receive Response                      received = 0;                      try                      {                          //MyAnimeLog.Write("soUDP.ReceiveTimeout = {0}"' soUDP.ReceiveTimeout.ToString());                              received = soUDP.ReceiveFrom(byReceivedAdd' ref RemotePoint);                          ShokoService.LastAniDBMessage = DateTime.Now;                          ShokoService.LastAniDBUDPMessage = DateTime.Now;                          if (commandType != enAniDBCommandType.Ping)                              ShokoService.LastAniDBMessageNonPing = DateTime.Now;                          else                              ShokoService.LastAniDBPing = DateTime.Now;                            //MyAnimeLog.Write("Buffer length = {0}"' received.ToString());                          if ((received > 2) && (byReceivedAdd[0] == 0) && (byReceivedAdd[1] == 0))                          {                              //deflate                              Byte[] buff = new byte[65536];                              Byte[] input = new byte[received - 2];                              Array.Copy(byReceivedAdd' 2' input' 0' received - 2);                              Inflater inf = new Inflater(false);                              inf.SetInput(input);                              inf.Inflate(buff);                              byReceivedAdd = buff;                              received = (int) inf.TotalOut;                          }                      }                      catch (SocketException sex)                      {                          // most likely we have timed out                          logger.Error(sex' sex.ToString());                          errorOccurred = true;                          errorMessage = sex.ToString();                      }                      catch (Exception ex)                      {                          logger.Error(ex' ex.ToString());                          errorOccurred = true;                          errorMessage = ex.ToString();                      }                      if ((commandType == enAniDBCommandType.Login) && (byReceivedAdd[0] == 0xFE) &&                          (byReceivedAdd[1] == 0xFF) &&                          (byReceivedAdd[3] == 53) && (byReceivedAdd[5] != 53) &&                          !Encoding.EncodingName.ToLower().StartsWith("unicode") && (changeencoding != null) &&                          changeencoding.EncodingName.ToLower().StartsWith("unicode"))                      {                          //Previous Session used utf-16 and was not logged out' AniDB was not yet issued a timeout.                          //AUTH command was not understand because it was encoded in ASCII.                          encoding = changeencoding;                          repeatcmd = true;                      }                  } while (repeatcmd);                    if (!errorOccurred)                  {                      if (changeencoding != null)                          encoding = changeencoding;                      System.Text.Encoding enco;                      if ((byReceivedAdd[0] == 0xFE) && (byReceivedAdd[1] == 0xFF))                          enco = encoding;                      else                          enco = Encoding.ASCII;                      decodedstring = enco.GetString(byReceivedAdd' 0' received);                        if (decodedstring[0] == 0xFEFF) // remove BOM                          decodedstring = decodedstring.Substring(1);                      if (commandType == enAniDBCommandType.GetAnimeDescription ||                          commandType == enAniDBCommandType.GetReview)                      {                          //Lets handle multipart                          part++;                          string[] sp1 = decodedstring.Split(new char[] {'\n'}' StringSplitOptions.RemoveEmptyEntries);                            if (sp1[0].StartsWith("233 ANIMEDESC") || sp1[0].StartsWith("233  ANIMEDESC"))                          {                              string[] sp2 = sp1[1].Split('|');                              fulldesc += sp2[2];                              maxpart = int.Parse(sp2[1]);                          }                            if (sp1[0].StartsWith("234 REVIEW") || sp1[0].StartsWith("234  REVIEW"))                          {                              string[] sp2 = sp1[1].Split('|');                                if (sp2.Length == 3)                                  fulldesc += sp2[2];                              else                              {                                  for (int i = 2; i < sp2.Length; i++)                                      fulldesc += "|" + sp2[i];                              }                                  maxpart = int.Parse(sp2[1]);                          }                          multipart = true;                          if (part == maxpart)                          {                              decodedstring = sp1[0] + "\n0|1|" + fulldesc + "\n";                              multipart = false;                          }                      }                  }              } while (multipart && !errorOccurred);
Magic Number,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The following statement contains a magic number: do              {                  if (part > 0)                  {                      mcommandText = mcommandText.Replace("part=" + (part - 1).ToString()' "part=" + part.ToString());                      AniDbRateLimiter.Instance.EnsureRate();                  }                  if (commandType != enAniDBCommandType.Login)                  {                      string msg = string.Format("UDP_COMMAND: {0}"' mcommandText);                      ShokoService.LogToSystem(Constants.DBLogType.APIAniDBUDP' msg);                  }                  else                  {                      //string msg = commandText.Replace(ShokoServer.settings.Username' "******");                      //msg = msg.Replace(ShokoServer.settings.Password' "******");                      //MyAnimeLog.Write("commandText: {0}"' msg);                  }                  bool repeatcmd;                  int received;                  Byte[] byReceivedAdd = new Byte[2000]; // max length should actually be 1400                  do                  {                      repeatcmd = false;                      // Send Message                      Byte[] SendByteAdd = Encoding.GetBytes(mcommandText.ToCharArray());                        try                      {                          ShokoService.LastAniDBMessage = DateTime.Now;                          ShokoService.LastAniDBUDPMessage = DateTime.Now;                          if (commandType != enAniDBCommandType.Ping)                              ShokoService.LastAniDBMessageNonPing = DateTime.Now;                          else                              ShokoService.LastAniDBPing = DateTime.Now;                            soUDP.SendTo(SendByteAdd' remoteIpEndPoint);                      }                      catch (Exception ex)                      {                          logger.Error(ex' ex.ToString());                          //MyAnimeLog.Write(ex.ToString());                          errorOccurred = true;                          errorMessage = ex.ToString();                      }                          // Receive Response                      received = 0;                      try                      {                          //MyAnimeLog.Write("soUDP.ReceiveTimeout = {0}"' soUDP.ReceiveTimeout.ToString());                              received = soUDP.ReceiveFrom(byReceivedAdd' ref RemotePoint);                          ShokoService.LastAniDBMessage = DateTime.Now;                          ShokoService.LastAniDBUDPMessage = DateTime.Now;                          if (commandType != enAniDBCommandType.Ping)                              ShokoService.LastAniDBMessageNonPing = DateTime.Now;                          else                              ShokoService.LastAniDBPing = DateTime.Now;                            //MyAnimeLog.Write("Buffer length = {0}"' received.ToString());                          if ((received > 2) && (byReceivedAdd[0] == 0) && (byReceivedAdd[1] == 0))                          {                              //deflate                              Byte[] buff = new byte[65536];                              Byte[] input = new byte[received - 2];                              Array.Copy(byReceivedAdd' 2' input' 0' received - 2);                              Inflater inf = new Inflater(false);                              inf.SetInput(input);                              inf.Inflate(buff);                              byReceivedAdd = buff;                              received = (int) inf.TotalOut;                          }                      }                      catch (SocketException sex)                      {                          // most likely we have timed out                          logger.Error(sex' sex.ToString());                          errorOccurred = true;                          errorMessage = sex.ToString();                      }                      catch (Exception ex)                      {                          logger.Error(ex' ex.ToString());                          errorOccurred = true;                          errorMessage = ex.ToString();                      }                      if ((commandType == enAniDBCommandType.Login) && (byReceivedAdd[0] == 0xFE) &&                          (byReceivedAdd[1] == 0xFF) &&                          (byReceivedAdd[3] == 53) && (byReceivedAdd[5] != 53) &&                          !Encoding.EncodingName.ToLower().StartsWith("unicode") && (changeencoding != null) &&                          changeencoding.EncodingName.ToLower().StartsWith("unicode"))                      {                          //Previous Session used utf-16 and was not logged out' AniDB was not yet issued a timeout.                          //AUTH command was not understand because it was encoded in ASCII.                          encoding = changeencoding;                          repeatcmd = true;                      }                  } while (repeatcmd);                    if (!errorOccurred)                  {                      if (changeencoding != null)                          encoding = changeencoding;                      System.Text.Encoding enco;                      if ((byReceivedAdd[0] == 0xFE) && (byReceivedAdd[1] == 0xFF))                          enco = encoding;                      else                          enco = Encoding.ASCII;                      decodedstring = enco.GetString(byReceivedAdd' 0' received);                        if (decodedstring[0] == 0xFEFF) // remove BOM                          decodedstring = decodedstring.Substring(1);                      if (commandType == enAniDBCommandType.GetAnimeDescription ||                          commandType == enAniDBCommandType.GetReview)                      {                          //Lets handle multipart                          part++;                          string[] sp1 = decodedstring.Split(new char[] {'\n'}' StringSplitOptions.RemoveEmptyEntries);                            if (sp1[0].StartsWith("233 ANIMEDESC") || sp1[0].StartsWith("233  ANIMEDESC"))                          {                              string[] sp2 = sp1[1].Split('|');                              fulldesc += sp2[2];                              maxpart = int.Parse(sp2[1]);                          }                            if (sp1[0].StartsWith("234 REVIEW") || sp1[0].StartsWith("234  REVIEW"))                          {                              string[] sp2 = sp1[1].Split('|');                                if (sp2.Length == 3)                                  fulldesc += sp2[2];                              else                              {                                  for (int i = 2; i < sp2.Length; i++)                                      fulldesc += "|" + sp2[i];                              }                                  maxpart = int.Parse(sp2[1]);                          }                          multipart = true;                          if (part == maxpart)                          {                              decodedstring = sp1[0] + "\n0|1|" + fulldesc + "\n";                              multipart = false;                          }                      }                  }              } while (multipart && !errorOccurred);
Magic Number,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The following statement contains a magic number: do              {                  if (part > 0)                  {                      mcommandText = mcommandText.Replace("part=" + (part - 1).ToString()' "part=" + part.ToString());                      AniDbRateLimiter.Instance.EnsureRate();                  }                  if (commandType != enAniDBCommandType.Login)                  {                      string msg = string.Format("UDP_COMMAND: {0}"' mcommandText);                      ShokoService.LogToSystem(Constants.DBLogType.APIAniDBUDP' msg);                  }                  else                  {                      //string msg = commandText.Replace(ShokoServer.settings.Username' "******");                      //msg = msg.Replace(ShokoServer.settings.Password' "******");                      //MyAnimeLog.Write("commandText: {0}"' msg);                  }                  bool repeatcmd;                  int received;                  Byte[] byReceivedAdd = new Byte[2000]; // max length should actually be 1400                  do                  {                      repeatcmd = false;                      // Send Message                      Byte[] SendByteAdd = Encoding.GetBytes(mcommandText.ToCharArray());                        try                      {                          ShokoService.LastAniDBMessage = DateTime.Now;                          ShokoService.LastAniDBUDPMessage = DateTime.Now;                          if (commandType != enAniDBCommandType.Ping)                              ShokoService.LastAniDBMessageNonPing = DateTime.Now;                          else                              ShokoService.LastAniDBPing = DateTime.Now;                            soUDP.SendTo(SendByteAdd' remoteIpEndPoint);                      }                      catch (Exception ex)                      {                          logger.Error(ex' ex.ToString());                          //MyAnimeLog.Write(ex.ToString());                          errorOccurred = true;                          errorMessage = ex.ToString();                      }                          // Receive Response                      received = 0;                      try                      {                          //MyAnimeLog.Write("soUDP.ReceiveTimeout = {0}"' soUDP.ReceiveTimeout.ToString());                              received = soUDP.ReceiveFrom(byReceivedAdd' ref RemotePoint);                          ShokoService.LastAniDBMessage = DateTime.Now;                          ShokoService.LastAniDBUDPMessage = DateTime.Now;                          if (commandType != enAniDBCommandType.Ping)                              ShokoService.LastAniDBMessageNonPing = DateTime.Now;                          else                              ShokoService.LastAniDBPing = DateTime.Now;                            //MyAnimeLog.Write("Buffer length = {0}"' received.ToString());                          if ((received > 2) && (byReceivedAdd[0] == 0) && (byReceivedAdd[1] == 0))                          {                              //deflate                              Byte[] buff = new byte[65536];                              Byte[] input = new byte[received - 2];                              Array.Copy(byReceivedAdd' 2' input' 0' received - 2);                              Inflater inf = new Inflater(false);                              inf.SetInput(input);                              inf.Inflate(buff);                              byReceivedAdd = buff;                              received = (int) inf.TotalOut;                          }                      }                      catch (SocketException sex)                      {                          // most likely we have timed out                          logger.Error(sex' sex.ToString());                          errorOccurred = true;                          errorMessage = sex.ToString();                      }                      catch (Exception ex)                      {                          logger.Error(ex' ex.ToString());                          errorOccurred = true;                          errorMessage = ex.ToString();                      }                      if ((commandType == enAniDBCommandType.Login) && (byReceivedAdd[0] == 0xFE) &&                          (byReceivedAdd[1] == 0xFF) &&                          (byReceivedAdd[3] == 53) && (byReceivedAdd[5] != 53) &&                          !Encoding.EncodingName.ToLower().StartsWith("unicode") && (changeencoding != null) &&                          changeencoding.EncodingName.ToLower().StartsWith("unicode"))                      {                          //Previous Session used utf-16 and was not logged out' AniDB was not yet issued a timeout.                          //AUTH command was not understand because it was encoded in ASCII.                          encoding = changeencoding;                          repeatcmd = true;                      }                  } while (repeatcmd);                    if (!errorOccurred)                  {                      if (changeencoding != null)                          encoding = changeencoding;                      System.Text.Encoding enco;                      if ((byReceivedAdd[0] == 0xFE) && (byReceivedAdd[1] == 0xFF))                          enco = encoding;                      else                          enco = Encoding.ASCII;                      decodedstring = enco.GetString(byReceivedAdd' 0' received);                        if (decodedstring[0] == 0xFEFF) // remove BOM                          decodedstring = decodedstring.Substring(1);                      if (commandType == enAniDBCommandType.GetAnimeDescription ||                          commandType == enAniDBCommandType.GetReview)                      {                          //Lets handle multipart                          part++;                          string[] sp1 = decodedstring.Split(new char[] {'\n'}' StringSplitOptions.RemoveEmptyEntries);                            if (sp1[0].StartsWith("233 ANIMEDESC") || sp1[0].StartsWith("233  ANIMEDESC"))                          {                              string[] sp2 = sp1[1].Split('|');                              fulldesc += sp2[2];                              maxpart = int.Parse(sp2[1]);                          }                            if (sp1[0].StartsWith("234 REVIEW") || sp1[0].StartsWith("234  REVIEW"))                          {                              string[] sp2 = sp1[1].Split('|');                                if (sp2.Length == 3)                                  fulldesc += sp2[2];                              else                              {                                  for (int i = 2; i < sp2.Length; i++)                                      fulldesc += "|" + sp2[i];                              }                                  maxpart = int.Parse(sp2[1]);                          }                          multipart = true;                          if (part == maxpart)                          {                              decodedstring = sp1[0] + "\n0|1|" + fulldesc + "\n";                              multipart = false;                          }                      }                  }              } while (multipart && !errorOccurred);
Magic Number,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The following statement contains a magic number: do              {                  if (part > 0)                  {                      mcommandText = mcommandText.Replace("part=" + (part - 1).ToString()' "part=" + part.ToString());                      AniDbRateLimiter.Instance.EnsureRate();                  }                  if (commandType != enAniDBCommandType.Login)                  {                      string msg = string.Format("UDP_COMMAND: {0}"' mcommandText);                      ShokoService.LogToSystem(Constants.DBLogType.APIAniDBUDP' msg);                  }                  else                  {                      //string msg = commandText.Replace(ShokoServer.settings.Username' "******");                      //msg = msg.Replace(ShokoServer.settings.Password' "******");                      //MyAnimeLog.Write("commandText: {0}"' msg);                  }                  bool repeatcmd;                  int received;                  Byte[] byReceivedAdd = new Byte[2000]; // max length should actually be 1400                  do                  {                      repeatcmd = false;                      // Send Message                      Byte[] SendByteAdd = Encoding.GetBytes(mcommandText.ToCharArray());                        try                      {                          ShokoService.LastAniDBMessage = DateTime.Now;                          ShokoService.LastAniDBUDPMessage = DateTime.Now;                          if (commandType != enAniDBCommandType.Ping)                              ShokoService.LastAniDBMessageNonPing = DateTime.Now;                          else                              ShokoService.LastAniDBPing = DateTime.Now;                            soUDP.SendTo(SendByteAdd' remoteIpEndPoint);                      }                      catch (Exception ex)                      {                          logger.Error(ex' ex.ToString());                          //MyAnimeLog.Write(ex.ToString());                          errorOccurred = true;                          errorMessage = ex.ToString();                      }                          // Receive Response                      received = 0;                      try                      {                          //MyAnimeLog.Write("soUDP.ReceiveTimeout = {0}"' soUDP.ReceiveTimeout.ToString());                              received = soUDP.ReceiveFrom(byReceivedAdd' ref RemotePoint);                          ShokoService.LastAniDBMessage = DateTime.Now;                          ShokoService.LastAniDBUDPMessage = DateTime.Now;                          if (commandType != enAniDBCommandType.Ping)                              ShokoService.LastAniDBMessageNonPing = DateTime.Now;                          else                              ShokoService.LastAniDBPing = DateTime.Now;                            //MyAnimeLog.Write("Buffer length = {0}"' received.ToString());                          if ((received > 2) && (byReceivedAdd[0] == 0) && (byReceivedAdd[1] == 0))                          {                              //deflate                              Byte[] buff = new byte[65536];                              Byte[] input = new byte[received - 2];                              Array.Copy(byReceivedAdd' 2' input' 0' received - 2);                              Inflater inf = new Inflater(false);                              inf.SetInput(input);                              inf.Inflate(buff);                              byReceivedAdd = buff;                              received = (int) inf.TotalOut;                          }                      }                      catch (SocketException sex)                      {                          // most likely we have timed out                          logger.Error(sex' sex.ToString());                          errorOccurred = true;                          errorMessage = sex.ToString();                      }                      catch (Exception ex)                      {                          logger.Error(ex' ex.ToString());                          errorOccurred = true;                          errorMessage = ex.ToString();                      }                      if ((commandType == enAniDBCommandType.Login) && (byReceivedAdd[0] == 0xFE) &&                          (byReceivedAdd[1] == 0xFF) &&                          (byReceivedAdd[3] == 53) && (byReceivedAdd[5] != 53) &&                          !Encoding.EncodingName.ToLower().StartsWith("unicode") && (changeencoding != null) &&                          changeencoding.EncodingName.ToLower().StartsWith("unicode"))                      {                          //Previous Session used utf-16 and was not logged out' AniDB was not yet issued a timeout.                          //AUTH command was not understand because it was encoded in ASCII.                          encoding = changeencoding;                          repeatcmd = true;                      }                  } while (repeatcmd);                    if (!errorOccurred)                  {                      if (changeencoding != null)                          encoding = changeencoding;                      System.Text.Encoding enco;                      if ((byReceivedAdd[0] == 0xFE) && (byReceivedAdd[1] == 0xFF))                          enco = encoding;                      else                          enco = Encoding.ASCII;                      decodedstring = enco.GetString(byReceivedAdd' 0' received);                        if (decodedstring[0] == 0xFEFF) // remove BOM                          decodedstring = decodedstring.Substring(1);                      if (commandType == enAniDBCommandType.GetAnimeDescription ||                          commandType == enAniDBCommandType.GetReview)                      {                          //Lets handle multipart                          part++;                          string[] sp1 = decodedstring.Split(new char[] {'\n'}' StringSplitOptions.RemoveEmptyEntries);                            if (sp1[0].StartsWith("233 ANIMEDESC") || sp1[0].StartsWith("233  ANIMEDESC"))                          {                              string[] sp2 = sp1[1].Split('|');                              fulldesc += sp2[2];                              maxpart = int.Parse(sp2[1]);                          }                            if (sp1[0].StartsWith("234 REVIEW") || sp1[0].StartsWith("234  REVIEW"))                          {                              string[] sp2 = sp1[1].Split('|');                                if (sp2.Length == 3)                                  fulldesc += sp2[2];                              else                              {                                  for (int i = 2; i < sp2.Length; i++)                                      fulldesc += "|" + sp2[i];                              }                                  maxpart = int.Parse(sp2[1]);                          }                          multipart = true;                          if (part == maxpart)                          {                              decodedstring = sp1[0] + "\n0|1|" + fulldesc + "\n";                              multipart = false;                          }                      }                  }              } while (multipart && !errorOccurred);
Magic Number,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The following statement contains a magic number: do              {                  if (part > 0)                  {                      mcommandText = mcommandText.Replace("part=" + (part - 1).ToString()' "part=" + part.ToString());                      AniDbRateLimiter.Instance.EnsureRate();                  }                  if (commandType != enAniDBCommandType.Login)                  {                      string msg = string.Format("UDP_COMMAND: {0}"' mcommandText);                      ShokoService.LogToSystem(Constants.DBLogType.APIAniDBUDP' msg);                  }                  else                  {                      //string msg = commandText.Replace(ShokoServer.settings.Username' "******");                      //msg = msg.Replace(ShokoServer.settings.Password' "******");                      //MyAnimeLog.Write("commandText: {0}"' msg);                  }                  bool repeatcmd;                  int received;                  Byte[] byReceivedAdd = new Byte[2000]; // max length should actually be 1400                  do                  {                      repeatcmd = false;                      // Send Message                      Byte[] SendByteAdd = Encoding.GetBytes(mcommandText.ToCharArray());                        try                      {                          ShokoService.LastAniDBMessage = DateTime.Now;                          ShokoService.LastAniDBUDPMessage = DateTime.Now;                          if (commandType != enAniDBCommandType.Ping)                              ShokoService.LastAniDBMessageNonPing = DateTime.Now;                          else                              ShokoService.LastAniDBPing = DateTime.Now;                            soUDP.SendTo(SendByteAdd' remoteIpEndPoint);                      }                      catch (Exception ex)                      {                          logger.Error(ex' ex.ToString());                          //MyAnimeLog.Write(ex.ToString());                          errorOccurred = true;                          errorMessage = ex.ToString();                      }                          // Receive Response                      received = 0;                      try                      {                          //MyAnimeLog.Write("soUDP.ReceiveTimeout = {0}"' soUDP.ReceiveTimeout.ToString());                              received = soUDP.ReceiveFrom(byReceivedAdd' ref RemotePoint);                          ShokoService.LastAniDBMessage = DateTime.Now;                          ShokoService.LastAniDBUDPMessage = DateTime.Now;                          if (commandType != enAniDBCommandType.Ping)                              ShokoService.LastAniDBMessageNonPing = DateTime.Now;                          else                              ShokoService.LastAniDBPing = DateTime.Now;                            //MyAnimeLog.Write("Buffer length = {0}"' received.ToString());                          if ((received > 2) && (byReceivedAdd[0] == 0) && (byReceivedAdd[1] == 0))                          {                              //deflate                              Byte[] buff = new byte[65536];                              Byte[] input = new byte[received - 2];                              Array.Copy(byReceivedAdd' 2' input' 0' received - 2);                              Inflater inf = new Inflater(false);                              inf.SetInput(input);                              inf.Inflate(buff);                              byReceivedAdd = buff;                              received = (int) inf.TotalOut;                          }                      }                      catch (SocketException sex)                      {                          // most likely we have timed out                          logger.Error(sex' sex.ToString());                          errorOccurred = true;                          errorMessage = sex.ToString();                      }                      catch (Exception ex)                      {                          logger.Error(ex' ex.ToString());                          errorOccurred = true;                          errorMessage = ex.ToString();                      }                      if ((commandType == enAniDBCommandType.Login) && (byReceivedAdd[0] == 0xFE) &&                          (byReceivedAdd[1] == 0xFF) &&                          (byReceivedAdd[3] == 53) && (byReceivedAdd[5] != 53) &&                          !Encoding.EncodingName.ToLower().StartsWith("unicode") && (changeencoding != null) &&                          changeencoding.EncodingName.ToLower().StartsWith("unicode"))                      {                          //Previous Session used utf-16 and was not logged out' AniDB was not yet issued a timeout.                          //AUTH command was not understand because it was encoded in ASCII.                          encoding = changeencoding;                          repeatcmd = true;                      }                  } while (repeatcmd);                    if (!errorOccurred)                  {                      if (changeencoding != null)                          encoding = changeencoding;                      System.Text.Encoding enco;                      if ((byReceivedAdd[0] == 0xFE) && (byReceivedAdd[1] == 0xFF))                          enco = encoding;                      else                          enco = Encoding.ASCII;                      decodedstring = enco.GetString(byReceivedAdd' 0' received);                        if (decodedstring[0] == 0xFEFF) // remove BOM                          decodedstring = decodedstring.Substring(1);                      if (commandType == enAniDBCommandType.GetAnimeDescription ||                          commandType == enAniDBCommandType.GetReview)                      {                          //Lets handle multipart                          part++;                          string[] sp1 = decodedstring.Split(new char[] {'\n'}' StringSplitOptions.RemoveEmptyEntries);                            if (sp1[0].StartsWith("233 ANIMEDESC") || sp1[0].StartsWith("233  ANIMEDESC"))                          {                              string[] sp2 = sp1[1].Split('|');                              fulldesc += sp2[2];                              maxpart = int.Parse(sp2[1]);                          }                            if (sp1[0].StartsWith("234 REVIEW") || sp1[0].StartsWith("234  REVIEW"))                          {                              string[] sp2 = sp1[1].Split('|');                                if (sp2.Length == 3)                                  fulldesc += sp2[2];                              else                              {                                  for (int i = 2; i < sp2.Length; i++)                                      fulldesc += "|" + sp2[i];                              }                                  maxpart = int.Parse(sp2[1]);                          }                          multipart = true;                          if (part == maxpart)                          {                              decodedstring = sp1[0] + "\n0|1|" + fulldesc + "\n";                              multipart = false;                          }                      }                  }              } while (multipart && !errorOccurred);
Magic Number,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The following statement contains a magic number: do              {                  if (part > 0)                  {                      mcommandText = mcommandText.Replace("part=" + (part - 1).ToString()' "part=" + part.ToString());                      AniDbRateLimiter.Instance.EnsureRate();                  }                  if (commandType != enAniDBCommandType.Login)                  {                      string msg = string.Format("UDP_COMMAND: {0}"' mcommandText);                      ShokoService.LogToSystem(Constants.DBLogType.APIAniDBUDP' msg);                  }                  else                  {                      //string msg = commandText.Replace(ShokoServer.settings.Username' "******");                      //msg = msg.Replace(ShokoServer.settings.Password' "******");                      //MyAnimeLog.Write("commandText: {0}"' msg);                  }                  bool repeatcmd;                  int received;                  Byte[] byReceivedAdd = new Byte[2000]; // max length should actually be 1400                  do                  {                      repeatcmd = false;                      // Send Message                      Byte[] SendByteAdd = Encoding.GetBytes(mcommandText.ToCharArray());                        try                      {                          ShokoService.LastAniDBMessage = DateTime.Now;                          ShokoService.LastAniDBUDPMessage = DateTime.Now;                          if (commandType != enAniDBCommandType.Ping)                              ShokoService.LastAniDBMessageNonPing = DateTime.Now;                          else                              ShokoService.LastAniDBPing = DateTime.Now;                            soUDP.SendTo(SendByteAdd' remoteIpEndPoint);                      }                      catch (Exception ex)                      {                          logger.Error(ex' ex.ToString());                          //MyAnimeLog.Write(ex.ToString());                          errorOccurred = true;                          errorMessage = ex.ToString();                      }                          // Receive Response                      received = 0;                      try                      {                          //MyAnimeLog.Write("soUDP.ReceiveTimeout = {0}"' soUDP.ReceiveTimeout.ToString());                              received = soUDP.ReceiveFrom(byReceivedAdd' ref RemotePoint);                          ShokoService.LastAniDBMessage = DateTime.Now;                          ShokoService.LastAniDBUDPMessage = DateTime.Now;                          if (commandType != enAniDBCommandType.Ping)                              ShokoService.LastAniDBMessageNonPing = DateTime.Now;                          else                              ShokoService.LastAniDBPing = DateTime.Now;                            //MyAnimeLog.Write("Buffer length = {0}"' received.ToString());                          if ((received > 2) && (byReceivedAdd[0] == 0) && (byReceivedAdd[1] == 0))                          {                              //deflate                              Byte[] buff = new byte[65536];                              Byte[] input = new byte[received - 2];                              Array.Copy(byReceivedAdd' 2' input' 0' received - 2);                              Inflater inf = new Inflater(false);                              inf.SetInput(input);                              inf.Inflate(buff);                              byReceivedAdd = buff;                              received = (int) inf.TotalOut;                          }                      }                      catch (SocketException sex)                      {                          // most likely we have timed out                          logger.Error(sex' sex.ToString());                          errorOccurred = true;                          errorMessage = sex.ToString();                      }                      catch (Exception ex)                      {                          logger.Error(ex' ex.ToString());                          errorOccurred = true;                          errorMessage = ex.ToString();                      }                      if ((commandType == enAniDBCommandType.Login) && (byReceivedAdd[0] == 0xFE) &&                          (byReceivedAdd[1] == 0xFF) &&                          (byReceivedAdd[3] == 53) && (byReceivedAdd[5] != 53) &&                          !Encoding.EncodingName.ToLower().StartsWith("unicode") && (changeencoding != null) &&                          changeencoding.EncodingName.ToLower().StartsWith("unicode"))                      {                          //Previous Session used utf-16 and was not logged out' AniDB was not yet issued a timeout.                          //AUTH command was not understand because it was encoded in ASCII.                          encoding = changeencoding;                          repeatcmd = true;                      }                  } while (repeatcmd);                    if (!errorOccurred)                  {                      if (changeencoding != null)                          encoding = changeencoding;                      System.Text.Encoding enco;                      if ((byReceivedAdd[0] == 0xFE) && (byReceivedAdd[1] == 0xFF))                          enco = encoding;                      else                          enco = Encoding.ASCII;                      decodedstring = enco.GetString(byReceivedAdd' 0' received);                        if (decodedstring[0] == 0xFEFF) // remove BOM                          decodedstring = decodedstring.Substring(1);                      if (commandType == enAniDBCommandType.GetAnimeDescription ||                          commandType == enAniDBCommandType.GetReview)                      {                          //Lets handle multipart                          part++;                          string[] sp1 = decodedstring.Split(new char[] {'\n'}' StringSplitOptions.RemoveEmptyEntries);                            if (sp1[0].StartsWith("233 ANIMEDESC") || sp1[0].StartsWith("233  ANIMEDESC"))                          {                              string[] sp2 = sp1[1].Split('|');                              fulldesc += sp2[2];                              maxpart = int.Parse(sp2[1]);                          }                            if (sp1[0].StartsWith("234 REVIEW") || sp1[0].StartsWith("234  REVIEW"))                          {                              string[] sp2 = sp1[1].Split('|');                                if (sp2.Length == 3)                                  fulldesc += sp2[2];                              else                              {                                  for (int i = 2; i < sp2.Length; i++)                                      fulldesc += "|" + sp2[i];                              }                                  maxpart = int.Parse(sp2[1]);                          }                          multipart = true;                          if (part == maxpart)                          {                              decodedstring = sp1[0] + "\n0|1|" + fulldesc + "\n";                              multipart = false;                          }                      }                  }              } while (multipart && !errorOccurred);
Magic Number,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The following statement contains a magic number: do              {                  if (part > 0)                  {                      mcommandText = mcommandText.Replace("part=" + (part - 1).ToString()' "part=" + part.ToString());                      AniDbRateLimiter.Instance.EnsureRate();                  }                  if (commandType != enAniDBCommandType.Login)                  {                      string msg = string.Format("UDP_COMMAND: {0}"' mcommandText);                      ShokoService.LogToSystem(Constants.DBLogType.APIAniDBUDP' msg);                  }                  else                  {                      //string msg = commandText.Replace(ShokoServer.settings.Username' "******");                      //msg = msg.Replace(ShokoServer.settings.Password' "******");                      //MyAnimeLog.Write("commandText: {0}"' msg);                  }                  bool repeatcmd;                  int received;                  Byte[] byReceivedAdd = new Byte[2000]; // max length should actually be 1400                  do                  {                      repeatcmd = false;                      // Send Message                      Byte[] SendByteAdd = Encoding.GetBytes(mcommandText.ToCharArray());                        try                      {                          ShokoService.LastAniDBMessage = DateTime.Now;                          ShokoService.LastAniDBUDPMessage = DateTime.Now;                          if (commandType != enAniDBCommandType.Ping)                              ShokoService.LastAniDBMessageNonPing = DateTime.Now;                          else                              ShokoService.LastAniDBPing = DateTime.Now;                            soUDP.SendTo(SendByteAdd' remoteIpEndPoint);                      }                      catch (Exception ex)                      {                          logger.Error(ex' ex.ToString());                          //MyAnimeLog.Write(ex.ToString());                          errorOccurred = true;                          errorMessage = ex.ToString();                      }                          // Receive Response                      received = 0;                      try                      {                          //MyAnimeLog.Write("soUDP.ReceiveTimeout = {0}"' soUDP.ReceiveTimeout.ToString());                              received = soUDP.ReceiveFrom(byReceivedAdd' ref RemotePoint);                          ShokoService.LastAniDBMessage = DateTime.Now;                          ShokoService.LastAniDBUDPMessage = DateTime.Now;                          if (commandType != enAniDBCommandType.Ping)                              ShokoService.LastAniDBMessageNonPing = DateTime.Now;                          else                              ShokoService.LastAniDBPing = DateTime.Now;                            //MyAnimeLog.Write("Buffer length = {0}"' received.ToString());                          if ((received > 2) && (byReceivedAdd[0] == 0) && (byReceivedAdd[1] == 0))                          {                              //deflate                              Byte[] buff = new byte[65536];                              Byte[] input = new byte[received - 2];                              Array.Copy(byReceivedAdd' 2' input' 0' received - 2);                              Inflater inf = new Inflater(false);                              inf.SetInput(input);                              inf.Inflate(buff);                              byReceivedAdd = buff;                              received = (int) inf.TotalOut;                          }                      }                      catch (SocketException sex)                      {                          // most likely we have timed out                          logger.Error(sex' sex.ToString());                          errorOccurred = true;                          errorMessage = sex.ToString();                      }                      catch (Exception ex)                      {                          logger.Error(ex' ex.ToString());                          errorOccurred = true;                          errorMessage = ex.ToString();                      }                      if ((commandType == enAniDBCommandType.Login) && (byReceivedAdd[0] == 0xFE) &&                          (byReceivedAdd[1] == 0xFF) &&                          (byReceivedAdd[3] == 53) && (byReceivedAdd[5] != 53) &&                          !Encoding.EncodingName.ToLower().StartsWith("unicode") && (changeencoding != null) &&                          changeencoding.EncodingName.ToLower().StartsWith("unicode"))                      {                          //Previous Session used utf-16 and was not logged out' AniDB was not yet issued a timeout.                          //AUTH command was not understand because it was encoded in ASCII.                          encoding = changeencoding;                          repeatcmd = true;                      }                  } while (repeatcmd);                    if (!errorOccurred)                  {                      if (changeencoding != null)                          encoding = changeencoding;                      System.Text.Encoding enco;                      if ((byReceivedAdd[0] == 0xFE) && (byReceivedAdd[1] == 0xFF))                          enco = encoding;                      else                          enco = Encoding.ASCII;                      decodedstring = enco.GetString(byReceivedAdd' 0' received);                        if (decodedstring[0] == 0xFEFF) // remove BOM                          decodedstring = decodedstring.Substring(1);                      if (commandType == enAniDBCommandType.GetAnimeDescription ||                          commandType == enAniDBCommandType.GetReview)                      {                          //Lets handle multipart                          part++;                          string[] sp1 = decodedstring.Split(new char[] {'\n'}' StringSplitOptions.RemoveEmptyEntries);                            if (sp1[0].StartsWith("233 ANIMEDESC") || sp1[0].StartsWith("233  ANIMEDESC"))                          {                              string[] sp2 = sp1[1].Split('|');                              fulldesc += sp2[2];                              maxpart = int.Parse(sp2[1]);                          }                            if (sp1[0].StartsWith("234 REVIEW") || sp1[0].StartsWith("234  REVIEW"))                          {                              string[] sp2 = sp1[1].Split('|');                                if (sp2.Length == 3)                                  fulldesc += sp2[2];                              else                              {                                  for (int i = 2; i < sp2.Length; i++)                                      fulldesc += "|" + sp2[i];                              }                                  maxpart = int.Parse(sp2[1]);                          }                          multipart = true;                          if (part == maxpart)                          {                              decodedstring = sp1[0] + "\n0|1|" + fulldesc + "\n";                              multipart = false;                          }                      }                  }              } while (multipart && !errorOccurred);
Magic Number,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The following statement contains a magic number: if (errorOccurred)              {                  socketResponse = string.Empty;              }              else              {                  // there should be 2 newline characters in each response                  // the first is after the command .e.g "220 FILE"                  // the second is at the end of the data                  int i = 0' ipos = 0' foundpos = 0;                  foreach (char c in decodedstring)                  {                      if (c == '\n')                      {                          //MyAnimeLog.Write("NEWLINE FOUND AT: {0}"' ipos);                          i++;                          foundpos = ipos;                      }                      ipos++;                  }                    if (i != 2)                  {                      socketResponse = decodedstring;                        TimeSpan ts = DateTime.Now - start;                      string msg = string.Format("UDP_RESPONSE in {0} ms - {1} "' ts.TotalMilliseconds' socketResponse);                      ShokoService.LogToSystem(Constants.DBLogType.APIAniDBUDP' msg);                  }                  else                  {                      socketResponse = decodedstring.Substring(0' foundpos + 1);                        TimeSpan ts = DateTime.Now - start;                      string msg = string.Format("UDP_RESPONSE_TRUNC in {0}ms - {1} "' ts.TotalMilliseconds'                          socketResponse);                      ShokoService.LogToSystem(Constants.DBLogType.APIAniDBUDP' msg);                  }              }
Magic Number,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The following statement contains a magic number: if (socketResponse.Length > 2)                  int.TryParse(socketResponse.Substring(0' 3)' out val);
Magic Number,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The following statement contains a magic number: if (socketResponse.Length > 2)                  int.TryParse(socketResponse.Substring(0' 3)' out val);
Magic Number,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The following statement contains a magic number: if (ResponseCode == 555)              {                  ShokoService.AnidbProcessor.IsBanned = true;                  ShokoService.AnidbProcessor.BanOrigin = "UDP";              }              else              {                  ShokoService.AnidbProcessor.IsBanned = false;                  ShokoService.AnidbProcessor.BanOrigin = string.Empty;              }
Magic Number,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The following statement contains a magic number: if (ResponseCode == 598 || ResponseCode == 506 || ResponseCode == 506)              {                  ShokoService.AnidbProcessor.IsInvalidSession = true;                  logger.Trace("FORCING Logout because of invalid session");                  ForceReconnection();              }
Magic Number,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The following statement contains a magic number: if (ResponseCode == 598 || ResponseCode == 506 || ResponseCode == 506)              {                  ShokoService.AnidbProcessor.IsInvalidSession = true;                  logger.Trace("FORCING Logout because of invalid session");                  ForceReconnection();              }
Magic Number,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The following statement contains a magic number: if (ResponseCode == 598 || ResponseCode == 506 || ResponseCode == 506)              {                  ShokoService.AnidbProcessor.IsInvalidSession = true;                  logger.Trace("FORCING Logout because of invalid session");                  ForceReconnection();              }
Magic Number,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The following statement contains a magic number: if (ResponseCode == 600 || ResponseCode == 601 || ResponseCode == 602 || ResponseCode == 604)              {                  string errormsg = string.Empty;                  switch (ResponseCode)                  {                      case 600:                          errormsg = "600 INTERNAL SERVER ERROR";                          break;                      case 601:                          errormsg = "601 ANIDB OUT OF SERVICE - TRY AGAIN LATER";                          break;                      case 602:                          errormsg = "602 SERVER BUSY - TRY AGAIN LATER";                          break;                      case 604:                          errormsg = "TIMEOUT - DELAY AND RESUBMIT";                          break;                  }                  logger.Trace("FORCING Logout because of invalid session");                  ShokoService.AnidbProcessor.ExtendPause(300' errormsg);              }
Magic Number,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The following statement contains a magic number: if (ResponseCode == 600 || ResponseCode == 601 || ResponseCode == 602 || ResponseCode == 604)              {                  string errormsg = string.Empty;                  switch (ResponseCode)                  {                      case 600:                          errormsg = "600 INTERNAL SERVER ERROR";                          break;                      case 601:                          errormsg = "601 ANIDB OUT OF SERVICE - TRY AGAIN LATER";                          break;                      case 602:                          errormsg = "602 SERVER BUSY - TRY AGAIN LATER";                          break;                      case 604:                          errormsg = "TIMEOUT - DELAY AND RESUBMIT";                          break;                  }                  logger.Trace("FORCING Logout because of invalid session");                  ShokoService.AnidbProcessor.ExtendPause(300' errormsg);              }
Magic Number,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The following statement contains a magic number: if (ResponseCode == 600 || ResponseCode == 601 || ResponseCode == 602 || ResponseCode == 604)              {                  string errormsg = string.Empty;                  switch (ResponseCode)                  {                      case 600:                          errormsg = "600 INTERNAL SERVER ERROR";                          break;                      case 601:                          errormsg = "601 ANIDB OUT OF SERVICE - TRY AGAIN LATER";                          break;                      case 602:                          errormsg = "602 SERVER BUSY - TRY AGAIN LATER";                          break;                      case 604:                          errormsg = "TIMEOUT - DELAY AND RESUBMIT";                          break;                  }                  logger.Trace("FORCING Logout because of invalid session");                  ShokoService.AnidbProcessor.ExtendPause(300' errormsg);              }
Magic Number,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The following statement contains a magic number: if (ResponseCode == 600 || ResponseCode == 601 || ResponseCode == 602 || ResponseCode == 604)              {                  string errormsg = string.Empty;                  switch (ResponseCode)                  {                      case 600:                          errormsg = "600 INTERNAL SERVER ERROR";                          break;                      case 601:                          errormsg = "601 ANIDB OUT OF SERVICE - TRY AGAIN LATER";                          break;                      case 602:                          errormsg = "602 SERVER BUSY - TRY AGAIN LATER";                          break;                      case 604:                          errormsg = "TIMEOUT - DELAY AND RESUBMIT";                          break;                  }                  logger.Trace("FORCING Logout because of invalid session");                  ShokoService.AnidbProcessor.ExtendPause(300' errormsg);              }
Magic Number,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The following statement contains a magic number: if (ResponseCode == 600 || ResponseCode == 601 || ResponseCode == 602 || ResponseCode == 604)              {                  string errormsg = string.Empty;                  switch (ResponseCode)                  {                      case 600:                          errormsg = "600 INTERNAL SERVER ERROR";                          break;                      case 601:                          errormsg = "601 ANIDB OUT OF SERVICE - TRY AGAIN LATER";                          break;                      case 602:                          errormsg = "602 SERVER BUSY - TRY AGAIN LATER";                          break;                      case 604:                          errormsg = "TIMEOUT - DELAY AND RESUBMIT";                          break;                  }                  logger.Trace("FORCING Logout because of invalid session");                  ShokoService.AnidbProcessor.ExtendPause(300' errormsg);              }
Magic Number,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The following statement contains a magic number: if (ResponseCode == 600 || ResponseCode == 601 || ResponseCode == 602 || ResponseCode == 604)              {                  string errormsg = string.Empty;                  switch (ResponseCode)                  {                      case 600:                          errormsg = "600 INTERNAL SERVER ERROR";                          break;                      case 601:                          errormsg = "601 ANIDB OUT OF SERVICE - TRY AGAIN LATER";                          break;                      case 602:                          errormsg = "602 SERVER BUSY - TRY AGAIN LATER";                          break;                      case 604:                          errormsg = "TIMEOUT - DELAY AND RESUBMIT";                          break;                  }                  logger.Trace("FORCING Logout because of invalid session");                  ShokoService.AnidbProcessor.ExtendPause(300' errormsg);              }
Magic Number,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The following statement contains a magic number: if (ResponseCode == 600 || ResponseCode == 601 || ResponseCode == 602 || ResponseCode == 604)              {                  string errormsg = string.Empty;                  switch (ResponseCode)                  {                      case 600:                          errormsg = "600 INTERNAL SERVER ERROR";                          break;                      case 601:                          errormsg = "601 ANIDB OUT OF SERVICE - TRY AGAIN LATER";                          break;                      case 602:                          errormsg = "602 SERVER BUSY - TRY AGAIN LATER";                          break;                      case 604:                          errormsg = "TIMEOUT - DELAY AND RESUBMIT";                          break;                  }                  logger.Trace("FORCING Logout because of invalid session");                  ShokoService.AnidbProcessor.ExtendPause(300' errormsg);              }
Magic Number,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The following statement contains a magic number: if (ResponseCode == 600 || ResponseCode == 601 || ResponseCode == 602 || ResponseCode == 604)              {                  string errormsg = string.Empty;                  switch (ResponseCode)                  {                      case 600:                          errormsg = "600 INTERNAL SERVER ERROR";                          break;                      case 601:                          errormsg = "601 ANIDB OUT OF SERVICE - TRY AGAIN LATER";                          break;                      case 602:                          errormsg = "602 SERVER BUSY - TRY AGAIN LATER";                          break;                      case 604:                          errormsg = "TIMEOUT - DELAY AND RESUBMIT";                          break;                  }                  logger.Trace("FORCING Logout because of invalid session");                  ShokoService.AnidbProcessor.ExtendPause(300' errormsg);              }
Magic Number,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The following statement contains a magic number: if (ResponseCode == 600 || ResponseCode == 601 || ResponseCode == 602 || ResponseCode == 604)              {                  string errormsg = string.Empty;                  switch (ResponseCode)                  {                      case 600:                          errormsg = "600 INTERNAL SERVER ERROR";                          break;                      case 601:                          errormsg = "601 ANIDB OUT OF SERVICE - TRY AGAIN LATER";                          break;                      case 602:                          errormsg = "602 SERVER BUSY - TRY AGAIN LATER";                          break;                      case 604:                          errormsg = "TIMEOUT - DELAY AND RESUBMIT";                          break;                  }                  logger.Trace("FORCING Logout because of invalid session");                  ShokoService.AnidbProcessor.ExtendPause(300' errormsg);              }
Magic Number,Shoko.Server.Commands,AniDBCommand_GetGroup,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetGroup.cs,Process,The following statement contains a magic number: if (ResponseCode == 598) return enHelperActivityType.UnknownCommand_598;
Magic Number,Shoko.Server.Commands,AniDBCommand_GetGroup,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetGroup.cs,Process,The following statement contains a magic number: if (ResponseCode == 555) return enHelperActivityType.Banned_555;
Magic Number,Shoko.Server.Commands,AniDBCommand_GetGroup,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetGroup.cs,Process,The following statement contains a magic number: string sMsgType = socketResponse.Substring(0' 3);
Magic Number,Shoko.Server.Commands,CommandRequest_DownloadImage,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_DownloadImage.cs,ProcessCommand,The following statement contains a magic number: try              {                  ImageDownloadRequest req = null;                  switch (EntityTypeEnum)                  {                      case ImageEntityType.TvDB_Episode:                          TvDB_Episode ep = RepoFactory.TvDB_Episode.GetByID(EntityID);                          if (string.IsNullOrEmpty(ep?.Filename))                          {                              logger.Warn($"TvDB Episode image failed to download: Can't get episode with ID: {EntityID}");                              return;                          }                          req = new ImageDownloadRequest(EntityTypeEnum' ep' ForceDownload);                          break;                        case ImageEntityType.TvDB_FanArt:                          TvDB_ImageFanart fanart = RepoFactory.TvDB_ImageFanart.GetByID(EntityID);                          if (string.IsNullOrEmpty(fanart?.BannerPath))                          {                              logger.Warn($"TvDB Fanart image failed to download: Can't find valid fanart with ID: {EntityID}");                              RemoveImageRecord();                              return;                          }                          req = new ImageDownloadRequest(EntityTypeEnum' fanart' ForceDownload);                          break;                        case ImageEntityType.TvDB_Cover:                          TvDB_ImagePoster poster = RepoFactory.TvDB_ImagePoster.GetByID(EntityID);                          if (string.IsNullOrEmpty(poster?.BannerPath))                          {                              logger.Warn($"TvDB Poster image failed to download: Can't find valid poster with ID: {EntityID}");                              RemoveImageRecord();                              return;                          }                          req = new ImageDownloadRequest(EntityTypeEnum' poster' ForceDownload);                          break;                        case ImageEntityType.TvDB_Banner:                          TvDB_ImageWideBanner wideBanner = RepoFactory.TvDB_ImageWideBanner.GetByID(EntityID);                          if (string.IsNullOrEmpty(wideBanner?.BannerPath))                          {                              logger.Warn($"TvDB Banner image failed to download: Can't find valid banner with ID: {EntityID}");                              RemoveImageRecord();                              return;                          }                          req = new ImageDownloadRequest(EntityTypeEnum' wideBanner' ForceDownload);                          break;                        case ImageEntityType.MovieDB_Poster:                          MovieDB_Poster moviePoster = RepoFactory.MovieDB_Poster.GetByID(EntityID);                          if (string.IsNullOrEmpty(moviePoster?.URL))                          {                              logger.Warn($"MovieDB Poster image failed to download: Can't find valid poster with ID: {EntityID}");                              RemoveImageRecord();                              return;                          }                          req = new ImageDownloadRequest(EntityTypeEnum' moviePoster' ForceDownload);                          break;                        case ImageEntityType.MovieDB_FanArt:                          MovieDB_Fanart movieFanart = RepoFactory.MovieDB_Fanart.GetByID(EntityID);                          if (string.IsNullOrEmpty(movieFanart?.URL))                          {                              logger.Warn($"MovieDB Fanart image failed to download: Can't find valid fanart with ID: {EntityID}");                              return;                          }                          req = new ImageDownloadRequest(EntityTypeEnum' movieFanart' ForceDownload);                          break;                        case ImageEntityType.AniDB_Cover:                          SVR_AniDB_Anime anime = RepoFactory.AniDB_Anime.GetByAnimeID(EntityID);                          if (anime == null)                          {                              logger.Warn($"AniDB poster image failed to download: Can't find AniDB_Anime with ID: {EntityID}");                              return;                          }                          AniDbImageRateLimiter.Instance.EnsureRate();                          req = new ImageDownloadRequest(EntityTypeEnum' anime' ForceDownload);                          break;                        case ImageEntityType.AniDB_Character:                          AniDB_Character chr = RepoFactory.AniDB_Character.GetByCharID(EntityID);                          if (chr == null)                          {                              logger.Warn($"AniDB Character image failed to download: Can't find AniDB Character with ID: {EntityID}");                              return;                          }                          AniDbImageRateLimiter.Instance.EnsureRate();                          req = new ImageDownloadRequest(EntityTypeEnum' chr' ForceDownload);                          break;                        case ImageEntityType.AniDB_Creator:                          AniDB_Seiyuu creator = RepoFactory.AniDB_Seiyuu.GetBySeiyuuID(EntityID);                          if (creator == null)                          {                              logger.Warn($"AniDB Seiyuu image failed to download: Can't find Seiyuu with ID: {EntityID}");                              return;                          }                          AniDbImageRateLimiter.Instance.EnsureRate();                          req = new ImageDownloadRequest(EntityTypeEnum' creator' ForceDownload);                          break;                  }                    if (req == null)                  {                      logger.Warn($"Image failed to download: No implementation found for {EntityTypeEnum}");                      return;                  }                    List<string> fileNames = new List<string>();                  List<string> downloadURLs = new List<string>();                    string fileNameTemp = GetFileName(req' false);                  string downloadURLTemp = GetFileURL(req' false);                    fileNames.Add(fileNameTemp);                  downloadURLs.Add(downloadURLTemp);                    if (req.ImageType == ImageEntityType.TvDB_FanArt)                  {                      fileNameTemp = GetFileName(req' true);                      downloadURLTemp = GetFileURL(req' true);                        fileNames.Add(fileNameTemp);                      downloadURLs.Add(downloadURLTemp);                  }                    for (int i = 0; i < fileNames.Count; i++)                  {                      try                      {                          string fileName = fileNames[i];                          downloadURL = downloadURLs[i];                            bool downloadImage = true;                          bool fileExists = File.Exists(fileName);                          bool imageValid = fileExists && Misc.IsImageValid(fileName);                            if (imageValid && !req.ForceDownload) downloadImage = false;                            if (!downloadImage) continue;                            string tempName = Path.Combine(ImageUtils.GetImagesTempFolder()' Path.GetFileName(fileName));                            try                          {                              if (fileExists) File.Delete(fileName);                          }                          catch (Exception ex)                          {                              Thread.CurrentThread.CurrentUICulture = CultureInfo.GetCultureInfo(ServerSettings.Culture);                                logger.Warn(Resources.Command_DeleteError' fileName' ex.Message);                              return;                          }                            // If this has any issues' it will throw an exception' so the catch below will handle it                          RecursivelyRetryDownload(downloadURL' ref tempName' 0' 5);                            // move the file to it's final location                          // check that the final folder exists                          string fullPath = Path.GetDirectoryName(fileName);                          if (!Directory.Exists(fullPath))                              Directory.CreateDirectory(fullPath);                            File.Move(tempName' fileName);                          logger.Info($"Image downloaded: {fileName} from {downloadURL}");                      }                      catch (WebException e)                      {                          logger.Warn("Error processing CommandRequest_DownloadImage: {0} ({1}) - {2}"' downloadURL'                              EntityID'                              e.Message);                          // Remove the record if the image doesn't exist or can't download                          RemoveImageRecord();                      }                  }              }              catch (Exception ex)              {                  logger.Warn("Error processing CommandRequest_DownloadImage: {0} ({1}) - {2}"' downloadURL' EntityID'                      ex.Message);              }
Magic Number,Shoko.Server.Commands,CommandRequest_DownloadImage,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_DownloadImage.cs,RecursivelyRetryDownload,The following statement contains a magic number: try              {                  // download image                  if (downloadURL.Length <= 0) return;                  using (WebClient client = new WebClient())                  {                      client.Headers.Add("user-agent"' "JMM");                      //OnImageDownloadEvent(new ImageDownloadEventArgs(""' req' ImageDownloadEventType.Started));                      //BaseConfig.MyAnimeLog.Write("ProcessImages: Download: {0}  *** to ***  {1}"' req.URL' fullName);                        byte[] bytes = client.DownloadData(downloadURL);                      if (bytes.Length < 4)                          throw new WebException(                              "The image download stream returned less than 4 bytes (a valid image has 2-4 bytes in the header)");                        ImageFormatEnum imageFormat = Misc.GetImageFormat(bytes);                      string extension;                      switch (imageFormat)                      {                          case ImageFormatEnum.bmp:                              extension = ".bmp";                              break;                          case ImageFormatEnum.gif:                              extension = ".gif";                              break;                          case ImageFormatEnum.jpeg:                              extension = ".jpeg";                              break;                          case ImageFormatEnum.png:                              extension = ".png";                              break;                          case ImageFormatEnum.tiff:                              extension = ".tiff";                              break;                          default: throw new WebException("The image download stream returned an invalid image");                      }                        if (extension.Length <= 0) return;                      string newFile = Path.ChangeExtension(tempFilePath' extension);                      if(newFile == null) return;                        if (File.Exists(newFile)) File.Delete(newFile);                      using (var fs = new FileStream(newFile' FileMode.Create' FileAccess.Write))                      {                          fs.Write(bytes' 0' bytes.Length);                      }                      tempFilePath = newFile;                  }              }              catch (WebException)              {                  if (count + 1 >= maxretry) throw;                  Thread.Sleep(500);                  RecursivelyRetryDownload(downloadURL' ref tempFilePath' count + 1' maxretry);              }
Magic Number,Shoko.Server.Commands,CommandRequest_DownloadImage,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_DownloadImage.cs,RecursivelyRetryDownload,The following statement contains a magic number: try              {                  // download image                  if (downloadURL.Length <= 0) return;                  using (WebClient client = new WebClient())                  {                      client.Headers.Add("user-agent"' "JMM");                      //OnImageDownloadEvent(new ImageDownloadEventArgs(""' req' ImageDownloadEventType.Started));                      //BaseConfig.MyAnimeLog.Write("ProcessImages: Download: {0}  *** to ***  {1}"' req.URL' fullName);                        byte[] bytes = client.DownloadData(downloadURL);                      if (bytes.Length < 4)                          throw new WebException(                              "The image download stream returned less than 4 bytes (a valid image has 2-4 bytes in the header)");                        ImageFormatEnum imageFormat = Misc.GetImageFormat(bytes);                      string extension;                      switch (imageFormat)                      {                          case ImageFormatEnum.bmp:                              extension = ".bmp";                              break;                          case ImageFormatEnum.gif:                              extension = ".gif";                              break;                          case ImageFormatEnum.jpeg:                              extension = ".jpeg";                              break;                          case ImageFormatEnum.png:                              extension = ".png";                              break;                          case ImageFormatEnum.tiff:                              extension = ".tiff";                              break;                          default: throw new WebException("The image download stream returned an invalid image");                      }                        if (extension.Length <= 0) return;                      string newFile = Path.ChangeExtension(tempFilePath' extension);                      if(newFile == null) return;                        if (File.Exists(newFile)) File.Delete(newFile);                      using (var fs = new FileStream(newFile' FileMode.Create' FileAccess.Write))                      {                          fs.Write(bytes' 0' bytes.Length);                      }                      tempFilePath = newFile;                  }              }              catch (WebException)              {                  if (count + 1 >= maxretry) throw;                  Thread.Sleep(500);                  RecursivelyRetryDownload(downloadURL' ref tempFilePath' count + 1' maxretry);              }
Magic Number,Shoko.Server.Commands,CommandRequest_HashFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_HashFile.cs,ProcessFile_LocalInfo,The following statement contains a magic number: if (folder.CloudID == null) // Local Access              {                  if (!File.Exists(FileName))                  {                      logger.Error("File does not exist: {0}"' FileName);                      return null;                  }                    int numAttempts = 0;                    // Wait 1 minute before giving up on trying to access the file                  while ((filesize = CanAccessFile(FileName)) == 0 && (numAttempts < 60))                  {                      numAttempts++;                      Thread.Sleep(1000);                      Console.WriteLine($@"Attempt # {numAttempts}");                  }                    // if we failed to access the file' get ouuta here                  if (numAttempts >= 60)                  {                      logger.Error("Could not access file: " + FileName);                      return null;                  }              }
Magic Number,Shoko.Server.Commands,CommandRequest_HashFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_HashFile.cs,ProcessFile_LocalInfo,The following statement contains a magic number: if (folder.CloudID == null) // Local Access              {                  if (!File.Exists(FileName))                  {                      logger.Error("File does not exist: {0}"' FileName);                      return null;                  }                    int numAttempts = 0;                    // Wait 1 minute before giving up on trying to access the file                  while ((filesize = CanAccessFile(FileName)) == 0 && (numAttempts < 60))                  {                      numAttempts++;                      Thread.Sleep(1000);                      Console.WriteLine($@"Attempt # {numAttempts}");                  }                    // if we failed to access the file' get ouuta here                  if (numAttempts >= 60)                  {                      logger.Error("Could not access file: " + FileName);                      return null;                  }              }
Magic Number,Shoko.Server.Commands,CommandRequest_HashFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_HashFile.cs,ProcessFile_LocalInfo,The following statement contains a magic number: if (folder.CloudID == null) // Local Access              {                  if (!File.Exists(FileName))                  {                      logger.Error("File does not exist: {0}"' FileName);                      return null;                  }                    int numAttempts = 0;                    // Wait 1 minute before giving up on trying to access the file                  while ((filesize = CanAccessFile(FileName)) == 0 && (numAttempts < 60))                  {                      numAttempts++;                      Thread.Sleep(1000);                      Console.WriteLine($@"Attempt # {numAttempts}");                  }                    // if we failed to access the file' get ouuta here                  if (numAttempts >= 60)                  {                      logger.Error("Could not access file: " + FileName);                      return null;                  }              }
Magic Number,Shoko.Server.Commands,CommandRequest_LinkFileManually,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_LinkFileManually.cs,ProcessCommand,The following statement contains a magic number: try              {                  xref.PopulateManually(vlocal' episode);                  if (Percentage > 0 && Percentage <= 100)                  {                      xref.Percentage = Percentage;                  }              }              catch (Exception ex)              {                  logger.Error(ex' "Error populating XREF: {0}"' vlocal.ToStringDetailed());                  throw;              }
Magic Number,Shoko.Server.Commands,CommandRequest_ProcessFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_ProcessFile.cs,ProcessFile_AniDB,The following statement contains a magic number: lock (vidLocal)              {                  SVR_AniDB_File aniFile = null;                    if (!ForceAniDB)                  {                      aniFile = RepoFactory.AniDB_File.GetByHashAndFileSize(vidLocal.Hash' vlocal.FileSize);                        if (aniFile == null)                          logger.Trace("AniDB_File record not found");                  }                  // If cross refs were wiped' but the AniDB_File was not' we unfortunately need to requery the info                  List<CrossRef_File_Episode> crossRefs = RepoFactory.CrossRef_File_Episode.GetByHash(vidLocal.Hash);                  if (crossRefs == null || crossRefs.Count == 0) aniFile = null;                    int animeID = 0;                    if (aniFile == null)                  {                      // get info from AniDB                      logger.Debug("Getting AniDB_File record from AniDB....");                        // check if we already have a record                      aniFile = RepoFactory.AniDB_File.GetByHashAndFileSize(vidLocal.Hash' vlocal.FileSize);                        if (aniFile == null)                      {                          aniFile = new SVR_AniDB_File();                          ForceAniDB = true;                      }                        if (ForceAniDB)                      {                          Raw_AniDB_File fileInfo = ShokoService.AnidbProcessor.GetFileInfo(vidLocal);                          if (fileInfo != null)                          {                              SVR_AniDB_File.Populate(aniFile' fileInfo);                              if (!string.IsNullOrEmpty(fileInfo.OtherEpisodesRAW))                              {                                  string[] epIDs = fileInfo.OtherEpisodesRAW.Split(''');                                  foreach (string epid in epIDs)                                  {                                      if (!int.TryParse(epid' out int id)) continue;                                      CommandRequest_GetEpisode cmdEp = new CommandRequest_GetEpisode(id);                                      cmdEp.Save();                                  }                              }                          }                          else aniFile = null;                      }                        if (aniFile != null)                      {                          //overwrite with local file name                          string localFileName = vidLocal.GetBestVideoLocalPlace()?.FullServerPath;                          localFileName = !string.IsNullOrEmpty(localFileName)                              ? Path.GetFileName(localFileName)                              : vidLocal.FileName;                          aniFile.FileName = localFileName;                            RepoFactory.AniDB_File.Save(aniFile' false);                          aniFile.CreateLanguages();                          aniFile.CreateCrossEpisodes(localFileName);                            animeID = aniFile.AnimeID;                      }                  }                    bool missingEpisodes = false;                    // if we still haven't got the AniDB_File Info we try the web cache or local records                  if (aniFile == null)                  {                      // check if we have any records from previous imports                      crossRefs = RepoFactory.CrossRef_File_Episode.GetByHash(vidLocal.Hash);                      if (crossRefs == null || crossRefs.Count == 0)                      {                          // lets see if we can find the episode/anime info from the web cache                          if (ServerSettings.WebCache_XRefFileEpisode_Get)                          {                              List<Azure_CrossRef_File_Episode> xrefs =                                  AzureWebAPI.Get_CrossRefFileEpisode(vidLocal);                                crossRefs = new List<CrossRef_File_Episode>();                              if (xrefs == null || xrefs.Count == 0)                              {                                  logger.Debug(                                      $"Cannot find AniDB_File record or get cross ref from web cache record so exiting: {vidLocal.ED2KHash}");                                  return;                              }                              string fileName = vidLocal.GetBestVideoLocalPlace()?.FullServerPath;                              fileName = !string.IsNullOrEmpty(fileName) ? Path.GetFileName(fileName) : vidLocal.FileName;                              foreach (Azure_CrossRef_File_Episode xref in xrefs)                              {                                  CrossRef_File_Episode xrefEnt = new CrossRef_File_Episode                                  {                                      Hash = vidLocal.ED2KHash'                                      FileName = fileName'                                      FileSize = vidLocal.FileSize'                                      CrossRefSource = (int)CrossRefSource.WebCache'                                      AnimeID = xref.AnimeID'                                      EpisodeID = xref.EpisodeID'                                      Percentage = xref.Percentage'                                      EpisodeOrder = xref.EpisodeOrder                                  };                                  bool duplicate = false;                                    foreach (CrossRef_File_Episode xrefcheck in crossRefs)                                  {                                      if (xrefcheck.AnimeID == xrefEnt.AnimeID &&                                          xrefcheck.EpisodeID == xrefEnt.EpisodeID &&                                          xrefcheck.Hash == xrefEnt.Hash)                                          duplicate = true;                                  }                                    if (!duplicate)                                  {                                      crossRefs.Add(xrefEnt);                                      // in this case we need to save the cross refs manually as AniDB did not provide them                                      RepoFactory.CrossRef_File_Episode.Save(xrefEnt);                                  }                              }                          }                          else                          {                              logger.Debug($"Cannot get AniDB_File record so exiting: {vidLocal.ED2KHash}");                              return;                          }                      }                        // we assume that all episodes belong to the same anime                      foreach (CrossRef_File_Episode xref in crossRefs)                      {                          animeID = xref.AnimeID;                            AniDB_Episode ep = RepoFactory.AniDB_Episode.GetByEpisodeID(xref.EpisodeID);                          if (ep == null) missingEpisodes = true;                      }                  }                  else                  {                      // check if we have the episode info                      // if we don't' we will need to re-download the anime info (which also has episode info)                        if (aniFile.EpisodeCrossRefs.Count == 0)                      {                          animeID = aniFile.AnimeID;                            // if we have the anidb file' but no cross refs it means something has been broken                          logger.Debug($"Could not find any cross ref records for: {vidLocal.ED2KHash}");                          missingEpisodes = true;                      }                      else                      {                          foreach (CrossRef_File_Episode xref in aniFile.EpisodeCrossRefs)                          {                              AniDB_Episode ep = RepoFactory.AniDB_Episode.GetByEpisodeID(xref.EpisodeID);                              if (ep == null)                                  missingEpisodes = true;                                animeID = xref.AnimeID;                          }                      }                  }                    // get from DB                  SVR_AniDB_Anime anime = RepoFactory.AniDB_Anime.GetByAnimeID(animeID);                  var update = RepoFactory.AniDB_AnimeUpdate.GetByAnimeID(animeID);                  bool animeRecentlyUpdated = false;                    if (anime != null && update != null)                  {                      TimeSpan ts = DateTime.Now - update.UpdatedAt;                      if (ts.TotalHours < 4) animeRecentlyUpdated = true;                  }                  else                      missingEpisodes = true;                    // even if we are missing episode info' don't get data  more than once every 4 hours                  // this is to prevent banning                  if (missingEpisodes && !animeRecentlyUpdated)                  {                      logger.Debug("Getting Anime record from AniDB....");                      anime = ShokoService.AnidbProcessor.GetAnimeInfoHTTP(animeID' true'                          ServerSettings.AutoGroupSeries || ServerSettings.AniDB_DownloadRelatedAnime);                  }                    // create the group/series/episode records if needed                  SVR_AnimeSeries ser = null;                  if (anime != null)                  {                      logger.Debug("Creating groups' series and episodes....");                      // check if there is an AnimeSeries Record associated with this AnimeID                      ser = RepoFactory.AnimeSeries.GetByAnimeID(animeID) ?? anime.CreateAnimeSeriesAndGroup();                        ser.CreateAnimeEpisodes();                        // check if we have any group status data for this associated anime                      // if not we will download it now                      if (RepoFactory.AniDB_GroupStatus.GetByAnimeID(anime.AnimeID).Count == 0)                      {                          CommandRequest_GetReleaseGroupStatus cmdStatus =                              new CommandRequest_GetReleaseGroupStatus(anime.AnimeID' false);                          cmdStatus.Save();                      }                        // update stats                      ser.EpisodeAddedDate = DateTime.Now;                      RepoFactory.AnimeSeries.Save(ser' false' false);                        foreach (SVR_AnimeGroup grp in ser.AllGroupsAbove)                      {                          grp.EpisodeAddedDate = DateTime.Now;                          RepoFactory.AnimeGroup.Save(grp' true' false);                      }                        if (ServerSettings.FileQualityFilterEnabled)                      {                          // We do this inside' as the info will not be available as needed otherwise                          List<SVR_VideoLocal> videoLocals =                              aniFile?.EpisodeIDs?.SelectMany(a => RepoFactory.VideoLocal.GetByAniDBEpisodeID(a))                                  .Where(b => b != null)                                  .ToList();                          if (videoLocals != null)                          {                              videoLocals.Sort(FileQualityFilter.CompareTo);                              List<SVR_VideoLocal> keep = videoLocals                                  .Take(FileQualityFilter.Settings.MaxNumberOfFilesToKeep)                                  .ToList();                              foreach (SVR_VideoLocal vl2 in keep) videoLocals.Remove(vl2);                              if (!FileQualityFilter.Settings.AllowDeletionOfImportedFiles &&                                  videoLocals.Contains(vidLocal)) videoLocals.Remove(vidLocal);                              videoLocals = videoLocals.Where(a => !FileQualityFilter.CheckFileKeep(a)).ToList();                                foreach (SVR_VideoLocal toDelete in videoLocals)                              {                                  toDelete.Places.ForEach(a => a.RemoveAndDeleteFile());                              }                          }                      }                  }                  else                  {                      logger.Warn($"Unable to create AniDB_Anime for file: {vidLocal.FileName}");                  }                  vidLocal.Places.ForEach(a => { a.RenameAndMoveAsRequired(); });                    // update stats for groups and series                  // update all the groups above this series in the heirarchy                  ser?.QueueUpdateStats();                      // Add this file to the users list                  if (ServerSettings.AniDB_MyList_AddFiles)                  {                      CommandRequest_AddFileToMyList cmd = new CommandRequest_AddFileToMyList(vidLocal.ED2KHash);                      cmd.Save();                  }              }
Magic Number,Shoko.Server.Commands,CommandRequest_ValidateAllImages,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_ValidateAllImages.cs,ProcessCommand,The following statement contains a magic number: try              {                  QueueStateStruct queueState = PrettyDescription;                  queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBEpisodes};                  ShokoService.CmdProcessorImages.QueueState = queueState;                  int count = 0;                  logger.Info("Scanning TvDB Episode thumbs for corrupted images");                  var episodes = RepoFactory.TvDB_Episode.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                    logger.Info($"Found {episodes.Count} corrupted TvDB Episode {(episodes.Count == 1 ? "thumb" : "thumbs")}");                  foreach (var fanart in episodes)                  {                      logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                      RemoveImageAndQueueRedownload(ImageEntityType.TvDB_Episode' fanart.TvDB_EpisodeID' fanart);                      count++;                      if (count % 10 == 0)                      {                          logger.Info($"Deleting and queueing for redownload {count}/{episodes.Count}");                          queueState.extraParams = new[]                              {$"{Resources.Command_ValidateAllImages_TvDBEpisodes} - {count}/{episodes.Count}"};                          ShokoService.CmdProcessorImages.QueueState = queueState;                      }                  }                    if (ServerSettings.TvDB_AutoFanart)                  {                      count = 0;                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBFanarts};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      logger.Info("Scanning TvDB Fanarts for corrupted images");                      var fanarts = RepoFactory.TvDB_ImageFanart.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted TvDB {(fanarts.Count == 1 ? "Fanart" : "Fanarts")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.TvDB_FanArt' fanart.TvDB_ImageFanartID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_TvDBFanarts} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.TvDB_AutoPosters)                  {                      count = 0;                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBPosters};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      logger.Info("Scanning TvDB Posters for corrupted images");                      var fanarts = RepoFactory.TvDB_ImagePoster.GetAll().Where(fanart =>                              !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                              !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted TvDB {(fanarts.Count == 1 ? "Poster" : "Posters")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.TvDB_Cover' fanart.TvDB_ImagePosterID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_TvDBPosters} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.TvDB_AutoWideBanners)                  {                      count = 0;                      logger.Info("Scanning TvDB Banners for corrupted images");                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBBanners};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      var fanarts = RepoFactory.TvDB_ImageWideBanner.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted TvDB {(fanarts.Count == 1 ? "Banner" : "Banners")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.TvDB_Banner' fanart.TvDB_ImageWideBannerID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_TvDBBanners} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.MovieDB_AutoPosters)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_MovieDBPosters};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning MovieDB Posters for corrupted images");                      var fanarts = RepoFactory.MovieDB_Poster.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted MovieDB {(fanarts.Count == 1 ? "Poster" : "Posters")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.MovieDB_Poster' fanart.MovieDB_PosterID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_MovieDBPosters} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.MovieDB_AutoFanart)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_MovieDBFanarts};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning MovieDB Fanarts for corrupted images");                      var fanarts = RepoFactory.MovieDB_Fanart.GetAll().Where(fanart =>                              !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                              !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                      logger.Info($"Found {fanarts.Count} corrupted MovieDB {(fanarts.Count == 1 ? "Fanart" : "Fanarts")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.MovieDB_FanArt' fanart.MovieDB_FanartID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_MovieDBFanarts} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    queueState.extraParams = new[] {Resources.Command_ValidateAllImages_AniDBPosters};                  ShokoService.CmdProcessorImages.QueueState = queueState;                  count = 0;                  logger.Info("Scanning AniDB Posters for corrupted images");                  var posters = RepoFactory.AniDB_Anime.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.PosterPath) && !Misc.IsImageValid(fanart.PosterPath)).ToList();                  logger.Info($"Found {posters.Count} corrupted AniDB {(posters.Count == 1 ? "Poster" : "Posters")}");                  foreach (var fanart in posters)                  {                      logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.PosterPath}");                      RemoveImageAndQueueRedownload(ImageEntityType.AniDB_Cover' fanart.AnimeID' fanart);                      count++;                      if (count % 10 == 0)                      {                          logger.Info($"Deleting and queueing for redownload {count}/{posters.Count}");                          queueState.extraParams = new[]                              {$"{Resources.Command_ValidateAllImages_AniDBPosters} - {count}/{posters.Count}"};                          ShokoService.CmdProcessorImages.QueueState = queueState;                      }                  }                    if (ServerSettings.AniDB_DownloadCharacters)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_AniDBCharacters};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning AniDB Characters for corrupted images");                      var fanarts = RepoFactory.AniDB_Character.GetAll().Where(fanart =>                              !string.IsNullOrEmpty(fanart.GetPosterPath()) && !Misc.IsImageValid(fanart.GetPosterPath()))                          .ToList();                      logger.Info($"Found {fanarts.Count} corrupted AniDB Character {(fanarts.Count == 1 ? "image" : "images")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetPosterPath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.AniDB_Character' fanart.AniDB_CharacterID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_AniDBCharacters} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.AniDB_DownloadCreators)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_AniDBSeiyuus};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning AniDB Seiyuus for corrupted images");                      var fanarts = RepoFactory.AniDB_Seiyuu.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetPosterPath()) && !Misc.IsImageValid(fanart.GetPosterPath())).ToList();                      logger.Info($"Found {fanarts.Count} corrupted AniDB Seiyuu {(fanarts.Count == 1 ? "image" : "images")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetPosterPath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.AniDB_Creator' fanart.SeiyuuID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_AniDBSeiyuus} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }              }              catch (Exception ex)              {                  logger.Warn($"Error processing CommandRequest_ValidateAllImages: {ex.Message}");              }
Magic Number,Shoko.Server.Commands,CommandRequest_ValidateAllImages,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_ValidateAllImages.cs,ProcessCommand,The following statement contains a magic number: try              {                  QueueStateStruct queueState = PrettyDescription;                  queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBEpisodes};                  ShokoService.CmdProcessorImages.QueueState = queueState;                  int count = 0;                  logger.Info("Scanning TvDB Episode thumbs for corrupted images");                  var episodes = RepoFactory.TvDB_Episode.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                    logger.Info($"Found {episodes.Count} corrupted TvDB Episode {(episodes.Count == 1 ? "thumb" : "thumbs")}");                  foreach (var fanart in episodes)                  {                      logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                      RemoveImageAndQueueRedownload(ImageEntityType.TvDB_Episode' fanart.TvDB_EpisodeID' fanart);                      count++;                      if (count % 10 == 0)                      {                          logger.Info($"Deleting and queueing for redownload {count}/{episodes.Count}");                          queueState.extraParams = new[]                              {$"{Resources.Command_ValidateAllImages_TvDBEpisodes} - {count}/{episodes.Count}"};                          ShokoService.CmdProcessorImages.QueueState = queueState;                      }                  }                    if (ServerSettings.TvDB_AutoFanart)                  {                      count = 0;                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBFanarts};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      logger.Info("Scanning TvDB Fanarts for corrupted images");                      var fanarts = RepoFactory.TvDB_ImageFanart.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted TvDB {(fanarts.Count == 1 ? "Fanart" : "Fanarts")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.TvDB_FanArt' fanart.TvDB_ImageFanartID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_TvDBFanarts} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.TvDB_AutoPosters)                  {                      count = 0;                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBPosters};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      logger.Info("Scanning TvDB Posters for corrupted images");                      var fanarts = RepoFactory.TvDB_ImagePoster.GetAll().Where(fanart =>                              !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                              !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted TvDB {(fanarts.Count == 1 ? "Poster" : "Posters")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.TvDB_Cover' fanart.TvDB_ImagePosterID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_TvDBPosters} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.TvDB_AutoWideBanners)                  {                      count = 0;                      logger.Info("Scanning TvDB Banners for corrupted images");                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBBanners};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      var fanarts = RepoFactory.TvDB_ImageWideBanner.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted TvDB {(fanarts.Count == 1 ? "Banner" : "Banners")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.TvDB_Banner' fanart.TvDB_ImageWideBannerID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_TvDBBanners} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.MovieDB_AutoPosters)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_MovieDBPosters};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning MovieDB Posters for corrupted images");                      var fanarts = RepoFactory.MovieDB_Poster.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted MovieDB {(fanarts.Count == 1 ? "Poster" : "Posters")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.MovieDB_Poster' fanart.MovieDB_PosterID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_MovieDBPosters} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.MovieDB_AutoFanart)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_MovieDBFanarts};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning MovieDB Fanarts for corrupted images");                      var fanarts = RepoFactory.MovieDB_Fanart.GetAll().Where(fanart =>                              !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                              !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                      logger.Info($"Found {fanarts.Count} corrupted MovieDB {(fanarts.Count == 1 ? "Fanart" : "Fanarts")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.MovieDB_FanArt' fanart.MovieDB_FanartID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_MovieDBFanarts} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    queueState.extraParams = new[] {Resources.Command_ValidateAllImages_AniDBPosters};                  ShokoService.CmdProcessorImages.QueueState = queueState;                  count = 0;                  logger.Info("Scanning AniDB Posters for corrupted images");                  var posters = RepoFactory.AniDB_Anime.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.PosterPath) && !Misc.IsImageValid(fanart.PosterPath)).ToList();                  logger.Info($"Found {posters.Count} corrupted AniDB {(posters.Count == 1 ? "Poster" : "Posters")}");                  foreach (var fanart in posters)                  {                      logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.PosterPath}");                      RemoveImageAndQueueRedownload(ImageEntityType.AniDB_Cover' fanart.AnimeID' fanart);                      count++;                      if (count % 10 == 0)                      {                          logger.Info($"Deleting and queueing for redownload {count}/{posters.Count}");                          queueState.extraParams = new[]                              {$"{Resources.Command_ValidateAllImages_AniDBPosters} - {count}/{posters.Count}"};                          ShokoService.CmdProcessorImages.QueueState = queueState;                      }                  }                    if (ServerSettings.AniDB_DownloadCharacters)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_AniDBCharacters};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning AniDB Characters for corrupted images");                      var fanarts = RepoFactory.AniDB_Character.GetAll().Where(fanart =>                              !string.IsNullOrEmpty(fanart.GetPosterPath()) && !Misc.IsImageValid(fanart.GetPosterPath()))                          .ToList();                      logger.Info($"Found {fanarts.Count} corrupted AniDB Character {(fanarts.Count == 1 ? "image" : "images")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetPosterPath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.AniDB_Character' fanart.AniDB_CharacterID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_AniDBCharacters} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.AniDB_DownloadCreators)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_AniDBSeiyuus};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning AniDB Seiyuus for corrupted images");                      var fanarts = RepoFactory.AniDB_Seiyuu.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetPosterPath()) && !Misc.IsImageValid(fanart.GetPosterPath())).ToList();                      logger.Info($"Found {fanarts.Count} corrupted AniDB Seiyuu {(fanarts.Count == 1 ? "image" : "images")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetPosterPath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.AniDB_Creator' fanart.SeiyuuID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_AniDBSeiyuus} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }              }              catch (Exception ex)              {                  logger.Warn($"Error processing CommandRequest_ValidateAllImages: {ex.Message}");              }
Magic Number,Shoko.Server.Commands,CommandRequest_ValidateAllImages,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_ValidateAllImages.cs,ProcessCommand,The following statement contains a magic number: try              {                  QueueStateStruct queueState = PrettyDescription;                  queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBEpisodes};                  ShokoService.CmdProcessorImages.QueueState = queueState;                  int count = 0;                  logger.Info("Scanning TvDB Episode thumbs for corrupted images");                  var episodes = RepoFactory.TvDB_Episode.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                    logger.Info($"Found {episodes.Count} corrupted TvDB Episode {(episodes.Count == 1 ? "thumb" : "thumbs")}");                  foreach (var fanart in episodes)                  {                      logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                      RemoveImageAndQueueRedownload(ImageEntityType.TvDB_Episode' fanart.TvDB_EpisodeID' fanart);                      count++;                      if (count % 10 == 0)                      {                          logger.Info($"Deleting and queueing for redownload {count}/{episodes.Count}");                          queueState.extraParams = new[]                              {$"{Resources.Command_ValidateAllImages_TvDBEpisodes} - {count}/{episodes.Count}"};                          ShokoService.CmdProcessorImages.QueueState = queueState;                      }                  }                    if (ServerSettings.TvDB_AutoFanart)                  {                      count = 0;                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBFanarts};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      logger.Info("Scanning TvDB Fanarts for corrupted images");                      var fanarts = RepoFactory.TvDB_ImageFanart.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted TvDB {(fanarts.Count == 1 ? "Fanart" : "Fanarts")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.TvDB_FanArt' fanart.TvDB_ImageFanartID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_TvDBFanarts} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.TvDB_AutoPosters)                  {                      count = 0;                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBPosters};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      logger.Info("Scanning TvDB Posters for corrupted images");                      var fanarts = RepoFactory.TvDB_ImagePoster.GetAll().Where(fanart =>                              !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                              !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted TvDB {(fanarts.Count == 1 ? "Poster" : "Posters")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.TvDB_Cover' fanart.TvDB_ImagePosterID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_TvDBPosters} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.TvDB_AutoWideBanners)                  {                      count = 0;                      logger.Info("Scanning TvDB Banners for corrupted images");                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBBanners};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      var fanarts = RepoFactory.TvDB_ImageWideBanner.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted TvDB {(fanarts.Count == 1 ? "Banner" : "Banners")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.TvDB_Banner' fanart.TvDB_ImageWideBannerID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_TvDBBanners} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.MovieDB_AutoPosters)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_MovieDBPosters};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning MovieDB Posters for corrupted images");                      var fanarts = RepoFactory.MovieDB_Poster.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted MovieDB {(fanarts.Count == 1 ? "Poster" : "Posters")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.MovieDB_Poster' fanart.MovieDB_PosterID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_MovieDBPosters} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.MovieDB_AutoFanart)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_MovieDBFanarts};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning MovieDB Fanarts for corrupted images");                      var fanarts = RepoFactory.MovieDB_Fanart.GetAll().Where(fanart =>                              !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                              !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                      logger.Info($"Found {fanarts.Count} corrupted MovieDB {(fanarts.Count == 1 ? "Fanart" : "Fanarts")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.MovieDB_FanArt' fanart.MovieDB_FanartID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_MovieDBFanarts} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    queueState.extraParams = new[] {Resources.Command_ValidateAllImages_AniDBPosters};                  ShokoService.CmdProcessorImages.QueueState = queueState;                  count = 0;                  logger.Info("Scanning AniDB Posters for corrupted images");                  var posters = RepoFactory.AniDB_Anime.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.PosterPath) && !Misc.IsImageValid(fanart.PosterPath)).ToList();                  logger.Info($"Found {posters.Count} corrupted AniDB {(posters.Count == 1 ? "Poster" : "Posters")}");                  foreach (var fanart in posters)                  {                      logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.PosterPath}");                      RemoveImageAndQueueRedownload(ImageEntityType.AniDB_Cover' fanart.AnimeID' fanart);                      count++;                      if (count % 10 == 0)                      {                          logger.Info($"Deleting and queueing for redownload {count}/{posters.Count}");                          queueState.extraParams = new[]                              {$"{Resources.Command_ValidateAllImages_AniDBPosters} - {count}/{posters.Count}"};                          ShokoService.CmdProcessorImages.QueueState = queueState;                      }                  }                    if (ServerSettings.AniDB_DownloadCharacters)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_AniDBCharacters};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning AniDB Characters for corrupted images");                      var fanarts = RepoFactory.AniDB_Character.GetAll().Where(fanart =>                              !string.IsNullOrEmpty(fanart.GetPosterPath()) && !Misc.IsImageValid(fanart.GetPosterPath()))                          .ToList();                      logger.Info($"Found {fanarts.Count} corrupted AniDB Character {(fanarts.Count == 1 ? "image" : "images")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetPosterPath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.AniDB_Character' fanart.AniDB_CharacterID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_AniDBCharacters} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.AniDB_DownloadCreators)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_AniDBSeiyuus};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning AniDB Seiyuus for corrupted images");                      var fanarts = RepoFactory.AniDB_Seiyuu.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetPosterPath()) && !Misc.IsImageValid(fanart.GetPosterPath())).ToList();                      logger.Info($"Found {fanarts.Count} corrupted AniDB Seiyuu {(fanarts.Count == 1 ? "image" : "images")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetPosterPath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.AniDB_Creator' fanart.SeiyuuID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_AniDBSeiyuus} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }              }              catch (Exception ex)              {                  logger.Warn($"Error processing CommandRequest_ValidateAllImages: {ex.Message}");              }
Magic Number,Shoko.Server.Commands,CommandRequest_ValidateAllImages,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_ValidateAllImages.cs,ProcessCommand,The following statement contains a magic number: try              {                  QueueStateStruct queueState = PrettyDescription;                  queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBEpisodes};                  ShokoService.CmdProcessorImages.QueueState = queueState;                  int count = 0;                  logger.Info("Scanning TvDB Episode thumbs for corrupted images");                  var episodes = RepoFactory.TvDB_Episode.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                    logger.Info($"Found {episodes.Count} corrupted TvDB Episode {(episodes.Count == 1 ? "thumb" : "thumbs")}");                  foreach (var fanart in episodes)                  {                      logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                      RemoveImageAndQueueRedownload(ImageEntityType.TvDB_Episode' fanart.TvDB_EpisodeID' fanart);                      count++;                      if (count % 10 == 0)                      {                          logger.Info($"Deleting and queueing for redownload {count}/{episodes.Count}");                          queueState.extraParams = new[]                              {$"{Resources.Command_ValidateAllImages_TvDBEpisodes} - {count}/{episodes.Count}"};                          ShokoService.CmdProcessorImages.QueueState = queueState;                      }                  }                    if (ServerSettings.TvDB_AutoFanart)                  {                      count = 0;                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBFanarts};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      logger.Info("Scanning TvDB Fanarts for corrupted images");                      var fanarts = RepoFactory.TvDB_ImageFanart.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted TvDB {(fanarts.Count == 1 ? "Fanart" : "Fanarts")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.TvDB_FanArt' fanart.TvDB_ImageFanartID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_TvDBFanarts} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.TvDB_AutoPosters)                  {                      count = 0;                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBPosters};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      logger.Info("Scanning TvDB Posters for corrupted images");                      var fanarts = RepoFactory.TvDB_ImagePoster.GetAll().Where(fanart =>                              !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                              !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted TvDB {(fanarts.Count == 1 ? "Poster" : "Posters")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.TvDB_Cover' fanart.TvDB_ImagePosterID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_TvDBPosters} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.TvDB_AutoWideBanners)                  {                      count = 0;                      logger.Info("Scanning TvDB Banners for corrupted images");                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBBanners};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      var fanarts = RepoFactory.TvDB_ImageWideBanner.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted TvDB {(fanarts.Count == 1 ? "Banner" : "Banners")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.TvDB_Banner' fanart.TvDB_ImageWideBannerID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_TvDBBanners} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.MovieDB_AutoPosters)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_MovieDBPosters};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning MovieDB Posters for corrupted images");                      var fanarts = RepoFactory.MovieDB_Poster.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted MovieDB {(fanarts.Count == 1 ? "Poster" : "Posters")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.MovieDB_Poster' fanart.MovieDB_PosterID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_MovieDBPosters} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.MovieDB_AutoFanart)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_MovieDBFanarts};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning MovieDB Fanarts for corrupted images");                      var fanarts = RepoFactory.MovieDB_Fanart.GetAll().Where(fanart =>                              !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                              !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                      logger.Info($"Found {fanarts.Count} corrupted MovieDB {(fanarts.Count == 1 ? "Fanart" : "Fanarts")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.MovieDB_FanArt' fanart.MovieDB_FanartID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_MovieDBFanarts} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    queueState.extraParams = new[] {Resources.Command_ValidateAllImages_AniDBPosters};                  ShokoService.CmdProcessorImages.QueueState = queueState;                  count = 0;                  logger.Info("Scanning AniDB Posters for corrupted images");                  var posters = RepoFactory.AniDB_Anime.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.PosterPath) && !Misc.IsImageValid(fanart.PosterPath)).ToList();                  logger.Info($"Found {posters.Count} corrupted AniDB {(posters.Count == 1 ? "Poster" : "Posters")}");                  foreach (var fanart in posters)                  {                      logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.PosterPath}");                      RemoveImageAndQueueRedownload(ImageEntityType.AniDB_Cover' fanart.AnimeID' fanart);                      count++;                      if (count % 10 == 0)                      {                          logger.Info($"Deleting and queueing for redownload {count}/{posters.Count}");                          queueState.extraParams = new[]                              {$"{Resources.Command_ValidateAllImages_AniDBPosters} - {count}/{posters.Count}"};                          ShokoService.CmdProcessorImages.QueueState = queueState;                      }                  }                    if (ServerSettings.AniDB_DownloadCharacters)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_AniDBCharacters};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning AniDB Characters for corrupted images");                      var fanarts = RepoFactory.AniDB_Character.GetAll().Where(fanart =>                              !string.IsNullOrEmpty(fanart.GetPosterPath()) && !Misc.IsImageValid(fanart.GetPosterPath()))                          .ToList();                      logger.Info($"Found {fanarts.Count} corrupted AniDB Character {(fanarts.Count == 1 ? "image" : "images")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetPosterPath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.AniDB_Character' fanart.AniDB_CharacterID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_AniDBCharacters} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.AniDB_DownloadCreators)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_AniDBSeiyuus};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning AniDB Seiyuus for corrupted images");                      var fanarts = RepoFactory.AniDB_Seiyuu.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetPosterPath()) && !Misc.IsImageValid(fanart.GetPosterPath())).ToList();                      logger.Info($"Found {fanarts.Count} corrupted AniDB Seiyuu {(fanarts.Count == 1 ? "image" : "images")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetPosterPath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.AniDB_Creator' fanart.SeiyuuID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_AniDBSeiyuus} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }              }              catch (Exception ex)              {                  logger.Warn($"Error processing CommandRequest_ValidateAllImages: {ex.Message}");              }
Magic Number,Shoko.Server.Commands,CommandRequest_ValidateAllImages,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_ValidateAllImages.cs,ProcessCommand,The following statement contains a magic number: try              {                  QueueStateStruct queueState = PrettyDescription;                  queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBEpisodes};                  ShokoService.CmdProcessorImages.QueueState = queueState;                  int count = 0;                  logger.Info("Scanning TvDB Episode thumbs for corrupted images");                  var episodes = RepoFactory.TvDB_Episode.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                    logger.Info($"Found {episodes.Count} corrupted TvDB Episode {(episodes.Count == 1 ? "thumb" : "thumbs")}");                  foreach (var fanart in episodes)                  {                      logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                      RemoveImageAndQueueRedownload(ImageEntityType.TvDB_Episode' fanart.TvDB_EpisodeID' fanart);                      count++;                      if (count % 10 == 0)                      {                          logger.Info($"Deleting and queueing for redownload {count}/{episodes.Count}");                          queueState.extraParams = new[]                              {$"{Resources.Command_ValidateAllImages_TvDBEpisodes} - {count}/{episodes.Count}"};                          ShokoService.CmdProcessorImages.QueueState = queueState;                      }                  }                    if (ServerSettings.TvDB_AutoFanart)                  {                      count = 0;                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBFanarts};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      logger.Info("Scanning TvDB Fanarts for corrupted images");                      var fanarts = RepoFactory.TvDB_ImageFanart.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted TvDB {(fanarts.Count == 1 ? "Fanart" : "Fanarts")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.TvDB_FanArt' fanart.TvDB_ImageFanartID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_TvDBFanarts} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.TvDB_AutoPosters)                  {                      count = 0;                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBPosters};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      logger.Info("Scanning TvDB Posters for corrupted images");                      var fanarts = RepoFactory.TvDB_ImagePoster.GetAll().Where(fanart =>                              !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                              !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted TvDB {(fanarts.Count == 1 ? "Poster" : "Posters")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.TvDB_Cover' fanart.TvDB_ImagePosterID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_TvDBPosters} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.TvDB_AutoWideBanners)                  {                      count = 0;                      logger.Info("Scanning TvDB Banners for corrupted images");                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBBanners};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      var fanarts = RepoFactory.TvDB_ImageWideBanner.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted TvDB {(fanarts.Count == 1 ? "Banner" : "Banners")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.TvDB_Banner' fanart.TvDB_ImageWideBannerID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_TvDBBanners} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.MovieDB_AutoPosters)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_MovieDBPosters};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning MovieDB Posters for corrupted images");                      var fanarts = RepoFactory.MovieDB_Poster.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted MovieDB {(fanarts.Count == 1 ? "Poster" : "Posters")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.MovieDB_Poster' fanart.MovieDB_PosterID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_MovieDBPosters} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.MovieDB_AutoFanart)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_MovieDBFanarts};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning MovieDB Fanarts for corrupted images");                      var fanarts = RepoFactory.MovieDB_Fanart.GetAll().Where(fanart =>                              !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                              !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                      logger.Info($"Found {fanarts.Count} corrupted MovieDB {(fanarts.Count == 1 ? "Fanart" : "Fanarts")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.MovieDB_FanArt' fanart.MovieDB_FanartID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_MovieDBFanarts} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    queueState.extraParams = new[] {Resources.Command_ValidateAllImages_AniDBPosters};                  ShokoService.CmdProcessorImages.QueueState = queueState;                  count = 0;                  logger.Info("Scanning AniDB Posters for corrupted images");                  var posters = RepoFactory.AniDB_Anime.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.PosterPath) && !Misc.IsImageValid(fanart.PosterPath)).ToList();                  logger.Info($"Found {posters.Count} corrupted AniDB {(posters.Count == 1 ? "Poster" : "Posters")}");                  foreach (var fanart in posters)                  {                      logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.PosterPath}");                      RemoveImageAndQueueRedownload(ImageEntityType.AniDB_Cover' fanart.AnimeID' fanart);                      count++;                      if (count % 10 == 0)                      {                          logger.Info($"Deleting and queueing for redownload {count}/{posters.Count}");                          queueState.extraParams = new[]                              {$"{Resources.Command_ValidateAllImages_AniDBPosters} - {count}/{posters.Count}"};                          ShokoService.CmdProcessorImages.QueueState = queueState;                      }                  }                    if (ServerSettings.AniDB_DownloadCharacters)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_AniDBCharacters};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning AniDB Characters for corrupted images");                      var fanarts = RepoFactory.AniDB_Character.GetAll().Where(fanart =>                              !string.IsNullOrEmpty(fanart.GetPosterPath()) && !Misc.IsImageValid(fanart.GetPosterPath()))                          .ToList();                      logger.Info($"Found {fanarts.Count} corrupted AniDB Character {(fanarts.Count == 1 ? "image" : "images")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetPosterPath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.AniDB_Character' fanart.AniDB_CharacterID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_AniDBCharacters} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.AniDB_DownloadCreators)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_AniDBSeiyuus};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning AniDB Seiyuus for corrupted images");                      var fanarts = RepoFactory.AniDB_Seiyuu.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetPosterPath()) && !Misc.IsImageValid(fanart.GetPosterPath())).ToList();                      logger.Info($"Found {fanarts.Count} corrupted AniDB Seiyuu {(fanarts.Count == 1 ? "image" : "images")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetPosterPath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.AniDB_Creator' fanart.SeiyuuID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_AniDBSeiyuus} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }              }              catch (Exception ex)              {                  logger.Warn($"Error processing CommandRequest_ValidateAllImages: {ex.Message}");              }
Magic Number,Shoko.Server.Commands,CommandRequest_ValidateAllImages,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_ValidateAllImages.cs,ProcessCommand,The following statement contains a magic number: try              {                  QueueStateStruct queueState = PrettyDescription;                  queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBEpisodes};                  ShokoService.CmdProcessorImages.QueueState = queueState;                  int count = 0;                  logger.Info("Scanning TvDB Episode thumbs for corrupted images");                  var episodes = RepoFactory.TvDB_Episode.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                    logger.Info($"Found {episodes.Count} corrupted TvDB Episode {(episodes.Count == 1 ? "thumb" : "thumbs")}");                  foreach (var fanart in episodes)                  {                      logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                      RemoveImageAndQueueRedownload(ImageEntityType.TvDB_Episode' fanart.TvDB_EpisodeID' fanart);                      count++;                      if (count % 10 == 0)                      {                          logger.Info($"Deleting and queueing for redownload {count}/{episodes.Count}");                          queueState.extraParams = new[]                              {$"{Resources.Command_ValidateAllImages_TvDBEpisodes} - {count}/{episodes.Count}"};                          ShokoService.CmdProcessorImages.QueueState = queueState;                      }                  }                    if (ServerSettings.TvDB_AutoFanart)                  {                      count = 0;                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBFanarts};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      logger.Info("Scanning TvDB Fanarts for corrupted images");                      var fanarts = RepoFactory.TvDB_ImageFanart.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted TvDB {(fanarts.Count == 1 ? "Fanart" : "Fanarts")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.TvDB_FanArt' fanart.TvDB_ImageFanartID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_TvDBFanarts} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.TvDB_AutoPosters)                  {                      count = 0;                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBPosters};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      logger.Info("Scanning TvDB Posters for corrupted images");                      var fanarts = RepoFactory.TvDB_ImagePoster.GetAll().Where(fanart =>                              !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                              !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted TvDB {(fanarts.Count == 1 ? "Poster" : "Posters")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.TvDB_Cover' fanart.TvDB_ImagePosterID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_TvDBPosters} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.TvDB_AutoWideBanners)                  {                      count = 0;                      logger.Info("Scanning TvDB Banners for corrupted images");                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBBanners};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      var fanarts = RepoFactory.TvDB_ImageWideBanner.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted TvDB {(fanarts.Count == 1 ? "Banner" : "Banners")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.TvDB_Banner' fanart.TvDB_ImageWideBannerID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_TvDBBanners} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.MovieDB_AutoPosters)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_MovieDBPosters};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning MovieDB Posters for corrupted images");                      var fanarts = RepoFactory.MovieDB_Poster.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted MovieDB {(fanarts.Count == 1 ? "Poster" : "Posters")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.MovieDB_Poster' fanart.MovieDB_PosterID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_MovieDBPosters} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.MovieDB_AutoFanart)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_MovieDBFanarts};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning MovieDB Fanarts for corrupted images");                      var fanarts = RepoFactory.MovieDB_Fanart.GetAll().Where(fanart =>                              !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                              !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                      logger.Info($"Found {fanarts.Count} corrupted MovieDB {(fanarts.Count == 1 ? "Fanart" : "Fanarts")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.MovieDB_FanArt' fanart.MovieDB_FanartID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_MovieDBFanarts} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    queueState.extraParams = new[] {Resources.Command_ValidateAllImages_AniDBPosters};                  ShokoService.CmdProcessorImages.QueueState = queueState;                  count = 0;                  logger.Info("Scanning AniDB Posters for corrupted images");                  var posters = RepoFactory.AniDB_Anime.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.PosterPath) && !Misc.IsImageValid(fanart.PosterPath)).ToList();                  logger.Info($"Found {posters.Count} corrupted AniDB {(posters.Count == 1 ? "Poster" : "Posters")}");                  foreach (var fanart in posters)                  {                      logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.PosterPath}");                      RemoveImageAndQueueRedownload(ImageEntityType.AniDB_Cover' fanart.AnimeID' fanart);                      count++;                      if (count % 10 == 0)                      {                          logger.Info($"Deleting and queueing for redownload {count}/{posters.Count}");                          queueState.extraParams = new[]                              {$"{Resources.Command_ValidateAllImages_AniDBPosters} - {count}/{posters.Count}"};                          ShokoService.CmdProcessorImages.QueueState = queueState;                      }                  }                    if (ServerSettings.AniDB_DownloadCharacters)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_AniDBCharacters};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning AniDB Characters for corrupted images");                      var fanarts = RepoFactory.AniDB_Character.GetAll().Where(fanart =>                              !string.IsNullOrEmpty(fanart.GetPosterPath()) && !Misc.IsImageValid(fanart.GetPosterPath()))                          .ToList();                      logger.Info($"Found {fanarts.Count} corrupted AniDB Character {(fanarts.Count == 1 ? "image" : "images")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetPosterPath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.AniDB_Character' fanart.AniDB_CharacterID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_AniDBCharacters} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.AniDB_DownloadCreators)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_AniDBSeiyuus};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning AniDB Seiyuus for corrupted images");                      var fanarts = RepoFactory.AniDB_Seiyuu.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetPosterPath()) && !Misc.IsImageValid(fanart.GetPosterPath())).ToList();                      logger.Info($"Found {fanarts.Count} corrupted AniDB Seiyuu {(fanarts.Count == 1 ? "image" : "images")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetPosterPath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.AniDB_Creator' fanart.SeiyuuID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_AniDBSeiyuus} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }              }              catch (Exception ex)              {                  logger.Warn($"Error processing CommandRequest_ValidateAllImages: {ex.Message}");              }
Magic Number,Shoko.Server.Commands,CommandRequest_ValidateAllImages,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_ValidateAllImages.cs,ProcessCommand,The following statement contains a magic number: try              {                  QueueStateStruct queueState = PrettyDescription;                  queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBEpisodes};                  ShokoService.CmdProcessorImages.QueueState = queueState;                  int count = 0;                  logger.Info("Scanning TvDB Episode thumbs for corrupted images");                  var episodes = RepoFactory.TvDB_Episode.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                    logger.Info($"Found {episodes.Count} corrupted TvDB Episode {(episodes.Count == 1 ? "thumb" : "thumbs")}");                  foreach (var fanart in episodes)                  {                      logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                      RemoveImageAndQueueRedownload(ImageEntityType.TvDB_Episode' fanart.TvDB_EpisodeID' fanart);                      count++;                      if (count % 10 == 0)                      {                          logger.Info($"Deleting and queueing for redownload {count}/{episodes.Count}");                          queueState.extraParams = new[]                              {$"{Resources.Command_ValidateAllImages_TvDBEpisodes} - {count}/{episodes.Count}"};                          ShokoService.CmdProcessorImages.QueueState = queueState;                      }                  }                    if (ServerSettings.TvDB_AutoFanart)                  {                      count = 0;                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBFanarts};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      logger.Info("Scanning TvDB Fanarts for corrupted images");                      var fanarts = RepoFactory.TvDB_ImageFanart.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted TvDB {(fanarts.Count == 1 ? "Fanart" : "Fanarts")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.TvDB_FanArt' fanart.TvDB_ImageFanartID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_TvDBFanarts} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.TvDB_AutoPosters)                  {                      count = 0;                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBPosters};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      logger.Info("Scanning TvDB Posters for corrupted images");                      var fanarts = RepoFactory.TvDB_ImagePoster.GetAll().Where(fanart =>                              !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                              !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted TvDB {(fanarts.Count == 1 ? "Poster" : "Posters")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.TvDB_Cover' fanart.TvDB_ImagePosterID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_TvDBPosters} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.TvDB_AutoWideBanners)                  {                      count = 0;                      logger.Info("Scanning TvDB Banners for corrupted images");                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBBanners};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      var fanarts = RepoFactory.TvDB_ImageWideBanner.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted TvDB {(fanarts.Count == 1 ? "Banner" : "Banners")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.TvDB_Banner' fanart.TvDB_ImageWideBannerID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_TvDBBanners} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.MovieDB_AutoPosters)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_MovieDBPosters};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning MovieDB Posters for corrupted images");                      var fanarts = RepoFactory.MovieDB_Poster.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted MovieDB {(fanarts.Count == 1 ? "Poster" : "Posters")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.MovieDB_Poster' fanart.MovieDB_PosterID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_MovieDBPosters} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.MovieDB_AutoFanart)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_MovieDBFanarts};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning MovieDB Fanarts for corrupted images");                      var fanarts = RepoFactory.MovieDB_Fanart.GetAll().Where(fanart =>                              !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                              !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                      logger.Info($"Found {fanarts.Count} corrupted MovieDB {(fanarts.Count == 1 ? "Fanart" : "Fanarts")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.MovieDB_FanArt' fanart.MovieDB_FanartID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_MovieDBFanarts} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    queueState.extraParams = new[] {Resources.Command_ValidateAllImages_AniDBPosters};                  ShokoService.CmdProcessorImages.QueueState = queueState;                  count = 0;                  logger.Info("Scanning AniDB Posters for corrupted images");                  var posters = RepoFactory.AniDB_Anime.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.PosterPath) && !Misc.IsImageValid(fanart.PosterPath)).ToList();                  logger.Info($"Found {posters.Count} corrupted AniDB {(posters.Count == 1 ? "Poster" : "Posters")}");                  foreach (var fanart in posters)                  {                      logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.PosterPath}");                      RemoveImageAndQueueRedownload(ImageEntityType.AniDB_Cover' fanart.AnimeID' fanart);                      count++;                      if (count % 10 == 0)                      {                          logger.Info($"Deleting and queueing for redownload {count}/{posters.Count}");                          queueState.extraParams = new[]                              {$"{Resources.Command_ValidateAllImages_AniDBPosters} - {count}/{posters.Count}"};                          ShokoService.CmdProcessorImages.QueueState = queueState;                      }                  }                    if (ServerSettings.AniDB_DownloadCharacters)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_AniDBCharacters};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning AniDB Characters for corrupted images");                      var fanarts = RepoFactory.AniDB_Character.GetAll().Where(fanart =>                              !string.IsNullOrEmpty(fanart.GetPosterPath()) && !Misc.IsImageValid(fanart.GetPosterPath()))                          .ToList();                      logger.Info($"Found {fanarts.Count} corrupted AniDB Character {(fanarts.Count == 1 ? "image" : "images")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetPosterPath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.AniDB_Character' fanart.AniDB_CharacterID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_AniDBCharacters} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.AniDB_DownloadCreators)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_AniDBSeiyuus};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning AniDB Seiyuus for corrupted images");                      var fanarts = RepoFactory.AniDB_Seiyuu.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetPosterPath()) && !Misc.IsImageValid(fanart.GetPosterPath())).ToList();                      logger.Info($"Found {fanarts.Count} corrupted AniDB Seiyuu {(fanarts.Count == 1 ? "image" : "images")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetPosterPath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.AniDB_Creator' fanart.SeiyuuID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_AniDBSeiyuus} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }              }              catch (Exception ex)              {                  logger.Warn($"Error processing CommandRequest_ValidateAllImages: {ex.Message}");              }
Magic Number,Shoko.Server.Commands,CommandRequest_ValidateAllImages,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_ValidateAllImages.cs,ProcessCommand,The following statement contains a magic number: try              {                  QueueStateStruct queueState = PrettyDescription;                  queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBEpisodes};                  ShokoService.CmdProcessorImages.QueueState = queueState;                  int count = 0;                  logger.Info("Scanning TvDB Episode thumbs for corrupted images");                  var episodes = RepoFactory.TvDB_Episode.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                    logger.Info($"Found {episodes.Count} corrupted TvDB Episode {(episodes.Count == 1 ? "thumb" : "thumbs")}");                  foreach (var fanart in episodes)                  {                      logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                      RemoveImageAndQueueRedownload(ImageEntityType.TvDB_Episode' fanart.TvDB_EpisodeID' fanart);                      count++;                      if (count % 10 == 0)                      {                          logger.Info($"Deleting and queueing for redownload {count}/{episodes.Count}");                          queueState.extraParams = new[]                              {$"{Resources.Command_ValidateAllImages_TvDBEpisodes} - {count}/{episodes.Count}"};                          ShokoService.CmdProcessorImages.QueueState = queueState;                      }                  }                    if (ServerSettings.TvDB_AutoFanart)                  {                      count = 0;                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBFanarts};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      logger.Info("Scanning TvDB Fanarts for corrupted images");                      var fanarts = RepoFactory.TvDB_ImageFanart.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted TvDB {(fanarts.Count == 1 ? "Fanart" : "Fanarts")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.TvDB_FanArt' fanart.TvDB_ImageFanartID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_TvDBFanarts} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.TvDB_AutoPosters)                  {                      count = 0;                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBPosters};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      logger.Info("Scanning TvDB Posters for corrupted images");                      var fanarts = RepoFactory.TvDB_ImagePoster.GetAll().Where(fanart =>                              !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                              !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted TvDB {(fanarts.Count == 1 ? "Poster" : "Posters")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.TvDB_Cover' fanart.TvDB_ImagePosterID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_TvDBPosters} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.TvDB_AutoWideBanners)                  {                      count = 0;                      logger.Info("Scanning TvDB Banners for corrupted images");                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBBanners};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      var fanarts = RepoFactory.TvDB_ImageWideBanner.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted TvDB {(fanarts.Count == 1 ? "Banner" : "Banners")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.TvDB_Banner' fanart.TvDB_ImageWideBannerID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_TvDBBanners} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.MovieDB_AutoPosters)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_MovieDBPosters};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning MovieDB Posters for corrupted images");                      var fanarts = RepoFactory.MovieDB_Poster.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted MovieDB {(fanarts.Count == 1 ? "Poster" : "Posters")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.MovieDB_Poster' fanart.MovieDB_PosterID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_MovieDBPosters} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.MovieDB_AutoFanart)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_MovieDBFanarts};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning MovieDB Fanarts for corrupted images");                      var fanarts = RepoFactory.MovieDB_Fanart.GetAll().Where(fanart =>                              !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                              !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                      logger.Info($"Found {fanarts.Count} corrupted MovieDB {(fanarts.Count == 1 ? "Fanart" : "Fanarts")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.MovieDB_FanArt' fanart.MovieDB_FanartID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_MovieDBFanarts} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    queueState.extraParams = new[] {Resources.Command_ValidateAllImages_AniDBPosters};                  ShokoService.CmdProcessorImages.QueueState = queueState;                  count = 0;                  logger.Info("Scanning AniDB Posters for corrupted images");                  var posters = RepoFactory.AniDB_Anime.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.PosterPath) && !Misc.IsImageValid(fanart.PosterPath)).ToList();                  logger.Info($"Found {posters.Count} corrupted AniDB {(posters.Count == 1 ? "Poster" : "Posters")}");                  foreach (var fanart in posters)                  {                      logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.PosterPath}");                      RemoveImageAndQueueRedownload(ImageEntityType.AniDB_Cover' fanart.AnimeID' fanart);                      count++;                      if (count % 10 == 0)                      {                          logger.Info($"Deleting and queueing for redownload {count}/{posters.Count}");                          queueState.extraParams = new[]                              {$"{Resources.Command_ValidateAllImages_AniDBPosters} - {count}/{posters.Count}"};                          ShokoService.CmdProcessorImages.QueueState = queueState;                      }                  }                    if (ServerSettings.AniDB_DownloadCharacters)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_AniDBCharacters};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning AniDB Characters for corrupted images");                      var fanarts = RepoFactory.AniDB_Character.GetAll().Where(fanart =>                              !string.IsNullOrEmpty(fanart.GetPosterPath()) && !Misc.IsImageValid(fanart.GetPosterPath()))                          .ToList();                      logger.Info($"Found {fanarts.Count} corrupted AniDB Character {(fanarts.Count == 1 ? "image" : "images")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetPosterPath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.AniDB_Character' fanart.AniDB_CharacterID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_AniDBCharacters} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.AniDB_DownloadCreators)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_AniDBSeiyuus};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning AniDB Seiyuus for corrupted images");                      var fanarts = RepoFactory.AniDB_Seiyuu.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetPosterPath()) && !Misc.IsImageValid(fanart.GetPosterPath())).ToList();                      logger.Info($"Found {fanarts.Count} corrupted AniDB Seiyuu {(fanarts.Count == 1 ? "image" : "images")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetPosterPath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.AniDB_Creator' fanart.SeiyuuID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_AniDBSeiyuus} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }              }              catch (Exception ex)              {                  logger.Warn($"Error processing CommandRequest_ValidateAllImages: {ex.Message}");              }
Magic Number,Shoko.Server.Commands,CommandRequest_ValidateAllImages,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_ValidateAllImages.cs,ProcessCommand,The following statement contains a magic number: try              {                  QueueStateStruct queueState = PrettyDescription;                  queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBEpisodes};                  ShokoService.CmdProcessorImages.QueueState = queueState;                  int count = 0;                  logger.Info("Scanning TvDB Episode thumbs for corrupted images");                  var episodes = RepoFactory.TvDB_Episode.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                    logger.Info($"Found {episodes.Count} corrupted TvDB Episode {(episodes.Count == 1 ? "thumb" : "thumbs")}");                  foreach (var fanart in episodes)                  {                      logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                      RemoveImageAndQueueRedownload(ImageEntityType.TvDB_Episode' fanart.TvDB_EpisodeID' fanart);                      count++;                      if (count % 10 == 0)                      {                          logger.Info($"Deleting and queueing for redownload {count}/{episodes.Count}");                          queueState.extraParams = new[]                              {$"{Resources.Command_ValidateAllImages_TvDBEpisodes} - {count}/{episodes.Count}"};                          ShokoService.CmdProcessorImages.QueueState = queueState;                      }                  }                    if (ServerSettings.TvDB_AutoFanart)                  {                      count = 0;                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBFanarts};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      logger.Info("Scanning TvDB Fanarts for corrupted images");                      var fanarts = RepoFactory.TvDB_ImageFanart.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted TvDB {(fanarts.Count == 1 ? "Fanart" : "Fanarts")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.TvDB_FanArt' fanart.TvDB_ImageFanartID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_TvDBFanarts} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.TvDB_AutoPosters)                  {                      count = 0;                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBPosters};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      logger.Info("Scanning TvDB Posters for corrupted images");                      var fanarts = RepoFactory.TvDB_ImagePoster.GetAll().Where(fanart =>                              !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                              !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted TvDB {(fanarts.Count == 1 ? "Poster" : "Posters")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.TvDB_Cover' fanart.TvDB_ImagePosterID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_TvDBPosters} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.TvDB_AutoWideBanners)                  {                      count = 0;                      logger.Info("Scanning TvDB Banners for corrupted images");                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_TvDBBanners};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      var fanarts = RepoFactory.TvDB_ImageWideBanner.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted TvDB {(fanarts.Count == 1 ? "Banner" : "Banners")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.TvDB_Banner' fanart.TvDB_ImageWideBannerID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_TvDBBanners} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.MovieDB_AutoPosters)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_MovieDBPosters};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning MovieDB Posters for corrupted images");                      var fanarts = RepoFactory.MovieDB_Poster.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                          !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                        logger.Info($"Found {fanarts.Count} corrupted MovieDB {(fanarts.Count == 1 ? "Poster" : "Posters")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.MovieDB_Poster' fanart.MovieDB_PosterID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_MovieDBPosters} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.MovieDB_AutoFanart)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_MovieDBFanarts};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning MovieDB Fanarts for corrupted images");                      var fanarts = RepoFactory.MovieDB_Fanart.GetAll().Where(fanart =>                              !string.IsNullOrEmpty(fanart.GetFullImagePath()) &&                              !Misc.IsImageValid(fanart.GetFullImagePath())).ToList();                      logger.Info($"Found {fanarts.Count} corrupted MovieDB {(fanarts.Count == 1 ? "Fanart" : "Fanarts")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetFullImagePath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.MovieDB_FanArt' fanart.MovieDB_FanartID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_MovieDBFanarts} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    queueState.extraParams = new[] {Resources.Command_ValidateAllImages_AniDBPosters};                  ShokoService.CmdProcessorImages.QueueState = queueState;                  count = 0;                  logger.Info("Scanning AniDB Posters for corrupted images");                  var posters = RepoFactory.AniDB_Anime.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.PosterPath) && !Misc.IsImageValid(fanart.PosterPath)).ToList();                  logger.Info($"Found {posters.Count} corrupted AniDB {(posters.Count == 1 ? "Poster" : "Posters")}");                  foreach (var fanart in posters)                  {                      logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.PosterPath}");                      RemoveImageAndQueueRedownload(ImageEntityType.AniDB_Cover' fanart.AnimeID' fanart);                      count++;                      if (count % 10 == 0)                      {                          logger.Info($"Deleting and queueing for redownload {count}/{posters.Count}");                          queueState.extraParams = new[]                              {$"{Resources.Command_ValidateAllImages_AniDBPosters} - {count}/{posters.Count}"};                          ShokoService.CmdProcessorImages.QueueState = queueState;                      }                  }                    if (ServerSettings.AniDB_DownloadCharacters)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_AniDBCharacters};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning AniDB Characters for corrupted images");                      var fanarts = RepoFactory.AniDB_Character.GetAll().Where(fanart =>                              !string.IsNullOrEmpty(fanart.GetPosterPath()) && !Misc.IsImageValid(fanart.GetPosterPath()))                          .ToList();                      logger.Info($"Found {fanarts.Count} corrupted AniDB Character {(fanarts.Count == 1 ? "image" : "images")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetPosterPath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.AniDB_Character' fanart.AniDB_CharacterID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_AniDBCharacters} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }                    if (ServerSettings.AniDB_DownloadCreators)                  {                      queueState.extraParams = new[] {Resources.Command_ValidateAllImages_AniDBSeiyuus};                      ShokoService.CmdProcessorImages.QueueState = queueState;                      count = 0;                      logger.Info("Scanning AniDB Seiyuus for corrupted images");                      var fanarts = RepoFactory.AniDB_Seiyuu.GetAll().Where(fanart =>                          !string.IsNullOrEmpty(fanart.GetPosterPath()) && !Misc.IsImageValid(fanart.GetPosterPath())).ToList();                      logger.Info($"Found {fanarts.Count} corrupted AniDB Seiyuu {(fanarts.Count == 1 ? "image" : "images")}");                      foreach (var fanart in fanarts)                      {                          logger.Trace($"Corrupt image found! Attempting Redownload: {fanart.GetPosterPath()}");                          RemoveImageAndQueueRedownload(ImageEntityType.AniDB_Creator' fanart.SeiyuuID' fanart);                          count++;                          if (count % 10 == 0)                          {                              logger.Info($"Deleting and queueing for redownload {count}/{fanarts.Count}");                              queueState.extraParams = new[]                                  {$"{Resources.Command_ValidateAllImages_AniDBSeiyuus} - {count}/{fanarts.Count}"};                              ShokoService.CmdProcessorImages.QueueState = queueState;                          }                      }                  }              }              catch (Exception ex)              {                  logger.Warn($"Error processing CommandRequest_ValidateAllImages: {ex.Message}");              }
Magic Number,Shoko.Server.Commands,CommandProcessorGeneral,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\CommandProcessorGeneral.cs,WorkerCommands_DoWork,The following statement contains a magic number: while (true)              {                  if (workerCommands.CancellationPending)                  {                      e.Cancel = true;                      return;                  }                    // if paused we will sleep for 5 seconds' and the try again                  // we will remove the pause if it was set more than 12 hours ago                  // the pause is initiated when banned from AniDB or manually by the user                  if (Paused)                  {                      try                      {                          if (workerCommands.CancellationPending)                          {                              e.Cancel = true;                              return;                          }                            TimeSpan ts = DateTime.Now - pauseTime.Value;                          if (ts.TotalHours >= 12)                              Paused = false;                      }                      catch                      {                          // ignore                      }                      Thread.Sleep(200);                      continue;                  }                    CommandRequest crdb = RepoFactory.CommandRequest.GetNextDBCommandRequestGeneral();                  if (crdb == null)                  {                      if (QueueCount > 0)                          logger.Error($"No command returned from repo' but there are {QueueCount} commands left");                      return;                  }                    if (workerCommands.CancellationPending)                  {                      e.Cancel = true;                      return;                  }                    ICommandRequest icr = CommandHelper.GetCommand(crdb);                  if (icr == null)                  {                      logger.Error("No implementation found for command: {0}-{1}"' crdb.CommandType' crdb.CommandID);                  }                  else                  {                      QueueState = icr.PrettyDescription;                        if (workerCommands.CancellationPending)                      {                          e.Cancel = true;                          return;                      }                        logger.Trace("Processing command request: {0}"' crdb.CommandID);                      try                      {                          icr.ProcessCommand();                      }                      catch (Exception ex)                      {                          logger.Error(ex' "ProcessCommand exception: {0}\n{1}"' crdb.CommandID' ex);                      }                  }                    logger.Trace("Deleting command request: {0}"' crdb.CommandID);                  RepoFactory.CommandRequest.Delete(crdb.CommandRequestID);                    QueueCount = RepoFactory.CommandRequest.GetQueuedCommandCountGeneral();              }
Magic Number,Shoko.Server.Commands,CommandProcessorGeneral,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\CommandProcessorGeneral.cs,WorkerCommands_DoWork,The following statement contains a magic number: while (true)              {                  if (workerCommands.CancellationPending)                  {                      e.Cancel = true;                      return;                  }                    // if paused we will sleep for 5 seconds' and the try again                  // we will remove the pause if it was set more than 12 hours ago                  // the pause is initiated when banned from AniDB or manually by the user                  if (Paused)                  {                      try                      {                          if (workerCommands.CancellationPending)                          {                              e.Cancel = true;                              return;                          }                            TimeSpan ts = DateTime.Now - pauseTime.Value;                          if (ts.TotalHours >= 12)                              Paused = false;                      }                      catch                      {                          // ignore                      }                      Thread.Sleep(200);                      continue;                  }                    CommandRequest crdb = RepoFactory.CommandRequest.GetNextDBCommandRequestGeneral();                  if (crdb == null)                  {                      if (QueueCount > 0)                          logger.Error($"No command returned from repo' but there are {QueueCount} commands left");                      return;                  }                    if (workerCommands.CancellationPending)                  {                      e.Cancel = true;                      return;                  }                    ICommandRequest icr = CommandHelper.GetCommand(crdb);                  if (icr == null)                  {                      logger.Error("No implementation found for command: {0}-{1}"' crdb.CommandType' crdb.CommandID);                  }                  else                  {                      QueueState = icr.PrettyDescription;                        if (workerCommands.CancellationPending)                      {                          e.Cancel = true;                          return;                      }                        logger.Trace("Processing command request: {0}"' crdb.CommandID);                      try                      {                          icr.ProcessCommand();                      }                      catch (Exception ex)                      {                          logger.Error(ex' "ProcessCommand exception: {0}\n{1}"' crdb.CommandID' ex);                      }                  }                    logger.Trace("Deleting command request: {0}"' crdb.CommandID);                  RepoFactory.CommandRequest.Delete(crdb.CommandRequestID);                    QueueCount = RepoFactory.CommandRequest.GetQueuedCommandCountGeneral();              }
Magic Number,Shoko.Server.Commands,CommandProcessorHasher,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\CommandProcessorHasher.cs,WorkerCommands_DoWork,The following statement contains a magic number: while (true)              {                  if (workerCommands.CancellationPending)                  {                      e.Cancel = true;                      return;                  }                    // if paused we will sleep for 5 seconds' and the try again                  // we will remove the pause if it was set more than 6 hours ago                  // the pause is initiated when banned from AniDB or manually by the user                  if (Paused)                  {                      try                      {                          if (workerCommands.CancellationPending)                          {                              e.Cancel = true;                              return;                          }                          TimeSpan ts = DateTime.Now - pauseTime.Value;                          if (ts.TotalHours >= 6)                              Paused = false;                      }                      catch                      {                          // ignore                      }                      Thread.Sleep(200);                      continue;                  }                    CommandRequest crdb = RepoFactory.CommandRequest.GetNextDBCommandRequestHasher();                  if (crdb == null)                  {                      if (QueueCount > 0)                          logger.Error($"No command returned from repo' but there are {QueueCount} commands left");                      return;                  }                    if (workerCommands.CancellationPending)                  {                      e.Cancel = true;                      return;                  }                    ICommandRequest icr = CommandHelper.GetCommand(crdb);                  if (icr == null)                  {                      logger.Trace("No implementation found for command: {0}-{1}"' crdb.CommandType' crdb.CommandID);                      return;                  }                    QueueState = icr.PrettyDescription;                    if (workerCommands.CancellationPending)                  {                      e.Cancel = true;                      return;                  }                    icr.ProcessCommand();                    RepoFactory.CommandRequest.Delete(crdb.CommandRequestID);                  QueueCount = RepoFactory.CommandRequest.GetQueuedCommandCountHasher();              }
Magic Number,Shoko.Server.Commands,CommandProcessorHasher,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\CommandProcessorHasher.cs,WorkerCommands_DoWork,The following statement contains a magic number: while (true)              {                  if (workerCommands.CancellationPending)                  {                      e.Cancel = true;                      return;                  }                    // if paused we will sleep for 5 seconds' and the try again                  // we will remove the pause if it was set more than 6 hours ago                  // the pause is initiated when banned from AniDB or manually by the user                  if (Paused)                  {                      try                      {                          if (workerCommands.CancellationPending)                          {                              e.Cancel = true;                              return;                          }                          TimeSpan ts = DateTime.Now - pauseTime.Value;                          if (ts.TotalHours >= 6)                              Paused = false;                      }                      catch                      {                          // ignore                      }                      Thread.Sleep(200);                      continue;                  }                    CommandRequest crdb = RepoFactory.CommandRequest.GetNextDBCommandRequestHasher();                  if (crdb == null)                  {                      if (QueueCount > 0)                          logger.Error($"No command returned from repo' but there are {QueueCount} commands left");                      return;                  }                    if (workerCommands.CancellationPending)                  {                      e.Cancel = true;                      return;                  }                    ICommandRequest icr = CommandHelper.GetCommand(crdb);                  if (icr == null)                  {                      logger.Trace("No implementation found for command: {0}-{1}"' crdb.CommandType' crdb.CommandID);                      return;                  }                    QueueState = icr.PrettyDescription;                    if (workerCommands.CancellationPending)                  {                      e.Cancel = true;                      return;                  }                    icr.ProcessCommand();                    RepoFactory.CommandRequest.Delete(crdb.CommandRequestID);                  QueueCount = RepoFactory.CommandRequest.GetQueuedCommandCountHasher();              }
Magic Number,Shoko.Server.Commands,CommandProcessorImages,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\CommandProcessorImages.cs,WorkerCommands_DoWork,The following statement contains a magic number: while (true)              {                  if (workerCommands.CancellationPending)                  {                      e.Cancel = true;                      return;                  }                    // if paused we will sleep for 5 seconds' and the try again                  // we will remove the pause if it was set more than 6 hours ago                  // the pause is initiated when banned from AniDB or manually by the user                  if (Paused)                  {                      try                      {                          if (workerCommands.CancellationPending)                          {                              e.Cancel = true;                              return;                          }                            TimeSpan ts = DateTime.Now - pauseTime.Value;                          if (ts.TotalHours >= 6)                              Paused = false;                      }                      catch                      {                          // ignore                      }                      Thread.Sleep(200);                      continue;                  }                    CommandRequest crdb = RepoFactory.CommandRequest.GetNextDBCommandRequestImages();                  if (crdb == null) return;                    if (workerCommands.CancellationPending)                  {                      e.Cancel = true;                      return;                  }                    ICommandRequest icr = CommandHelper.GetCommand(crdb);                  if (icr == null)                      return;                    if (workerCommands.CancellationPending)                  {                      e.Cancel = true;                      return;                  }                    QueueState = icr.PrettyDescription;                    icr.ProcessCommand();                    RepoFactory.CommandRequest.Delete(crdb.CommandRequestID);                  QueueCount = RepoFactory.CommandRequest.GetQueuedCommandCountImages();              }
Magic Number,Shoko.Server.Commands,CommandProcessorImages,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\CommandProcessorImages.cs,WorkerCommands_DoWork,The following statement contains a magic number: while (true)              {                  if (workerCommands.CancellationPending)                  {                      e.Cancel = true;                      return;                  }                    // if paused we will sleep for 5 seconds' and the try again                  // we will remove the pause if it was set more than 6 hours ago                  // the pause is initiated when banned from AniDB or manually by the user                  if (Paused)                  {                      try                      {                          if (workerCommands.CancellationPending)                          {                              e.Cancel = true;                              return;                          }                            TimeSpan ts = DateTime.Now - pauseTime.Value;                          if (ts.TotalHours >= 6)                              Paused = false;                      }                      catch                      {                          // ignore                      }                      Thread.Sleep(200);                      continue;                  }                    CommandRequest crdb = RepoFactory.CommandRequest.GetNextDBCommandRequestImages();                  if (crdb == null) return;                    if (workerCommands.CancellationPending)                  {                      e.Cancel = true;                      return;                  }                    ICommandRequest icr = CommandHelper.GetCommand(crdb);                  if (icr == null)                      return;                    if (workerCommands.CancellationPending)                  {                      e.Cancel = true;                      return;                  }                    QueueState = icr.PrettyDescription;                    icr.ProcessCommand();                    RepoFactory.CommandRequest.Delete(crdb.CommandRequestID);                  QueueCount = RepoFactory.CommandRequest.GetQueuedCommandCountImages();              }
Magic Number,Shoko.Server.Commands,CommandRequestImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\CommandRequestImplementation.cs,Save,The following statement contains a magic number: switch (CommandRequestRepository.GetQueueIndex(cri))              {                  case 0:                      ShokoService.CmdProcessorGeneral.NotifyOfNewCommand();                      break;                  case 1:                      ShokoService.CmdProcessorHasher.NotifyOfNewCommand();                      break;                  case 2:                      ShokoService.CmdProcessorImages.NotifyOfNewCommand();                      break;              }
Magic Number,Shoko.Server.Commands,CommandRequestImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\CommandRequestImplementation.cs,Save,The following statement contains a magic number: switch (CommandRequestRepository.GetQueueIndex(cri))              {                  case 0:                      ShokoService.CmdProcessorGeneral.NotifyOfNewCommand();                      break;                  case 1:                      ShokoService.CmdProcessorHasher.NotifyOfNewCommand();                      break;                  case 2:                      ShokoService.CmdProcessorImages.NotifyOfNewCommand();                      break;              }
Magic Number,Shoko.Server.Commands,CommandRequest_AddFileToMyList,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\AniDB\CommandRequest_AddFileToMyList.cs,ProcessCommand,The following statement contains a magic number: try              {                  if (vid == null) return;                    List<SVR_AnimeEpisode> animeEpisodes = vid.GetAnimeEpisodes();                  // when adding a file via the API' newWatchedStatus will return with current watched status on AniDB                  // if the file is already on the user's list                    bool isManualLink = false;                  List<CrossRef_File_Episode> xrefs = vid.EpisodeCrossRefs;                  if (xrefs.Count > 0)                      isManualLink = xrefs[0].CrossRefSource != (int) CrossRefSource.AniDB;                    // mark the video file as watched                  DateTime? watchedDate = null;                  bool? newWatchedStatus;                  AniDBFile_State? state = null;                    if (isManualLink)                      newWatchedStatus = ShokoService.AnidbProcessor.AddFileToMyList(xrefs[0].AnimeID'                          xrefs[0].GetEpisode().EpisodeNumber'                          ref watchedDate);                  else                      newWatchedStatus = ShokoService.AnidbProcessor.AddFileToMyList(vid' ref watchedDate' ref state);                    // do for all AniDB users                  List<SVR_JMMUser> aniDBUsers = RepoFactory.JMMUser.GetAniDBUsers();                      if (aniDBUsers.Count > 0)                  {                      string datemessage = watchedDate?.ToShortDateString() ?? "Not Watched";                      if (watchedDate?.Equals(new DateTime(1970' 1' 1' 0' 0' 0' DateTimeKind.Utc).ToLocalTime()) ?? false)                          datemessage = "No Watch Date Specified";                      logger.Info($"Adding file to list: {vid.FileName} - {datemessage}");                      bool watched = watchedDate != null;                      if (newWatchedStatus != null) watched = newWatchedStatus.Value;                        SVR_JMMUser juser = aniDBUsers[0];                      bool watchedLocally = vid.GetUserRecord(juser.JMMUserID)?.WatchedDate != null;                      bool watchedChanged = watched != watchedLocally;                        // handle import watched settings. Don't update AniDB in either case' we'll do that with the storage state                      if (ServerSettings.AniDB_MyList_ReadWatched && watched && !watchedLocally)                      {                          vid.ToggleWatchedStatus(true' false' watchedDate' false' juser.JMMUserID'                              false' false);                      }                      else if (ServerSettings.AniDB_MyList_ReadUnwatched && !watched && watchedLocally)                      {                          vid.ToggleWatchedStatus(false' false' watchedDate' false' juser.JMMUserID'                              false' false);                      }                        if (watchedChanged || state != ServerSettings.AniDB_MyList_StorageState)                      {                          int watchedDateSec = Commons.Utils.AniDB.GetAniDBDateAsSeconds(watchedDate);                          var cmdUpdate = new CommandRequest_UpdateMyListFileStatus(Hash' watched' false' watchedDateSec);                          cmdUpdate.Save();                      }                  }                    SVR_AnimeSeries ser = animeEpisodes[0].GetAnimeSeries();                  // all the eps should belong to the same anime                  ser.QueueUpdateStats();                  //StatsCache.Instance.UpdateUsingSeries(ser.AnimeSeriesID);                    // lets also try adding to the users trakt collecion                  if (ServerSettings.Trakt_IsEnabled &&                      !string.IsNullOrEmpty(ServerSettings.Trakt_AuthToken))                  {                      foreach (SVR_AnimeEpisode aep in animeEpisodes)                      {                          CommandRequest_TraktCollectionEpisode cmdSyncTrakt =                              new CommandRequest_TraktCollectionEpisode                              (                                  aep.AnimeEpisodeID' TraktSyncAction.Add);                          cmdSyncTrakt.Save();                      }                  }                    // sync the series on MAL                  if (!string.IsNullOrEmpty(ServerSettings.MAL_Username) &&                      !string.IsNullOrEmpty(ServerSettings.MAL_Password))                  {                      CommandRequest_MALUpdatedWatchedStatus cmdMAL =                          new CommandRequest_MALUpdatedWatchedStatus(ser.AniDB_ID);                      cmdMAL.Save();                  }              }              catch (Exception ex)              {                  logger.Error($"Error processing CommandRequest_AddFileToMyList: {Hash} - {ex}");              }
Magic Number,Shoko.Server.Commands,CommandRequest_GetAniDBTitles,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\AniDB\CommandRequest_GetAniDBTitles.cs,ProcessCommand,The following statement contains a magic number: try              {                  bool process =                      ServerSettings.AniDB_Username.Equals("jonbaby"' StringComparison.InvariantCultureIgnoreCase) ||                      ServerSettings.AniDB_Username.Equals("jmediamanager"' StringComparison.InvariantCultureIgnoreCase);                    if (!process) return;                    string url = Constants.AniDBTitlesURL;                  logger.Trace("Get AniDB Titles: {0}"' url);                    Stream s = Misc.DownloadWebBinary(url);                  int bytes = 2048;                  byte[] data = new byte[bytes]; //USE OF BYTES LENGTH VALUES FOR DATA SIZE                  StringBuilder b = new StringBuilder();                  UTF8Encoding enc = new UTF8Encoding();                    GZipInputStream zis = new GZipInputStream(s);                    while ((bytes = zis.Read(data' 0' data.Length)) > 0)                      b.Append(enc.GetString(data' 0' bytes));                    zis.Close();                      string[] lines = b.ToString().Split('\n');                  Dictionary<int' Azure_AnimeIDTitle> titles = new Dictionary<int' Azure_AnimeIDTitle>();                  foreach (string line in lines)                  {                      if (line.Trim().Length == 0 || line.Trim().Substring(0' 1) == "#") continue;                        string[] fields = line.Split('|');                        int.TryParse(fields[0]' out int animeID);                      if (animeID == 0) continue;                        string titleType = fields[1].Trim().ToLower();                      //string language = fields[2].Trim().ToLower();                      string titleValue = fields[3].Trim();                          Azure_AnimeIDTitle thisTitle = null;                      if (titles.ContainsKey(animeID))                      {                          thisTitle = titles[animeID];                      }                      else                      {                          thisTitle = new Azure_AnimeIDTitle                          {                              AnimeIDTitleId = 0'                              MainTitle = titleValue'                              AnimeID = animeID                          };                          titles[animeID] = thisTitle;                      }                        if (!string.IsNullOrEmpty(thisTitle.Titles))                          thisTitle.Titles += "|";                        if (titleType.Equals("1"))                          thisTitle.MainTitle = titleValue;                        thisTitle.Titles += titleValue;                  }                    foreach (Azure_AnimeIDTitle aniTitle in titles.Values)                  {                      //AzureWebAPI.Send_AnimeTitle(aniTitle);                      CommandRequest_Azure_SendAnimeTitle cmdAzure =                          new CommandRequest_Azure_SendAnimeTitle(aniTitle.AnimeID'                              aniTitle.MainTitle' aniTitle.Titles);                      cmdAzure.Save();                  }              }              catch (Exception ex)              {                  logger.Error("Error processing CommandRequest_GetAniDBTitles: {0}"' ex);              }
Magic Number,Shoko.Server.Commands,CommandRequest_GetAniDBTitles,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\AniDB\CommandRequest_GetAniDBTitles.cs,ProcessCommand,The following statement contains a magic number: try              {                  bool process =                      ServerSettings.AniDB_Username.Equals("jonbaby"' StringComparison.InvariantCultureIgnoreCase) ||                      ServerSettings.AniDB_Username.Equals("jmediamanager"' StringComparison.InvariantCultureIgnoreCase);                    if (!process) return;                    string url = Constants.AniDBTitlesURL;                  logger.Trace("Get AniDB Titles: {0}"' url);                    Stream s = Misc.DownloadWebBinary(url);                  int bytes = 2048;                  byte[] data = new byte[bytes]; //USE OF BYTES LENGTH VALUES FOR DATA SIZE                  StringBuilder b = new StringBuilder();                  UTF8Encoding enc = new UTF8Encoding();                    GZipInputStream zis = new GZipInputStream(s);                    while ((bytes = zis.Read(data' 0' data.Length)) > 0)                      b.Append(enc.GetString(data' 0' bytes));                    zis.Close();                      string[] lines = b.ToString().Split('\n');                  Dictionary<int' Azure_AnimeIDTitle> titles = new Dictionary<int' Azure_AnimeIDTitle>();                  foreach (string line in lines)                  {                      if (line.Trim().Length == 0 || line.Trim().Substring(0' 1) == "#") continue;                        string[] fields = line.Split('|');                        int.TryParse(fields[0]' out int animeID);                      if (animeID == 0) continue;                        string titleType = fields[1].Trim().ToLower();                      //string language = fields[2].Trim().ToLower();                      string titleValue = fields[3].Trim();                          Azure_AnimeIDTitle thisTitle = null;                      if (titles.ContainsKey(animeID))                      {                          thisTitle = titles[animeID];                      }                      else                      {                          thisTitle = new Azure_AnimeIDTitle                          {                              AnimeIDTitleId = 0'                              MainTitle = titleValue'                              AnimeID = animeID                          };                          titles[animeID] = thisTitle;                      }                        if (!string.IsNullOrEmpty(thisTitle.Titles))                          thisTitle.Titles += "|";                        if (titleType.Equals("1"))                          thisTitle.MainTitle = titleValue;                        thisTitle.Titles += titleValue;                  }                    foreach (Azure_AnimeIDTitle aniTitle in titles.Values)                  {                      //AzureWebAPI.Send_AnimeTitle(aniTitle);                      CommandRequest_Azure_SendAnimeTitle cmdAzure =                          new CommandRequest_Azure_SendAnimeTitle(aniTitle.AnimeID'                              aniTitle.MainTitle' aniTitle.Titles);                      cmdAzure.Save();                  }              }              catch (Exception ex)              {                  logger.Error("Error processing CommandRequest_GetAniDBTitles: {0}"' ex);              }
Magic Number,Shoko.Server.Commands,CommandRequest_GetCalendar,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\AniDB\CommandRequest_GetCalendar.cs,ProcessCommand,The following statement contains a magic number: try              {                  // we will always assume that an anime was downloaded via http first                    ScheduledUpdate sched =                      RepoFactory.ScheduledUpdate.GetByUpdateType((int) ScheduledUpdateType.AniDBCalendar);                  if (sched == null)                  {                      sched = new ScheduledUpdate                      {                          UpdateType = (int)ScheduledUpdateType.AniDBCalendar'                          UpdateDetails = string.Empty                      };                  }                  else                  {                      int freqHours = Utils.GetScheduledHours(ServerSettings.AniDB_Calendar_UpdateFrequency);                        // if we have run this in the last 12 hours and are not forcing it' then exit                      TimeSpan tsLastRun = DateTime.Now - sched.LastUpdate;                      if (tsLastRun.TotalHours < freqHours)                      {                          if (!ForceRefresh) return;                      }                  }                    sched.LastUpdate = DateTime.Now;                  RepoFactory.ScheduledUpdate.Save(sched);                    CalendarCollection colCalendars = ShokoService.AnidbProcessor.GetCalendarUDP();                  if (colCalendars == null || colCalendars.Calendars == null)                  {                      logger.Error("Could not get calendar from AniDB");                      return;                  }                  foreach (Calendar cal in colCalendars.Calendars)                  {                      SVR_AniDB_Anime anime = RepoFactory.AniDB_Anime.GetByAnimeID(cal.AnimeID);                      var update = RepoFactory.AniDB_AnimeUpdate.GetByAnimeID(cal.AnimeID);                      if (anime != null && update != null)                      {                          // don't update if the local data is less 2 days old                          TimeSpan ts = DateTime.Now - update.UpdatedAt;                          if (ts.TotalDays >= 2)                          {                              CommandRequest_GetAnimeHTTP cmdAnime = new CommandRequest_GetAnimeHTTP(cal.AnimeID' true'                                  false);                              cmdAnime.Save();                          }                          else                          {                              // update the release date even if we don't update the anime record                              if (anime.AirDate != cal.ReleaseDate)                              {                                  anime.AirDate = cal.ReleaseDate;                                  RepoFactory.AniDB_Anime.Save(anime);                                  SVR_AnimeSeries ser = RepoFactory.AnimeSeries.GetByAnimeID(anime.AnimeID);                                  if (ser != null)                                      RepoFactory.AnimeSeries.Save(ser' true' false);                              }                          }                      }                      else                      {                          CommandRequest_GetAnimeHTTP cmdAnime =                              new CommandRequest_GetAnimeHTTP(cal.AnimeID' true' false);                          cmdAnime.Save();                      }                  }              }              catch (Exception ex)              {                  logger.Error(ex' "Error processing CommandRequest_GetCalendar: " + ex);              }
Magic Number,Shoko.Server.Commands,CommandRequest_GetReleaseGroupStatus,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\AniDB\CommandRequest_GetReleaseGroupStatus.cs,ProcessCommand,The following statement contains a magic number: try              {                  // only get group status if we have an associated series                  SVR_AnimeSeries series = RepoFactory.AnimeSeries.GetByAnimeID(AnimeID);                  if (series == null) return;                    SVR_AniDB_Anime anime = RepoFactory.AniDB_Anime.GetByAnimeID(AnimeID);                  if (anime == null) return;                    // don't get group status if the anime has already ended more than 50 days ago                  bool skip = false;                  if (!ForceRefresh)                  {                      if (anime.EndDate.HasValue)                      {                          if (anime.EndDate.Value < DateTime.Now)                          {                              TimeSpan ts = DateTime.Now - anime.EndDate.Value;                              if (ts.TotalDays > 50)                              {                                  // don't skip if we have never downloaded this info before                                  List<AniDB_GroupStatus> grpStatuses =                                      RepoFactory.AniDB_GroupStatus.GetByAnimeID(AnimeID);                                  if (grpStatuses != null && grpStatuses.Count > 0)                                  {                                      skip = true;                                  }                              }                          }                      }                  }                    if (skip)                  {                      logger.Info("Skipping group status command because anime has already ended: {0}"' anime);                      return;                  }                    GroupStatusCollection grpCol = ShokoService.AnidbProcessor.GetReleaseGroupStatusUDP(AnimeID);                    if (ServerSettings.AniDB_DownloadReleaseGroups && grpCol != null && grpCol.Groups != null &&                      grpCol.Groups.Count > 0)                  {                      // save in bulk to improve performance                      using (var session = DatabaseFactory.SessionFactory.OpenSession())                      {                          foreach (Raw_AniDB_GroupStatus grpStatus in grpCol.Groups)                          {                              CommandRequest_GetReleaseGroup cmdRelgrp =                                  new CommandRequest_GetReleaseGroup(grpStatus.GroupID' false);                              cmdRelgrp.Save(session);                          }                      }                  }              }              catch (Exception ex)              {                  logger.Error("Error processing CommandRequest_GetReleaseGroupStatus: {0} - {1}"' AnimeID'                      ex);              }
Magic Number,Shoko.Server.Commands,CommandRequest_GetUpdated,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\AniDB\CommandRequest_GetUpdated.cs,ProcessCommand,The following statement contains a magic number: try              {                  List<int> animeIDsToUpdate = new List<int>();                    // check the automated update table to see when the last time we ran this command                  ScheduledUpdate sched =                      RepoFactory.ScheduledUpdate.GetByUpdateType((int) ScheduledUpdateType.AniDBUpdates);                  if (sched != null)                  {                      int freqHours = Utils.GetScheduledHours(ServerSettings.AniDB_Anime_UpdateFrequency);                        // if we have run this in the last 12 hours and are not forcing it' then exit                      TimeSpan tsLastRun = DateTime.Now - sched.LastUpdate;                      if (tsLastRun.TotalHours < freqHours)                      {                          if (!ForceRefresh) return;                      }                  }                      long webUpdateTime = 0;                  long webUpdateTimeNew = 0;                  if (sched == null)                  {                      // if this is the first time' lets ask for last 3 days                      DateTime localTime = DateTime.Now.AddDays(-3);                      DateTime utcTime = localTime.ToUniversalTime();                      webUpdateTime = long.Parse(Commons.Utils.AniDB.AniDBDate(utcTime));                      webUpdateTimeNew = long.Parse(Commons.Utils.AniDB.AniDBDate(DateTime.Now.ToUniversalTime()));                        sched = new ScheduledUpdate                      {                          UpdateType = (int)ScheduledUpdateType.AniDBUpdates                      };                  }                  else                  {                      logger.Trace("Last anidb info update was : {0}"' sched.UpdateDetails);                      webUpdateTime = long.Parse(sched.UpdateDetails);                      webUpdateTimeNew = long.Parse(Commons.Utils.AniDB.AniDBDate(DateTime.Now.ToUniversalTime()));                        logger.Info(                          $"{Utils.FormatSecondsToDisplayTime(int.Parse((webUpdateTimeNew - webUpdateTime).ToString()))} since last UPDATED command");                  }                    // get a list of updates from AniDB                  // startTime will contain the date/time from which the updates apply to                  ShokoService.AnidbProcessor.GetUpdated(ref animeIDsToUpdate' ref webUpdateTime);                    // now save the update time from AniDB                  // we will use this next time as a starting point when querying the web cache                  sched.LastUpdate = DateTime.Now;                  sched.UpdateDetails = webUpdateTimeNew.ToString();                  RepoFactory.ScheduledUpdate.Save(sched);                    if (animeIDsToUpdate.Count == 0)                  {                      logger.Info("No anime to be updated");                      return;                  }                      int countAnime = 0;                  int countSeries = 0;                  foreach (int animeID in animeIDsToUpdate)                  {                      // update the anime from HTTP                      SVR_AniDB_Anime anime = RepoFactory.AniDB_Anime.GetByAnimeID(animeID);                      if (anime == null)                      {                          logger.Trace("No local record found for Anime ID: {0}' so skipping..."' animeID);                          continue;                      }                        logger.Info("Updating CommandRequest_GetUpdated: {0} "' animeID);                        var update = RepoFactory.AniDB_AnimeUpdate.GetByAnimeID(animeID);                        // but only if it hasn't been recently updated                      TimeSpan ts = DateTime.Now - update.UpdatedAt;                      if (ts.TotalHours > 4)                      {                          CommandRequest_GetAnimeHTTP cmdAnime = new CommandRequest_GetAnimeHTTP(animeID' true' false);                          cmdAnime.Save();                          countAnime++;                      }                        // update the group status                      // this will allow us to determine which anime has missing episodes                      // so we wonly get by an amime where we also have an associated series                      SVR_AnimeSeries ser = RepoFactory.AnimeSeries.GetByAnimeID(animeID);                      if (ser != null)                      {                          CommandRequest_GetReleaseGroupStatus cmdStatus =                              new CommandRequest_GetReleaseGroupStatus(animeID' true);                          cmdStatus.Save();                          countSeries++;                      }                  }                    logger.Info("Updating {0} anime records' and {1} group status records"' countAnime' countSeries);              }              catch (Exception ex)              {                  logger.Error("Error processing CommandRequest_GetUpdated: {0}"' ex);              }
Magic Number,Shoko.Server.Commands,CommandRequest_GetUpdated,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\AniDB\CommandRequest_GetUpdated.cs,ProcessCommand,The following statement contains a magic number: try              {                  List<int> animeIDsToUpdate = new List<int>();                    // check the automated update table to see when the last time we ran this command                  ScheduledUpdate sched =                      RepoFactory.ScheduledUpdate.GetByUpdateType((int) ScheduledUpdateType.AniDBUpdates);                  if (sched != null)                  {                      int freqHours = Utils.GetScheduledHours(ServerSettings.AniDB_Anime_UpdateFrequency);                        // if we have run this in the last 12 hours and are not forcing it' then exit                      TimeSpan tsLastRun = DateTime.Now - sched.LastUpdate;                      if (tsLastRun.TotalHours < freqHours)                      {                          if (!ForceRefresh) return;                      }                  }                      long webUpdateTime = 0;                  long webUpdateTimeNew = 0;                  if (sched == null)                  {                      // if this is the first time' lets ask for last 3 days                      DateTime localTime = DateTime.Now.AddDays(-3);                      DateTime utcTime = localTime.ToUniversalTime();                      webUpdateTime = long.Parse(Commons.Utils.AniDB.AniDBDate(utcTime));                      webUpdateTimeNew = long.Parse(Commons.Utils.AniDB.AniDBDate(DateTime.Now.ToUniversalTime()));                        sched = new ScheduledUpdate                      {                          UpdateType = (int)ScheduledUpdateType.AniDBUpdates                      };                  }                  else                  {                      logger.Trace("Last anidb info update was : {0}"' sched.UpdateDetails);                      webUpdateTime = long.Parse(sched.UpdateDetails);                      webUpdateTimeNew = long.Parse(Commons.Utils.AniDB.AniDBDate(DateTime.Now.ToUniversalTime()));                        logger.Info(                          $"{Utils.FormatSecondsToDisplayTime(int.Parse((webUpdateTimeNew - webUpdateTime).ToString()))} since last UPDATED command");                  }                    // get a list of updates from AniDB                  // startTime will contain the date/time from which the updates apply to                  ShokoService.AnidbProcessor.GetUpdated(ref animeIDsToUpdate' ref webUpdateTime);                    // now save the update time from AniDB                  // we will use this next time as a starting point when querying the web cache                  sched.LastUpdate = DateTime.Now;                  sched.UpdateDetails = webUpdateTimeNew.ToString();                  RepoFactory.ScheduledUpdate.Save(sched);                    if (animeIDsToUpdate.Count == 0)                  {                      logger.Info("No anime to be updated");                      return;                  }                      int countAnime = 0;                  int countSeries = 0;                  foreach (int animeID in animeIDsToUpdate)                  {                      // update the anime from HTTP                      SVR_AniDB_Anime anime = RepoFactory.AniDB_Anime.GetByAnimeID(animeID);                      if (anime == null)                      {                          logger.Trace("No local record found for Anime ID: {0}' so skipping..."' animeID);                          continue;                      }                        logger.Info("Updating CommandRequest_GetUpdated: {0} "' animeID);                        var update = RepoFactory.AniDB_AnimeUpdate.GetByAnimeID(animeID);                        // but only if it hasn't been recently updated                      TimeSpan ts = DateTime.Now - update.UpdatedAt;                      if (ts.TotalHours > 4)                      {                          CommandRequest_GetAnimeHTTP cmdAnime = new CommandRequest_GetAnimeHTTP(animeID' true' false);                          cmdAnime.Save();                          countAnime++;                      }                        // update the group status                      // this will allow us to determine which anime has missing episodes                      // so we wonly get by an amime where we also have an associated series                      SVR_AnimeSeries ser = RepoFactory.AnimeSeries.GetByAnimeID(animeID);                      if (ser != null)                      {                          CommandRequest_GetReleaseGroupStatus cmdStatus =                              new CommandRequest_GetReleaseGroupStatus(animeID' true);                          cmdStatus.Save();                          countSeries++;                      }                  }                    logger.Info("Updating {0} anime records' and {1} group status records"' countAnime' countSeries);              }              catch (Exception ex)              {                  logger.Error("Error processing CommandRequest_GetUpdated: {0}"' ex);              }
Magic Number,Shoko.Server.Commands,CommandRequest_TvDBSearchAnime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\TvDB\CommandRequest_TvDBSearchAnime.cs,ProcessSearchResults,The following statement contains a magic number: if (results.Count == 1)              {                  // since we are using this result' lets download the info                  logger.Trace("Found 1 tvdb results for search on {0} --- Linked to {1} ({2})"' searchCriteria'                      results[0].SeriesName'                      results[0].SeriesID);                  TvDB_Series tvser = TvDBApiHelper.GetSeriesInfoOnline(results[0].SeriesID' false);                  TvDBApiHelper.LinkAniDBTvDB(AnimeID' EpisodeType.Episode' 1' results[0].SeriesID' 1' 1' true);                    // add links for multiple seasons (for long shows)                  List<int> seasons = RepoFactory.TvDB_Episode.GetSeasonNumbersForSeries(results[0].SeriesID);                  foreach (int season in seasons)                  {                      if (season < 2) continue; // we just linked season 1' so start after (and skip specials)                      TvDB_Episode ep = RepoFactory.TvDB_Episode.GetBySeriesIDSeasonNumberAndEpisode(results[0].SeriesID' season' 1);                      if (ep?.AbsoluteNumber != null)                      {                          AddCrossRef_AniDB_TvDBV2(AnimeID' ep.AbsoluteNumber.Value' results[0].SeriesID'                              season' tvser?.SeriesName ?? string.Empty);                      }                  }                  SVR_AniDB_Anime.UpdateStatsByAnimeID(AnimeID);                  return true;              }
Magic Number,Shoko.Server.Commands,CommandRequest_TvDBSearchAnime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\TvDB\CommandRequest_TvDBSearchAnime.cs,ProcessSearchResults,The following statement contains a magic number: if (results.Count > 1)              {                  logger.Trace("Found multiple ({0}) tvdb results for search on so checking for english results {1}"'                      results.Count'                      searchCriteria);                  foreach (TVDB_Series_Search_Response sres in results)                  {                      // since we are using this result' lets download the info                      logger.Trace("Found english result for search on {0} --- Linked to {1} ({2})"' searchCriteria'                          sres.SeriesName'                          sres.SeriesID);                      TvDB_Series tvser = TvDBApiHelper.GetSeriesInfoOnline(results[0].SeriesID' false);                      TvDBApiHelper.LinkAniDBTvDB(AnimeID' EpisodeType.Episode' 1' sres.SeriesID' 1' 1' true);                        // add links for multiple seasons (for long shows)                      List<int> seasons = RepoFactory.TvDB_Episode.GetSeasonNumbersForSeries(results[0].SeriesID);                      foreach (int season in seasons)                      {                          if (season < 2) continue; // we just linked season 1' so start after (and skip specials)                          TvDB_Episode ep = RepoFactory.TvDB_Episode                              .GetBySeriesIDSeasonNumberAndEpisode(results[0].SeriesID' season' 1);                          if (ep?.AbsoluteNumber != null)                          {                              AddCrossRef_AniDB_TvDBV2(AnimeID' ep.AbsoluteNumber.Value' results[0].SeriesID'                                  season' tvser?.SeriesName ?? string.Empty);                          }                      }                      return true;                  }                  logger.Trace("No english results found' so SKIPPING: {0}"' searchCriteria);              }
Magic Number,Shoko.Server.AniDB_API.Raws,Raw_AniDB_MyListStats,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_MyListStats.cs,Raw_AniDB_MyListStats,The following statement contains a magic number: string[] sDetails = sRecMessage.Substring(16).Split('|');
Magic Number,Shoko.Server.AniDB_API.Raws,Raw_AniDB_MyListStats,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_MyListStats.cs,Raw_AniDB_MyListStats,The following statement contains a magic number: this.Files = AniDBAPILib.ProcessAniDBInt(sDetails[2]);
Magic Number,Shoko.Server.AniDB_API.Raws,Raw_AniDB_MyListStats,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_MyListStats.cs,Raw_AniDB_MyListStats,The following statement contains a magic number: this.SizeOfFiles = AniDBAPILib.ProcessAniDBLong(sDetails[3]);
Magic Number,Shoko.Server.AniDB_API.Raws,Raw_AniDB_MyListStats,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_MyListStats.cs,Raw_AniDB_MyListStats,The following statement contains a magic number: this.AddedAnimes = AniDBAPILib.ProcessAniDBInt(sDetails[4]);
Magic Number,Shoko.Server.AniDB_API.Raws,Raw_AniDB_MyListStats,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_MyListStats.cs,Raw_AniDB_MyListStats,The following statement contains a magic number: this.AddedEpisodes = AniDBAPILib.ProcessAniDBInt(sDetails[5]);
Magic Number,Shoko.Server.AniDB_API.Raws,Raw_AniDB_MyListStats,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_MyListStats.cs,Raw_AniDB_MyListStats,The following statement contains a magic number: this.AddedFiles = AniDBAPILib.ProcessAniDBInt(sDetails[6]);
Magic Number,Shoko.Server.AniDB_API.Raws,Raw_AniDB_MyListStats,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_MyListStats.cs,Raw_AniDB_MyListStats,The following statement contains a magic number: this.AddedGroups = AniDBAPILib.ProcessAniDBInt(sDetails[7]);
Magic Number,Shoko.Server.AniDB_API.Raws,Raw_AniDB_MyListStats,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_MyListStats.cs,Raw_AniDB_MyListStats,The following statement contains a magic number: this.LeechPct = AniDBAPILib.ProcessAniDBInt(sDetails[8]);
Magic Number,Shoko.Server.AniDB_API.Raws,Raw_AniDB_MyListStats,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_MyListStats.cs,Raw_AniDB_MyListStats,The following statement contains a magic number: this.GloryPct = AniDBAPILib.ProcessAniDBInt(sDetails[9]);
Magic Number,Shoko.Server.AniDB_API.Raws,Raw_AniDB_MyListStats,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_MyListStats.cs,Raw_AniDB_MyListStats,The following statement contains a magic number: this.ViewedPct = AniDBAPILib.ProcessAniDBInt(sDetails[10]);
Magic Number,Shoko.Server.AniDB_API.Raws,Raw_AniDB_MyListStats,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_MyListStats.cs,Raw_AniDB_MyListStats,The following statement contains a magic number: this.MylistPct = AniDBAPILib.ProcessAniDBInt(sDetails[11]);
Magic Number,Shoko.Server.AniDB_API.Raws,Raw_AniDB_MyListStats,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_MyListStats.cs,Raw_AniDB_MyListStats,The following statement contains a magic number: this.ViewedMylistPct = AniDBAPILib.ProcessAniDBInt(sDetails[12]);
Magic Number,Shoko.Server.AniDB_API.Raws,Raw_AniDB_MyListStats,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_MyListStats.cs,Raw_AniDB_MyListStats,The following statement contains a magic number: this.EpisodesViewed = AniDBAPILib.ProcessAniDBInt(sDetails[13]);
Magic Number,Shoko.Server.AniDB_API.Raws,Raw_AniDB_MyListStats,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_MyListStats.cs,Raw_AniDB_MyListStats,The following statement contains a magic number: this.Votes = AniDBAPILib.ProcessAniDBInt(sDetails[14]);
Magic Number,Shoko.Server.AniDB_API.Raws,Raw_AniDB_MyListStats,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_MyListStats.cs,Raw_AniDB_MyListStats,The following statement contains a magic number: this.Reviews = AniDBAPILib.ProcessAniDBInt(sDetails[15]);
Magic Number,Shoko.Server.AniDB_API.Raws,Raw_AniDB_MyListStats,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_MyListStats.cs,Raw_AniDB_MyListStats,The following statement contains a magic number: this.ViewiedLength = AniDBAPILib.ProcessAniDBInt(sDetails[16]);
Magic Number,Shoko.Server.AniDB_API.Raws,Raw_AniDB_Vote_HTTP,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Vote_HTTP.cs,ProcessAnime,The following statement contains a magic number: int.TryParse((val * 100).ToString()' out int ival);
Magic Number,Shoko.Server.AniDB_API.Raws,Raw_AniDB_Vote_HTTP,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Vote_HTTP.cs,ProcessAnimeTemp,The following statement contains a magic number: int.TryParse((val * 100).ToString()' out int ival);
Magic Number,Shoko.Server.AniDB_API.Raws,Raw_AniDB_Vote_HTTP,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Raws\Raw_AniDB_Vote_HTTP.cs,ProcessEpisode,The following statement contains a magic number: int.TryParse((val * 100).ToString()' out int ival);
Magic Number,Shoko.Server.API,APIHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\APIHelper.cs,ConvertRestImageToNonRestUrl,The following statement contains a magic number: if (int.TryParse(split[split.Length - 1]' out int id)) // no ratio              {                  if (int.TryParse(split[split.Length - 2]' out type))                  {                      return ConstructImageLinkFromTypeAndId(ctx' type' id' short_url);                  }              }              else if (int.TryParse(split[split.Length - 2]' out id)) // ratio              {                  if (int.TryParse(split[split.Length - 3]' out type))                  {                      return ConstructImageLinkFromTypeAndId(ctx' type' id' short_url);                  }              }
Magic Number,Shoko.Server.API,APIHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\APIHelper.cs,ConvertRestImageToNonRestUrl,The following statement contains a magic number: if (int.TryParse(split[split.Length - 1]' out int id)) // no ratio              {                  if (int.TryParse(split[split.Length - 2]' out type))                  {                      return ConstructImageLinkFromTypeAndId(ctx' type' id' short_url);                  }              }              else if (int.TryParse(split[split.Length - 2]' out id)) // ratio              {                  if (int.TryParse(split[split.Length - 3]' out type))                  {                      return ConstructImageLinkFromTypeAndId(ctx' type' id' short_url);                  }              }
Magic Number,Shoko.Server.API,APIHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\APIHelper.cs,ConvertRestImageToNonRestUrl,The following statement contains a magic number: if (int.TryParse(split[split.Length - 1]' out int id)) // no ratio              {                  if (int.TryParse(split[split.Length - 2]' out type))                  {                      return ConstructImageLinkFromTypeAndId(ctx' type' id' short_url);                  }              }              else if (int.TryParse(split[split.Length - 2]' out id)) // ratio              {                  if (int.TryParse(split[split.Length - 3]' out type))                  {                      return ConstructImageLinkFromTypeAndId(ctx' type' id' short_url);                  }              }
Magic Number,Shoko.Server.API,Bootstrapper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\Bootstrapper.cs,RequestStartup,The following statement contains a magic number: GzipCompressionSettings gzipsettings = new GzipCompressionSettings              {                  MinimumBytes = 16384 //16k              };
Magic Number,Shoko.Server.API,StatusCodeHandler,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\Bootstrapper.cs,Handle,The following statement contains a magic number: context.Response.Contents = stream =>              {                  try                  {                      var filename = Path.Combine(_rootPathProvider.GetRootPath()' @"webui"' "index.html");                      using (var file = File.OpenRead(filename))                      {                          file.CopyTo(stream);                      }                  }                  catch (Exception)                  {                      try                      {                          StreamWriter writer = new StreamWriter(stream' Encoding.Unicode' 128' true);                          writer.Write(@"<html><body>File not Found (404)</body></html>");                          writer.Flush();                          writer.Close();                      }                      catch                      {}                  }              };
Magic Number,Shoko.Server.API.v2.Models.common,Group,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Models\common\Group.cs,GenerateFromAnimeGroup,The following statement contains a magic number: if (animes != null && animes.Count > 0)              {                  var anime = animes.FirstOrDefault();                  Random rand = new Random();                  if (allpic || pic > 1)                  {                      if (allpic) pic = 999;                      int pic_index = 0;                      foreach (var ani in animes)                      {                          foreach (var cont_image in ani.AllPosters)                              if (pic_index < pic)                              {                                  g.art.thumb.Add(new Art                                  {                                      url = APIHelper.ConstructImageLinkFromTypeAndId(ctx' cont_image.ImageType'                                          cont_image.AniDB_Anime_DefaultImageID)'                                      index = pic_index                                  });                                  pic_index++;                              }                              else                              {                                  break;                              }                            pic_index = 0;                          foreach (var cont_image in ani.Contract.AniDBAnime.Fanarts)                              if (pic_index < pic)                              {                                  g.art.fanart.Add(new Art                                  {                                      url = APIHelper.ConstructImageLinkFromTypeAndId(ctx' cont_image.ImageType'                                          cont_image.AniDB_Anime_DefaultImageID)'                                      index = pic_index                                  });                                  pic_index++;                              }                              else                              {                                  break;                              }                            pic_index = 0;                          foreach (var cont_image in ani.Contract.AniDBAnime.Banners)                              if (pic_index < pic)                              {                                  g.art.banner.Add(new Art                                  {                                      url = APIHelper.ConstructImageLinkFromTypeAndId(ctx' cont_image.ImageType'                                          cont_image.AniDB_Anime_DefaultImageID)'                                      index = pic_index                                  });                                  pic_index++;                              }                              else                              {                                  break;                              }                      }                  }                  else                  {                      g.art.thumb.Add(new Art                      {                          url = APIHelper.ConstructImageLinkFromTypeAndId(ctx' (int) ImageEntityType.AniDB_Cover'                              anime.AnimeID)'                          index = 0                      });                        var fanarts = anime.Contract.AniDBAnime.Fanarts;                      if (fanarts != null && fanarts.Count > 0)                      {                          var art = fanarts[rand.Next(fanarts.Count)];                          g.art.fanart.Add(new Art                          {                              url = APIHelper.ConstructImageLinkFromTypeAndId(ctx' art.ImageType'                                  art.AniDB_Anime_DefaultImageID)'                              index = 0                          });                      }                        fanarts = anime.Contract.AniDBAnime.Banners;                      if (fanarts != null && fanarts.Count > 0)                      {                          var art = fanarts[rand.Next(fanarts.Count)];                          g.art.banner.Add(new Art                          {                              url = APIHelper.ConstructImageLinkFromTypeAndId(ctx' art.ImageType'                                  art.AniDB_Anime_DefaultImageID)'                              index = 0                          });                      }                  }                    List<SVR_AnimeEpisode> ael;                  if (filter != null)                      ael = filter.SeriesIds[uid].Select(id => RepoFactory.AnimeSeries.GetByID(id))                          .Where(ser => ser?.AnimeGroupID == ag.AnimeGroupID).SelectMany(ser => ser.GetAnimeEpisodes())                          .ToList();                  else                      ael = ag.GetAllSeries().SelectMany(a => a.GetAnimeEpisodes()).ToList();                    GenerateSizes(g' ael' uid);                    g.air = anime.AirDate?.ToPlexDate() ?? string.Empty;                    g.rating = Math.Round(ag.AniDBRating / 100' 1).ToString(CultureInfo.InvariantCulture);                  g.summary = anime.Description ?? string.Empty;                  g.titles = anime.GetTitles().ToAPIContract();                  g.year = anime.BeginYear.ToString();                    if (!notag && ag.Contract.Stat_AllTags != null)                      g.tags = TagFilter.ProcessTags(tagfilter' ag.Contract.Stat_AllTags.ToList());                    if (!nocast)                  {                      var xref_animestaff =                          RepoFactory.CrossRef_Anime_Staff.GetByAnimeIDAndRoleType(anime.AnimeID' StaffRoleType.Seiyuu);                      foreach (var xref in xref_animestaff)                      {                          if (xref.RoleID == null) continue;                          var character = RepoFactory.AnimeCharacter.GetByID(xref.RoleID.Value);                          if (character == null) continue;                          var staff = RepoFactory.AnimeStaff.GetByID(xref.StaffID);                          if (staff == null) continue;                          var role = new Role                          {                              character = character.Name'                              character_image = APIHelper.ConstructImageLinkFromTypeAndId(ctx' (int) ImageEntityType.Character'                                  xref.RoleID.Value)'                              staff = staff.Name'                              staff_image = APIHelper.ConstructImageLinkFromTypeAndId(ctx' (int) ImageEntityType.Staff'                                  xref.StaffID)'                              role = xref.Role'                              type = ((StaffRoleType) xref.RoleType).ToString()                          };                          if (g.roles == null) g.roles = new List<Role>();                          g.roles.Add(role);                      }                  }              }
Magic Number,Shoko.Server.API.v2.Models.common,Group,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Models\common\Group.cs,GenerateFromAnimeGroup,The following statement contains a magic number: if (animes != null && animes.Count > 0)              {                  var anime = animes.FirstOrDefault();                  Random rand = new Random();                  if (allpic || pic > 1)                  {                      if (allpic) pic = 999;                      int pic_index = 0;                      foreach (var ani in animes)                      {                          foreach (var cont_image in ani.AllPosters)                              if (pic_index < pic)                              {                                  g.art.thumb.Add(new Art                                  {                                      url = APIHelper.ConstructImageLinkFromTypeAndId(ctx' cont_image.ImageType'                                          cont_image.AniDB_Anime_DefaultImageID)'                                      index = pic_index                                  });                                  pic_index++;                              }                              else                              {                                  break;                              }                            pic_index = 0;                          foreach (var cont_image in ani.Contract.AniDBAnime.Fanarts)                              if (pic_index < pic)                              {                                  g.art.fanart.Add(new Art                                  {                                      url = APIHelper.ConstructImageLinkFromTypeAndId(ctx' cont_image.ImageType'                                          cont_image.AniDB_Anime_DefaultImageID)'                                      index = pic_index                                  });                                  pic_index++;                              }                              else                              {                                  break;                              }                            pic_index = 0;                          foreach (var cont_image in ani.Contract.AniDBAnime.Banners)                              if (pic_index < pic)                              {                                  g.art.banner.Add(new Art                                  {                                      url = APIHelper.ConstructImageLinkFromTypeAndId(ctx' cont_image.ImageType'                                          cont_image.AniDB_Anime_DefaultImageID)'                                      index = pic_index                                  });                                  pic_index++;                              }                              else                              {                                  break;                              }                      }                  }                  else                  {                      g.art.thumb.Add(new Art                      {                          url = APIHelper.ConstructImageLinkFromTypeAndId(ctx' (int) ImageEntityType.AniDB_Cover'                              anime.AnimeID)'                          index = 0                      });                        var fanarts = anime.Contract.AniDBAnime.Fanarts;                      if (fanarts != null && fanarts.Count > 0)                      {                          var art = fanarts[rand.Next(fanarts.Count)];                          g.art.fanart.Add(new Art                          {                              url = APIHelper.ConstructImageLinkFromTypeAndId(ctx' art.ImageType'                                  art.AniDB_Anime_DefaultImageID)'                              index = 0                          });                      }                        fanarts = anime.Contract.AniDBAnime.Banners;                      if (fanarts != null && fanarts.Count > 0)                      {                          var art = fanarts[rand.Next(fanarts.Count)];                          g.art.banner.Add(new Art                          {                              url = APIHelper.ConstructImageLinkFromTypeAndId(ctx' art.ImageType'                                  art.AniDB_Anime_DefaultImageID)'                              index = 0                          });                      }                  }                    List<SVR_AnimeEpisode> ael;                  if (filter != null)                      ael = filter.SeriesIds[uid].Select(id => RepoFactory.AnimeSeries.GetByID(id))                          .Where(ser => ser?.AnimeGroupID == ag.AnimeGroupID).SelectMany(ser => ser.GetAnimeEpisodes())                          .ToList();                  else                      ael = ag.GetAllSeries().SelectMany(a => a.GetAnimeEpisodes()).ToList();                    GenerateSizes(g' ael' uid);                    g.air = anime.AirDate?.ToPlexDate() ?? string.Empty;                    g.rating = Math.Round(ag.AniDBRating / 100' 1).ToString(CultureInfo.InvariantCulture);                  g.summary = anime.Description ?? string.Empty;                  g.titles = anime.GetTitles().ToAPIContract();                  g.year = anime.BeginYear.ToString();                    if (!notag && ag.Contract.Stat_AllTags != null)                      g.tags = TagFilter.ProcessTags(tagfilter' ag.Contract.Stat_AllTags.ToList());                    if (!nocast)                  {                      var xref_animestaff =                          RepoFactory.CrossRef_Anime_Staff.GetByAnimeIDAndRoleType(anime.AnimeID' StaffRoleType.Seiyuu);                      foreach (var xref in xref_animestaff)                      {                          if (xref.RoleID == null) continue;                          var character = RepoFactory.AnimeCharacter.GetByID(xref.RoleID.Value);                          if (character == null) continue;                          var staff = RepoFactory.AnimeStaff.GetByID(xref.StaffID);                          if (staff == null) continue;                          var role = new Role                          {                              character = character.Name'                              character_image = APIHelper.ConstructImageLinkFromTypeAndId(ctx' (int) ImageEntityType.Character'                                  xref.RoleID.Value)'                              staff = staff.Name'                              staff_image = APIHelper.ConstructImageLinkFromTypeAndId(ctx' (int) ImageEntityType.Staff'                                  xref.StaffID)'                              role = xref.Role'                              type = ((StaffRoleType) xref.RoleType).ToString()                          };                          if (g.roles == null) g.roles = new List<Role>();                          g.roles.Add(role);                      }                  }              }
Magic Number,Shoko.Server.API.v2.Models.common,Episode,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Models\common\Episode.cs,GenerateFromAnimeEpisode,The following statement contains a magic number: if (double.TryParse(ep.rating' out double rating))              {                  // 0.1 should be the absolute lowest rating                  if (rating > 10) ep.rating = (rating / 100).ToString(CultureInfo.InvariantCulture);              }
Magic Number,Shoko.Server.API.v2.Models.common,Episode,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Models\common\Episode.cs,GenerateFromAnimeEpisode,The following statement contains a magic number: if (double.TryParse(ep.rating' out double rating))              {                  // 0.1 should be the absolute lowest rating                  if (rating > 10) ep.rating = (rating / 100).ToString(CultureInfo.InvariantCulture);              }
Magic Number,Shoko.Server.API.v2.Models.common,Role,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Models\common\Role.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  return ((character != null ? character.GetHashCode() : 0) * 397) ^ (staff != null ? staff.GetHashCode() : 0);              }
Magic Number,Shoko.Server.API.v2.Models.common,Serie,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Models\common\Serie.cs,GenerateFromAnimeSeries,The following statement contains a magic number: if (anime != null)              {                  Random rand = new Random();                  if (allpics || pic > 1)                  {                      if (allpics)                      {                          pic = 999;                      }                      int pic_index = 0;                      if (anime.AllPosters != null)                          foreach (var cont_image in anime.AllPosters)                          {                              if (pic_index < pic)                              {                                  sr.art.thumb.Add(new Art()                                  {                                      url = APIHelper.ConstructImageLinkFromTypeAndId(ctx' cont_image.ImageType'                                          cont_image.AniDB_Anime_DefaultImageID)'                                      index = pic_index                                  });                                  pic_index++;                              }                              else                              {                                  break;                              }                          }                        pic_index = 0;                      if (anime.Contract.AniDBAnime.Fanarts != null)                          foreach (var cont_image in anime.Contract.AniDBAnime.Fanarts)                          {                              if (pic_index < pic)                              {                                  sr.art.fanart.Add(new Art()                                  {                                      url = APIHelper.ConstructImageLinkFromTypeAndId(ctx' cont_image.ImageType'                                          cont_image.AniDB_Anime_DefaultImageID)'                                      index = pic_index                                  });                                  pic_index++;                              }                              else                              {                                  break;                              }                          }                        pic_index = 0;                      if (anime.Contract.AniDBAnime.Banners != null)                          foreach (var cont_image in anime.Contract.AniDBAnime.Banners)                          {                              if (pic_index < pic)                              {                                  sr.art.banner.Add(new Art()                                  {                                      url = APIHelper.ConstructImageLinkFromTypeAndId(ctx' cont_image.ImageType'                                          cont_image.AniDB_Anime_DefaultImageID)'                                      index = pic_index                                  });                                  pic_index++;                              }                              else                              {                                  break;                              }                          }                  }                  else                  {                      sr.art.thumb.Add(new Art()                      {                          url = APIHelper.ConstructImageLinkFromTypeAndId(ctx' (int) ImageEntityType.AniDB_Cover'                              anime.AnimeID)'                          index = 0                      });                        var fanarts = anime.Contract.AniDBAnime.Fanarts;                      if (fanarts != null && fanarts.Count > 0)                      {                          var art = fanarts[rand.Next(fanarts.Count)];                          sr.art.fanart.Add(new Art()                          {                              url = APIHelper.ConstructImageLinkFromTypeAndId(ctx' art.ImageType'                                  art.AniDB_Anime_DefaultImageID)'                              index = 0                          });                      }                        fanarts = anime.Contract.AniDBAnime.Banners;                      if (fanarts != null && fanarts.Count > 0)                      {                          var art = fanarts[rand.Next(fanarts.Count)];                          sr.art.banner.Add(new Art()                          {                              url = APIHelper.ConstructImageLinkFromTypeAndId(ctx' art.ImageType'                                  art.AniDB_Anime_DefaultImageID)'                              index = 0                          });                      }                  }              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,Common,The following statement contains a magic number: Get["/news/get"' true] = async (x'ct) => await Task.Factory.StartNew(() => GetNews(5)' ct);
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,AddFolder,The following statement contains a magic number: try              {                  ImportFolder folder = this.Bind();                  if (folder.ImportFolderLocation != string.Empty)                  {                      try                      {                          CL_Response<ImportFolder> response = new ShokoServiceImplementation().SaveImportFolder(folder);                            if (string.IsNullOrEmpty(response.ErrorMessage))                          {                              return APIStatus.OK();                          }                          return new APIMessage(500' response.ErrorMessage);                      }                      catch                      {                          return APIStatus.InternalError();                      }                  }                  return new APIMessage(400' "Bad Request: The Folder path must not be Empty");              }              catch (ModelBindingException)              {                  return new APIMessage(400' "Bad binding");              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,AddFolder,The following statement contains a magic number: try              {                  ImportFolder folder = this.Bind();                  if (folder.ImportFolderLocation != string.Empty)                  {                      try                      {                          CL_Response<ImportFolder> response = new ShokoServiceImplementation().SaveImportFolder(folder);                            if (string.IsNullOrEmpty(response.ErrorMessage))                          {                              return APIStatus.OK();                          }                          return new APIMessage(500' response.ErrorMessage);                      }                      catch                      {                          return APIStatus.InternalError();                      }                  }                  return new APIMessage(400' "Bad Request: The Folder path must not be Empty");              }              catch (ModelBindingException)              {                  return new APIMessage(400' "Bad binding");              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,AddFolder,The following statement contains a magic number: try              {                  ImportFolder folder = this.Bind();                  if (folder.ImportFolderLocation != string.Empty)                  {                      try                      {                          CL_Response<ImportFolder> response = new ShokoServiceImplementation().SaveImportFolder(folder);                            if (string.IsNullOrEmpty(response.ErrorMessage))                          {                              return APIStatus.OK();                          }                          return new APIMessage(500' response.ErrorMessage);                      }                      catch                      {                          return APIStatus.InternalError();                      }                  }                  return new APIMessage(400' "Bad Request: The Folder path must not be Empty");              }              catch (ModelBindingException)              {                  return new APIMessage(400' "Bad binding");              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,EditFolder,The following statement contains a magic number: if (!String.IsNullOrEmpty(folder.ImportFolderLocation) && folder.ImportFolderID != 0)              {                  try                  {                      if (folder.IsDropDestination == 1 && folder.IsDropSource == 1)                      {                          return new APIMessage(409' "The Folder Can't be both Destination and Source Simultaneously");                      }                      if (folder.ImportFolderID != 0)                      {                          CL_Response<ImportFolder> response =                              new ShokoServiceImplementation().SaveImportFolder(folder);                          if (!string.IsNullOrEmpty(response.ErrorMessage))                          {                              return new APIMessage(500' response.ErrorMessage);                          }                          return APIStatus.OK();                      }                      return new APIMessage(409' "The Import Folder must have an ID");                  }                  catch                  {                      return APIStatus.InternalError();                  }              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,EditFolder,The following statement contains a magic number: if (!String.IsNullOrEmpty(folder.ImportFolderLocation) && folder.ImportFolderID != 0)              {                  try                  {                      if (folder.IsDropDestination == 1 && folder.IsDropSource == 1)                      {                          return new APIMessage(409' "The Folder Can't be both Destination and Source Simultaneously");                      }                      if (folder.ImportFolderID != 0)                      {                          CL_Response<ImportFolder> response =                              new ShokoServiceImplementation().SaveImportFolder(folder);                          if (!string.IsNullOrEmpty(response.ErrorMessage))                          {                              return new APIMessage(500' response.ErrorMessage);                          }                          return APIStatus.OK();                      }                      return new APIMessage(409' "The Import Folder must have an ID");                  }                  catch                  {                      return APIStatus.InternalError();                  }              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,EditFolder,The following statement contains a magic number: if (!String.IsNullOrEmpty(folder.ImportFolderLocation) && folder.ImportFolderID != 0)              {                  try                  {                      if (folder.IsDropDestination == 1 && folder.IsDropSource == 1)                      {                          return new APIMessage(409' "The Folder Can't be both Destination and Source Simultaneously");                      }                      if (folder.ImportFolderID != 0)                      {                          CL_Response<ImportFolder> response =                              new ShokoServiceImplementation().SaveImportFolder(folder);                          if (!string.IsNullOrEmpty(response.ErrorMessage))                          {                              return new APIMessage(500' response.ErrorMessage);                          }                          return APIStatus.OK();                      }                      return new APIMessage(409' "The Import Folder must have an ID");                  }                  catch                  {                      return APIStatus.InternalError();                  }              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,EditFolder,The following statement contains a magic number: return new APIMessage(400' "ImportFolderLocation and ImportFolderID missing");
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,DeleteFolder,The following statement contains a magic number: if (folder.ImportFolderID != 0)              {                  string res = Importer.DeleteImportFolder(folder.ImportFolderID);                  if (res == string.Empty)                  {                      return APIStatus.OK();                  }                  return new APIMessage(500' res);              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,DeleteFolder,The following statement contains a magic number: return new APIMessage(400' "ImportFolderID missing");
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,BigSearch,The following statement contains a magic number: if (para.limit == 0)              {                  //hardcoded                  para.limit = 100;              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,SearchStartsWith,The following statement contains a magic number: if (para.limit == 0)              {                  //hardcoded                  para.limit = 100;              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,ClearHasherQueue,The following statement contains a magic number: try              {                  ShokoService.CmdProcessorHasher.Stop();                    while (ShokoService.CmdProcessorHasher.ProcessingCommands)                  {                      Thread.Sleep(200);                  }                  Thread.Sleep(200);                    RepoFactory.CommandRequest.Delete(RepoFactory.CommandRequest.GetAllCommandRequestHasher());                    ShokoService.CmdProcessorHasher.Init();                    return APIStatus.OK();              }              catch              {                  return APIStatus.InternalError();              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,ClearHasherQueue,The following statement contains a magic number: try              {                  ShokoService.CmdProcessorHasher.Stop();                    while (ShokoService.CmdProcessorHasher.ProcessingCommands)                  {                      Thread.Sleep(200);                  }                  Thread.Sleep(200);                    RepoFactory.CommandRequest.Delete(RepoFactory.CommandRequest.GetAllCommandRequestHasher());                    ShokoService.CmdProcessorHasher.Init();                    return APIStatus.OK();              }              catch              {                  return APIStatus.InternalError();              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,ClearGeneralQueue,The following statement contains a magic number: try              {                  ShokoService.CmdProcessorGeneral.Stop();                    while (ShokoService.CmdProcessorGeneral.ProcessingCommands)                  {                      Thread.Sleep(200);                  }                  Thread.Sleep(200);                    RepoFactory.CommandRequest.Delete(RepoFactory.CommandRequest.GetAllCommandRequestGeneral());                    ShokoService.CmdProcessorGeneral.Init();                    return APIStatus.OK();              }              catch              {                  return APIStatus.InternalError();              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,ClearGeneralQueue,The following statement contains a magic number: try              {                  ShokoService.CmdProcessorGeneral.Stop();                    while (ShokoService.CmdProcessorGeneral.ProcessingCommands)                  {                      Thread.Sleep(200);                  }                  Thread.Sleep(200);                    RepoFactory.CommandRequest.Delete(RepoFactory.CommandRequest.GetAllCommandRequestGeneral());                    ShokoService.CmdProcessorGeneral.Init();                    return APIStatus.OK();              }              catch              {                  return APIStatus.InternalError();              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,ClearImagesQueue,The following statement contains a magic number: try              {                  ShokoService.CmdProcessorImages.Stop();                    while (ShokoService.CmdProcessorImages.ProcessingCommands)                  {                      Thread.Sleep(200);                  }                  Thread.Sleep(200);                    RepoFactory.CommandRequest.Delete(RepoFactory.CommandRequest.GetAllCommandRequestImages());                    ShokoService.CmdProcessorImages.Init();                    return APIStatus.OK();              }              catch              {                  return APIStatus.InternalError();              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,ClearImagesQueue,The following statement contains a magic number: try              {                  ShokoService.CmdProcessorImages.Stop();                    while (ShokoService.CmdProcessorImages.ProcessingCommands)                  {                      Thread.Sleep(200);                  }                  Thread.Sleep(200);                    RepoFactory.CommandRequest.Delete(RepoFactory.CommandRequest.GetAllCommandRequestImages());                    ShokoService.CmdProcessorImages.Init();                    return APIStatus.OK();              }              catch              {                  return APIStatus.InternalError();              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,GetRecentFiles,The following statement contains a magic number: if (limit == 0)              {                  if (para.limit == 0)                  {                      para.limit = 10;                  }              }              else              {                  para.limit = limit;              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,GetAllFiles,The following statement contains a magic number: if (limit == 0)              {                  limit_x = 100;              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,GetRecentEpisodes,The following statement contains a magic number: if (para.limit == 0)              {                  //hardcoded                  para.limit = 10;              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,EpisodeScrobble,The following statement contains a magic number: try              {                  Request request = Request;                  API_Call_Parameters para = this.Bind();                    // statys 1-start' 2-pause' 3-stop                  // progres 0-100                  // type 1-movie' 2-episode                  if (para.id > 0 & para.progress >= 0 & para.status > 0)                  {                      ShokoServiceImplementation impl = new ShokoServiceImplementation();                      int type = 2;                      if (para.ismovie == 0)                      {                          type = 2;                      }                      else                      {                          type = 1;                      }                      switch (impl.TraktScrobble(para.id' type' para.progress' para.status))                      {                          case 200:                              return APIStatus.OK();                          case 404:                              return APIStatus.NotFound();                          default:                              return APIStatus.InternalError();                      }                  }                  return APIStatus.BadRequest();              }              catch              {                  return APIStatus.InternalError();              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,EpisodeScrobble,The following statement contains a magic number: try              {                  Request request = Request;                  API_Call_Parameters para = this.Bind();                    // statys 1-start' 2-pause' 3-stop                  // progres 0-100                  // type 1-movie' 2-episode                  if (para.id > 0 & para.progress >= 0 & para.status > 0)                  {                      ShokoServiceImplementation impl = new ShokoServiceImplementation();                      int type = 2;                      if (para.ismovie == 0)                      {                          type = 2;                      }                      else                      {                          type = 1;                      }                      switch (impl.TraktScrobble(para.id' type' para.progress' para.status))                      {                          case 200:                              return APIStatus.OK();                          case 404:                              return APIStatus.NotFound();                          default:                              return APIStatus.InternalError();                      }                  }                  return APIStatus.BadRequest();              }              catch              {                  return APIStatus.InternalError();              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,EpisodeScrobble,The following statement contains a magic number: try              {                  Request request = Request;                  API_Call_Parameters para = this.Bind();                    // statys 1-start' 2-pause' 3-stop                  // progres 0-100                  // type 1-movie' 2-episode                  if (para.id > 0 & para.progress >= 0 & para.status > 0)                  {                      ShokoServiceImplementation impl = new ShokoServiceImplementation();                      int type = 2;                      if (para.ismovie == 0)                      {                          type = 2;                      }                      else                      {                          type = 1;                      }                      switch (impl.TraktScrobble(para.id' type' para.progress' para.status))                      {                          case 200:                              return APIStatus.OK();                          case 404:                              return APIStatus.NotFound();                          default:                              return APIStatus.InternalError();                      }                  }                  return APIStatus.BadRequest();              }              catch              {                  return APIStatus.InternalError();              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,EpisodeScrobble,The following statement contains a magic number: try              {                  Request request = Request;                  API_Call_Parameters para = this.Bind();                    // statys 1-start' 2-pause' 3-stop                  // progres 0-100                  // type 1-movie' 2-episode                  if (para.id > 0 & para.progress >= 0 & para.status > 0)                  {                      ShokoServiceImplementation impl = new ShokoServiceImplementation();                      int type = 2;                      if (para.ismovie == 0)                      {                          type = 2;                      }                      else                      {                          type = 1;                      }                      switch (impl.TraktScrobble(para.id' type' para.progress' para.status))                      {                          case 200:                              return APIStatus.OK();                          case 404:                              return APIStatus.NotFound();                          default:                              return APIStatus.InternalError();                      }                  }                  return APIStatus.BadRequest();              }              catch              {                  return APIStatus.InternalError();              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,GetAllEpisodes,The following statement contains a magic number: if (limit == 0)              {                  // hardcoded                  limit = 100;              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,EpisodeVote,The following statement contains a magic number: if (id > 0)              {                  if (score > 0 && score < 1000)                  {                      AniDB_Vote thisVote = RepoFactory.AniDB_Vote.GetByEntityAndType(id' AniDBVoteType.Episode);                        if (thisVote == null)                      {                          thisVote = new AniDB_Vote                          {                              VoteType = (int)AniDBVoteType.Episode'                              EntityID = id                          };                      }                        if (score <= 10)                      {                          score = score * 100;                      }                        thisVote.VoteValue = score;                      RepoFactory.AniDB_Vote.Save(thisVote);                        //CommandRequest_VoteAnime cmdVote = new CommandRequest_VoteAnime(animeID' voteType' voteValue);                      //cmdVote.Save();                        return APIStatus.OK();                  }                  return APIStatus.BadRequest("'score' value is wrong");              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,EpisodeVote,The following statement contains a magic number: if (id > 0)              {                  if (score > 0 && score < 1000)                  {                      AniDB_Vote thisVote = RepoFactory.AniDB_Vote.GetByEntityAndType(id' AniDBVoteType.Episode);                        if (thisVote == null)                      {                          thisVote = new AniDB_Vote                          {                              VoteType = (int)AniDBVoteType.Episode'                              EntityID = id                          };                      }                        if (score <= 10)                      {                          score = score * 100;                      }                        thisVote.VoteValue = score;                      RepoFactory.AniDB_Vote.Save(thisVote);                        //CommandRequest_VoteAnime cmdVote = new CommandRequest_VoteAnime(animeID' voteType' voteValue);                      //cmdVote.Save();                        return APIStatus.OK();                  }                  return APIStatus.BadRequest("'score' value is wrong");              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,EpisodeVote,The following statement contains a magic number: if (id > 0)              {                  if (score > 0 && score < 1000)                  {                      AniDB_Vote thisVote = RepoFactory.AniDB_Vote.GetByEntityAndType(id' AniDBVoteType.Episode);                        if (thisVote == null)                      {                          thisVote = new AniDB_Vote                          {                              VoteType = (int)AniDBVoteType.Episode'                              EntityID = id                          };                      }                        if (score <= 10)                      {                          score = score * 100;                      }                        thisVote.VoteValue = score;                      RepoFactory.AniDB_Vote.Save(thisVote);                        //CommandRequest_VoteAnime cmdVote = new CommandRequest_VoteAnime(animeID' voteType' voteValue);                      //cmdVote.Save();                        return APIStatus.OK();                  }                  return APIStatus.BadRequest("'score' value is wrong");              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,SeriesToday,The following statement contains a magic number: List<Serie> result = allSeries.Where(ser =>              {                  var anime = RepoFactory.AniDB_Anime.GetByAnimeID(ser.AniDB_ID);                  // It might end today' but that's okay                  if (anime.EndDate != null)                  {                      if (now > anime.EndDate.Value && now - anime.EndDate.Value > new TimeSpan(16' 0' 0)) return false;                  }                  if (ser.AirsOn == null) return false;                  return DateTime.Now.DayOfWeek == ser.AirsOn.Value;              }).Select(ser => Serie.GenerateFromAnimeSeries(Context' ser' user.JMMUserID' para.nocast == 1'                  para.notag == 1' para.level' para.all == 1' para.allpics == 1' para.pic' para.tagfilter)).OrderBy(a => a.name).ToList();
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,GetSeriesRecent,The following statement contains a magic number: if (para.limit == 0)              {                  para.limit = 10;              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,SearchForSerie,The following statement contains a magic number: if (para.limit == 0)              {                  //hardcoded                  para.limit = 100;              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,SearchForTag,The following statement contains a magic number: if (para.limit == 0)              {                  //hardcoded                  para.limit = 100;              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,GetSeriesByFolder,The following statement contains a magic number: if (limit == 0)              {                  // hardcoded limit                  limit = 100;              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,GetSeriesInfoByFolder,The following statement contains a magic number: if (limit == 0)              {                  // hardcoded limit                  limit = 100;              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,GetSeriesInfoByFolder,The following statement contains a magic number: foreach (SVR_VideoLocal vl in vlpall)              {                  Serie ser = Serie.GenerateFromVideoLocal(Context' vl' uid' true' true' 2' false' false' 0' tagfilter);                    ObjectList objl = new ObjectList(ser.name' ObjectList.ListType.SERIE' ser.filesize);                  if (ser.name != null)                  {                      if (!tmp_list.ContainsKey(ser.name))                      {                          tmp_list.Add(ser.name' ser.filesize);                          allseries.Add(objl);                      }                      else                      {                          if (tmp_list[ser.name] != ser.filesize)                          {                              while (tmp_list.ContainsKey(objl.name))                              {                                  objl.name = objl.name + "*";                              }                              tmp_list.Add(objl.name' ser.filesize);                              allseries.Add(objl);                          }                      }                  }                                    if (allseries.Count >= limit)                  {                      break;                  }              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,CheckTitlesFuzzy,The following statement contains a magic number: foreach (string title in a.Contract.AniDBAnime.AnimeTitles.Select(b => b.Title).ToList())              {                  if (string.IsNullOrEmpty(title)) continue;                  int k = Math.Max(Math.Min((int)(title.Length / 6D)' (int)(query.Length / 6D))' 1);                  if (query.Length <= 4 || title.Length <= 4) k = 0;                  if (Misc.BitapFuzzySearch(title' query' k' out int newDist) == -1) continue;                  if (newDist < dist)                  {                      match = title;                      dist = newDist;                  }              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,CheckTitlesFuzzy,The following statement contains a magic number: foreach (string title in a.Contract.AniDBAnime.AnimeTitles.Select(b => b.Title).ToList())              {                  if (string.IsNullOrEmpty(title)) continue;                  int k = Math.Max(Math.Min((int)(title.Length / 6D)' (int)(query.Length / 6D))' 1);                  if (query.Length <= 4 || title.Length <= 4) k = 0;                  if (Misc.BitapFuzzySearch(title' query' k' out int newDist) == -1) continue;                  if (newDist < dist)                  {                      match = title;                      dist = newDist;                  }              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,Search,The following statement contains a magic number: switch (tagSearch)              {                  case 0:                      if (!fuzzy || query.Length >= (IntPtr.Size * 8))                      {                          series = allSeries                              .Where(a => Join("'"' a.Contract.AniDBAnime.AnimeTitles.Select(b => b.Title)' fuzzy)                                              .IndexOf(SanitizeFuzzy(query' fuzzy)' 0'                                                  StringComparison.InvariantCultureIgnoreCase) >= 0)                              .OrderBy(a => a.Contract.AniDBAnime.AniDBAnime.MainTitle)                              .ToDictionary(a => a' a => string.Empty);                          foreach (KeyValuePair<SVR_AnimeSeries' string> ser in series)                          {                              if (offset == 0)                              {                                  series_list.Add(                                      SearchResult.GenerateFromAnimeSeries(Context' ser.Key' uid' nocast' notag' level' all'                                          ser.Value' allpic' pic' tagfilter));                                  if (series_list.Count >= limit)                                  {                                      break;                                  }                              }                              else                              {                                  offset -= 1;                              }                          }                      }                      else                      {                          var distLevenshtein = new ConcurrentDictionary<SVR_AnimeSeries' Tuple<int' string>>();                          allSeries.ForAll(a => CheckTitlesFuzzy(a' query' ref distLevenshtein' limit));                            series = distLevenshtein.Keys.OrderBy(a => distLevenshtein[a].Item1)                              .ThenBy(a => distLevenshtein[a].Item2.Length)                              .ThenBy(a => a.Contract.AniDBAnime.AniDBAnime.MainTitle)                              .ToDictionary(a => a' a => distLevenshtein[a].Item2);                          foreach (KeyValuePair<SVR_AnimeSeries' string> ser in series)                          {                              if (offset == 0)                              {                                  series_list.Add(SearchResult.GenerateFromAnimeSeries(Context' ser.Key' uid' nocast' notag' level'                                      all'                                      ser.Value' allpic' pic' tagfilter));                                  if (series_list.Count >= limit)                                  {                                      break;                                  }                              }                              else                              {                                  offset -= 1;                              }                          }                      }                      break;                  case 1:                      int realLimit = limit_tag != 0 ? limit_tag : limit;                      if (!fuzzy || query.Length >= IntPtr.Size)                      {                          series = allSeries                              .Where(a => a?.Contract?.AniDBAnime?.AniDBAnime != null &&                                          (a.Contract.AniDBAnime.Tags.Select(b => b.TagName)                                               .Contains(query'                                                   StringComparer.InvariantCultureIgnoreCase) || a.Contract.AniDBAnime                                               .CustomTags                                               .Select(b => b.TagName)                                               .Contains(query' StringComparer.InvariantCultureIgnoreCase)))                              .OrderBy(a => a.Contract.AniDBAnime.AniDBAnime.MainTitle)                              .ToDictionary(a => a' a => string.Empty);                          foreach (KeyValuePair<SVR_AnimeSeries' string> ser in series)                          {                              if (offset == 0)                              {                                  series_list.Add(                                      SearchResult.GenerateFromAnimeSeries(Context' ser.Key' uid' nocast' notag' level' all'                                          ser.Value' allpic' pic' tagfilter));                                  if (series_list.Count >= realLimit)                                  {                                      break;                                  }                              }                              else                              {                                  offset -= 1;                              }                          }                      }                      else                      {                          var distLevenshtein = new ConcurrentDictionary<SVR_AnimeSeries' Tuple<int' string>>();                          allSeries.ForAll(a => CheckTagsFuzzy(a' query' ref distLevenshtein' realLimit));                            series = distLevenshtein.Keys.OrderBy(a => distLevenshtein[a].Item1)                              .ThenBy(a => distLevenshtein[a].Item2.Length)                              .ThenBy(a => a.Contract.AniDBAnime.AniDBAnime.MainTitle)                              .ToDictionary(a => a' a => distLevenshtein[a].Item2);                          foreach (KeyValuePair<SVR_AnimeSeries' string> ser in series)                          {                              if (offset == 0)                              {                                  series_list.Add(SearchResult.GenerateFromAnimeSeries(Context' ser.Key' uid' nocast' notag' level'                                      all'                                      ser.Value' allpic' pic' tagfilter));                                  if (series_list.Count >= realLimit)                                  {                                      break;                                  }                              }                              else                              {                                  offset -= 1;                              }                          }                      }                      break;                  default:                      bool use_extra = limit_tag != 0;                      if (!fuzzy || query.Length >= (IntPtr.Size * 8))                      {                          series = allSeries                              .Where(a => a?.Contract?.AniDBAnime?.AniDBAnime != null &&                                          Join("'"' a.Contract.AniDBAnime.AnimeTitles.Select(b => b.Title)' fuzzy)                                              .IndexOf(SanitizeFuzzy(query' fuzzy)' 0'                                                  StringComparison.InvariantCultureIgnoreCase) >= 0)                              .OrderBy(a => a.Contract.AniDBAnime.AniDBAnime.MainTitle)                              .ToDictionary(a => a' a => string.Empty);                            int tag_limit = use_extra ? limit_tag : limit - series.Count;                          if (tag_limit < 0) tag_limit = 0;                          series = series.ToList().Take(limit).ToDictionary(a => a.Key' a => a.Value);                          if (tag_limit > 0)                              series.AddRange(allSeries.Where(a => a?.Contract?.AniDBAnime?.AniDBAnime != null &&                                                                   (a.Contract.AniDBAnime.Tags.Select(b => b.TagName)                                                                        .Contains(query'                                                                            StringComparer.InvariantCultureIgnoreCase) ||                                                                    a                                                                        .Contract                                                                        .AniDBAnime.CustomTags.Select(b => b.TagName)                                                                        .Contains(query'                                                                            StringComparer.InvariantCultureIgnoreCase)))                                  .OrderBy(a => a.Contract.AniDBAnime.AniDBAnime.MainTitle)                                  .Take(tag_limit)                                  .ToDictionary(a => a' a => string.Empty));                          foreach (KeyValuePair<SVR_AnimeSeries' string> ser in series)                          {                              if (offset == 0)                              {                                  series_list.Add(                                      SearchResult.GenerateFromAnimeSeries(Context' ser.Key' uid' nocast' notag' level' all'                                          ser.Value' allpic' pic' tagfilter));                              }                              else                              {                                  offset -= 1;                              }                          }                      }                      else                      {                          var distLevenshtein = new ConcurrentDictionary<SVR_AnimeSeries' Tuple<int' string>>();                          allSeries.ForAll(a => CheckTitlesFuzzy(a' query' ref distLevenshtein' limit));                            series.AddRange(distLevenshtein.Keys.OrderBy(a => distLevenshtein[a].Item1)                              .ThenBy(a => distLevenshtein[a].Item2.Length)                              .ThenBy(a => a.Contract.AniDBAnime.AniDBAnime.MainTitle)                              .ToDictionary(a => a' a => distLevenshtein[a].Item2));                          distLevenshtein = new ConcurrentDictionary<SVR_AnimeSeries' Tuple<int' string>>();                            int tag_limit = use_extra ? limit_tag : limit - series.Count;                          if (tag_limit < 0) tag_limit = 0;                            if (tag_limit > 0)                          {                              allSeries.ForAll(a => CheckTagsFuzzy(a' query' ref distLevenshtein' tag_limit));                              series.AddRange(distLevenshtein.Keys.OrderBy(a => distLevenshtein[a].Item1)                                  .ThenBy(a => distLevenshtein[a].Item2.Length)                                  .ThenBy(a => a.Contract.AniDBAnime.AniDBAnime.MainTitle)                                  .ToDictionary(a => a' a => distLevenshtein[a].Item2));                          }                          foreach (KeyValuePair<SVR_AnimeSeries' string> ser in series)                          {                              if (offset == 0)                              {                                  series_list.Add(SearchResult.GenerateFromAnimeSeries(Context' ser.Key' uid' nocast' notag' level'                                      all'                                      ser.Value' allpic' pic' tagfilter));                              }                              else                              {                                  offset -= 1;                              }                          }                      }                      break;              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,Search,The following statement contains a magic number: switch (tagSearch)              {                  case 0:                      if (!fuzzy || query.Length >= (IntPtr.Size * 8))                      {                          series = allSeries                              .Where(a => Join("'"' a.Contract.AniDBAnime.AnimeTitles.Select(b => b.Title)' fuzzy)                                              .IndexOf(SanitizeFuzzy(query' fuzzy)' 0'                                                  StringComparison.InvariantCultureIgnoreCase) >= 0)                              .OrderBy(a => a.Contract.AniDBAnime.AniDBAnime.MainTitle)                              .ToDictionary(a => a' a => string.Empty);                          foreach (KeyValuePair<SVR_AnimeSeries' string> ser in series)                          {                              if (offset == 0)                              {                                  series_list.Add(                                      SearchResult.GenerateFromAnimeSeries(Context' ser.Key' uid' nocast' notag' level' all'                                          ser.Value' allpic' pic' tagfilter));                                  if (series_list.Count >= limit)                                  {                                      break;                                  }                              }                              else                              {                                  offset -= 1;                              }                          }                      }                      else                      {                          var distLevenshtein = new ConcurrentDictionary<SVR_AnimeSeries' Tuple<int' string>>();                          allSeries.ForAll(a => CheckTitlesFuzzy(a' query' ref distLevenshtein' limit));                            series = distLevenshtein.Keys.OrderBy(a => distLevenshtein[a].Item1)                              .ThenBy(a => distLevenshtein[a].Item2.Length)                              .ThenBy(a => a.Contract.AniDBAnime.AniDBAnime.MainTitle)                              .ToDictionary(a => a' a => distLevenshtein[a].Item2);                          foreach (KeyValuePair<SVR_AnimeSeries' string> ser in series)                          {                              if (offset == 0)                              {                                  series_list.Add(SearchResult.GenerateFromAnimeSeries(Context' ser.Key' uid' nocast' notag' level'                                      all'                                      ser.Value' allpic' pic' tagfilter));                                  if (series_list.Count >= limit)                                  {                                      break;                                  }                              }                              else                              {                                  offset -= 1;                              }                          }                      }                      break;                  case 1:                      int realLimit = limit_tag != 0 ? limit_tag : limit;                      if (!fuzzy || query.Length >= IntPtr.Size)                      {                          series = allSeries                              .Where(a => a?.Contract?.AniDBAnime?.AniDBAnime != null &&                                          (a.Contract.AniDBAnime.Tags.Select(b => b.TagName)                                               .Contains(query'                                                   StringComparer.InvariantCultureIgnoreCase) || a.Contract.AniDBAnime                                               .CustomTags                                               .Select(b => b.TagName)                                               .Contains(query' StringComparer.InvariantCultureIgnoreCase)))                              .OrderBy(a => a.Contract.AniDBAnime.AniDBAnime.MainTitle)                              .ToDictionary(a => a' a => string.Empty);                          foreach (KeyValuePair<SVR_AnimeSeries' string> ser in series)                          {                              if (offset == 0)                              {                                  series_list.Add(                                      SearchResult.GenerateFromAnimeSeries(Context' ser.Key' uid' nocast' notag' level' all'                                          ser.Value' allpic' pic' tagfilter));                                  if (series_list.Count >= realLimit)                                  {                                      break;                                  }                              }                              else                              {                                  offset -= 1;                              }                          }                      }                      else                      {                          var distLevenshtein = new ConcurrentDictionary<SVR_AnimeSeries' Tuple<int' string>>();                          allSeries.ForAll(a => CheckTagsFuzzy(a' query' ref distLevenshtein' realLimit));                            series = distLevenshtein.Keys.OrderBy(a => distLevenshtein[a].Item1)                              .ThenBy(a => distLevenshtein[a].Item2.Length)                              .ThenBy(a => a.Contract.AniDBAnime.AniDBAnime.MainTitle)                              .ToDictionary(a => a' a => distLevenshtein[a].Item2);                          foreach (KeyValuePair<SVR_AnimeSeries' string> ser in series)                          {                              if (offset == 0)                              {                                  series_list.Add(SearchResult.GenerateFromAnimeSeries(Context' ser.Key' uid' nocast' notag' level'                                      all'                                      ser.Value' allpic' pic' tagfilter));                                  if (series_list.Count >= realLimit)                                  {                                      break;                                  }                              }                              else                              {                                  offset -= 1;                              }                          }                      }                      break;                  default:                      bool use_extra = limit_tag != 0;                      if (!fuzzy || query.Length >= (IntPtr.Size * 8))                      {                          series = allSeries                              .Where(a => a?.Contract?.AniDBAnime?.AniDBAnime != null &&                                          Join("'"' a.Contract.AniDBAnime.AnimeTitles.Select(b => b.Title)' fuzzy)                                              .IndexOf(SanitizeFuzzy(query' fuzzy)' 0'                                                  StringComparison.InvariantCultureIgnoreCase) >= 0)                              .OrderBy(a => a.Contract.AniDBAnime.AniDBAnime.MainTitle)                              .ToDictionary(a => a' a => string.Empty);                            int tag_limit = use_extra ? limit_tag : limit - series.Count;                          if (tag_limit < 0) tag_limit = 0;                          series = series.ToList().Take(limit).ToDictionary(a => a.Key' a => a.Value);                          if (tag_limit > 0)                              series.AddRange(allSeries.Where(a => a?.Contract?.AniDBAnime?.AniDBAnime != null &&                                                                   (a.Contract.AniDBAnime.Tags.Select(b => b.TagName)                                                                        .Contains(query'                                                                            StringComparer.InvariantCultureIgnoreCase) ||                                                                    a                                                                        .Contract                                                                        .AniDBAnime.CustomTags.Select(b => b.TagName)                                                                        .Contains(query'                                                                            StringComparer.InvariantCultureIgnoreCase)))                                  .OrderBy(a => a.Contract.AniDBAnime.AniDBAnime.MainTitle)                                  .Take(tag_limit)                                  .ToDictionary(a => a' a => string.Empty));                          foreach (KeyValuePair<SVR_AnimeSeries' string> ser in series)                          {                              if (offset == 0)                              {                                  series_list.Add(                                      SearchResult.GenerateFromAnimeSeries(Context' ser.Key' uid' nocast' notag' level' all'                                          ser.Value' allpic' pic' tagfilter));                              }                              else                              {                                  offset -= 1;                              }                          }                      }                      else                      {                          var distLevenshtein = new ConcurrentDictionary<SVR_AnimeSeries' Tuple<int' string>>();                          allSeries.ForAll(a => CheckTitlesFuzzy(a' query' ref distLevenshtein' limit));                            series.AddRange(distLevenshtein.Keys.OrderBy(a => distLevenshtein[a].Item1)                              .ThenBy(a => distLevenshtein[a].Item2.Length)                              .ThenBy(a => a.Contract.AniDBAnime.AniDBAnime.MainTitle)                              .ToDictionary(a => a' a => distLevenshtein[a].Item2));                          distLevenshtein = new ConcurrentDictionary<SVR_AnimeSeries' Tuple<int' string>>();                            int tag_limit = use_extra ? limit_tag : limit - series.Count;                          if (tag_limit < 0) tag_limit = 0;                            if (tag_limit > 0)                          {                              allSeries.ForAll(a => CheckTagsFuzzy(a' query' ref distLevenshtein' tag_limit));                              series.AddRange(distLevenshtein.Keys.OrderBy(a => distLevenshtein[a].Item1)                                  .ThenBy(a => distLevenshtein[a].Item2.Length)                                  .ThenBy(a => a.Contract.AniDBAnime.AniDBAnime.MainTitle)                                  .ToDictionary(a => a' a => distLevenshtein[a].Item2));                          }                          foreach (KeyValuePair<SVR_AnimeSeries' string> ser in series)                          {                              if (offset == 0)                              {                                  series_list.Add(SearchResult.GenerateFromAnimeSeries(Context' ser.Key' uid' nocast' notag' level'                                      all'                                      ser.Value' allpic' pic' tagfilter));                              }                              else                              {                                  offset -= 1;                              }                          }                      }                      break;              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,SerieVote,The following statement contains a magic number: if (score <= 0 || score > 1000)              {                  return APIStatus.BadRequest("'score' value is wrong");              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,SerieVote,The following statement contains a magic number: if (score <= 10)              {                  score = score * 100;              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,SerieVote,The following statement contains a magic number: if (score <= 10)              {                  score = score * 100;              }
Magic Number,Shoko.Server.API.v2.Modules,Common,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Common.cs,SerieVote,The following statement contains a magic number: CommandRequest_VoteAnime cmdVote =                  new CommandRequest_VoteAnime(ser.AniDB_ID' voteType' Convert.ToDecimal(score / 100));
Magic Number,Shoko.Server.API.v2.Modules,Core,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Core.cs,Core,The following statement contains a magic number: Get["/log/get"' true] = async (x'ct) => await Task.Factory.StartNew(() => GetLog(10' 0)' ct);
Magic Number,Shoko.Server.API.v2.Modules,Core,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Core.cs,SetPort,The following statement contains a magic number: return new APIMessage(400' "Port Missing");
Magic Number,Shoko.Server.API.v2.Modules,Core,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Core.cs,SetImagepath,The following statement contains a magic number: if (!String.IsNullOrEmpty(imagepath.path) && imagepath.path != string.Empty)              {                  if (Directory.Exists(imagepath.path))                  {                      ServerSettings.ImagesPath = imagepath.path;                      return APIStatus.OK();                  }                  return new APIMessage(404' "Directory Not Found on Host");              }
Magic Number,Shoko.Server.API.v2.Modules,Core,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Core.cs,SetImagepath,The following statement contains a magic number: return new APIMessage(400' "Path Missing");
Magic Number,Shoko.Server.API.v2.Modules,Core,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Core.cs,SetAniDB,The following statement contains a magic number: return new APIMessage(400' "Login and Password missing");
Magic Number,Shoko.Server.API.v2.Modules,Core,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Core.cs,TestAniDB,The following statement contains a magic number: Thread.Sleep(1000);
Magic Number,Shoko.Server.API.v2.Modules,Core,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Core.cs,SetMAL,The following statement contains a magic number: return new APIMessage(400' "Login and Password missing");
Magic Number,Shoko.Server.API.v2.Modules,Core,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Core.cs,SetTraktPIN,The following statement contains a magic number: return new APIMessage(400' "Token missing");
Magic Number,Shoko.Server.API.v2.Modules,Core,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Core.cs,SyncTrakt,The following statement contains a magic number: return new APIMessage(204' "Trakt is not enabled or you are missing the authtoken");
Magic Number,Shoko.Server.API.v2.Modules,Core,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Core.cs,GetOSFolder,The following statement contains a magic number: return new APIMessage(400' "full_path missing");
Magic Number,Shoko.Server.API.v2.Modules,Image,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Image.cs,ResizeImageToRatio,The following statement contains a magic number: if (newwidth < im.Width)                  x = (im.Width - newwidth) / 2;
Magic Number,Shoko.Server.API.v2.Modules,Image,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Image.cs,ResizeImageToRatio,The following statement contains a magic number: if (newheight < im.Height)                  y = (im.Height - newheight) / 2;
Magic Number,Shoko.Server.API.v2.Modules,Init,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Init.cs,GetVersion,The following statement contains a magic number: if (File.Exists("webui//index.ver"))              {                  string webui_version = File.ReadAllText("webui//index.ver");                  string[] versions = webui_version.Split('>');                  if (versions.Length == 2)                  {                      version = new ComponentVersion                      {                          name = "webui/" + versions[0]'                          version = versions[1]                      };                      list.Add(version);                  }              }
Magic Number,Shoko.Server.API.v2.Modules,Init,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Init.cs,SetAniDB,The following statement contains a magic number: if (details.Count > 0) return new APIMessage(400' "Login or Password missing"' details);
Magic Number,Shoko.Server.API.v2.Modules,Init,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Init.cs,TestAniDB,The following statement contains a magic number: Thread.Sleep(1000);
Magic Number,Shoko.Server.API.v2.Modules,Version,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Version.cs,GetVersion,The following statement contains a magic number: if (File.Exists("webui//index.ver"))              {                  string webui_version = File.ReadAllText("webui//index.ver");                  string[] versions = webui_version.Split('>');                  if (versions.Length == 2)                  {                      version = new ComponentVersion                      {                          name = "webui/" + versions[0]'                          version = versions[1]                      };                      list.Add(version);                  }              }
Magic Number,Shoko.Server.API.v2.Modules,PlexWebhook,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\PlexWebhook.cs,TraktScrobble,The following statement contains a magic number: float per = 100 * (metadata.ViewOffset / (float)vl.Duration);
Magic Number,Shoko.Server.API.v2.Modules,PlexWebhook,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\PlexWebhook.cs,GetEpisode,The following statement contains a magic number: int series = int.Parse(parts[2]);
Magic Number,Shoko.Server.API.v2.Modules,PlexWebhook,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\PlexWebhook.cs,GetEpisode,The following statement contains a magic number: switch (series) //I hate magic number's but this is just about how I can do this' also the rest of this is for later.              {                  case -4:                      episodeType = EpisodeType.Parody;                      break;                  case -3:                      episodeType = EpisodeType.Trailer;                      break;                  case -2:                      episodeType = EpisodeType.Other;                      break;                  case -1:                      episodeType = EpisodeType.Credits;                      break;                  case 0:                      episodeType = EpisodeType.Special;                      break;                  default:                      episodeType = EpisodeType.Episode;                      break;              }
Magic Number,Shoko.Server.API.v2.Modules,PlexWebhook,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\PlexWebhook.cs,GetEpisode,The following statement contains a magic number: switch (series) //I hate magic number's but this is just about how I can do this' also the rest of this is for later.              {                  case -4:                      episodeType = EpisodeType.Parody;                      break;                  case -3:                      episodeType = EpisodeType.Trailer;                      break;                  case -2:                      episodeType = EpisodeType.Other;                      break;                  case -1:                      episodeType = EpisodeType.Credits;                      break;                  case 0:                      episodeType = EpisodeType.Special;                      break;                  default:                      episodeType = EpisodeType.Episode;                      break;              }
Magic Number,Shoko.Server.API.v2.Modules,PlexWebhook,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\PlexWebhook.cs,GetEpisode,The following statement contains a magic number: switch (series) //I hate magic number's but this is just about how I can do this' also the rest of this is for later.              {                  case -4:                      episodeType = EpisodeType.Parody;                      break;                  case -3:                      episodeType = EpisodeType.Trailer;                      break;                  case -2:                      episodeType = EpisodeType.Other;                      break;                  case -1:                      episodeType = EpisodeType.Credits;                      break;                  case 0:                      episodeType = EpisodeType.Special;                      break;                  default:                      episodeType = EpisodeType.Episode;                      break;              }
Magic Number,Shoko.Server.API.v2.Modules,PlexWebhook,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\PlexWebhook.cs,FromUnixTime,The following statement contains a magic number: return new DateTime(1970' 1' 1' 0' 0' 0' DateTimeKind.Utc).AddSeconds(unixTime);
Magic Number,Shoko.Server.API.v2.Modules,Webui,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Webui.cs,WebUIGetUrlAndUpdate,The following statement contains a magic number: try              {                  var client = new System.Net.WebClient();                  client.Headers.Add("Accept: application/vnd.github.v3+json");                  client.Headers.Add("User-Agent"' "jmmserver");                  var response = client.DownloadString(                      new Uri("https://api.github.com/repos/japanesemediamanager/shokoserver-webui/releases/tags/" +                              tag_name));                    dynamic result = Newtonsoft.Json.JsonConvert.DeserializeObject(response);                  string url = string.Empty;                  foreach (dynamic obj in result.assets)                  {                      if (obj.name == "latest.zip")                      {                          url = obj.browser_download_url;                          break;                      }                  }                    //check if tag was parsed corrently as it make the url                  return url != string.Empty                       ? WebUIUpdate(url' channel' tag_name)                       : new APIMessage(204' "Content is missing");              }              catch              {                  return APIStatus.InternalError();              }
Magic Number,Shoko.Server.API.v2.Modules,Webui,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Webui.cs,WebUIUpdate,The following statement contains a magic number: try              {                  //download latest version                  var client = new System.Net.WebClient();                  client.Headers.Add("User-Agent"' "shokoserver");                  client.DownloadFile(url' Path.Combine("webui"' "latest.zip"));                    //create 'old' dictionary                  if (!Directory.Exists(Path.Combine("webui"' "old")))                  {                      System.IO.Directory.CreateDirectory(Path.Combine("webui"' "old"));                  }                  try                  {                      //move all directories and files to 'old' folder as fallback recovery                      foreach (string dir in directories)                      {                          if (Directory.Exists(dir) && dir != Path.Combine("webui"' "old") && dir != Path.Combine("webui"' "tweak"))                          {                              string n_dir = dir.Replace("webui"' Path.Combine("webui"' "old"));                              Directory.Move(dir' n_dir);                          }                      }                      foreach (string file in files)                      {                          if (File.Exists(file))                          {                              string n_file = file.Replace("webui"' Path.Combine("webui"' "old"));                              File.Move(file' n_file);                          }                      }                        try                      {                          //extract latest webui                          System.IO.Compression.ZipFile.ExtractToDirectory(Path.Combine("webui"' "latest.zip")' "webui");                            //clean because we already have working updated webui                          Directory.Delete(Path.Combine("webui"' "old")' true);                          File.Delete(Path.Combine("webui"' "latest.zip"));                            //save version type>version that was installed successful                          if (File.Exists(Path.Combine("webui"' "index.ver")))                          {                              File.Delete(Path.Combine("webui"' "index.ver"));                          }                          File.AppendAllText(Path.Combine("webui"' "index.ver")' channel + ">" + version);                            return APIStatus.OK();                      }                      catch                      {                          //when extracting latest.zip failes                          return new APIMessage(405' "MethodNotAllowed");                      }                  }                  catch                  {                      //when moving files to 'old' folder failed                      return new APIMessage(423' "Locked");                  }              }              catch              {                  //when download failed                  return new APIMessage(499' "download failed");              }
Magic Number,Shoko.Server.API.v2.Modules,Webui,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Webui.cs,WebUIUpdate,The following statement contains a magic number: try              {                  //download latest version                  var client = new System.Net.WebClient();                  client.Headers.Add("User-Agent"' "shokoserver");                  client.DownloadFile(url' Path.Combine("webui"' "latest.zip"));                    //create 'old' dictionary                  if (!Directory.Exists(Path.Combine("webui"' "old")))                  {                      System.IO.Directory.CreateDirectory(Path.Combine("webui"' "old"));                  }                  try                  {                      //move all directories and files to 'old' folder as fallback recovery                      foreach (string dir in directories)                      {                          if (Directory.Exists(dir) && dir != Path.Combine("webui"' "old") && dir != Path.Combine("webui"' "tweak"))                          {                              string n_dir = dir.Replace("webui"' Path.Combine("webui"' "old"));                              Directory.Move(dir' n_dir);                          }                      }                      foreach (string file in files)                      {                          if (File.Exists(file))                          {                              string n_file = file.Replace("webui"' Path.Combine("webui"' "old"));                              File.Move(file' n_file);                          }                      }                        try                      {                          //extract latest webui                          System.IO.Compression.ZipFile.ExtractToDirectory(Path.Combine("webui"' "latest.zip")' "webui");                            //clean because we already have working updated webui                          Directory.Delete(Path.Combine("webui"' "old")' true);                          File.Delete(Path.Combine("webui"' "latest.zip"));                            //save version type>version that was installed successful                          if (File.Exists(Path.Combine("webui"' "index.ver")))                          {                              File.Delete(Path.Combine("webui"' "index.ver"));                          }                          File.AppendAllText(Path.Combine("webui"' "index.ver")' channel + ">" + version);                            return APIStatus.OK();                      }                      catch                      {                          //when extracting latest.zip failes                          return new APIMessage(405' "MethodNotAllowed");                      }                  }                  catch                  {                      //when moving files to 'old' folder failed                      return new APIMessage(423' "Locked");                  }              }              catch              {                  //when download failed                  return new APIMessage(499' "download failed");              }
Magic Number,Shoko.Server.API.v2.Modules,Webui,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Webui.cs,WebUIUpdate,The following statement contains a magic number: try              {                  //download latest version                  var client = new System.Net.WebClient();                  client.Headers.Add("User-Agent"' "shokoserver");                  client.DownloadFile(url' Path.Combine("webui"' "latest.zip"));                    //create 'old' dictionary                  if (!Directory.Exists(Path.Combine("webui"' "old")))                  {                      System.IO.Directory.CreateDirectory(Path.Combine("webui"' "old"));                  }                  try                  {                      //move all directories and files to 'old' folder as fallback recovery                      foreach (string dir in directories)                      {                          if (Directory.Exists(dir) && dir != Path.Combine("webui"' "old") && dir != Path.Combine("webui"' "tweak"))                          {                              string n_dir = dir.Replace("webui"' Path.Combine("webui"' "old"));                              Directory.Move(dir' n_dir);                          }                      }                      foreach (string file in files)                      {                          if (File.Exists(file))                          {                              string n_file = file.Replace("webui"' Path.Combine("webui"' "old"));                              File.Move(file' n_file);                          }                      }                        try                      {                          //extract latest webui                          System.IO.Compression.ZipFile.ExtractToDirectory(Path.Combine("webui"' "latest.zip")' "webui");                            //clean because we already have working updated webui                          Directory.Delete(Path.Combine("webui"' "old")' true);                          File.Delete(Path.Combine("webui"' "latest.zip"));                            //save version type>version that was installed successful                          if (File.Exists(Path.Combine("webui"' "index.ver")))                          {                              File.Delete(Path.Combine("webui"' "index.ver"));                          }                          File.AppendAllText(Path.Combine("webui"' "index.ver")' channel + ">" + version);                            return APIStatus.OK();                      }                      catch                      {                          //when extracting latest.zip failes                          return new APIMessage(405' "MethodNotAllowed");                      }                  }                  catch                  {                      //when moving files to 'old' folder failed                      return new APIMessage(423' "Locked");                  }              }              catch              {                  //when download failed                  return new APIMessage(499' "download failed");              }
Magic Number,Shoko.Server.API.v2.Modules,Webui,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\Webui.cs,SetWebUIConfig,The following statement contains a magic number: if (settings.Valid())              {                  try                  {                      ServerSettings.WebUI_Settings = JsonConvert.SerializeObject(settings);                      return APIStatus.OK();                  }                  catch                  {                      return APIStatus.InternalError("error at saving webui settings");                  }              }              else              {                  return new APIMessage(400' "Config is not a Valid.");              }
Magic Number,Shoko.Server.Commands.Plex,CommandRequest_PlexSyncWatched,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Plex\CommandRequest_PlexSyncWatched.cs,FromUnixTime,The following statement contains a magic number: return new DateTime(1970' 1' 1' 0' 0' 0' DateTimeKind.Utc)                  .AddSeconds(unixTime);
Magic Number,Shoko.Server.Commands.Plex,PlexHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Plex\PlexHelper.cs,GetPlexSeries,The following statement contains a magic number: for (int i = 0; i < keys.Count; i++)              {                  XmlAttributeCollection attributes = keys[i].Attributes;                  string key = attributes?["key"].Value;                  if (string.IsNullOrEmpty(key)) continue;                      XmlDocument doc = GetXml(                      $"http://{ServerSettings.Plex_Server}{key.Substring(0' key.Length - 9)}/allLeaves");                  var files = doc.SelectNodes("/MediaContainer/Video");                    PlexSeries series = new PlexSeries                  {                      Episodes = new List<PlexEpisode>()'                      Name = attributes?["title"].InnerText'                      Season = Convert.ToInt32(attributes?["ratingKey"].InnerText)                  };                    for (int j = 0; j < files?.Count; j++)                  {                      var videoXml = files[j];                      string file = videoXml.SelectSingleNode("Media/Part")?.Attributes?["file"].InnerText;                      int watchCount = Convert.ToInt32(videoXml.Attributes?["viewCount"]?.InnerText ?? "0");                      int lastWatchedUnix = Convert.ToInt32(videoXml.Attributes?["lastViewedAt"]?.InnerText);                      uint ratingKey = Convert.ToUInt32(videoXml.Attributes?["ratingKey"]?.InnerText);                        series.Episodes.Add(new PlexEpisode                      {                          File = file'                          Key = ratingKey'                          LastWatched = lastWatchedUnix'                          WatchCount = watchCount'                          Helper = this                      });                  }                    toReturn.Add(series);              }
Magic Number,Shoko.Server.Commands.Plex,PlexHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Plex\PlexHelper.cs,CreateWebRequest,The following statement contains a magic number: request.Timeout = 120000;
Magic Number,Shoko.Server.Extensions,ModelProviders,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Extensions\ModelProviders.cs,ToMedia,The following statement contains a magic number: int size = (m.MediaInfo[0] << 24) | (m.MediaInfo[1] << 16) | (m.MediaInfo[2] << 8) | m.MediaInfo[3];
Magic Number,Shoko.Server.Extensions,ModelProviders,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Extensions\ModelProviders.cs,ToMedia,The following statement contains a magic number: int size = (m.MediaInfo[0] << 24) | (m.MediaInfo[1] << 16) | (m.MediaInfo[2] << 8) | m.MediaInfo[3];
Magic Number,Shoko.Server.Extensions,ModelProviders,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Extensions\ModelProviders.cs,ToMedia,The following statement contains a magic number: int size = (m.MediaInfo[0] << 24) | (m.MediaInfo[1] << 16) | (m.MediaInfo[2] << 8) | m.MediaInfo[3];
Magic Number,Shoko.Server.Extensions,ModelProviders,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Extensions\ModelProviders.cs,ToMedia,The following statement contains a magic number: int size = (m.MediaInfo[0] << 24) | (m.MediaInfo[1] << 16) | (m.MediaInfo[2] << 8) | m.MediaInfo[3];
Magic Number,Shoko.Server.Extensions,ModelProviders,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Extensions\ModelProviders.cs,ToMedia,The following statement contains a magic number: int size = (m.MediaInfo[0] << 24) | (m.MediaInfo[1] << 16) | (m.MediaInfo[2] << 8) | m.MediaInfo[3];
Magic Number,Shoko.Server.Extensions,ModelProviders,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Extensions\ModelProviders.cs,ToMedia,The following statement contains a magic number: byte[] data = new byte[m.MediaInfo.Length - 4];
Magic Number,Shoko.Server.Extensions,ModelProviders,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Extensions\ModelProviders.cs,ToMedia,The following statement contains a magic number: Array.Copy(m.MediaInfo' 4' data' 0' data.Length);
Magic Number,Shoko.Server.Extensions,ModelProviders,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Extensions\ModelProviders.cs,ToMediaRequest,The following statement contains a magic number: r.MediaInfo = new byte[data.Length + 4];
Magic Number,Shoko.Server.Extensions,ModelProviders,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Extensions\ModelProviders.cs,ToMediaRequest,The following statement contains a magic number: r.MediaInfo[0] = (byte)(outsize >> 24);
Magic Number,Shoko.Server.Extensions,ModelProviders,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Extensions\ModelProviders.cs,ToMediaRequest,The following statement contains a magic number: r.MediaInfo[1] = (byte)((outsize >> 16) & 0xFF);
Magic Number,Shoko.Server.Extensions,ModelProviders,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Extensions\ModelProviders.cs,ToMediaRequest,The following statement contains a magic number: r.MediaInfo[2] = (byte)((outsize >> 8) & 0xFF);
Magic Number,Shoko.Server.Extensions,ModelProviders,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Extensions\ModelProviders.cs,ToMediaRequest,The following statement contains a magic number: r.MediaInfo[2] = (byte)((outsize >> 8) & 0xFF);
Magic Number,Shoko.Server.Extensions,ModelProviders,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Extensions\ModelProviders.cs,ToMediaRequest,The following statement contains a magic number: r.MediaInfo[3] = (byte)(outsize & 0xFF);
Magic Number,Shoko.Server.Extensions,ModelProviders,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Extensions\ModelProviders.cs,ToMediaRequest,The following statement contains a magic number: Array.Copy(data' 0' r.MediaInfo' 4' data.Length);
Magic Number,Shoko.Server.Extensions,ModelProviders,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Extensions\ModelProviders.cs,ToMediaRequest,The following statement contains a magic number: r.MediaInfo = new byte[data.Length + 4];
Magic Number,Shoko.Server.Extensions,ModelProviders,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Extensions\ModelProviders.cs,ToMediaRequest,The following statement contains a magic number: r.MediaInfo[0] = (byte)(outsize >> 24);
Magic Number,Shoko.Server.Extensions,ModelProviders,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Extensions\ModelProviders.cs,ToMediaRequest,The following statement contains a magic number: r.MediaInfo[1] = (byte)((outsize >> 16) & 0xFF);
Magic Number,Shoko.Server.Extensions,ModelProviders,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Extensions\ModelProviders.cs,ToMediaRequest,The following statement contains a magic number: r.MediaInfo[2] = (byte)((outsize >> 8) & 0xFF);
Magic Number,Shoko.Server.Extensions,ModelProviders,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Extensions\ModelProviders.cs,ToMediaRequest,The following statement contains a magic number: r.MediaInfo[2] = (byte)((outsize >> 8) & 0xFF);
Magic Number,Shoko.Server.Extensions,ModelProviders,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Extensions\ModelProviders.cs,ToMediaRequest,The following statement contains a magic number: r.MediaInfo[3] = (byte)(outsize & 0xFF);
Magic Number,Shoko.Server.Extensions,ModelProviders,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Extensions\ModelProviders.cs,ToMediaRequest,The following statement contains a magic number: Array.Copy(data' 0' r.MediaInfo' 4' data.Length);
Magic Number,Shoko.Server.Extensions,ModelProviders,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Extensions\ModelProviders.cs,PopulateFromSeriesInfo,The following statement contains a magic number: if (apiSeries.SiteRating != null) series.Rating = (int) Math.Round(apiSeries.SiteRating.Value * 10);
Magic Number,Shoko.Server.Extensions,ModelProviders,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Extensions\ModelProviders.cs,Populate,The following statement contains a magic number: tag.Approval = 100;
Magic Number,Shoko.Server.Extensions,ModelProviders,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Extensions\ModelProviders.cs,PopulateManually,The following statement contains a magic number: cross.Percentage = 100;
Magic Number,Shoko.Server.Databases,BaseDatabase<T>,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Databases\BaseDatabase.cs,ExecuteDatabaseFixes,The following statement contains a magic number: foreach (DatabaseCommand cmd in Fixes)              {                  try                  {                      string message = cmd.CommandName;                      if (message.Length > 42)                          message = message.Substring(0' 42) + "...";                      ServerState.Instance.CurrentSetupStatus = ServerState.Instance.CurrentSetupStatus =                          Commons.Properties.Resources.Database_ApplySchema + cmd.Version + "." + cmd.Revision +                          " - " + message;                        cmd.DatabaseFix();                      AddVersion(cmd.Version.ToString()' cmd.Revision.ToString()' cmd.CommandName);                  }                  catch (Exception e)                  {                      throw new DatabaseCommandException(e.ToString()' cmd);                  }              }
Magic Number,Shoko.Server.Databases,BaseDatabase<T>,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Databases\BaseDatabase.cs,ExecuteDatabaseFixes,The following statement contains a magic number: foreach (DatabaseCommand cmd in Fixes)              {                  try                  {                      string message = cmd.CommandName;                      if (message.Length > 42)                          message = message.Substring(0' 42) + "...";                      ServerState.Instance.CurrentSetupStatus = ServerState.Instance.CurrentSetupStatus =                          Commons.Properties.Resources.Database_ApplySchema + cmd.Version + "." + cmd.Revision +                          " - " + message;                        cmd.DatabaseFix();                      AddVersion(cmd.Version.ToString()' cmd.Revision.ToString()' cmd.CommandName);                  }                  catch (Exception e)                  {                      throw new DatabaseCommandException(e.ToString()' cmd);                  }              }
Magic Number,Shoko.Server.Databases,BaseDatabase<T>,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Databases\BaseDatabase.cs,ExecuteCommand,The following statement contains a magic number: if (message.Length > 42)                  message = message.Substring(0' 42) + "...";
Magic Number,Shoko.Server.Databases,BaseDatabase<T>,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Databases\BaseDatabase.cs,ExecuteCommand,The following statement contains a magic number: if (message.Length > 42)                  message = message.Substring(0' 42) + "...";
Magic Number,Shoko.Server.Databases,BaseDatabase<T>,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Databases\BaseDatabase.cs,CreateInitialRenameScript,The following statement contains a magic number: initialScript.Script =                  "// Sample Output: [Coalgirls]_Highschool_of_the_Dead_-_01_(1920x1080_Blu-ray_H264)_[90CC6DC1].mkv" +                  Environment.NewLine +                  "// Sub group name" + Environment.NewLine +                  "DO ADD '[%grp] '" + Environment.NewLine +                  "// Anime Name' use english name if it exists' otherwise use the Romaji name" + Environment.NewLine +                  "IF I(eng) DO ADD '%eng '" + Environment.NewLine +                  "IF I(ann);I(!eng) DO ADD '%ann '" + Environment.NewLine +                  "// Episode Number' don't use episode number for movies" + Environment.NewLine +                  "IF T(!Movie) DO ADD '- %enr'" + Environment.NewLine +                  "// If the file version is v2 or higher add it here" + Environment.NewLine +                  "IF F(!1) DO ADD 'v%ver'" + Environment.NewLine +                  "// Video Resolution" + Environment.NewLine +                  "DO ADD ' (%res'" + Environment.NewLine +                  "// Video Source (only if blu-ray or DVD)" + Environment.NewLine +                  "IF R(DVD)'R(Blu-ray) DO ADD ' %src'" + Environment.NewLine +                  "// Video Codec" + Environment.NewLine +                  "DO ADD ' %vid'" + Environment.NewLine +                  "// Video Bit Depth (only if 10bit)" + Environment.NewLine +                  "IF Z(10) DO ADD ' %bitbit'" + Environment.NewLine +                  "DO ADD ') '" + Environment.NewLine +                  "DO ADD '[%CRC]'" + Environment.NewLine +                  string.Empty + Environment.NewLine +                  "// Replacement rules (cleanup)" + Environment.NewLine +                  "DO REPLACE ' ' '_' // replace spaces with underscores" + Environment.NewLine +                  "DO REPLACE 'H264/AVC' 'H264'" + Environment.NewLine +                  "DO REPLACE '0x0' ''" + Environment.NewLine +                  "DO REPLACE '__' '_'" + Environment.NewLine +                  "DO REPLACE '__' '_'" + Environment.NewLine +                  string.Empty + Environment.NewLine +                  "// Replace all illegal file name characters" + Environment.NewLine +                  "DO REPLACE '<' '('" + Environment.NewLine +                  "DO REPLACE '>' ')'" + Environment.NewLine +                  "DO REPLACE ':' '-'" + Environment.NewLine +                  "DO REPLACE '" + ((Char) 34).ToString() + "' '`'" + Environment.NewLine +                  "DO REPLACE '/' '_'" + Environment.NewLine +                  "DO REPLACE '/' '_'" + Environment.NewLine +                  "DO REPLACE '\\' '_'" + Environment.NewLine +                  "DO REPLACE '|' '_'" + Environment.NewLine +                  "DO REPLACE '?' '_'" + Environment.NewLine +                  "DO REPLACE '*' '_'" + Environment.NewLine;
Magic Number,Shoko.Server.Databases,DatabaseFactory,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Databases\DatabaseFactory.cs,InitDB,The following statement contains a magic number: try              {                  Instance = null;                  if (!Instance.DatabaseAlreadyExists())                  {                      Instance.CreateDatabase();                      Thread.Sleep(3000);                  }                  Thread.CurrentThread.CurrentUICulture = CultureInfo.GetCultureInfo(ServerSettings.Culture);                    DatabaseFactory.CloseSessionFactory();                  ServerState.Instance.CurrentSetupStatus = Commons.Properties.Resources.Database_Initializing;                  ISessionFactory temp = DatabaseFactory.SessionFactory;                  Instance.Init();                  int version = Instance.GetDatabaseVersion();                  if (version > Instance.RequiredVersion)                  {                      ServerState.Instance.CurrentSetupStatus =                          Commons.Properties.Resources.Database_NotSupportedVersion;                      errorMessage = Commons.Properties.Resources.Database_NotSupportedVersion;                      return false;                  }                  if (version != 0 && version < Instance.RequiredVersion)                  {                      ServerState.Instance.CurrentSetupStatus = Commons.Properties.Resources.Database_Backup;                      Instance.BackupDatabase(Instance.GetDatabaseBackupName(version));                  }                  try                  {                      logger.Info($"{Instance.GetType()}Instance.CreateAndUpdateSchema()");                      Instance.CreateAndUpdateSchema();                        logger.Info($"RepoFactory.Init()");                      RepoFactory.Init();                      Instance.ExecuteDatabaseFixes();                      Instance.PopulateInitialData();                      RepoFactory.PostInit();                  }                  catch (Exception ex)                  {                      if (ex is DatabaseCommandException)                      {                          logger.Error(ex' ex.ToString());                          Utils.ShowErrorMessage("Database Error :\n\r " + ex +                              "\n\rNotify developers about this error' it will be logged in your logs"' "Database Error");                          ServerState.Instance.CurrentSetupStatus =                              Commons.Properties.Resources.Server_DatabaseFail;                          errorMessage = "Database Error :\n\r " + ex +                                         "\n\rNotify developers about this error' it will be logged in your logs";                          return false;                      }                      if (ex is TimeoutException)                      {                          logger.Error(ex' $"Database Timeout: {ex}");                          ServerState.Instance.CurrentSetupStatus =                              Commons.Properties.Resources.Server_DatabaseTimeOut;                          errorMessage = Commons.Properties.Resources.Server_DatabaseTimeOut + "\n\r" + ex;                          return false;                      }                      // throw to the outer try/catch                      throw;                  }                    errorMessage = string.Empty;                  return true;              }              catch (Exception ex)              {                  errorMessage = $"Could not init database: {ex}";                  logger.Error(ex' errorMessage);                  ServerState.Instance.CurrentSetupStatus = Commons.Properties.Resources.Server_DatabaseFail;                  return false;              }
Magic Number,Shoko.Server.Databases,DatabaseFixes,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Databases\DatabaseFixes.cs,PopulateAniDBEpisodeDescriptions,The following statement contains a magic number: foreach (var animeID in list)              {                  if (i % 10 == 0)                      ServerState.Instance.CurrentSetupStatus = string.Format(                          Commons.Properties.Resources.Database_Validating' "Populating Episode Descriptions from Cache"'                          $" {i}/{list.Count}");                  i++;                  try                  {                      var getAnimeCmd = new AniDBHTTPCommand_GetFullAnime();                      getAnimeCmd.Init(animeID' false' false' true);                      var result = getAnimeCmd.Process();                      if (result == enHelperActivityType.Banned_555 || result == enHelperActivityType.NoSuchAnime)                          continue;                      if (getAnimeCmd.Anime == null) continue;                      using (var session = DatabaseFactory.SessionFactory.OpenSession())                      {                          ShokoService.AnidbProcessor.SaveResultsForAnimeXML(session' animeID' false' getAnimeCmd);                      }                  }                  catch (Exception e)                  {                      logger.Error(                          $"There was an error Populating AniDB_Episode Descriptions for AniDB_Anime {animeID}' Update the Series' AniDB Info for a full stack: {e.Message}");                  }              }
Magic Number,Shoko.Server.FileHelper,NativeHasher,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\NativeHasher.cs,GetHash,The following statement contains a magic number: using (Stream source = File.OpenRead(filename))              {                  byte[] buffer = new byte[8192];                  int bytesRead;                  while ((bytesRead = source.Read(buffer' 0' buffer.Length)) > 0)                  {                      var buf = Marshal.AllocHGlobal(bytesRead);                      Marshal.Copy(buffer' 0' buf' bytesRead);                      Native.rhash_update(ctx' buf' bytesRead);                      Marshal.FreeHGlobal(buf);                  }              }
Magic Number,Shoko.Server.FileHelper,NativeHasher,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\NativeHasher.cs,GetHash,The following statement contains a magic number: IntPtr output = Marshal.AllocHGlobal(200);
Magic Number,Shoko.Server.FileHelper,Crc32,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\Crc32.cs,HashCore,The following statement contains a magic number: unchecked              {                  while (--length >= 0)                  {                      _crcValue = CrcTable[(_crcValue ^ buffer[start++]) & 0xFF] ^ (_crcValue >> 8);                  }              }
Magic Number,Shoko.Server.FileHelper,Crc32,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\Crc32.cs,HashFinal,The following statement contains a magic number: HashValue = new[]              {                  (byte) ((_crcValue >> 24) & 0xff)'                  (byte) ((_crcValue >> 16) & 0xff)'                  (byte) ((_crcValue >> 8) & 0xff)'                  (byte) (_crcValue & 0xff)              };
Magic Number,Shoko.Server.FileHelper,Crc32,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\Crc32.cs,HashFinal,The following statement contains a magic number: HashValue = new[]              {                  (byte) ((_crcValue >> 24) & 0xff)'                  (byte) ((_crcValue >> 16) & 0xff)'                  (byte) ((_crcValue >> 8) & 0xff)'                  (byte) (_crcValue & 0xff)              };
Magic Number,Shoko.Server.FileHelper,Crc32,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\Crc32.cs,HashFinal,The following statement contains a magic number: HashValue = new[]              {                  (byte) ((_crcValue >> 24) & 0xff)'                  (byte) ((_crcValue >> 16) & 0xff)'                  (byte) ((_crcValue >> 8) & 0xff)'                  (byte) (_crcValue & 0xff)              };
Magic Number,Shoko.Server.FileHelper,Hasher,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\Hasher.cs,HashToString,The following statement contains a magic number: StringBuilder hex = new StringBuilder(length * 2);
Magic Number,Shoko.Server.FileHelper,Hasher,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\Hasher.cs,CalculateHashes,The following statement contains a magic number: if (Finalise.ModuleHandle != IntPtr.Zero || Utils.IsLinux)              {                  byte[] hash = new byte[56];                  bool gotHash = false;                  int rval = -1;                  try                  {                      string filename = strPath;                      if (!Utils.IsLinux) filename = strPath.StartsWith(@"\\") ? strPath : @"\\?\" + strPath; //only prepend non-UNC paths (or paths that have this already)                        (string e2Dk' string crc32' string md5' string sha1) = NativeHasher.GetHash(filename);                      rhash.ED2K = e2Dk;                      if (!string.IsNullOrEmpty(rhash.ED2K)) gotHash = true;                      if (getCRC32) rhash.CRC32 = crc32;                      if (getMD5) rhash.MD5 = md5;                      if (getSHA1) rhash.SHA1 = sha1;                  }                  catch (Exception ex)                  {                      logger.Error(ex' ex.ToString());                  }                    if (gotHash)                      return rhash;                                    logger.Error("Error using DLL to get hash (Functon returned {0})' trying C# code instead: {0}"' rval' strPath);              }
Magic Number,Shoko.Server.FileHelper,Hasher,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\Hasher.cs,CalculateHashes_here,The following statement contains a magic number: int lChunkSize = 9728000;
Magic Number,Shoko.Server.FileHelper,Hasher,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\Hasher.cs,CalculateHashes_here,The following statement contains a magic number: byte[] baED2KHash = new byte[16 * nBlocks];
Magic Number,Shoko.Server.FileHelper,Hasher,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\Hasher.cs,CalculateHashes_here,The following statement contains a magic number: while (nBytesRemaining > 0)              {                  iChunkCount++;                    //logger.Trace("Hashing Chunk: " + iChunkCount.ToString());                    int nBytesRead = fs.Read(ByteArray' 0' nBytesToRead);                    if (getED2k)                  {                      byte[] baHash = md4.ComputeHash(ByteArray' 0' nBytesRead);                      int j = (int) ((iChunkCount - 1) * 16);                      for (int i = 0; i < 16; i++)                          baED2KHash[j + i] = baHash[i];                  }                    if (getMD5) md5.TransformBlock(ByteArray' 0' nBytesRead' ByteArray' 0);                  if (getSHA1) sha1.TransformBlock(ByteArray' 0' nBytesRead' ByteArray' 0);                  if (getCRC32) crc32.TransformBlock(ByteArray' 0' nBytesRead' ByteArray' 0);                    int percentComplete = (int)(iChunkCount / (float)nBlocks * 100);                  onHashProgress?.Invoke(strPath' percentComplete);                    iOffSet += lChunkSize;                  nBytesRemaining = nBytes - iOffSet;                  if (nBytesRemaining < lChunkSize)                      nBytesToRead = (int) nBytesRemaining;              }
Magic Number,Shoko.Server.FileHelper,Hasher,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\Hasher.cs,CalculateHashes_here,The following statement contains a magic number: while (nBytesRemaining > 0)              {                  iChunkCount++;                    //logger.Trace("Hashing Chunk: " + iChunkCount.ToString());                    int nBytesRead = fs.Read(ByteArray' 0' nBytesToRead);                    if (getED2k)                  {                      byte[] baHash = md4.ComputeHash(ByteArray' 0' nBytesRead);                      int j = (int) ((iChunkCount - 1) * 16);                      for (int i = 0; i < 16; i++)                          baED2KHash[j + i] = baHash[i];                  }                    if (getMD5) md5.TransformBlock(ByteArray' 0' nBytesRead' ByteArray' 0);                  if (getSHA1) sha1.TransformBlock(ByteArray' 0' nBytesRead' ByteArray' 0);                  if (getCRC32) crc32.TransformBlock(ByteArray' 0' nBytesRead' ByteArray' 0);                    int percentComplete = (int)(iChunkCount / (float)nBlocks * 100);                  onHashProgress?.Invoke(strPath' percentComplete);                    iOffSet += lChunkSize;                  nBytesRemaining = nBytes - iOffSet;                  if (nBytesRemaining < lChunkSize)                      nBytesToRead = (int) nBytesRemaining;              }
Magic Number,Shoko.Server.FileHelper,Hasher,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\Hasher.cs,CalculateHashes_here,The following statement contains a magic number: while (nBytesRemaining > 0)              {                  iChunkCount++;                    //logger.Trace("Hashing Chunk: " + iChunkCount.ToString());                    int nBytesRead = fs.Read(ByteArray' 0' nBytesToRead);                    if (getED2k)                  {                      byte[] baHash = md4.ComputeHash(ByteArray' 0' nBytesRead);                      int j = (int) ((iChunkCount - 1) * 16);                      for (int i = 0; i < 16; i++)                          baED2KHash[j + i] = baHash[i];                  }                    if (getMD5) md5.TransformBlock(ByteArray' 0' nBytesRead' ByteArray' 0);                  if (getSHA1) sha1.TransformBlock(ByteArray' 0' nBytesRead' ByteArray' 0);                  if (getCRC32) crc32.TransformBlock(ByteArray' 0' nBytesRead' ByteArray' 0);                    int percentComplete = (int)(iChunkCount / (float)nBlocks * 100);                  onHashProgress?.Invoke(strPath' percentComplete);                    iOffSet += lChunkSize;                  nBytesRemaining = nBytes - iOffSet;                  if (nBytesRemaining < lChunkSize)                      nBytesToRead = (int) nBytesRemaining;              }
Magic Number,Shoko.Server.FileHelper,Hasher,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\Hasher.cs,CalculateHashes_here,The following statement contains a magic number: onHashProgress?.Invoke(strPath' 100);
Magic Number,Shoko.Server.FileHelper,MD4,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4,The following statement contains a magic number: HashSizeValue = 128;
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Managed,The following statement contains a magic number: state = new uint[4];
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Managed,The following statement contains a magic number: count = new uint[2];
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Managed,The following statement contains a magic number: buffer = new byte[64];
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Managed,The following statement contains a magic number: digest = new byte[16];
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Managed,The following statement contains a magic number: x = new uint[16];
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,Initialize,The following statement contains a magic number: state[2] = 0x98badcfe;
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,Initialize,The following statement contains a magic number: state[3] = 0x10325476;
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,Initialize,The following statement contains a magic number: Array.Clear(buffer' 0' 64);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,Initialize,The following statement contains a magic number: Array.Clear(x' 0' 16);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,HashCore,The following statement contains a magic number: int index = (int) ((count[0] >> 3) & 0x3F);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,HashCore,The following statement contains a magic number: count[0] += (uint) (cbSize << 3);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,HashCore,The following statement contains a magic number: if (count[0] < cbSize << 3)                  count[1]++;
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,HashCore,The following statement contains a magic number: count[1] += (uint) (cbSize >> 29);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,HashCore,The following statement contains a magic number: int partLen = 64 - index;
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,HashCore,The following statement contains a magic number: if (cbSize >= partLen)              {                  //MD4_memcpy((POINTER)&context->buffer[index]' (POINTER)input' partLen);                  Buffer.BlockCopy(array' ibStart' buffer' index' partLen);                  MD4Transform(state' buffer' 0);                    for (i = partLen; i + 63 < cbSize; i += 64)                  {                      // MD4Transform (context->state' &input[i]);                      MD4Transform(state' array' i);                  }                    index = 0;              }
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,HashCore,The following statement contains a magic number: if (cbSize >= partLen)              {                  //MD4_memcpy((POINTER)&context->buffer[index]' (POINTER)input' partLen);                  Buffer.BlockCopy(array' ibStart' buffer' index' partLen);                  MD4Transform(state' buffer' 0);                    for (i = partLen; i + 63 < cbSize; i += 64)                  {                      // MD4Transform (context->state' &input[i]);                      MD4Transform(state' array' i);                  }                    index = 0;              }
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,HashFinal,The following statement contains a magic number: byte[] bits = new byte[8];
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,HashFinal,The following statement contains a magic number: uint index = (count[0] >> 3) & 0x3f;
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,HashFinal,The following statement contains a magic number: int padLen = (int) (index < 56 ? 56 - index : 120 - index);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,HashFinal,The following statement contains a magic number: int padLen = (int) (index < 56 ? 56 - index : 120 - index);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,HashFinal,The following statement contains a magic number: int padLen = (int) (index < 56 ? 56 - index : 120 - index);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,HashFinal,The following statement contains a magic number: HashCore(bits' 0' 8);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,ROL,The following statement contains a magic number: return (x << n) | (x >> (32 - n));
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,Encode,The following statement contains a magic number: for (int i = 0' j = 0; j < output.Length; i++' j += 4)              {                  output[j] = (byte) input[i];                  output[j + 1] = (byte) (input[i] >> 8);                  output[j + 2] = (byte) (input[i] >> 16);                  output[j + 3] = (byte) (input[i] >> 24);              }
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,Encode,The following statement contains a magic number: for (int i = 0' j = 0; j < output.Length; i++' j += 4)              {                  output[j] = (byte) input[i];                  output[j + 1] = (byte) (input[i] >> 8);                  output[j + 2] = (byte) (input[i] >> 16);                  output[j + 3] = (byte) (input[i] >> 24);              }
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,Encode,The following statement contains a magic number: for (int i = 0' j = 0; j < output.Length; i++' j += 4)              {                  output[j] = (byte) input[i];                  output[j + 1] = (byte) (input[i] >> 8);                  output[j + 2] = (byte) (input[i] >> 16);                  output[j + 3] = (byte) (input[i] >> 24);              }
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,Encode,The following statement contains a magic number: for (int i = 0' j = 0; j < output.Length; i++' j += 4)              {                  output[j] = (byte) input[i];                  output[j + 1] = (byte) (input[i] >> 8);                  output[j + 2] = (byte) (input[i] >> 16);                  output[j + 3] = (byte) (input[i] >> 24);              }
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,Encode,The following statement contains a magic number: for (int i = 0' j = 0; j < output.Length; i++' j += 4)              {                  output[j] = (byte) input[i];                  output[j + 1] = (byte) (input[i] >> 8);                  output[j + 2] = (byte) (input[i] >> 16);                  output[j + 3] = (byte) (input[i] >> 24);              }
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,Encode,The following statement contains a magic number: for (int i = 0' j = 0; j < output.Length; i++' j += 4)              {                  output[j] = (byte) input[i];                  output[j + 1] = (byte) (input[i] >> 8);                  output[j + 2] = (byte) (input[i] >> 16);                  output[j + 3] = (byte) (input[i] >> 24);              }
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,Decode,The following statement contains a magic number: for (int i = 0' j = index; i < output.Length; i++' j += 4)              {                  output[i] = (uint) (input[j] | (input[j + 1] << 8) | (input[j + 2] << 16) | (input[j + 3] << 24));              }
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,Decode,The following statement contains a magic number: for (int i = 0' j = index; i < output.Length; i++' j += 4)              {                  output[i] = (uint) (input[j] | (input[j + 1] << 8) | (input[j + 2] << 16) | (input[j + 3] << 24));              }
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,Decode,The following statement contains a magic number: for (int i = 0' j = index; i < output.Length; i++' j += 4)              {                  output[i] = (uint) (input[j] | (input[j + 1] << 8) | (input[j + 2] << 16) | (input[j + 3] << 24));              }
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,Decode,The following statement contains a magic number: for (int i = 0' j = index; i < output.Length; i++' j += 4)              {                  output[i] = (uint) (input[j] | (input[j + 1] << 8) | (input[j + 2] << 16) | (input[j + 3] << 24));              }
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,Decode,The following statement contains a magic number: for (int i = 0' j = index; i < output.Length; i++' j += 4)              {                  output[i] = (uint) (input[j] | (input[j + 1] << 8) | (input[j + 2] << 16) | (input[j + 3] << 24));              }
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,Decode,The following statement contains a magic number: for (int i = 0' j = index; i < output.Length; i++' j += 4)              {                  output[i] = (uint) (input[j] | (input[j + 1] << 8) | (input[j + 2] << 16) | (input[j + 3] << 24));              }
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: uint c = state[2];
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: uint d = state[3];
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: FF(ref c' d' a' b' x[2]' S13);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: FF(ref b' c' d' a' x[3]' S14);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: FF(ref a' b' c' d' x[4]' S11);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: FF(ref d' a' b' c' x[5]' S12);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: FF(ref c' d' a' b' x[6]' S13);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: FF(ref b' c' d' a' x[7]' S14);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: FF(ref a' b' c' d' x[8]' S11);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: FF(ref d' a' b' c' x[9]' S12);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: FF(ref c' d' a' b' x[10]' S13);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: FF(ref b' c' d' a' x[11]' S14);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: FF(ref a' b' c' d' x[12]' S11);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: FF(ref d' a' b' c' x[13]' S12);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: FF(ref c' d' a' b' x[14]' S13);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: FF(ref b' c' d' a' x[15]' S14);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: GG(ref d' a' b' c' x[4]' S22);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: GG(ref c' d' a' b' x[8]' S23);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: GG(ref b' c' d' a' x[12]' S24);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: GG(ref d' a' b' c' x[5]' S22);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: GG(ref c' d' a' b' x[9]' S23);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: GG(ref b' c' d' a' x[13]' S24);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: GG(ref a' b' c' d' x[2]' S21);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: GG(ref d' a' b' c' x[6]' S22);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: GG(ref c' d' a' b' x[10]' S23);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: GG(ref b' c' d' a' x[14]' S24);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: GG(ref a' b' c' d' x[3]' S21);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: GG(ref d' a' b' c' x[7]' S22);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: GG(ref c' d' a' b' x[11]' S23);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: GG(ref b' c' d' a' x[15]' S24);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: HH(ref d' a' b' c' x[8]' S32);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: HH(ref c' d' a' b' x[4]' S33);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: HH(ref b' c' d' a' x[12]' S34);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: HH(ref a' b' c' d' x[2]' S31);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: HH(ref d' a' b' c' x[10]' S32);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: HH(ref c' d' a' b' x[6]' S33);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: HH(ref b' c' d' a' x[14]' S34);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: HH(ref d' a' b' c' x[9]' S32);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: HH(ref c' d' a' b' x[5]' S33);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: HH(ref b' c' d' a' x[13]' S34);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: HH(ref a' b' c' d' x[3]' S31);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: HH(ref d' a' b' c' x[11]' S32);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: HH(ref c' d' a' b' x[7]' S33);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: HH(ref b' c' d' a' x[15]' S34);
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: state[2] += c;
Magic Number,Shoko.Server.FileHelper,MD4Managed,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MD4Managed.cs,MD4Transform,The following statement contains a magic number: state[3] += d;
Magic Number,Shoko.Server.Models,SVR_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AniDB_Anime.cs,GetDictTvDBSeasons,The following statement contains a magic number: if (dictTvDBSeasons == null)              {                  try                  {                      dictTvDBSeasons = new Dictionary<int' int>();                      // create a dictionary of season numbers and the first episode for that season                      int i = 1;                      int lastSeason = -999;                      foreach (TvDB_Episode ep in GetTvDBEpisodes())                      {                          if (ep.SeasonNumber != lastSeason)                              dictTvDBSeasons[ep.SeasonNumber] = i;                            lastSeason = ep.SeasonNumber;                          i++;                      }                  }                  catch (Exception ex)                  {                      logger.Error(ex' ex.ToString());                  }              }
Magic Number,Shoko.Server.Models,SVR_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AniDB_Anime.cs,GetDictTvDBSeasonsSpecials,The following statement contains a magic number: if (dictTvDBSeasonsSpecials == null)              {                  try                  {                      dictTvDBSeasonsSpecials = new Dictionary<int' int>();                      // create a dictionary of season numbers and the first episode for that season                      int i = 1;                      int lastSeason = -999;                      foreach (TvDB_Episode ep in GetTvDBEpisodes())                      {                          if (ep.SeasonNumber > 0) continue;                            int thisSeason = 0;                          if (ep.AirsBeforeSeason.HasValue) thisSeason = ep.AirsBeforeSeason.Value;                          if (ep.AirsAfterSeason.HasValue) thisSeason = ep.AirsAfterSeason.Value;                            if (thisSeason != lastSeason)                              dictTvDBSeasonsSpecials[thisSeason] = i;                            lastSeason = thisSeason;                          i++;                      }                  }                  catch (Exception ex)                  {                      logger.Error(ex' ex.ToString());                  }              }
Magic Number,Shoko.Server.Models,SVR_AnimeGroup,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeGroup.cs,BatchUpdateContracts,The following statement contains a magic number: foreach (SVR_AnimeGroup animeGroup in animeGroups)              {                  CL_AnimeGroup_User contract = animeGroup.Contract?.DeepCopy();                  bool localUpdateStats = updateStats;                    if (contract == null)                  {                      contract = new CL_AnimeGroup_User();                      localUpdateStats = true;                  }                    contract.AnimeGroupID = animeGroup.AnimeGroupID;                  contract.AnimeGroupParentID = animeGroup.AnimeGroupParentID;                  contract.DefaultAnimeSeriesID = animeGroup.DefaultAnimeSeriesID;                  contract.GroupName = animeGroup.GroupName;                  contract.Description = animeGroup.Description;                  contract.LatestEpisodeAirDate = animeGroup.LatestEpisodeAirDate;                  contract.SortName = animeGroup.SortName;                  contract.EpisodeAddedDate = animeGroup.EpisodeAddedDate;                  contract.OverrideDescription = animeGroup.OverrideDescription;                  contract.DateTimeUpdated = animeGroup.DateTimeUpdated;                  contract.IsFave = 0;                  contract.UnwatchedEpisodeCount = 0;                  contract.WatchedEpisodeCount = 0;                  contract.WatchedDate = null;                  contract.PlayedCount = 0;                  contract.WatchedCount = 0;                  contract.StoppedCount = 0;                  contract.MissingEpisodeCount = animeGroup.MissingEpisodeCount;                  contract.MissingEpisodeCountGroups = animeGroup.MissingEpisodeCountGroups;                    List<SVR_AnimeSeries> allSeriesForGroup = seriesByGroup[animeGroup.AnimeGroupID];                    if (localUpdateStats)                  {                      DateTime? airDateMin = null;                      DateTime? airDateMax = null;                      DateTime? groupEndDate = new DateTime(1980' 1' 1);                      DateTime? seriesCreatedDate = null;                      bool isComplete = false;                      bool hasFinishedAiring = false;                      bool isCurrentlyAiring = false;                      HashSet<string> videoQualityEpisodes =                          new HashSet<string>(StringComparer.InvariantCultureIgnoreCase);                      HashSet<string> audioLanguages = new HashSet<string>(StringComparer.InvariantCultureIgnoreCase);                      HashSet<string> subtitleLanguages = new HashSet<string>(StringComparer.InvariantCultureIgnoreCase);                      // Even though the contract value says 'has link'' it's easier to think about whether it's missing                      bool missingTvDBLink = false;                      bool missingMALLink = false;                      bool missingMovieDBLink = false;                      bool missingTvDBAndMovieDBLink = false;                      int seriesCount = 0;                      int epCount = 0;                        HashSet<int> allYears = new HashSet<int>();                      SortedSet<string> allSeasons = new SortedSet<string>(new SeasonComparator());                        foreach (SVR_AnimeSeries series in allSeriesForGroup)                      {                          seriesCount++;                            List<SVR_VideoLocal> vidsTemp = RepoFactory.VideoLocal.GetByAniDBAnimeID(series.AniDB_ID);                          List<CrossRef_File_Episode> crossRefs =                              RepoFactory.CrossRef_File_Episode.GetByAnimeID(series.AniDB_ID);                          ILookup<int' CrossRef_File_Episode> crossRefsLookup = crossRefs.ToLookup(cr => cr.EpisodeID);                          var dictVids = new Dictionary<string' SVR_VideoLocal>();                            foreach (SVR_VideoLocal vid in vidsTemp)                          //Hashes may be repeated from multiple locations but we don't care                              dictVids[vid.Hash] = vid;                            // All Video Quality Episodes                          // Try to determine if this anime has all the episodes available at a certain video quality                          // e.g.  the series has all episodes in blu-ray                          // Also look at languages                          Dictionary<string' int> vidQualEpCounts = new Dictionary<string' int>();                          // video quality' count of episodes                          SVR_AniDB_Anime anime = series.GetAnime();                            foreach (SVR_AnimeEpisode ep in series.GetAnimeEpisodes())                          {                              if (ep.EpisodeTypeEnum != EpisodeType.Episode)                                  continue;                                var epVids = new List<SVR_VideoLocal>();                                foreach (CrossRef_File_Episode xref in crossRefsLookup[ep.AniDB_EpisodeID])                              {                                  if (xref.EpisodeID != ep.AniDB_EpisodeID)                                      continue;                                      if (dictVids.TryGetValue(xref.Hash' out SVR_VideoLocal video))                                      epVids.Add(video);                              }                                var qualityAddedSoFar = new HashSet<string>();                                // Handle mutliple files of the same quality for one episode                              foreach (SVR_VideoLocal vid in epVids)                              {                                  SVR_AniDB_File anifile = vid.GetAniDBFile();                                    if (anifile == null)                                      continue;                                    if (!qualityAddedSoFar.Contains(anifile.File_Source))                                  {                                        vidQualEpCounts.TryGetValue(anifile.File_Source' out int srcCount);                                      vidQualEpCounts[anifile.File_Source] =                                          srcCount +                                          1; // If the file source wasn't originally in the dictionary' then it will be set to 1                                        qualityAddedSoFar.Add(anifile.File_Source);                                  }                              }                          }                            epCount += anime.EpisodeCountNormal;                            // Add all video qualities that span all of the normal episodes                          videoQualityEpisodes.UnionWith(                              vidQualEpCounts                                  .Where(vqec => anime.EpisodeCountNormal == vqec.Value)                                  .Select(vqec => vqec.Key));                              // Audio languages                          if (audioLangStatsByAnime.Value.TryGetValue(anime.AnimeID' out LanguageStat langStats))                              audioLanguages.UnionWith(langStats.LanguageNames);                            // Subtitle languages                          if (subLangStatsByAnime.Value.TryGetValue(anime.AnimeID' out langStats))                              subtitleLanguages.UnionWith(langStats.LanguageNames);                            // Calculate Air Date                          DateTime seriesAirDate = series.AirDate;                            if (seriesAirDate != DateTime.MinValue)                          {                              if (airDateMin == null || seriesAirDate < airDateMin.Value)                                  airDateMin = seriesAirDate;                                if (airDateMax == null || seriesAirDate > airDateMax.Value)                                  airDateMax = seriesAirDate;                          }                            // Calculate end date                          // If the end date is NULL it actually means it is ongoing' so this is the max possible value                          DateTime? seriesEndDate = series.EndDate;                            if (seriesEndDate == null || groupEndDate == null)                              groupEndDate = null;                          else if (seriesEndDate.Value > groupEndDate.Value)                              groupEndDate = seriesEndDate;                            // Note - only one series has to be finished airing to qualify                          if (series.EndDate != null && series.EndDate.Value < now)                              hasFinishedAiring = true;                          // Note - only one series has to be finished airing to qualify                          if (series.EndDate == null || series.EndDate.Value > now)                              isCurrentlyAiring = true;                            // We evaluate IsComplete as true if                          // 1. series has finished airing                          // 2. user has all episodes locally                          // Note - only one series has to be complete for the group to be considered complete                          if (series.EndDate != null && series.EndDate.Value < now                              && series.MissingEpisodeCount == 0 && series.MissingEpisodeCountGroups == 0)                              isComplete = true;                            // Calculate Series Created Date                          DateTime createdDate = series.DateTimeCreated;                            if (seriesCreatedDate == null || createdDate < seriesCreatedDate.Value)                              seriesCreatedDate = createdDate;                            // For the group' if any of the series don't have a tvdb link                          // we will consider the group as not having a tvdb link                          bool foundTvDBLink = tvDbXrefByAnime.Value[anime.AnimeID].Any();                          bool foundMovieDBLink = movieDbXRefByAnime.Value[anime.AnimeID].Any();                          bool isMovie = anime.AnimeType == (int) AnimeType.Movie;                          if (!foundTvDBLink)                              if (!isMovie && !(anime.Restricted > 0))                                  missingTvDBLink = true;                          if (!foundMovieDBLink)                              if (isMovie && !(anime.Restricted > 0))                                  missingMovieDBLink = true;                          if (!malXRefByAnime.Value[anime.AnimeID].Any())                              missingMALLink = true;                            missingTvDBAndMovieDBLink |= !(anime.Restricted > 0) && !foundTvDBLink && !foundMovieDBLink;                            int endyear = anime.EndYear;                          if (endyear == 0) endyear = DateTime.Today.Year;                          if (anime.BeginYear != 0)                          {                              var years = Enumerable.Range(anime.BeginYear' endyear - anime.BeginYear + 1).ToList();                              allYears.UnionWith(years);                              foreach (int year in years)                              foreach (AnimeSeason season in Enum.GetValues(typeof(AnimeSeason)))                                  if (anime.IsInSeason(season' year)) allSeasons.Add($"{season} {year}");                          }                      }                        contract.Stat_AllYears = allYears;                      contract.Stat_AllSeasons = allSeasons;                      contract.Stat_AllTags = animeGroup.Tags                          .Select(a => a.TagName.Trim())                          .ToHashSet(StringComparer.InvariantCultureIgnoreCase);                      contract.Stat_AllCustomTags = animeGroup.CustomTags                          .Select(a => a.TagName)                          .ToHashSet(StringComparer.InvariantCultureIgnoreCase);                      contract.Stat_AllTitles = animeGroup.Titles                          .Select(a => a.Title)                          .ToHashSet(StringComparer.InvariantCultureIgnoreCase);                      contract.Stat_AnimeTypes = allSeriesForGroup                          .Select(a => a.Contract?.AniDBAnime?.AniDBAnime)                          .Where(a => a != null)                          .Select(a => a.AnimeType.ToString())                          .ToHashSet(StringComparer.InvariantCultureIgnoreCase);                      contract.Stat_AllVideoQuality = allVidQualByGroup.Value[animeGroup.AnimeGroupID]                          .ToHashSet(StringComparer.InvariantCultureIgnoreCase);                      contract.Stat_IsComplete = isComplete;                      contract.Stat_HasFinishedAiring = hasFinishedAiring;                      contract.Stat_IsCurrentlyAiring = isCurrentlyAiring;                      contract.Stat_HasTvDBLink = !missingTvDBLink; // Has a link if it isn't missing                      contract.Stat_HasMALLink = !missingMALLink; // Has a link if it isn't missing                      contract.Stat_HasMovieDBLink = !missingMovieDBLink; // Has a link if it isn't missing                      contract.Stat_HasMovieDBOrTvDBLink = !missingTvDBAndMovieDBLink; // Has a link if it isn't missing                      contract.Stat_SeriesCount = seriesCount;                      contract.Stat_EpisodeCount = epCount;                      contract.Stat_AllVideoQuality_Episodes = videoQualityEpisodes;                      contract.Stat_AirDate_Min = airDateMin;                      contract.Stat_AirDate_Max = airDateMax;                      contract.Stat_EndDate = groupEndDate;                      contract.Stat_SeriesCreatedDate = seriesCreatedDate;                      contract.Stat_AniDBRating = animeGroup.AniDBRating;                      contract.Stat_AudioLanguages = audioLanguages;                      contract.Stat_SubtitleLanguages = subtitleLanguages;                      contract.LatestEpisodeAirDate = animeGroup.LatestEpisodeAirDate;                          votesByGroup.TryGetValue(animeGroup.AnimeGroupID' out GroupVotes votes);                      contract.Stat_UserVoteOverall = votes?.AllVotes;                      contract.Stat_UserVotePermanent = votes?.PermanentVotes;                      contract.Stat_UserVoteTemporary = votes?.TemporaryVotes;                  }                    grpFilterCondTypesByGroup[animeGroup.AnimeGroupID] =                      GetConditionTypesChanged(animeGroup.Contract' contract);                  animeGroup.Contract = contract;              }
Magic Number,Shoko.Server.Models,EpisodeList,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeSeries.cs,Add,The following statement contains a magic number: if ((AnimeType == AnimeType.OVA) || (AnimeType == AnimeType.Movie))                  {                      AniDB_Episode aniEp = ep.AniDB_Episode;                      string ename = aniEp.EnglishName.ToLower();                      Match m = partmatch.Match(ename);                      StatEpisodes.StatEpisode s = new StatEpisodes.StatEpisode                      {                          Available = available                      };                      if (m.Success)                      {                          int.TryParse(m.Groups[1].Value' out int part_number);                          int.TryParse(m.Groups[2].Value' out int part_count);                          string rname = partmatch.Replace(ename' string.Empty);                          rname = remsymbols.Replace(rname' string.Empty);                          rname = remmultispace.Replace(rname' " ");                              s.EpisodeType = StatEpisodes.StatEpisode.EpType.Part;                          s.PartCount = part_count;                          s.Match = rname.Trim();                          if ((s.Match == "complete movie") || (s.Match == "movie") || (s.Match == "ova"))                              s.Match = string.Empty;                      }                      else                      {                          if ((ename == "complete movie") || (ename == "movie") || (ename == "ova"))                          {                              s.Match = string.Empty;                          }                          else                          {                              string rname = partmatch.Replace(aniEp.EnglishName.ToLower()' string.Empty);                              rname = remsymbols.Replace(rname' string.Empty);                              rname = remmultispace.Replace(rname' " ");                              s.Match = rname.Trim();                          }                          s.EpisodeType = StatEpisodes.StatEpisode.EpType.Complete;                          s.PartCount = 0;                      }                      StatEpisodes fnd = null;                      foreach (StatEpisodes k in this)                      {                          foreach (StatEpisodes.StatEpisode ss in k)                              if (ss.Match == s.Match)                              {                                  fnd = k;                                  break;                              }                          if (fnd != null)                              break;                      }                      if (fnd == null)                      {                          StatEpisodes eps = new StatEpisodes();                          eps.Add(s);                          Add(eps);                      }                      else                          fnd.Add(s);                  }                  else                  {                      StatEpisodes eps = new StatEpisodes();                      StatEpisodes.StatEpisode es = new StatEpisodes.StatEpisode                      {                          Match = string.Empty'                          EpisodeType = StatEpisodes.StatEpisode.EpType.Complete'                          PartCount = 0'                          Available = available                      };                      eps.Add(es);                      Add(eps);                  }
Magic Number,Shoko.Server.Models,SVR_GroupFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_GroupFilter.cs,EvaluateConditions,The following statement contains a magic number: switch (gfc.GetConditionTypeEnum())              {                  case GroupFilterConditionType.Favourite:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include && contractGroup.IsFave == 0)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude && contractGroup.IsFave == 1)                          return false;                      break;                    case GroupFilterConditionType.MissingEpisodes:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include &&                          (contractGroup.MissingEpisodeCount > 0 || contractGroup.MissingEpisodeCountGroups > 0) ==                          false) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude &&                          (contractGroup.MissingEpisodeCount > 0 || contractGroup.MissingEpisodeCountGroups > 0)) return false;                      break;                    case GroupFilterConditionType.MissingEpisodesCollecting:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include &&                          contractGroup.MissingEpisodeCountGroups > 0 == false) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude &&                          contractGroup.MissingEpisodeCountGroups > 0) return false;                      break;                  case GroupFilterConditionType.Tag:                      List<string> tags =                          gfc.ConditionParameter.Trim()                              .Split(new[] {'''}' StringSplitOptions.RemoveEmptyEntries)                              .Select(a => a.ToLowerInvariant().Trim())                              .Where(a => !string.IsNullOrWhiteSpace(a))                              .ToList();                      bool tagsFound =                          tags.Any(                              a => contractGroup.Stat_AllTags.Contains(a' StringComparer.InvariantCultureIgnoreCase));                      if ((gfc.GetConditionOperatorEnum() == GroupFilterOperator.In ||                           gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include) && !tagsFound) return false;                      if ((gfc.GetConditionOperatorEnum() == GroupFilterOperator.NotIn ||                           gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude) && tagsFound) return false;                      break;                  case GroupFilterConditionType.Year:                      HashSet<int> years = new HashSet<int>();                      string[] parameterStrings = gfc.ConditionParameter.Trim()                          .Split(new[] {'''}' StringSplitOptions.RemoveEmptyEntries);                      foreach (string yearString in parameterStrings)                      {                          if (int.TryParse(yearString.Trim()' out int year))                              years.Add(year);                      }                      if (years.Count <= 0) return false;                      if ((gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include || gfc.GetConditionOperatorEnum() == GroupFilterOperator.In) &&                          !contractGroup.Stat_AllYears.FindInEnumerable(years))                          return false;                      if ((gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude || gfc.GetConditionOperatorEnum() == GroupFilterOperator.NotIn) &&                          contractGroup.Stat_AllYears.FindInEnumerable(years))                          return false;                      break;                  case GroupFilterConditionType.Season:                      string[] paramStrings = gfc.ConditionParameter.Trim().Split(''');                        switch (gfc.GetConditionOperatorEnum())                      {                          case GroupFilterOperator.Include:                          case GroupFilterOperator.In:                              return paramStrings.FindInEnumerable(contractGroup.Stat_AllSeasons);                          case GroupFilterOperator.Exclude:                          case GroupFilterOperator.NotIn:                              return !paramStrings.FindInEnumerable(contractGroup.Stat_AllSeasons);                      }                      break;                  case GroupFilterConditionType.HasWatchedEpisodes:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include &&                          contractGroup.WatchedEpisodeCount > 0 == false)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude &&                          contractGroup.WatchedEpisodeCount > 0)                          return false;                      break;                    case GroupFilterConditionType.HasUnwatchedEpisodes:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include &&                          contractGroup.UnwatchedEpisodeCount > 0 == false)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude &&                          contractGroup.UnwatchedEpisodeCount > 0)                          return false;                      break;                    case GroupFilterConditionType.AssignedTvDBInfo:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include &&                          contractGroup.Stat_HasTvDBLink == false)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude &&                          contractGroup.Stat_HasTvDBLink)                          return false;                      break;                    case GroupFilterConditionType.AssignedMALInfo:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include &&                          contractGroup.Stat_HasMALLink == false)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude &&                          contractGroup.Stat_HasMALLink)                          return false;                      break;                    case GroupFilterConditionType.AssignedMovieDBInfo:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include &&                          contractGroup.Stat_HasMovieDBLink == false)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude &&                          contractGroup.Stat_HasMovieDBLink)                          return false;                      break;                    case GroupFilterConditionType.AssignedTvDBOrMovieDBInfo:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include &&                          !contractGroup.Stat_HasMovieDBOrTvDBLink)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude &&                          contractGroup.Stat_HasMovieDBOrTvDBLink)                          return false;                      break;                    case GroupFilterConditionType.CompletedSeries:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include &&                          contractGroup.Stat_IsComplete == false)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude &&                          contractGroup.Stat_IsComplete)                          return false;                      break;                    case GroupFilterConditionType.FinishedAiring:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include &&                          contractGroup.Stat_HasFinishedAiring == false)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude &&                          contractGroup.Stat_HasFinishedAiring)                          return false;                      break;                    case GroupFilterConditionType.UserVoted:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include &&                          contractGroup.Stat_UserVotePermanent.HasValue == false) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude &&                          contractGroup.Stat_UserVotePermanent.HasValue) return false;                      break;                    case GroupFilterConditionType.UserVotedAny:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include &&                          contractGroup.Stat_UserVoteOverall.HasValue == false) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude &&                          contractGroup.Stat_UserVoteOverall.HasValue) return false;                      break;                    case GroupFilterConditionType.AirDate:                      DateTime filterDate;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          int.TryParse(gfc.ConditionParameter' out int days);                          filterDate = DateTime.Today.AddDays(0 - days);                      }                      else                          filterDate = GetDateFromString(gfc.ConditionParameter);                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.GreaterThan ||                          gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          if (!contractGroup.Stat_AirDate_Min.HasValue || !contractGroup.Stat_AirDate_Max.HasValue)                              return false;                          if (contractGroup.Stat_AirDate_Max.Value < filterDate) return false;                      }                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LessThan)                      {                          if (!contractGroup.Stat_AirDate_Min.HasValue || !contractGroup.Stat_AirDate_Max.HasValue)                              return false;                          if (contractGroup.Stat_AirDate_Min.Value > filterDate) return false;                      }                      break;                  case GroupFilterConditionType.LatestEpisodeAirDate:                      DateTime filterDateEpisodeLastAired;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          int.TryParse(gfc.ConditionParameter' out int days);                          filterDateEpisodeLastAired = DateTime.Today.AddDays(0 - days);                      }                      else                          filterDateEpisodeLastAired = GetDateFromString(gfc.ConditionParameter);                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.GreaterThan ||                          gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          if (!contractGroup.LatestEpisodeAirDate.HasValue) return false;                          if (contractGroup.LatestEpisodeAirDate.Value < filterDateEpisodeLastAired) return false;                      }                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LessThan)                      {                          if (!contractGroup.LatestEpisodeAirDate.HasValue) return false;                          if (contractGroup.LatestEpisodeAirDate.Value > filterDateEpisodeLastAired) return false;                      }                      break;                  case GroupFilterConditionType.SeriesCreatedDate:                      DateTime filterDateSeries;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          int.TryParse(gfc.ConditionParameter' out int days);                          filterDateSeries = DateTime.Today.AddDays(0 - days);                      }                      else                          filterDateSeries = GetDateFromString(gfc.ConditionParameter);                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.GreaterThan ||                          gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          if (!contractGroup.Stat_SeriesCreatedDate.HasValue) return false;                          if (contractGroup.Stat_SeriesCreatedDate.Value < filterDateSeries) return false;                      }                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LessThan)                      {                          if (!contractGroup.Stat_SeriesCreatedDate.HasValue) return false;                          if (contractGroup.Stat_SeriesCreatedDate.Value > filterDateSeries) return false;                      }                      break;                    case GroupFilterConditionType.EpisodeWatchedDate:                      DateTime filterDateEpsiodeWatched;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          int.TryParse(gfc.ConditionParameter' out int days);                          filterDateEpsiodeWatched = DateTime.Today.AddDays(0 - days);                      }                      else                          filterDateEpsiodeWatched = GetDateFromString(gfc.ConditionParameter);                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.GreaterThan ||                          gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          if (!contractGroup.WatchedDate.HasValue) return false;                          if (contractGroup.WatchedDate.Value < filterDateEpsiodeWatched) return false;                      }                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LessThan)                      {                          if (contractGroup?.WatchedDate == null) return false;                          if (contractGroup.WatchedDate.Value > filterDateEpsiodeWatched) return false;                      }                      break;                    case GroupFilterConditionType.EpisodeAddedDate:                      DateTime filterDateEpisodeAdded;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          int.TryParse(gfc.ConditionParameter' out int days);                          filterDateEpisodeAdded = DateTime.Today.AddDays(0 - days);                      }                      else                          filterDateEpisodeAdded = GetDateFromString(gfc.ConditionParameter);                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.GreaterThan ||                          gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          if (!contractGroup.EpisodeAddedDate.HasValue) return false;                          if (contractGroup.EpisodeAddedDate.Value < filterDateEpisodeAdded) return false;                      }                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LessThan)                      {                          if (!contractGroup.EpisodeAddedDate.HasValue) return false;                          if (contractGroup.EpisodeAddedDate.Value > filterDateEpisodeAdded) return false;                      }                      break;                    case GroupFilterConditionType.EpisodeCount:                      int.TryParse(gfc.ConditionParameter' out var epCount);                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.GreaterThan &&                          contractGroup.Stat_EpisodeCount < epCount)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LessThan &&                          contractGroup.Stat_EpisodeCount > epCount)                          return false;                      break;                    case GroupFilterConditionType.AniDBRating:                      decimal.TryParse(gfc.ConditionParameter' style' culture' out var dRating);                      decimal thisRating = contractGroup.Stat_AniDBRating / 100;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.GreaterThan && thisRating < dRating)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LessThan && thisRating > dRating)                          return false;                      break;                    case GroupFilterConditionType.UserRating:                      if (!contractGroup.Stat_UserVoteOverall.HasValue) return false;                      decimal.TryParse(gfc.ConditionParameter' style' culture' out var dUserRating);                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.GreaterThan &&                          contractGroup.Stat_UserVoteOverall.Value < dUserRating) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LessThan &&                          contractGroup.Stat_UserVoteOverall.Value > dUserRating) return false;                      break;                    case GroupFilterConditionType.CustomTags:                      List<string> ctags =                          gfc.ConditionParameter.Trim()                              .Split(new[] {'''}' StringSplitOptions.RemoveEmptyEntries)                              .Select(a => a.ToLowerInvariant().Trim())                              .ToList();                      bool foundTag = ctags.FindInEnumerable(contractGroup.Stat_AllCustomTags);                      if ((gfc.GetConditionOperatorEnum() == GroupFilterOperator.In) && !foundTag) return false;                      if ((gfc.GetConditionOperatorEnum() == GroupFilterOperator.NotIn) && foundTag) return false;                      break;                    case GroupFilterConditionType.AnimeType:                      List<string> ctypes =                          gfc.ConditionParameter                              .Split(new[] {'''}' StringSplitOptions.RemoveEmptyEntries)                              .Select(a => ((int) Commons.Extensions.Models.RawToType(a)).ToString())                              .ToList();                      bool foundAnimeType = ctypes.FindInEnumerable(contractGroup.Stat_AnimeTypes);                      if ((gfc.GetConditionOperatorEnum() == GroupFilterOperator.In) && !foundAnimeType) return false;                      if ((gfc.GetConditionOperatorEnum() == GroupFilterOperator.NotIn) && foundAnimeType)                          return false;                      break;                    case GroupFilterConditionType.VideoQuality:                      List<string> vqs =                          gfc.ConditionParameter                              .Split(new[] {'''}' StringSplitOptions.RemoveEmptyEntries)                              .Select(a => a.ToLowerInvariant().Trim())                              .ToList();                      bool foundVid = vqs.FindInEnumerable(contractGroup.Stat_AllVideoQuality);                      bool foundVidAllEps = vqs.FindInEnumerable(contractGroup.Stat_AllVideoQuality_Episodes);                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.In && !foundVid) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.NotIn && foundVid) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.InAllEpisodes && !foundVidAllEps)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.NotInAllEpisodes && foundVidAllEps)                          return false;                      break;                    case GroupFilterConditionType.AudioLanguage:                      List<string> als =                          gfc.ConditionParameter.Trim()                              .Split(new[] {'''}' StringSplitOptions.RemoveEmptyEntries)                              .Select(a => a.ToLowerInvariant().Trim())                              .ToList();                      bool foundLang = als.FindInEnumerable(contractGroup.Stat_AudioLanguages);                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.In && !foundLang) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.NotIn && foundLang) return false;                      break;                    case GroupFilterConditionType.SubtitleLanguage:                      List<string> ass =                          gfc.ConditionParameter                              .Split(new[] {'''}' StringSplitOptions.RemoveEmptyEntries)                              .Select(a => a.ToLowerInvariant().Trim())                              .ToList();                      bool foundSub = ass.FindInEnumerable(contractGroup.Stat_SubtitleLanguages);                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.In && !foundSub) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.NotIn && foundSub) return false;                      break;              }
Magic Number,Shoko.Server.Models,SVR_GroupFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_GroupFilter.cs,EvaluateConditions,The following statement contains a magic number: switch (gfc.GetConditionTypeEnum())              {                  case GroupFilterConditionType.MissingEpisodes:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include &&                          (contractSerie.MissingEpisodeCount > 0 || contractSerie.MissingEpisodeCountGroups > 0) ==                          false) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude &&                          (contractSerie.MissingEpisodeCount > 0 || contractSerie.MissingEpisodeCountGroups > 0))                          return false;                      break;                    case GroupFilterConditionType.MissingEpisodesCollecting:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include &&                          contractSerie.MissingEpisodeCountGroups > 0 == false) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude &&                          contractSerie.MissingEpisodeCountGroups > 0) return false;                      break;                  case GroupFilterConditionType.Tag:                      List<string> tags =                          gfc.ConditionParameter.Trim()                              .Split(new[] {'''}' StringSplitOptions.RemoveEmptyEntries)                              .Select(a => a.ToLowerInvariant().Trim())                              .Where(a => !string.IsNullOrWhiteSpace(a))                              .ToList();                      bool tagsFound =                          tags.Any(a => contractSerie.AniDBAnime.AniDBAnime.GetAllTags()                              .Contains(a'                                  StringComparer.InvariantCultureIgnoreCase));                      if ((gfc.GetConditionOperatorEnum() == GroupFilterOperator.In ||                           gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include) && !tagsFound) return false;                      if ((gfc.GetConditionOperatorEnum() == GroupFilterOperator.NotIn ||                           gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude) && tagsFound) return false;                      break;                  case GroupFilterConditionType.Year:                      int BeginYear = contractSerie.AniDBAnime.AniDBAnime.BeginYear;                      int EndYear = contractSerie.AniDBAnime.AniDBAnime.EndYear;                      if (BeginYear == 0) return false;                      if (EndYear == 0) EndYear = int.MaxValue;                      HashSet<int> years = new HashSet<int>();                      string[] parameterStrings = gfc.ConditionParameter.Trim().Split(''');                      foreach (string yearString in parameterStrings)                      {                          if (int.TryParse(yearString.Trim()' out int paramYear))                              years.Add(paramYear);                      }                        if (years.Count <= 0) return false;                      switch (gfc.GetConditionOperatorEnum())                      {                          case GroupFilterOperator.Include:                          case GroupFilterOperator.In:                              if (years.Any(year => year >= BeginYear && year <= EndYear))                                  return true;                              return false;                          case GroupFilterOperator.Exclude:                          case GroupFilterOperator.NotIn:                              if (years.Any(year => year >= BeginYear && year <= EndYear))                                  return false;                              return true;                      }                        break;                  case GroupFilterConditionType.Season:                      Tuple<AnimeSeason' int>[] paramStrings = gfc.ConditionParameter.Trim().Split(''').Select(a =>                      {                          var b = a.Trim().Split(' ');                          if (!Enum.TryParse(b[0]' out AnimeSeason season)) return null;                          if (!int.TryParse(b[1]' out int year)) return null;                          return Tuple.Create(season' year);                      }).Where(a => a != null).ToArray();                        switch (gfc.GetConditionOperatorEnum())                      {                          case GroupFilterOperator.Include:                          case GroupFilterOperator.In:                              return paramStrings.Any(a => contractSerie?.AniDBAnime?.IsInSeason(a.Item1' a.Item2) ?? false);                          case GroupFilterOperator.Exclude:                          case GroupFilterOperator.NotIn:                              return !paramStrings.Any(a => contractSerie?.AniDBAnime?.IsInSeason(a.Item1' a.Item2) ?? false);                      }                        break;                  case GroupFilterConditionType.HasWatchedEpisodes:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include &&                          contractSerie.WatchedEpisodeCount > 0 == false)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude &&                          contractSerie.WatchedEpisodeCount > 0)                          return false;                      break;                    case GroupFilterConditionType.HasUnwatchedEpisodes:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include &&                          contractSerie.UnwatchedEpisodeCount > 0 == false)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude &&                          contractSerie.UnwatchedEpisodeCount > 0)                          return false;                      break;                    case GroupFilterConditionType.AssignedTvDBInfo:                      bool tvDBInfoMissing = contractSerie.CrossRefAniDBTvDBV2 == null ||                                             contractSerie.CrossRefAniDBTvDBV2.Count == 0;                      bool supposedToHaveTvDBLink = contractSerie.AniDBAnime.AniDBAnime.AnimeType !=                                                    (int) AnimeType.Movie &&                                                    !(contractSerie.AniDBAnime.AniDBAnime.Restricted > 0);                      tvDBInfoMissing &= supposedToHaveTvDBLink;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include && tvDBInfoMissing)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude && !tvDBInfoMissing)                          return false;                      break;                    case GroupFilterConditionType.AssignedMALInfo:                      bool malMissing = contractSerie.CrossRefAniDBMAL == null ||                                        contractSerie.CrossRefAniDBMAL.Count == 0;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include && malMissing) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude && !malMissing) return false;                      break;                    case GroupFilterConditionType.AssignedMovieDBInfo:                      bool movieMissing = contractSerie.CrossRefAniDBMovieDB == null;                      bool supposedToHaveMovieLink = contractSerie.AniDBAnime.AniDBAnime.AnimeType ==                                                     (int) AnimeType.Movie &&                                                     !(contractSerie.AniDBAnime.AniDBAnime.Restricted > 0);                      movieMissing &= supposedToHaveMovieLink;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include && movieMissing) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude && !movieMissing)                          return false;                      break;                    case GroupFilterConditionType.AssignedTvDBOrMovieDBInfo:                      bool restricted = (contractSerie.AniDBAnime.AniDBAnime.Restricted > 0);                      bool movieLinkMissing = contractSerie.CrossRefAniDBMovieDB == null && !restricted;                      bool tvlinkMissing = (contractSerie.CrossRefAniDBTvDBV2 == null ||                                            contractSerie.CrossRefAniDBTvDBV2.Count == 0) && !restricted;                      bool bothMissing = movieLinkMissing && tvlinkMissing;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include && bothMissing) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude && !bothMissing) return false;                      break;                    case GroupFilterConditionType.CompletedSeries:                      bool completed = contractSerie.AniDBAnime.AniDBAnime.EndDate.HasValue &&                                       contractSerie.AniDBAnime.AniDBAnime.EndDate.Value < DateTime.Now &&                                       !(contractSerie.MissingEpisodeCount > 0 ||                                         contractSerie.MissingEpisodeCountGroups > 0);                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include && !completed) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude && completed) return false;                      break;                    case GroupFilterConditionType.FinishedAiring:                      bool finished = contractSerie.AniDBAnime.AniDBAnime.EndDate.HasValue &&                                      contractSerie.AniDBAnime.AniDBAnime.EndDate.Value < DateTime.Now;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include && !finished) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude && finished) return false;                      break;                    case GroupFilterConditionType.UserVoted:                      bool voted = (contractSerie.AniDBAnime.UserVote != null) &&                                   (contractSerie.AniDBAnime.UserVote.VoteType == (int) AniDBVoteType.Anime);                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include && !voted) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude && voted) return false;                      break;                    case GroupFilterConditionType.UserVotedAny:                      bool votedany = contractSerie.AniDBAnime.UserVote != null;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include && !votedany) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude && votedany) return false;                      break;                    case GroupFilterConditionType.AirDate:                      DateTime filterDate;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          int.TryParse(gfc.ConditionParameter' out int days);                          filterDate = DateTime.Today.AddDays(0 - days);                      }                      else                          filterDate = GroupFilterHelper.GetDateFromString(gfc.ConditionParameter);                        if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.GreaterThan ||                          gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                          if (!contractSerie.AniDBAnime.AniDBAnime.AirDate.HasValue ||                              contractSerie.AniDBAnime.AniDBAnime.AirDate.Value < filterDate)                              return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LessThan)                          if (!contractSerie.AniDBAnime.AniDBAnime.AirDate.HasValue ||                              contractSerie.AniDBAnime.AniDBAnime.AirDate.Value > filterDate)                              return false;                      break;                  case GroupFilterConditionType.LatestEpisodeAirDate:                      DateTime filterDateEpisodeLastAired;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          int.TryParse(gfc.ConditionParameter' out int days);                          filterDateEpisodeLastAired = DateTime.Today.AddDays(0 - days);                      }                      else                          filterDateEpisodeLastAired = GetDateFromString(gfc.ConditionParameter);                        if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.GreaterThan ||                          gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          if (!contractSerie.LatestEpisodeAirDate.HasValue) return false;                          if (contractSerie.LatestEpisodeAirDate.Value < filterDateEpisodeLastAired) return false;                      }                        if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LessThan)                      {                          if (!contractSerie.LatestEpisodeAirDate.HasValue) return false;                          if (contractSerie.LatestEpisodeAirDate.Value > filterDateEpisodeLastAired) return false;                      }                        break;                  case GroupFilterConditionType.SeriesCreatedDate:                      DateTime filterDateSeries;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          int.TryParse(gfc.ConditionParameter' out int days);                          filterDateSeries = DateTime.Today.AddDays(0 - days);                      }                      else                          filterDateSeries = GetDateFromString(gfc.ConditionParameter);                        if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.GreaterThan ||                          gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          if (contractSerie.DateTimeCreated < filterDateSeries) return false;                      }                        if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LessThan)                      {                          if (contractSerie.DateTimeCreated > filterDateSeries) return false;                      }                        break;                    case GroupFilterConditionType.EpisodeWatchedDate:                      DateTime filterDateEpsiodeWatched;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          int.TryParse(gfc.ConditionParameter' out int days);                          filterDateEpsiodeWatched = DateTime.Today.AddDays(0 - days);                      }                      else                          filterDateEpsiodeWatched = GetDateFromString(gfc.ConditionParameter);                        if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.GreaterThan ||                          gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          if (!contractSerie.WatchedDate.HasValue) return false;                          if (contractSerie.WatchedDate.Value < filterDateEpsiodeWatched) return false;                      }                        if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LessThan)                      {                          if (contractSerie?.WatchedDate == null) return false;                          if (contractSerie.WatchedDate.Value > filterDateEpsiodeWatched) return false;                      }                        break;                    case GroupFilterConditionType.EpisodeAddedDate:                      DateTime filterDateEpisodeAdded;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          int.TryParse(gfc.ConditionParameter' out int days);                          filterDateEpisodeAdded = DateTime.Today.AddDays(0 - days);                      }                      else                          filterDateEpisodeAdded = GetDateFromString(gfc.ConditionParameter);                        if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.GreaterThan ||                          gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          if (!contractSerie.EpisodeAddedDate.HasValue) return false;                          if (contractSerie.EpisodeAddedDate.Value < filterDateEpisodeAdded) return false;                      }                        if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LessThan)                      {                          if (!contractSerie.EpisodeAddedDate.HasValue) return false;                          if (contractSerie.EpisodeAddedDate.Value > filterDateEpisodeAdded) return false;                      }                        break;                    case GroupFilterConditionType.EpisodeCount:                      int.TryParse(gfc.ConditionParameter' out var epCount);                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.GreaterThan &&                          contractSerie.AniDBAnime.AniDBAnime.EpisodeCount < epCount) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LessThan &&                          contractSerie.AniDBAnime.AniDBAnime.EpisodeCount > epCount) return false;                      break;                    case GroupFilterConditionType.AniDBRating:                      decimal.TryParse(gfc.ConditionParameter' style' culture' out var dRating);                      int totalVotes = contractSerie.AniDBAnime.AniDBAnime.VoteCount +                                       contractSerie.AniDBAnime.AniDBAnime.TempVoteCount;                      decimal totalRating = contractSerie.AniDBAnime.AniDBAnime.Rating *                                            contractSerie.AniDBAnime.AniDBAnime.VoteCount +                                            contractSerie.AniDBAnime.AniDBAnime.TempRating *                                            contractSerie.AniDBAnime.AniDBAnime.TempVoteCount;                      decimal thisRating = totalVotes == 0 ? 0 : totalRating / totalVotes / 100;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.GreaterThan && thisRating < dRating)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LessThan && thisRating > dRating)                          return false;                      break;                    case GroupFilterConditionType.UserRating:                      decimal.TryParse(gfc.ConditionParameter' style' culture' out var dUserRating);                      decimal val = contractSerie.AniDBAnime.UserVote?.VoteValue ?? 0;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.GreaterThan && val < dUserRating)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LessThan && val > dUserRating)                          return false;                      break;                      case GroupFilterConditionType.CustomTags:                      List<string> ctags =                          gfc.ConditionParameter.Trim()                              .Split(new[] {'''}' StringSplitOptions.RemoveEmptyEntries)                              .Select(a => a.ToLowerInvariant().Trim())                              .ToList();                      bool foundTag =                          ctags.FindInEnumerable(contractSerie.AniDBAnime.CustomTags.Select(a => a.TagName));                      if ((gfc.GetConditionOperatorEnum() == GroupFilterOperator.In) && !foundTag) return false;                      if ((gfc.GetConditionOperatorEnum() == GroupFilterOperator.NotIn) && foundTag) return false;                      break;                    case GroupFilterConditionType.AnimeType:                      List<string> ctypes =                          gfc.ConditionParameter.Trim()                              .Split(new[] {'''}' StringSplitOptions.RemoveEmptyEntries)                              .Select(                                  a => ((int) Commons.Extensions.Models.RawToType(a.ToLowerInvariant())).ToString())                              .ToList();                      bool foundAnimeType = ctypes.Contains(contractSerie.AniDBAnime.AniDBAnime.AnimeType.ToString());                      if ((gfc.GetConditionOperatorEnum() == GroupFilterOperator.In) && !foundAnimeType) return false;                      if ((gfc.GetConditionOperatorEnum() == GroupFilterOperator.NotIn) && foundAnimeType)                          return false;                      break;                    case GroupFilterConditionType.VideoQuality:                      List<string> vqs =                          gfc.ConditionParameter.Trim()                              .Split(new[] {'''}' StringSplitOptions.RemoveEmptyEntries)                              .Select(a => a.ToLowerInvariant().Trim())                              .ToList();                      bool foundVid = vqs.FindInEnumerable(contractSerie.AniDBAnime.Stat_AllVideoQuality);                      bool foundVidAllEps =                          vqs.FindInEnumerable(contractSerie.AniDBAnime.Stat_AllVideoQuality_Episodes);                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.In && !foundVid) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.NotIn && foundVid) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.InAllEpisodes && !foundVidAllEps)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.NotInAllEpisodes && foundVidAllEps)                          return false;                      break;                    case GroupFilterConditionType.AudioLanguage:                      List<string> als =                          gfc.ConditionParameter.Trim()                              .Split(new[] {'''}' StringSplitOptions.RemoveEmptyEntries)                              .Select(a => a.ToLowerInvariant().Trim())                              .ToList();                      bool foundLang = als.FindInEnumerable(contractSerie.AniDBAnime.Stat_AudioLanguages);                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.In && !foundLang) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.NotIn && foundLang) return false;                      break;                    case GroupFilterConditionType.SubtitleLanguage:                      List<string> ass =                          gfc.ConditionParameter.Trim()                              .Split(new[] {'''}' StringSplitOptions.RemoveEmptyEntries)                              .Select(a => a.ToLowerInvariant().Trim())                              .ToList();                      bool foundSub = ass.FindInEnumerable(contractSerie.AniDBAnime.Stat_AudioLanguages);                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.In && !foundSub) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.NotIn && foundSub) return false;                      break;              }
Magic Number,Shoko.Server.Models,SVR_GroupFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_GroupFilter.cs,GetDateFromString,The following statement contains a magic number: try              {                  int year = int.Parse(sDate.Substring(0' 4));                  int month = int.Parse(sDate.Substring(4' 2));                  int day = int.Parse(sDate.Substring(6' 2));                    return new DateTime(year' month' day);              }              catch              {                  return DateTime.Today;              }
Magic Number,Shoko.Server.Models,SVR_GroupFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_GroupFilter.cs,GetDateFromString,The following statement contains a magic number: try              {                  int year = int.Parse(sDate.Substring(0' 4));                  int month = int.Parse(sDate.Substring(4' 2));                  int day = int.Parse(sDate.Substring(6' 2));                    return new DateTime(year' month' day);              }              catch              {                  return DateTime.Today;              }
Magic Number,Shoko.Server.Models,SVR_GroupFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_GroupFilter.cs,GetDateFromString,The following statement contains a magic number: try              {                  int year = int.Parse(sDate.Substring(0' 4));                  int month = int.Parse(sDate.Substring(4' 2));                  int day = int.Parse(sDate.Substring(6' 2));                    return new DateTime(year' month' day);              }              catch              {                  return DateTime.Today;              }
Magic Number,Shoko.Server.Models,SVR_GroupFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_GroupFilter.cs,GetDateFromString,The following statement contains a magic number: try              {                  int year = int.Parse(sDate.Substring(0' 4));                  int month = int.Parse(sDate.Substring(4' 2));                  int day = int.Parse(sDate.Substring(6' 2));                    return new DateTime(year' month' day);              }              catch              {                  return DateTime.Today;              }
Magic Number,Shoko.Server.Models,SVR_GroupFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_GroupFilter.cs,GetDateFromString,The following statement contains a magic number: try              {                  int year = int.Parse(sDate.Substring(0' 4));                  int month = int.Parse(sDate.Substring(4' 2));                  int day = int.Parse(sDate.Substring(6' 2));                    return new DateTime(year' month' day);              }              catch              {                  return DateTime.Today;              }
Magic Number,Shoko.Server.Models,SVR_VideoLocal,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_VideoLocal.cs,ToggleWatchedStatus,The following statement contains a magic number: if (watched)              {                  // find the total watched percentage                  // eg one file can have a % = 100                  // or if 2 files make up one episodes they will each have a % = 50                    foreach (CrossRef_File_Episode xref in xrefs)                  {                      // get the episodes for this file' may be more than one (One Piece x Toriko)                      SVR_AnimeEpisode ep = RepoFactory.AnimeEpisode.GetByAniDBEpisodeID(xref.EpisodeID);                      // get all the files for this episode                      int epPercentWatched = 0;                      foreach (CrossRef_File_Episode filexref in ep.FileCrossRefs)                      {                          VideoLocal_User vidUser = filexref.GetVideoLocalUserRecord(userID);                          if (vidUser?.WatchedDate != null)                              epPercentWatched += filexref.Percentage;                            if (epPercentWatched > 95) break;                      }                        if (epPercentWatched > 95)                      {                          ser = ep.GetAnimeSeries();                          if (!toUpdateSeries.ContainsKey(ser.AnimeSeriesID))                              toUpdateSeries.Add(ser.AnimeSeriesID' ser);                          if (user.IsAniDBUser == 0)                              ep.SaveWatchedStatus(true' userID' watchedDate' updateWatchedDate);                          else                              foreach (SVR_JMMUser juser in aniDBUsers)                                  if (juser.IsAniDBUser == 1)                                      ep.SaveWatchedStatus(true' juser.JMMUserID' watchedDate' updateWatchedDate);                            if (syncTrakt && ServerSettings.Trakt_IsEnabled &&                              !string.IsNullOrEmpty(ServerSettings.Trakt_AuthToken))                          {                              CommandRequest_TraktHistoryEpisode cmdSyncTrakt =                                  new CommandRequest_TraktHistoryEpisode(ep.AnimeEpisodeID' TraktSyncAction.Add);                              cmdSyncTrakt.Save();                          }                            if (!string.IsNullOrEmpty(ServerSettings.MAL_Username) &&                              !string.IsNullOrEmpty(ServerSettings.MAL_Password))                          {                              CommandRequest_MALUpdatedWatchedStatus cmdMAL =                                  new CommandRequest_MALUpdatedWatchedStatus(ser.AniDB_ID);                              cmdMAL.Save();                          }                      }                  }              }              else              {                  // if setting a file to unwatched only set the episode unwatched' if ALL the files are unwatched                  foreach (CrossRef_File_Episode xrefEp in xrefs)                  {                      // get the episodes for this file' may be more than one (One Piece x Toriko)                      SVR_AnimeEpisode ep = RepoFactory.AnimeEpisode.GetByAniDBEpisodeID(xrefEp.EpisodeID);                      ser = ep.GetAnimeSeries();                      if (!toUpdateSeries.ContainsKey(ser.AnimeSeriesID))                          toUpdateSeries.Add(ser.AnimeSeriesID' ser);                      // get all the files for this episode                      int epPercentWatched = 0;                      foreach (CrossRef_File_Episode filexref in ep.FileCrossRefs)                      {                          VideoLocal_User vidUser = filexref.GetVideoLocalUserRecord(userID);                          if (vidUser?.WatchedDate != null)                              epPercentWatched += filexref.Percentage;                            if (epPercentWatched > 95) break;                      }                        if (epPercentWatched < 95)                      {                          if (user.IsAniDBUser == 0)                              ep.SaveWatchedStatus(false' userID' watchedDate' true);                          else                              foreach (SVR_JMMUser juser in aniDBUsers)                                  if (juser.IsAniDBUser == 1)                                      ep.SaveWatchedStatus(false' juser.JMMUserID' watchedDate' true);                            if (syncTrakt && ServerSettings.Trakt_IsEnabled &&                              !string.IsNullOrEmpty(ServerSettings.Trakt_AuthToken))                          {                              CommandRequest_TraktHistoryEpisode cmdSyncTrakt =                                  new CommandRequest_TraktHistoryEpisode(ep.AnimeEpisodeID' TraktSyncAction.Remove);                              cmdSyncTrakt.Save();                          }                      }                  }                  if (!string.IsNullOrEmpty(ServerSettings.MAL_Username) &&                      !string.IsNullOrEmpty(ServerSettings.MAL_Password))                  {                      CommandRequest_MALUpdatedWatchedStatus cmdMAL =                          new CommandRequest_MALUpdatedWatchedStatus(ser.AniDB_ID);                      cmdMAL.Save();                  }              }
Magic Number,Shoko.Server.Models,SVR_VideoLocal,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_VideoLocal.cs,ToggleWatchedStatus,The following statement contains a magic number: if (watched)              {                  // find the total watched percentage                  // eg one file can have a % = 100                  // or if 2 files make up one episodes they will each have a % = 50                    foreach (CrossRef_File_Episode xref in xrefs)                  {                      // get the episodes for this file' may be more than one (One Piece x Toriko)                      SVR_AnimeEpisode ep = RepoFactory.AnimeEpisode.GetByAniDBEpisodeID(xref.EpisodeID);                      // get all the files for this episode                      int epPercentWatched = 0;                      foreach (CrossRef_File_Episode filexref in ep.FileCrossRefs)                      {                          VideoLocal_User vidUser = filexref.GetVideoLocalUserRecord(userID);                          if (vidUser?.WatchedDate != null)                              epPercentWatched += filexref.Percentage;                            if (epPercentWatched > 95) break;                      }                        if (epPercentWatched > 95)                      {                          ser = ep.GetAnimeSeries();                          if (!toUpdateSeries.ContainsKey(ser.AnimeSeriesID))                              toUpdateSeries.Add(ser.AnimeSeriesID' ser);                          if (user.IsAniDBUser == 0)                              ep.SaveWatchedStatus(true' userID' watchedDate' updateWatchedDate);                          else                              foreach (SVR_JMMUser juser in aniDBUsers)                                  if (juser.IsAniDBUser == 1)                                      ep.SaveWatchedStatus(true' juser.JMMUserID' watchedDate' updateWatchedDate);                            if (syncTrakt && ServerSettings.Trakt_IsEnabled &&                              !string.IsNullOrEmpty(ServerSettings.Trakt_AuthToken))                          {                              CommandRequest_TraktHistoryEpisode cmdSyncTrakt =                                  new CommandRequest_TraktHistoryEpisode(ep.AnimeEpisodeID' TraktSyncAction.Add);                              cmdSyncTrakt.Save();                          }                            if (!string.IsNullOrEmpty(ServerSettings.MAL_Username) &&                              !string.IsNullOrEmpty(ServerSettings.MAL_Password))                          {                              CommandRequest_MALUpdatedWatchedStatus cmdMAL =                                  new CommandRequest_MALUpdatedWatchedStatus(ser.AniDB_ID);                              cmdMAL.Save();                          }                      }                  }              }              else              {                  // if setting a file to unwatched only set the episode unwatched' if ALL the files are unwatched                  foreach (CrossRef_File_Episode xrefEp in xrefs)                  {                      // get the episodes for this file' may be more than one (One Piece x Toriko)                      SVR_AnimeEpisode ep = RepoFactory.AnimeEpisode.GetByAniDBEpisodeID(xrefEp.EpisodeID);                      ser = ep.GetAnimeSeries();                      if (!toUpdateSeries.ContainsKey(ser.AnimeSeriesID))                          toUpdateSeries.Add(ser.AnimeSeriesID' ser);                      // get all the files for this episode                      int epPercentWatched = 0;                      foreach (CrossRef_File_Episode filexref in ep.FileCrossRefs)                      {                          VideoLocal_User vidUser = filexref.GetVideoLocalUserRecord(userID);                          if (vidUser?.WatchedDate != null)                              epPercentWatched += filexref.Percentage;                            if (epPercentWatched > 95) break;                      }                        if (epPercentWatched < 95)                      {                          if (user.IsAniDBUser == 0)                              ep.SaveWatchedStatus(false' userID' watchedDate' true);                          else                              foreach (SVR_JMMUser juser in aniDBUsers)                                  if (juser.IsAniDBUser == 1)                                      ep.SaveWatchedStatus(false' juser.JMMUserID' watchedDate' true);                            if (syncTrakt && ServerSettings.Trakt_IsEnabled &&                              !string.IsNullOrEmpty(ServerSettings.Trakt_AuthToken))                          {                              CommandRequest_TraktHistoryEpisode cmdSyncTrakt =                                  new CommandRequest_TraktHistoryEpisode(ep.AnimeEpisodeID' TraktSyncAction.Remove);                              cmdSyncTrakt.Save();                          }                      }                  }                  if (!string.IsNullOrEmpty(ServerSettings.MAL_Username) &&                      !string.IsNullOrEmpty(ServerSettings.MAL_Password))                  {                      CommandRequest_MALUpdatedWatchedStatus cmdMAL =                          new CommandRequest_MALUpdatedWatchedStatus(ser.AniDB_ID);                      cmdMAL.Save();                  }              }
Magic Number,Shoko.Server.Models,SVR_VideoLocal,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_VideoLocal.cs,ToggleWatchedStatus,The following statement contains a magic number: if (watched)              {                  // find the total watched percentage                  // eg one file can have a % = 100                  // or if 2 files make up one episodes they will each have a % = 50                    foreach (CrossRef_File_Episode xref in xrefs)                  {                      // get the episodes for this file' may be more than one (One Piece x Toriko)                      SVR_AnimeEpisode ep = RepoFactory.AnimeEpisode.GetByAniDBEpisodeID(xref.EpisodeID);                      // get all the files for this episode                      int epPercentWatched = 0;                      foreach (CrossRef_File_Episode filexref in ep.FileCrossRefs)                      {                          VideoLocal_User vidUser = filexref.GetVideoLocalUserRecord(userID);                          if (vidUser?.WatchedDate != null)                              epPercentWatched += filexref.Percentage;                            if (epPercentWatched > 95) break;                      }                        if (epPercentWatched > 95)                      {                          ser = ep.GetAnimeSeries();                          if (!toUpdateSeries.ContainsKey(ser.AnimeSeriesID))                              toUpdateSeries.Add(ser.AnimeSeriesID' ser);                          if (user.IsAniDBUser == 0)                              ep.SaveWatchedStatus(true' userID' watchedDate' updateWatchedDate);                          else                              foreach (SVR_JMMUser juser in aniDBUsers)                                  if (juser.IsAniDBUser == 1)                                      ep.SaveWatchedStatus(true' juser.JMMUserID' watchedDate' updateWatchedDate);                            if (syncTrakt && ServerSettings.Trakt_IsEnabled &&                              !string.IsNullOrEmpty(ServerSettings.Trakt_AuthToken))                          {                              CommandRequest_TraktHistoryEpisode cmdSyncTrakt =                                  new CommandRequest_TraktHistoryEpisode(ep.AnimeEpisodeID' TraktSyncAction.Add);                              cmdSyncTrakt.Save();                          }                            if (!string.IsNullOrEmpty(ServerSettings.MAL_Username) &&                              !string.IsNullOrEmpty(ServerSettings.MAL_Password))                          {                              CommandRequest_MALUpdatedWatchedStatus cmdMAL =                                  new CommandRequest_MALUpdatedWatchedStatus(ser.AniDB_ID);                              cmdMAL.Save();                          }                      }                  }              }              else              {                  // if setting a file to unwatched only set the episode unwatched' if ALL the files are unwatched                  foreach (CrossRef_File_Episode xrefEp in xrefs)                  {                      // get the episodes for this file' may be more than one (One Piece x Toriko)                      SVR_AnimeEpisode ep = RepoFactory.AnimeEpisode.GetByAniDBEpisodeID(xrefEp.EpisodeID);                      ser = ep.GetAnimeSeries();                      if (!toUpdateSeries.ContainsKey(ser.AnimeSeriesID))                          toUpdateSeries.Add(ser.AnimeSeriesID' ser);                      // get all the files for this episode                      int epPercentWatched = 0;                      foreach (CrossRef_File_Episode filexref in ep.FileCrossRefs)                      {                          VideoLocal_User vidUser = filexref.GetVideoLocalUserRecord(userID);                          if (vidUser?.WatchedDate != null)                              epPercentWatched += filexref.Percentage;                            if (epPercentWatched > 95) break;                      }                        if (epPercentWatched < 95)                      {                          if (user.IsAniDBUser == 0)                              ep.SaveWatchedStatus(false' userID' watchedDate' true);                          else                              foreach (SVR_JMMUser juser in aniDBUsers)                                  if (juser.IsAniDBUser == 1)                                      ep.SaveWatchedStatus(false' juser.JMMUserID' watchedDate' true);                            if (syncTrakt && ServerSettings.Trakt_IsEnabled &&                              !string.IsNullOrEmpty(ServerSettings.Trakt_AuthToken))                          {                              CommandRequest_TraktHistoryEpisode cmdSyncTrakt =                                  new CommandRequest_TraktHistoryEpisode(ep.AnimeEpisodeID' TraktSyncAction.Remove);                              cmdSyncTrakt.Save();                          }                      }                  }                  if (!string.IsNullOrEmpty(ServerSettings.MAL_Username) &&                      !string.IsNullOrEmpty(ServerSettings.MAL_Password))                  {                      CommandRequest_MALUpdatedWatchedStatus cmdMAL =                          new CommandRequest_MALUpdatedWatchedStatus(ser.AniDB_ID);                      cmdMAL.Save();                  }              }
Magic Number,Shoko.Server.Models,SVR_VideoLocal,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_VideoLocal.cs,ToggleWatchedStatus,The following statement contains a magic number: if (watched)              {                  // find the total watched percentage                  // eg one file can have a % = 100                  // or if 2 files make up one episodes they will each have a % = 50                    foreach (CrossRef_File_Episode xref in xrefs)                  {                      // get the episodes for this file' may be more than one (One Piece x Toriko)                      SVR_AnimeEpisode ep = RepoFactory.AnimeEpisode.GetByAniDBEpisodeID(xref.EpisodeID);                      // get all the files for this episode                      int epPercentWatched = 0;                      foreach (CrossRef_File_Episode filexref in ep.FileCrossRefs)                      {                          VideoLocal_User vidUser = filexref.GetVideoLocalUserRecord(userID);                          if (vidUser?.WatchedDate != null)                              epPercentWatched += filexref.Percentage;                            if (epPercentWatched > 95) break;                      }                        if (epPercentWatched > 95)                      {                          ser = ep.GetAnimeSeries();                          if (!toUpdateSeries.ContainsKey(ser.AnimeSeriesID))                              toUpdateSeries.Add(ser.AnimeSeriesID' ser);                          if (user.IsAniDBUser == 0)                              ep.SaveWatchedStatus(true' userID' watchedDate' updateWatchedDate);                          else                              foreach (SVR_JMMUser juser in aniDBUsers)                                  if (juser.IsAniDBUser == 1)                                      ep.SaveWatchedStatus(true' juser.JMMUserID' watchedDate' updateWatchedDate);                            if (syncTrakt && ServerSettings.Trakt_IsEnabled &&                              !string.IsNullOrEmpty(ServerSettings.Trakt_AuthToken))                          {                              CommandRequest_TraktHistoryEpisode cmdSyncTrakt =                                  new CommandRequest_TraktHistoryEpisode(ep.AnimeEpisodeID' TraktSyncAction.Add);                              cmdSyncTrakt.Save();                          }                            if (!string.IsNullOrEmpty(ServerSettings.MAL_Username) &&                              !string.IsNullOrEmpty(ServerSettings.MAL_Password))                          {                              CommandRequest_MALUpdatedWatchedStatus cmdMAL =                                  new CommandRequest_MALUpdatedWatchedStatus(ser.AniDB_ID);                              cmdMAL.Save();                          }                      }                  }              }              else              {                  // if setting a file to unwatched only set the episode unwatched' if ALL the files are unwatched                  foreach (CrossRef_File_Episode xrefEp in xrefs)                  {                      // get the episodes for this file' may be more than one (One Piece x Toriko)                      SVR_AnimeEpisode ep = RepoFactory.AnimeEpisode.GetByAniDBEpisodeID(xrefEp.EpisodeID);                      ser = ep.GetAnimeSeries();                      if (!toUpdateSeries.ContainsKey(ser.AnimeSeriesID))                          toUpdateSeries.Add(ser.AnimeSeriesID' ser);                      // get all the files for this episode                      int epPercentWatched = 0;                      foreach (CrossRef_File_Episode filexref in ep.FileCrossRefs)                      {                          VideoLocal_User vidUser = filexref.GetVideoLocalUserRecord(userID);                          if (vidUser?.WatchedDate != null)                              epPercentWatched += filexref.Percentage;                            if (epPercentWatched > 95) break;                      }                        if (epPercentWatched < 95)                      {                          if (user.IsAniDBUser == 0)                              ep.SaveWatchedStatus(false' userID' watchedDate' true);                          else                              foreach (SVR_JMMUser juser in aniDBUsers)                                  if (juser.IsAniDBUser == 1)                                      ep.SaveWatchedStatus(false' juser.JMMUserID' watchedDate' true);                            if (syncTrakt && ServerSettings.Trakt_IsEnabled &&                              !string.IsNullOrEmpty(ServerSettings.Trakt_AuthToken))                          {                              CommandRequest_TraktHistoryEpisode cmdSyncTrakt =                                  new CommandRequest_TraktHistoryEpisode(ep.AnimeEpisodeID' TraktSyncAction.Remove);                              cmdSyncTrakt.Save();                          }                      }                  }                  if (!string.IsNullOrEmpty(ServerSettings.MAL_Username) &&                      !string.IsNullOrEmpty(ServerSettings.MAL_Password))                  {                      CommandRequest_MALUpdatedWatchedStatus cmdMAL =                          new CommandRequest_MALUpdatedWatchedStatus(ser.AniDB_ID);                      cmdMAL.Save();                  }              }
Magic Number,Shoko.Server.Providers.TvDB,TvDBApiHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TvDB\TvDBApiHelper.cs,CheckAuthorizationAsync,The following statement contains a magic number: try              {                  client.AcceptedLanguage = ServerSettings.TvDB_Language;                  if (string.IsNullOrEmpty(client.Authentication.Token))                  {                      TvDBRateLimiter.Instance.EnsureRate();                      await client.Authentication.AuthenticateAsync(Constants.TvDB.apiKey);                      if (string.IsNullOrEmpty(client.Authentication.Token))                          throw new TvDbServerException("Authentication Failed"' 200);                  }              }              catch (Exception e)              {                  logger.Error(e' $"Error in TvDBAuth: {e}");                  throw;              }
Magic Number,Shoko.Server.Providers.TvDB,TvDBApiHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TvDB\TvDBApiHelper.cs,GetEpisodesOnlineAsync,The following statement contains a magic number: try              {                  await CheckAuthorizationAsync();                    var tasks = new List<Task<TvDbResponse<BasicEpisode[]>>>();                  TvDBRateLimiter.Instance.EnsureRate();                  var firstResponse = await client.Series.GetEpisodesAsync(seriesID' 1);                    for (int i = 2; i <= firstResponse.Links.Last; i++)                  {                      TvDBRateLimiter.Instance.EnsureRate();                      tasks.Add(client.Series.GetEpisodesAsync(seriesID' i));                  }                    var results = await Task.WhenAll(tasks);                    apiEpisodes = firstResponse.Data.Concat(results.SelectMany(x => x.Data)).ToList();              }              catch (TvDbServerException exception)              {                  if (exception.StatusCode == (int)HttpStatusCode.Unauthorized)                  {                      client.Authentication.Token = null;                      await CheckAuthorizationAsync();                      if (!string.IsNullOrEmpty(client.Authentication.Token))                          return await GetEpisodesOnlineAsync(seriesID);                      // suppress 404 and move on                  }                  else if (exception.StatusCode == (int)HttpStatusCode.NotFound) return apiEpisodes;                  logger.Error(exception'                      $"TvDB returned an error code: {exception.StatusCode}\n        {exception.Message}");              }              catch (Exception ex)              {                  logger.Error(ex' $"Error in TvDBApiHelper.GetEpisodesOnlineAsync: {ex}");              }
Magic Number,Shoko.Server.Providers.TvDB,TvDBApiHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TvDB\TvDBApiHelper.cs,GetUpdatedSeriesListAsync,The following statement contains a magic number: try              {                  // Unix timestamp is seconds past epoch                  DateTime lastUpdateTime = new DateTime(1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);                  lastUpdateTime = lastUpdateTime.AddSeconds(lasttimeseconds).ToLocalTime();                    // api limits this to a week at a time' so split it up                  List<(DateTime' DateTime)> spans = new List<(DateTime' DateTime)>();                  if (lastUpdateTime.AddDays(7) < DateTime.Now)                  {                      DateTime time = lastUpdateTime;                      while (time < DateTime.Now)                      {                          var nextTime = time.AddDays(7);                          if (nextTime > DateTime.Now) nextTime = DateTime.Now;                          spans.Add((time' nextTime));                          time = time.AddDays(7);                      }                  }                  else                  {                      spans.Add((lastUpdateTime' DateTime.Now));                  }                    int i = 1;                  int count = spans.Count;                  foreach (var span in spans)                  {                      TvDBRateLimiter.Instance.EnsureRate();                      // this may take a while if you don't keep shoko running' so log info                      logger.Info($"Getting updates from TvDB' part {i} of {count}");                      i++;                      var response = await client.Updates.GetAsync(span.Item1' span.Item2);                        Update[] updates = response?.Data;                      if (updates == null) continue;                        seriesList.AddRange(updates.Where(item => item != null).Select(item => item.Id));                  }                    return seriesList;              }              catch (TvDbServerException exception)              {                  if (exception.StatusCode == (int)HttpStatusCode.Unauthorized)                  {                      client.Authentication.Token = null;                      await CheckAuthorizationAsync();                      if (!string.IsNullOrEmpty(client.Authentication.Token))                          return await GetUpdatedSeriesListAsync(lasttimeseconds);                      // suppress 404 and move on                  }                  else if (exception.StatusCode == (int)HttpStatusCode.NotFound) return seriesList;                  logger.Error(exception'                      $"TvDB returned an error code: {exception.StatusCode}\n        {exception.Message}");              }              catch (Exception ex)              {                  logger.Error(ex' $"Error in GetUpdatedSeriesList: {ex}");              }
Magic Number,Shoko.Server.Providers.TvDB,TvDBApiHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TvDB\TvDBApiHelper.cs,GetUpdatedSeriesListAsync,The following statement contains a magic number: try              {                  // Unix timestamp is seconds past epoch                  DateTime lastUpdateTime = new DateTime(1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);                  lastUpdateTime = lastUpdateTime.AddSeconds(lasttimeseconds).ToLocalTime();                    // api limits this to a week at a time' so split it up                  List<(DateTime' DateTime)> spans = new List<(DateTime' DateTime)>();                  if (lastUpdateTime.AddDays(7) < DateTime.Now)                  {                      DateTime time = lastUpdateTime;                      while (time < DateTime.Now)                      {                          var nextTime = time.AddDays(7);                          if (nextTime > DateTime.Now) nextTime = DateTime.Now;                          spans.Add((time' nextTime));                          time = time.AddDays(7);                      }                  }                  else                  {                      spans.Add((lastUpdateTime' DateTime.Now));                  }                    int i = 1;                  int count = spans.Count;                  foreach (var span in spans)                  {                      TvDBRateLimiter.Instance.EnsureRate();                      // this may take a while if you don't keep shoko running' so log info                      logger.Info($"Getting updates from TvDB' part {i} of {count}");                      i++;                      var response = await client.Updates.GetAsync(span.Item1' span.Item2);                        Update[] updates = response?.Data;                      if (updates == null) continue;                        seriesList.AddRange(updates.Where(item => item != null).Select(item => item.Id));                  }                    return seriesList;              }              catch (TvDbServerException exception)              {                  if (exception.StatusCode == (int)HttpStatusCode.Unauthorized)                  {                      client.Authentication.Token = null;                      await CheckAuthorizationAsync();                      if (!string.IsNullOrEmpty(client.Authentication.Token))                          return await GetUpdatedSeriesListAsync(lasttimeseconds);                      // suppress 404 and move on                  }                  else if (exception.StatusCode == (int)HttpStatusCode.NotFound) return seriesList;                  logger.Error(exception'                      $"TvDB returned an error code: {exception.StatusCode}\n        {exception.Message}");              }              catch (Exception ex)              {                  logger.Error(ex' $"Error in GetUpdatedSeriesList: {ex}");              }
Magic Number,Shoko.Server.Providers.TvDB,TvDBApiHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TvDB\TvDBApiHelper.cs,GetUpdatedSeriesListAsync,The following statement contains a magic number: try              {                  // Unix timestamp is seconds past epoch                  DateTime lastUpdateTime = new DateTime(1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);                  lastUpdateTime = lastUpdateTime.AddSeconds(lasttimeseconds).ToLocalTime();                    // api limits this to a week at a time' so split it up                  List<(DateTime' DateTime)> spans = new List<(DateTime' DateTime)>();                  if (lastUpdateTime.AddDays(7) < DateTime.Now)                  {                      DateTime time = lastUpdateTime;                      while (time < DateTime.Now)                      {                          var nextTime = time.AddDays(7);                          if (nextTime > DateTime.Now) nextTime = DateTime.Now;                          spans.Add((time' nextTime));                          time = time.AddDays(7);                      }                  }                  else                  {                      spans.Add((lastUpdateTime' DateTime.Now));                  }                    int i = 1;                  int count = spans.Count;                  foreach (var span in spans)                  {                      TvDBRateLimiter.Instance.EnsureRate();                      // this may take a while if you don't keep shoko running' so log info                      logger.Info($"Getting updates from TvDB' part {i} of {count}");                      i++;                      var response = await client.Updates.GetAsync(span.Item1' span.Item2);                        Update[] updates = response?.Data;                      if (updates == null) continue;                        seriesList.AddRange(updates.Where(item => item != null).Select(item => item.Id));                  }                    return seriesList;              }              catch (TvDbServerException exception)              {                  if (exception.StatusCode == (int)HttpStatusCode.Unauthorized)                  {                      client.Authentication.Token = null;                      await CheckAuthorizationAsync();                      if (!string.IsNullOrEmpty(client.Authentication.Token))                          return await GetUpdatedSeriesListAsync(lasttimeseconds);                      // suppress 404 and move on                  }                  else if (exception.StatusCode == (int)HttpStatusCode.NotFound) return seriesList;                  logger.Error(exception'                      $"TvDB returned an error code: {exception.StatusCode}\n        {exception.Message}");              }              catch (Exception ex)              {                  logger.Error(ex' $"Error in GetUpdatedSeriesList: {ex}");              }
Magic Number,Shoko.Server.Providers.TvDB,TvDBApiHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TvDB\TvDBApiHelper.cs,GetUpdatedSeriesListAsync,The following statement contains a magic number: try              {                  // Unix timestamp is seconds past epoch                  DateTime lastUpdateTime = new DateTime(1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);                  lastUpdateTime = lastUpdateTime.AddSeconds(lasttimeseconds).ToLocalTime();                    // api limits this to a week at a time' so split it up                  List<(DateTime' DateTime)> spans = new List<(DateTime' DateTime)>();                  if (lastUpdateTime.AddDays(7) < DateTime.Now)                  {                      DateTime time = lastUpdateTime;                      while (time < DateTime.Now)                      {                          var nextTime = time.AddDays(7);                          if (nextTime > DateTime.Now) nextTime = DateTime.Now;                          spans.Add((time' nextTime));                          time = time.AddDays(7);                      }                  }                  else                  {                      spans.Add((lastUpdateTime' DateTime.Now));                  }                    int i = 1;                  int count = spans.Count;                  foreach (var span in spans)                  {                      TvDBRateLimiter.Instance.EnsureRate();                      // this may take a while if you don't keep shoko running' so log info                      logger.Info($"Getting updates from TvDB' part {i} of {count}");                      i++;                      var response = await client.Updates.GetAsync(span.Item1' span.Item2);                        Update[] updates = response?.Data;                      if (updates == null) continue;                        seriesList.AddRange(updates.Where(item => item != null).Select(item => item.Id));                  }                    return seriesList;              }              catch (TvDbServerException exception)              {                  if (exception.StatusCode == (int)HttpStatusCode.Unauthorized)                  {                      client.Authentication.Token = null;                      await CheckAuthorizationAsync();                      if (!string.IsNullOrEmpty(client.Authentication.Token))                          return await GetUpdatedSeriesListAsync(lasttimeseconds);                      // suppress 404 and move on                  }                  else if (exception.StatusCode == (int)HttpStatusCode.NotFound) return seriesList;                  logger.Error(exception'                      $"TvDB returned an error code: {exception.StatusCode}\n        {exception.Message}");              }              catch (Exception ex)              {                  logger.Error(ex' $"Error in GetUpdatedSeriesList: {ex}");              }
Magic Number,Shoko.Server.Renamer,LegacyRenamer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Renamer\LegacyRenamer.cs,GetAction,The following statement contains a magic number: string action = line.Substring(posStart + 3' line.Length - posStart - 3);
Magic Number,Shoko.Server.Renamer,LegacyRenamer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Renamer\LegacyRenamer.cs,GetAction,The following statement contains a magic number: string action = line.Substring(posStart + 3' line.Length - posStart - 3);
Magic Number,Shoko.Server.Repositories.Cached,CrossRef_Anime_StaffRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\CrossRef_Anime_StaffRepository.cs,RegenerateDb,The following statement contains a magic number: foreach (var animeStaff in list)              {                  animeStaff.Role = Roles[animeStaff.Role].ToString().Replace("_"' " ");                  Save(animeStaff);                  i++;                  if (i % 10 == 0)                      ServerState.Instance.CurrentSetupStatus = string.Format(                          Commons.Properties.Resources.Database_Validating' typeof(CrossRef_Anime_Staff).Name'                          $" DbRegen - {i}/{list.Count}");              }
Magic Number,Shoko.Server.Repositories.Cached,AnimeEpisode_UserRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\AnimeEpisode_UserRepository.cs,PopulateIndexes,The following statement contains a magic number: UsersEpisodes = Cache.CreateIndex(a => (ulong) a.JMMUserID << 48 | (ulong) a.AnimeEpisodeID);
Magic Number,Shoko.Server.Repositories.Cached,AnimeEpisode_UserRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\AnimeEpisode_UserRepository.cs,PopulateIndexes,The following statement contains a magic number: UsersSeries = Cache.CreateIndex(a => (ulong) a.JMMUserID << 48 | (ulong) a.AnimeSeriesID);
Magic Number,Shoko.Server.Repositories.Cached,AnimeEpisode_UserRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\AnimeEpisode_UserRepository.cs,RegenerateDb,The following statement contains a magic number: foreach (SVR_AnimeEpisode_User g in sers)              {                  Save(g);                  cnt++;                  if (cnt % 10 == 0)                      ServerState.Instance.CurrentSetupStatus = string.Format(                          Commons.Properties.Resources.Database_Validating' typeof(AnimeEpisode_User).Name'                          " DbRegen - " + cnt + "/" + max);              }
Magic Number,Shoko.Server.Repositories.Cached,AnimeEpisode_UserRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\AnimeEpisode_UserRepository.cs,GetByUserIDAndEpisodeID,The following statement contains a magic number: lock (Cache)              {                  return UsersEpisodes.GetOne((ulong) userid << 48 | (ulong) epid);              }
Magic Number,Shoko.Server.Repositories.Cached,AnimeEpisode_UserRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\AnimeEpisode_UserRepository.cs,GetLastWatchedEpisodeForSeries,The following statement contains a magic number: lock (Cache)              {                  return UsersSeries.GetMultiple((ulong) userid << 48 | (ulong) seriesid).Where(a => a.WatchedCount > 0)                      .OrderByDescending(a => a.WatchedDate).FirstOrDefault();              }
Magic Number,Shoko.Server.Repositories.Cached,AnimeEpisode_UserRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\AnimeEpisode_UserRepository.cs,GetByUserIDAndSeriesID,The following statement contains a magic number: lock (Cache)              {                  return UsersSeries.GetMultiple((ulong) userid << 48 | (ulong) seriesid);              }
Magic Number,Shoko.Server.Repositories.Cached,AnimeGroupRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\AnimeGroupRepository.cs,RegenerateDb,The following statement contains a magic number: foreach (SVR_AnimeGroup g in grps)              {                  g.Description = g.Description?.Replace('`'' '\'');                  g.GroupName = g.GroupName?.Replace('`'' '\'');                  g.SortName = g.SortName?.Replace('`'' '\'');                  Save(g' true' false' false);                  cnt++;                  if (cnt % 10 == 0)                  {                      ServerState.Instance.CurrentSetupStatus = string.Format(                          Commons.Properties.Resources.Database_Validating' typeof(AnimeGroup).Name'                          " DbRegen - " + cnt + "/" + max);                  }              }
Magic Number,Shoko.Server.Repositories.Cached,AnimeSeriesRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\AnimeSeriesRepository.cs,RegenerateDb,The following statement contains a magic number: try              {                  int cnt = 0;                  List<SVR_AnimeSeries> sers =                      Cache.Values.Where(                              a => a.ContractVersion < SVR_AnimeSeries.CONTRACT_VERSION ||                                   a.Contract?.AniDBAnime?.AniDBAnime == null)                          .ToList();                  int max = sers.Count;                  ServerState.Instance.CurrentSetupStatus = string.Format(                      Commons.Properties.Resources.Database_Validating' typeof(AnimeSeries).Name' " DbRegen");                  if (max <= 0) return;                  foreach (SVR_AnimeSeries s in sers)                  {                      try                      {                          Save(s' false' false' true);                      }                      catch                      {                      }                        cnt++;                      if (cnt % 10 == 0)                      {                          ServerState.Instance.CurrentSetupStatus = string.Format(                              Commons.Properties.Resources.Database_Validating' typeof(AnimeSeries).Name'                              " DbRegen - " + cnt + "/" + max);                      }                  }                  ServerState.Instance.CurrentSetupStatus = string.Format(                      Commons.Properties.Resources.Database_Validating' typeof(AnimeSeries).Name'                      " DbRegen - " + max + "/" + max);              }              catch (Exception e)              {                  Console.WriteLine(e);                  throw;              }
Magic Number,Shoko.Server.Repositories.Cached,AnimeSeriesRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\AnimeSeriesRepository.cs,GetMostRecentlyAdded,The following statement contains a magic number: lock (Cache)              {                  return Cache.Values.OrderByDescending(a => a.DateTimeCreated).Take(maxResults + 15).ToList();              }
Magic Number,Shoko.Server.Repositories,RepoFactory,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\RepoFactory.cs,Init,The following statement contains a magic number: try              {                  foreach (var repo in CachedRepositories)                  {                      Task task = Task.Run(() => repo.Populate());                        // don't wait longer than 3 minutes                      if (!task.Wait(180000)) throw new TimeoutException($"{repo.GetType()} took too long to cache.");                  }              }              catch (Exception exception)              {                  logger.Error($"There was an error starting the Database Factory - Caching: {exception}");                  throw;              }
Magic Number,Shoko.Server.Repositories,AdhocRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\AdhocRepository.cs,GetAllVideoQualityByAnime,The following statement contains a magic number: using (var session = DatabaseFactory.SessionFactory.OpenSession())              {                  System.Data.IDbCommand command = session.Connection.CreateCommand();                  command.CommandText = "SELECT anime.AnimeID' anime.MainTitle' anifile.File_Source ";                  command.CommandText += "FROM AnimeSeries ser ";                  command.CommandText += "INNER JOIN AniDB_Anime anime on anime.AnimeID = ser.AniDB_ID ";                  command.CommandText += "INNER JOIN AnimeEpisode ep on ep.AnimeSeriesID = ser.AnimeSeriesID ";                  command.CommandText += "INNER JOIN AniDB_Episode aniep on ep.AniDB_EpisodeID = aniep.EpisodeID ";                  command.CommandText += "INNER JOIN CrossRef_File_Episode xref on aniep.EpisodeID = xref.EpisodeID ";                  command.CommandText += "INNER JOIN AniDB_File anifile on anifile.Hash = xref.Hash ";                  command.CommandText += "INNER JOIN CrossRef_Subtitles_AniDB_File subt on subt.FileID = anifile.FileID ";                  // See Note 1                  command.CommandText += "GROUP BY anime.AnimeID' anime.MainTitle' anifile.File_Source ";                      using (IDataReader rdr = command.ExecuteReader())                  {                      while (rdr.Read())                      {                          int groupID = int.Parse(rdr[0].ToString());                          string vidQual = rdr[2].ToString().Trim();                          HashSet<string> vids;                          if (allVidQuality.ContainsKey(groupID))                              vids = allVidQuality[groupID];                          else                          {                              vids = new HashSet<string>(StringComparer.InvariantCultureIgnoreCase);                              allVidQuality.Add(groupID' vids);                          }                          if (!vids.Contains(vidQual))                              vids.Add(vidQual);                      }                  }              }
Magic Number,Shoko.Server.Repositories,AdhocRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\AdhocRepository.cs,GetEpisodeVideoQualityStatsByAnime,The following statement contains a magic number: using (IDbCommand command = session.Connection.CreateCommand())              {                  command.CommandText = "SELECT anime.AnimeID' anime.MainTitle' anifile.File_Source' aniep.EpisodeNumber "                                        + "FROM AnimeSeries ser "                                        + "INNER JOIN AniDB_Anime anime on anime.AnimeID = ser.AniDB_ID "                                        + "INNER JOIN AnimeEpisode ep on ep.AnimeSeriesID = ser.AnimeSeriesID "                                        + "INNER JOIN AniDB_Episode aniep on ep.AniDB_EpisodeID = aniep.EpisodeID "                                        + "INNER JOIN CrossRef_File_Episode xref on aniep.EpisodeID = xref.EpisodeID "                                        + "INNER JOIN AniDB_File anifile on anifile.Hash = xref.Hash "                                        +                                        "INNER JOIN CrossRef_Subtitles_AniDB_File subt on subt.FileID = anifile.FileID ";                  // See Note 1                  command.CommandText += "WHERE aniep.EpisodeType = 1 "; // normal episodes only                    if (animeIds != null)                  {                      if (animeIds.Count == 0)                      {                          return dictStats; // No anime IDs means no results. So' no need to perform query                      }                        command.CommandText += "AND anime.AnimeID IN (" + String.Join("'"' animeIds) + ") ";                  }                    command.CommandText +=                      "GROUP BY anime.AnimeID' anime.MainTitle' anifile.File_Source' aniep.EpisodeNumber "                      + "ORDER BY anime.AnimeID' anime.MainTitle' anifile.File_Source' aniep.EpisodeNumber ";                    using (IDataReader rdr = command.ExecuteReader())                  {                      while (rdr.Read())                      {                          int animeID = Convert.ToInt32(rdr[0]);                          string mainTitle = rdr[1].ToString().Trim();                          string vidQual = rdr[2].ToString().Trim();                          int epNumber = Convert.ToInt32(rdr[3]);                            if (!dictStats.TryGetValue(animeID' out AnimeVideoQualityStat stat))                          {                              stat = new AnimeVideoQualityStat                              {                                  AnimeID = animeID'                                  MainTitle = mainTitle'                                  VideoQualityEpisodeCount = new Dictionary<string' int>()                              };                              dictStats.Add(animeID' stat);                          }                              stat.VideoQualityEpisodeCount.TryGetValue(vidQual' out int epCount);                          stat.VideoQualityEpisodeCount[vidQual] = epCount + 1;                      }                  }              }
Magic Number,Shoko.Server.Repositories,AdhocRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\AdhocRepository.cs,GetEpisodeVideoQualityStatsByAnime,The following statement contains a magic number: using (IDbCommand command = session.Connection.CreateCommand())              {                  command.CommandText = "SELECT anime.AnimeID' anime.MainTitle' anifile.File_Source' aniep.EpisodeNumber "                                        + "FROM AnimeSeries ser "                                        + "INNER JOIN AniDB_Anime anime on anime.AnimeID = ser.AniDB_ID "                                        + "INNER JOIN AnimeEpisode ep on ep.AnimeSeriesID = ser.AnimeSeriesID "                                        + "INNER JOIN AniDB_Episode aniep on ep.AniDB_EpisodeID = aniep.EpisodeID "                                        + "INNER JOIN CrossRef_File_Episode xref on aniep.EpisodeID = xref.EpisodeID "                                        + "INNER JOIN AniDB_File anifile on anifile.Hash = xref.Hash "                                        +                                        "INNER JOIN CrossRef_Subtitles_AniDB_File subt on subt.FileID = anifile.FileID ";                  // See Note 1                  command.CommandText += "WHERE aniep.EpisodeType = 1 "; // normal episodes only                    if (animeIds != null)                  {                      if (animeIds.Count == 0)                      {                          return dictStats; // No anime IDs means no results. So' no need to perform query                      }                        command.CommandText += "AND anime.AnimeID IN (" + String.Join("'"' animeIds) + ") ";                  }                    command.CommandText +=                      "GROUP BY anime.AnimeID' anime.MainTitle' anifile.File_Source' aniep.EpisodeNumber "                      + "ORDER BY anime.AnimeID' anime.MainTitle' anifile.File_Source' aniep.EpisodeNumber ";                    using (IDataReader rdr = command.ExecuteReader())                  {                      while (rdr.Read())                      {                          int animeID = Convert.ToInt32(rdr[0]);                          string mainTitle = rdr[1].ToString().Trim();                          string vidQual = rdr[2].ToString().Trim();                          int epNumber = Convert.ToInt32(rdr[3]);                            if (!dictStats.TryGetValue(animeID' out AnimeVideoQualityStat stat))                          {                              stat = new AnimeVideoQualityStat                              {                                  AnimeID = animeID'                                  MainTitle = mainTitle'                                  VideoQualityEpisodeCount = new Dictionary<string' int>()                              };                              dictStats.Add(animeID' stat);                          }                              stat.VideoQualityEpisodeCount.TryGetValue(vidQual' out int epCount);                          stat.VideoQualityEpisodeCount[vidQual] = epCount + 1;                      }                  }              }
Magic Number,Shoko.Server.Repositories,AdhocRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\AdhocRepository.cs,GetEpisodeVideoQualityStatsForAnime,The following statement contains a magic number: using (IDataReader rdr = command.ExecuteReader())              {                  while (rdr.Read())                  {                      stat.AnimeID = int.Parse(rdr[0].ToString());                      stat.MainTitle = rdr[1].ToString().Trim();                        string vidQual = rdr[2].ToString().Trim();                      int epNumber = int.Parse(rdr[3].ToString());                        if (!stat.VideoQualityEpisodeCount.ContainsKey(vidQual))                          stat.VideoQualityEpisodeCount[vidQual] = 1;                      else                          stat.VideoQualityEpisodeCount[vidQual]++;                  }              }
Magic Number,Shoko.Server.Repositories,AdhocRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\AdhocRepository.cs,GetEpisodeVideoQualityStatsForAnime,The following statement contains a magic number: using (IDataReader rdr = command.ExecuteReader())              {                  while (rdr.Read())                  {                      stat.AnimeID = int.Parse(rdr[0].ToString());                      stat.MainTitle = rdr[1].ToString().Trim();                        string vidQual = rdr[2].ToString().Trim();                      int epNumber = int.Parse(rdr[3].ToString());                        if (!stat.VideoQualityEpisodeCount.ContainsKey(vidQual))                          stat.VideoQualityEpisodeCount[vidQual] = 1;                      else                          stat.VideoQualityEpisodeCount[vidQual]++;                  }              }
Magic Number,Shoko.Server.Repositories,AdhocRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\AdhocRepository.cs,GetAudioLanguageStatsForAnime,The following statement contains a magic number: using (var session = DatabaseFactory.SessionFactory.OpenSession())              {                  System.Data.IDbCommand command = session.Connection.CreateCommand();                  command.CommandText = "SELECT anime.AnimeID' anime.MainTitle' lan.LanguageName ";                  command.CommandText += "FROM AnimeSeries ser  ";                  command.CommandText += "INNER JOIN AniDB_Anime anime on anime.AnimeID = ser.AniDB_ID ";                  command.CommandText += "INNER JOIN AnimeEpisode ep on ep.AnimeSeriesID = ser.AnimeSeriesID ";                  command.CommandText += "INNER JOIN AniDB_Episode aniep on ep.AniDB_EpisodeID = aniep.EpisodeID ";                  command.CommandText += "INNER JOIN CrossRef_File_Episode xref on aniep.EpisodeID = xref.EpisodeID ";                  command.CommandText += "INNER JOIN AniDB_File anifile on anifile.Hash = xref.Hash ";                  command.CommandText +=                      "INNER JOIN CrossRef_Languages_AniDB_File audio on audio.FileID = anifile.FileID ";                  command.CommandText += "INNER JOIN Language lan on audio.LanguageID = lan.LanguageID ";                  command.CommandText += "GROUP BY anime.AnimeID' anime.MainTitle' lan.LanguageName ";                    using (IDataReader rdr = command.ExecuteReader())                  {                      while (rdr.Read())                      {                          int animeID = int.Parse(rdr[0].ToString());                          string mainTitle = rdr[1].ToString().Trim();                          string lanName = rdr[2].ToString().Trim();                              if (animeID == 7656)                          {                              Debug.Print("");                          }                            if (!dictStats.ContainsKey(animeID))                          {                              LanguageStat stat = new LanguageStat                              {                                  AnimeID = animeID'                                  MainTitle = mainTitle'                                  LanguageNames = new List<string>()                              };                              stat.LanguageNames.Add(lanName);                              dictStats[animeID] = stat;                          }                          else                              dictStats[animeID].LanguageNames.Add(lanName);                      }                  }              }
Magic Number,Shoko.Server.Repositories,AdhocRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\AdhocRepository.cs,GetAudioLanguageStatsForAnime,The following statement contains a magic number: using (var session = DatabaseFactory.SessionFactory.OpenSession())              {                  System.Data.IDbCommand command = session.Connection.CreateCommand();                  command.CommandText = "SELECT anime.AnimeID' anime.MainTitle' lan.LanguageName ";                  command.CommandText += "FROM AnimeSeries ser  ";                  command.CommandText += "INNER JOIN AniDB_Anime anime on anime.AnimeID = ser.AniDB_ID ";                  command.CommandText += "INNER JOIN AnimeEpisode ep on ep.AnimeSeriesID = ser.AnimeSeriesID ";                  command.CommandText += "INNER JOIN AniDB_Episode aniep on ep.AniDB_EpisodeID = aniep.EpisodeID ";                  command.CommandText += "INNER JOIN CrossRef_File_Episode xref on aniep.EpisodeID = xref.EpisodeID ";                  command.CommandText += "INNER JOIN AniDB_File anifile on anifile.Hash = xref.Hash ";                  command.CommandText +=                      "INNER JOIN CrossRef_Languages_AniDB_File audio on audio.FileID = anifile.FileID ";                  command.CommandText += "INNER JOIN Language lan on audio.LanguageID = lan.LanguageID ";                  command.CommandText += "GROUP BY anime.AnimeID' anime.MainTitle' lan.LanguageName ";                    using (IDataReader rdr = command.ExecuteReader())                  {                      while (rdr.Read())                      {                          int animeID = int.Parse(rdr[0].ToString());                          string mainTitle = rdr[1].ToString().Trim();                          string lanName = rdr[2].ToString().Trim();                              if (animeID == 7656)                          {                              Debug.Print("");                          }                            if (!dictStats.ContainsKey(animeID))                          {                              LanguageStat stat = new LanguageStat                              {                                  AnimeID = animeID'                                  MainTitle = mainTitle'                                  LanguageNames = new List<string>()                              };                              stat.LanguageNames.Add(lanName);                              dictStats[animeID] = stat;                          }                          else                              dictStats[animeID].LanguageNames.Add(lanName);                      }                  }              }
Magic Number,Shoko.Server.Repositories,AdhocRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\AdhocRepository.cs,GetSubtitleLanguageStatsForAnime,The following statement contains a magic number: foreach (object[] cols in rows)              {                  int animeID = Convert.ToInt32(cols[0]);                  string mainTitle = cols[1].ToString().Trim();                  string lanName = cols[2].ToString().Trim();                    if (!dictStats.TryGetValue(animeID' out LanguageStat stat))                  {                      stat = new LanguageStat                      {                          AnimeID = animeID'                          MainTitle = mainTitle'                          LanguageNames = new List<string>()                      };                      dictStats.Add(animeID' stat);                  }                    stat.LanguageNames.Add(lanName);              }
Magic Number,Shoko.Server.Repositories,AdhocRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\AdhocRepository.cs,GetAudioLanguageStatsByAnimeResults,The following statement contains a magic number: foreach (object[] cols in rows)              {                  int animeID = Convert.ToInt32(cols[0]);                  string mainTitle = cols[1].ToString().Trim();                  string lanName = cols[2].ToString().Trim();                    if (!dictStats.TryGetValue(animeID' out LanguageStat stat))                  {                      stat = new LanguageStat                      {                          AnimeID = animeID'                          MainTitle = mainTitle'                          LanguageNames = new List<string>()                      };                      dictStats.Add(animeID' stat);                  }                    stat.LanguageNames.Add(lanName);              }
Magic Number,Shoko.Server.Repositories,AdhocRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\AdhocRepository.cs,GetSubtitleLanguageStatsByAnimeResults,The following statement contains a magic number: foreach (object[] cols in rows)              {                  int animeID = Convert.ToInt32(cols[0]);                  string mainTitle = cols[1].ToString().Trim();                  string lanName = cols[2].ToString().Trim();                    if (!dictStats.TryGetValue(animeID' out LanguageStat stat))                  {                      stat = new LanguageStat                      {                          AnimeID = animeID'                          MainTitle = mainTitle'                          LanguageNames = new List<string>()                      };                      dictStats.Add(animeID' stat);                  }                    stat.LanguageNames.Add(lanName);              }
Magic Number,Shoko.Server.Repositories,AniDB_AnimeRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\AniDB_AnimeRepository.cs,RegenerateDb,The following statement contains a magic number: using (var session = DatabaseFactory.SessionFactory.OpenStatelessSession())              {                  const int batchSize = 50;                  ISessionWrapper sessionWrapper = session.Wrap();                  IList<SVR_AniDB_Anime> animeToUpdate = session.CreateCriteria<SVR_AniDB_Anime>()                      .Add(Restrictions.Lt(nameof(SVR_AniDB_Anime.ContractVersion)' SVR_AniDB_Anime.CONTRACT_VERSION))                      .List<SVR_AniDB_Anime>();                  int max = animeToUpdate.Count;                  int count = 0;                    ServerState.Instance.CurrentSetupStatus = string.Format(                      Commons.Properties.Resources.Database_Validating' typeof(AniDB_Anime).Name' " DbRegen");                  if (max <= 0) return;                  foreach (SVR_AniDB_Anime[] animeBatch in animeToUpdate.Batch(batchSize))                  {                      SVR_AniDB_Anime.UpdateContractDetailedBatch(sessionWrapper' animeBatch);                        using (ITransaction trans = session.BeginTransaction())                      {                          foreach (SVR_AniDB_Anime anime in animeBatch)                          {                              anime.Description = anime.Description?.Replace("`"' "\'") ?? string.Empty;                              anime.MainTitle = anime.MainTitle.Replace("`"' "\'");                              anime.AllTags = anime.AllTags.Replace("`"' "\'");                              anime.AllTitles = anime.AllTitles.Replace("`"' "\'");                              session.Update(anime);                              Cache.Update(anime);                              count++;                          }                            trans.Commit();                      }                        ServerState.Instance.CurrentSetupStatus = string.Format(                          Commons.Properties.Resources.Database_Validating' typeof(AniDB_Anime).Name'                          " DbRegen - " + count + "/" + max);                  }                    ServerState.Instance.CurrentSetupStatus = string.Format(                      Commons.Properties.Resources.Database_Validating' typeof(AniDB_Anime).Name'                      " DbRegen - " + max + "/" + max);              }
Magic Number,Shoko.Server.Repositories,AniDB_AnimeRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\AniDB_AnimeRepository.cs,GetDefaultImagesByAnime,The following statement contains a magic number: lock (globalDBLock)              {                  // TODO: Determine if joining on the correct columns                  var results = session.CreateSQLQuery(@"                  SELECT {defImg.*}' {tvWide.*}' {tvPoster.*}' {tvFanart.*}' {movPoster.*}' {movFanart.*}                      FROM AniDB_Anime_DefaultImage defImg                          LEFT OUTER JOIN TvDB_ImageWideBanner AS tvWide                              ON tvWide.TvDB_ImageWideBannerID = defImg.ImageParentID AND defImg.ImageParentType = :tvdbBannerType                          LEFT OUTER JOIN TvDB_ImagePoster AS tvPoster                              ON tvPoster.TvDB_ImagePosterID = defImg.ImageParentID AND defImg.ImageParentType = :tvdbCoverType                          LEFT OUTER JOIN TvDB_ImageFanart AS tvFanart                              ON tvFanart.TvDB_ImageFanartID = defImg.ImageParentID AND defImg.ImageParentType = :tvdbFanartType                          LEFT OUTER JOIN MovieDB_Poster AS movPoster                              ON movPoster.MovieDB_PosterID = defImg.ImageParentID AND defImg.ImageParentType = :movdbPosterType                          LEFT OUTER JOIN MovieDB_Fanart AS movFanart                              ON movFanart.MovieDB_FanartID = defImg.ImageParentID AND defImg.ImageParentType = :movdbFanartType                      WHERE defImg.AnimeID IN (:animeIds) AND defImg.ImageParentType IN (:tvdbBannerType' :tvdbCoverType' :tvdbFanartType' :movdbPosterType' :movdbFanartType)")                      .AddEntity("defImg"' typeof(AniDB_Anime_DefaultImage))                      .AddEntity("tvWide"' typeof(TvDB_ImageWideBanner))                      .AddEntity("tvPoster"' typeof(TvDB_ImagePoster))                      .AddEntity("tvFanart"' typeof(TvDB_ImageFanart))                      .AddEntity("movPoster"' typeof(MovieDB_Poster))                      .AddEntity("movFanart"' typeof(MovieDB_Fanart))                      .SetParameterList("animeIds"' animeIds)                      .SetInt32("tvdbBannerType"' (int) ImageEntityType.TvDB_Banner)                      .SetInt32("tvdbCoverType"' (int) ImageEntityType.TvDB_Cover)                      .SetInt32("tvdbFanartType"' (int) ImageEntityType.TvDB_FanArt)                      .SetInt32("movdbPosterType"' (int) ImageEntityType.MovieDB_Poster)                      .SetInt32("movdbFanartType"' (int) ImageEntityType.MovieDB_FanArt)                      .List<object[]>();                    foreach (object[] result in results)                  {                      var aniDbDefImage = (AniDB_Anime_DefaultImage) result[0];                      IImageEntity parentImage = null;                        switch ((ImageEntityType) aniDbDefImage.ImageParentType)                      {                          case ImageEntityType.TvDB_Banner:                              parentImage = (IImageEntity) result[1];                              break;                          case ImageEntityType.TvDB_Cover:                              parentImage = (IImageEntity) result[2];                              break;                          case ImageEntityType.TvDB_FanArt:                              parentImage = (IImageEntity) result[3];                              break;                          case ImageEntityType.MovieDB_Poster:                              parentImage = (IImageEntity) result[4];                              break;                          case ImageEntityType.MovieDB_FanArt:                              parentImage = (IImageEntity) result[5];                              break;                      }                        if (parentImage == null)                      {                          continue;                      }                        DefaultAnimeImage defImage = new DefaultAnimeImage(aniDbDefImage' parentImage);                        if (!defImagesByAnime.TryGetValue(aniDbDefImage.AnimeID' out DefaultAnimeImages defImages))                      {                          defImages = new DefaultAnimeImages {AnimeID = aniDbDefImage.AnimeID};                          defImagesByAnime.Add(defImages.AnimeID' defImages);                      }                        switch (defImage.AniDBImageSizeType)                      {                          case ImageSizeType.Poster:                              defImages.Poster = defImage;                              break;                          case ImageSizeType.WideBanner:                              defImages.WideBanner = defImage;                              break;                          case ImageSizeType.Fanart:                              defImages.Fanart = defImage;                              break;                      }                  }              }
Magic Number,Shoko.Server.Repositories,AniDB_AnimeRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\AniDB_AnimeRepository.cs,GetDefaultImagesByAnime,The following statement contains a magic number: lock (globalDBLock)              {                  // TODO: Determine if joining on the correct columns                  var results = session.CreateSQLQuery(@"                  SELECT {defImg.*}' {tvWide.*}' {tvPoster.*}' {tvFanart.*}' {movPoster.*}' {movFanart.*}                      FROM AniDB_Anime_DefaultImage defImg                          LEFT OUTER JOIN TvDB_ImageWideBanner AS tvWide                              ON tvWide.TvDB_ImageWideBannerID = defImg.ImageParentID AND defImg.ImageParentType = :tvdbBannerType                          LEFT OUTER JOIN TvDB_ImagePoster AS tvPoster                              ON tvPoster.TvDB_ImagePosterID = defImg.ImageParentID AND defImg.ImageParentType = :tvdbCoverType                          LEFT OUTER JOIN TvDB_ImageFanart AS tvFanart                              ON tvFanart.TvDB_ImageFanartID = defImg.ImageParentID AND defImg.ImageParentType = :tvdbFanartType                          LEFT OUTER JOIN MovieDB_Poster AS movPoster                              ON movPoster.MovieDB_PosterID = defImg.ImageParentID AND defImg.ImageParentType = :movdbPosterType                          LEFT OUTER JOIN MovieDB_Fanart AS movFanart                              ON movFanart.MovieDB_FanartID = defImg.ImageParentID AND defImg.ImageParentType = :movdbFanartType                      WHERE defImg.AnimeID IN (:animeIds) AND defImg.ImageParentType IN (:tvdbBannerType' :tvdbCoverType' :tvdbFanartType' :movdbPosterType' :movdbFanartType)")                      .AddEntity("defImg"' typeof(AniDB_Anime_DefaultImage))                      .AddEntity("tvWide"' typeof(TvDB_ImageWideBanner))                      .AddEntity("tvPoster"' typeof(TvDB_ImagePoster))                      .AddEntity("tvFanart"' typeof(TvDB_ImageFanart))                      .AddEntity("movPoster"' typeof(MovieDB_Poster))                      .AddEntity("movFanart"' typeof(MovieDB_Fanart))                      .SetParameterList("animeIds"' animeIds)                      .SetInt32("tvdbBannerType"' (int) ImageEntityType.TvDB_Banner)                      .SetInt32("tvdbCoverType"' (int) ImageEntityType.TvDB_Cover)                      .SetInt32("tvdbFanartType"' (int) ImageEntityType.TvDB_FanArt)                      .SetInt32("movdbPosterType"' (int) ImageEntityType.MovieDB_Poster)                      .SetInt32("movdbFanartType"' (int) ImageEntityType.MovieDB_FanArt)                      .List<object[]>();                    foreach (object[] result in results)                  {                      var aniDbDefImage = (AniDB_Anime_DefaultImage) result[0];                      IImageEntity parentImage = null;                        switch ((ImageEntityType) aniDbDefImage.ImageParentType)                      {                          case ImageEntityType.TvDB_Banner:                              parentImage = (IImageEntity) result[1];                              break;                          case ImageEntityType.TvDB_Cover:                              parentImage = (IImageEntity) result[2];                              break;                          case ImageEntityType.TvDB_FanArt:                              parentImage = (IImageEntity) result[3];                              break;                          case ImageEntityType.MovieDB_Poster:                              parentImage = (IImageEntity) result[4];                              break;                          case ImageEntityType.MovieDB_FanArt:                              parentImage = (IImageEntity) result[5];                              break;                      }                        if (parentImage == null)                      {                          continue;                      }                        DefaultAnimeImage defImage = new DefaultAnimeImage(aniDbDefImage' parentImage);                        if (!defImagesByAnime.TryGetValue(aniDbDefImage.AnimeID' out DefaultAnimeImages defImages))                      {                          defImages = new DefaultAnimeImages {AnimeID = aniDbDefImage.AnimeID};                          defImagesByAnime.Add(defImages.AnimeID' defImages);                      }                        switch (defImage.AniDBImageSizeType)                      {                          case ImageSizeType.Poster:                              defImages.Poster = defImage;                              break;                          case ImageSizeType.WideBanner:                              defImages.WideBanner = defImage;                              break;                          case ImageSizeType.Fanart:                              defImages.Fanart = defImage;                              break;                      }                  }              }
Magic Number,Shoko.Server.Repositories,AniDB_AnimeRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\AniDB_AnimeRepository.cs,GetDefaultImagesByAnime,The following statement contains a magic number: lock (globalDBLock)              {                  // TODO: Determine if joining on the correct columns                  var results = session.CreateSQLQuery(@"                  SELECT {defImg.*}' {tvWide.*}' {tvPoster.*}' {tvFanart.*}' {movPoster.*}' {movFanart.*}                      FROM AniDB_Anime_DefaultImage defImg                          LEFT OUTER JOIN TvDB_ImageWideBanner AS tvWide                              ON tvWide.TvDB_ImageWideBannerID = defImg.ImageParentID AND defImg.ImageParentType = :tvdbBannerType                          LEFT OUTER JOIN TvDB_ImagePoster AS tvPoster                              ON tvPoster.TvDB_ImagePosterID = defImg.ImageParentID AND defImg.ImageParentType = :tvdbCoverType                          LEFT OUTER JOIN TvDB_ImageFanart AS tvFanart                              ON tvFanart.TvDB_ImageFanartID = defImg.ImageParentID AND defImg.ImageParentType = :tvdbFanartType                          LEFT OUTER JOIN MovieDB_Poster AS movPoster                              ON movPoster.MovieDB_PosterID = defImg.ImageParentID AND defImg.ImageParentType = :movdbPosterType                          LEFT OUTER JOIN MovieDB_Fanart AS movFanart                              ON movFanart.MovieDB_FanartID = defImg.ImageParentID AND defImg.ImageParentType = :movdbFanartType                      WHERE defImg.AnimeID IN (:animeIds) AND defImg.ImageParentType IN (:tvdbBannerType' :tvdbCoverType' :tvdbFanartType' :movdbPosterType' :movdbFanartType)")                      .AddEntity("defImg"' typeof(AniDB_Anime_DefaultImage))                      .AddEntity("tvWide"' typeof(TvDB_ImageWideBanner))                      .AddEntity("tvPoster"' typeof(TvDB_ImagePoster))                      .AddEntity("tvFanart"' typeof(TvDB_ImageFanart))                      .AddEntity("movPoster"' typeof(MovieDB_Poster))                      .AddEntity("movFanart"' typeof(MovieDB_Fanart))                      .SetParameterList("animeIds"' animeIds)                      .SetInt32("tvdbBannerType"' (int) ImageEntityType.TvDB_Banner)                      .SetInt32("tvdbCoverType"' (int) ImageEntityType.TvDB_Cover)                      .SetInt32("tvdbFanartType"' (int) ImageEntityType.TvDB_FanArt)                      .SetInt32("movdbPosterType"' (int) ImageEntityType.MovieDB_Poster)                      .SetInt32("movdbFanartType"' (int) ImageEntityType.MovieDB_FanArt)                      .List<object[]>();                    foreach (object[] result in results)                  {                      var aniDbDefImage = (AniDB_Anime_DefaultImage) result[0];                      IImageEntity parentImage = null;                        switch ((ImageEntityType) aniDbDefImage.ImageParentType)                      {                          case ImageEntityType.TvDB_Banner:                              parentImage = (IImageEntity) result[1];                              break;                          case ImageEntityType.TvDB_Cover:                              parentImage = (IImageEntity) result[2];                              break;                          case ImageEntityType.TvDB_FanArt:                              parentImage = (IImageEntity) result[3];                              break;                          case ImageEntityType.MovieDB_Poster:                              parentImage = (IImageEntity) result[4];                              break;                          case ImageEntityType.MovieDB_FanArt:                              parentImage = (IImageEntity) result[5];                              break;                      }                        if (parentImage == null)                      {                          continue;                      }                        DefaultAnimeImage defImage = new DefaultAnimeImage(aniDbDefImage' parentImage);                        if (!defImagesByAnime.TryGetValue(aniDbDefImage.AnimeID' out DefaultAnimeImages defImages))                      {                          defImages = new DefaultAnimeImages {AnimeID = aniDbDefImage.AnimeID};                          defImagesByAnime.Add(defImages.AnimeID' defImages);                      }                        switch (defImage.AniDBImageSizeType)                      {                          case ImageSizeType.Poster:                              defImages.Poster = defImage;                              break;                          case ImageSizeType.WideBanner:                              defImages.WideBanner = defImage;                              break;                          case ImageSizeType.Fanart:                              defImages.Fanart = defImage;                              break;                      }                  }              }
Magic Number,Shoko.Server.Repositories,AniDB_AnimeRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\AniDB_AnimeRepository.cs,GetDefaultImagesByAnime,The following statement contains a magic number: lock (globalDBLock)              {                  // TODO: Determine if joining on the correct columns                  var results = session.CreateSQLQuery(@"                  SELECT {defImg.*}' {tvWide.*}' {tvPoster.*}' {tvFanart.*}' {movPoster.*}' {movFanart.*}                      FROM AniDB_Anime_DefaultImage defImg                          LEFT OUTER JOIN TvDB_ImageWideBanner AS tvWide                              ON tvWide.TvDB_ImageWideBannerID = defImg.ImageParentID AND defImg.ImageParentType = :tvdbBannerType                          LEFT OUTER JOIN TvDB_ImagePoster AS tvPoster                              ON tvPoster.TvDB_ImagePosterID = defImg.ImageParentID AND defImg.ImageParentType = :tvdbCoverType                          LEFT OUTER JOIN TvDB_ImageFanart AS tvFanart                              ON tvFanart.TvDB_ImageFanartID = defImg.ImageParentID AND defImg.ImageParentType = :tvdbFanartType                          LEFT OUTER JOIN MovieDB_Poster AS movPoster                              ON movPoster.MovieDB_PosterID = defImg.ImageParentID AND defImg.ImageParentType = :movdbPosterType                          LEFT OUTER JOIN MovieDB_Fanart AS movFanart                              ON movFanart.MovieDB_FanartID = defImg.ImageParentID AND defImg.ImageParentType = :movdbFanartType                      WHERE defImg.AnimeID IN (:animeIds) AND defImg.ImageParentType IN (:tvdbBannerType' :tvdbCoverType' :tvdbFanartType' :movdbPosterType' :movdbFanartType)")                      .AddEntity("defImg"' typeof(AniDB_Anime_DefaultImage))                      .AddEntity("tvWide"' typeof(TvDB_ImageWideBanner))                      .AddEntity("tvPoster"' typeof(TvDB_ImagePoster))                      .AddEntity("tvFanart"' typeof(TvDB_ImageFanart))                      .AddEntity("movPoster"' typeof(MovieDB_Poster))                      .AddEntity("movFanart"' typeof(MovieDB_Fanart))                      .SetParameterList("animeIds"' animeIds)                      .SetInt32("tvdbBannerType"' (int) ImageEntityType.TvDB_Banner)                      .SetInt32("tvdbCoverType"' (int) ImageEntityType.TvDB_Cover)                      .SetInt32("tvdbFanartType"' (int) ImageEntityType.TvDB_FanArt)                      .SetInt32("movdbPosterType"' (int) ImageEntityType.MovieDB_Poster)                      .SetInt32("movdbFanartType"' (int) ImageEntityType.MovieDB_FanArt)                      .List<object[]>();                    foreach (object[] result in results)                  {                      var aniDbDefImage = (AniDB_Anime_DefaultImage) result[0];                      IImageEntity parentImage = null;                        switch ((ImageEntityType) aniDbDefImage.ImageParentType)                      {                          case ImageEntityType.TvDB_Banner:                              parentImage = (IImageEntity) result[1];                              break;                          case ImageEntityType.TvDB_Cover:                              parentImage = (IImageEntity) result[2];                              break;                          case ImageEntityType.TvDB_FanArt:                              parentImage = (IImageEntity) result[3];                              break;                          case ImageEntityType.MovieDB_Poster:                              parentImage = (IImageEntity) result[4];                              break;                          case ImageEntityType.MovieDB_FanArt:                              parentImage = (IImageEntity) result[5];                              break;                      }                        if (parentImage == null)                      {                          continue;                      }                        DefaultAnimeImage defImage = new DefaultAnimeImage(aniDbDefImage' parentImage);                        if (!defImagesByAnime.TryGetValue(aniDbDefImage.AnimeID' out DefaultAnimeImages defImages))                      {                          defImages = new DefaultAnimeImages {AnimeID = aniDbDefImage.AnimeID};                          defImagesByAnime.Add(defImages.AnimeID' defImages);                      }                        switch (defImage.AniDBImageSizeType)                      {                          case ImageSizeType.Poster:                              defImages.Poster = defImage;                              break;                          case ImageSizeType.WideBanner:                              defImages.WideBanner = defImage;                              break;                          case ImageSizeType.Fanart:                              defImages.Fanart = defImage;                              break;                      }                  }              }
Magic Number,Shoko.Server.Repositories.Direct,CommandRequestRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Direct\CommandRequestRepository.cs,GetQueueIndex,The following statement contains a magic number: if (CommandTypesImages.Contains(req.CommandType))                  return 2;
Magic Number,Shoko.Server.Repositories.Direct,AniDB_CharacterRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Direct\AniDB_CharacterRepository.cs,GetCharacterAndSeiyuuByAnime,The following statement contains a magic number: var animeChars = session.CreateSQLQuery(@"                  SELECT animeChr.AnimeID' {chr.*}' {seiyuu.*}' animeChr.CharType                      FROM AniDB_Anime_Character AS animeChr                          INNER JOIN AniDB_Character AS chr                              ON chr.CharID = animeChr.CharID                          LEFT OUTER JOIN (                              SELECT ac.AnimeID' ac.CharID' MIN(cs.SeiyuuID) AS SeiyuuID                                  FROM AniDB_Anime_Character ac                                      INNER JOIN AniDB_Character_Seiyuu cs                                          ON cs.CharID = ac.CharID                                  GROUP BY ac.AnimeID' ac.CharID                              ) AS chrSeiyuu                              ON chrSeiyuu.CharID = chr.CharID                                  AND chrSeiyuu.AnimeID = animeChr.AnimeID                          LEFT OUTER JOIN AniDB_Seiyuu AS seiyuu                              ON seiyuu.SeiyuuID = chrSeiyuu.SeiyuuID                      WHERE animeChr.AnimeID IN (:animeIds)")                  .AddScalar("AnimeID"' NHibernateUtil.Int32)                  .AddEntity("chr"' typeof(AniDB_Character))                  .AddEntity("seiyuu"' typeof(AniDB_Seiyuu))                  .AddScalar("CharType"' NHibernateUtil.String)                  .SetParameterList("animeIds"' animeIds)                  .List<object[]>()                  .Select(r => new AnimeCharacterAndSeiyuu((int) r[0]' (AniDB_Character) r[1]' (AniDB_Seiyuu) r[2]'                      (string) r[3]))                  .ToLookup(ac => ac.AnimeID);
Magic Number,Shoko.Server.Repositories.Direct,AniDB_CharacterRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Direct\AniDB_CharacterRepository.cs,GetCharacterAndSeiyuuByAnime,The following statement contains a magic number: var animeChars = session.CreateSQLQuery(@"                  SELECT animeChr.AnimeID' {chr.*}' {seiyuu.*}' animeChr.CharType                      FROM AniDB_Anime_Character AS animeChr                          INNER JOIN AniDB_Character AS chr                              ON chr.CharID = animeChr.CharID                          LEFT OUTER JOIN (                              SELECT ac.AnimeID' ac.CharID' MIN(cs.SeiyuuID) AS SeiyuuID                                  FROM AniDB_Anime_Character ac                                      INNER JOIN AniDB_Character_Seiyuu cs                                          ON cs.CharID = ac.CharID                                  GROUP BY ac.AnimeID' ac.CharID                              ) AS chrSeiyuu                              ON chrSeiyuu.CharID = chr.CharID                                  AND chrSeiyuu.AnimeID = animeChr.AnimeID                          LEFT OUTER JOIN AniDB_Seiyuu AS seiyuu                              ON seiyuu.SeiyuuID = chrSeiyuu.SeiyuuID                      WHERE animeChr.AnimeID IN (:animeIds)")                  .AddScalar("AnimeID"' NHibernateUtil.Int32)                  .AddEntity("chr"' typeof(AniDB_Character))                  .AddEntity("seiyuu"' typeof(AniDB_Seiyuu))                  .AddScalar("CharType"' NHibernateUtil.String)                  .SetParameterList("animeIds"' animeIds)                  .List<object[]>()                  .Select(r => new AnimeCharacterAndSeiyuu((int) r[0]' (AniDB_Character) r[1]' (AniDB_Seiyuu) r[2]'                      (string) r[3]))                  .ToLookup(ac => ac.AnimeID);
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,GetLanguageFromCode3,The following statement contains a magic number: for (int x = 0; x < languages.GetUpperBound(0); x++)              {                  if (languages[x' 2] == code3)                  {                      return languages[x' 0];                  }              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,TranslateAudioStream,The following statement contains a magic number: if (!string.IsNullOrEmpty(fset) && (fset == "Little / Signed") && (s.Codec == "pcm") && (bitdepth == 16))              {                  s.Profile = "pcm_s16le";              }              else if (!string.IsNullOrEmpty(fset) && (fset == "Big / Signed") && (s.Codec == "pcm") && (bitdepth == 16))              {                  s.Profile = "pcm_s16be";              }              else if (!string.IsNullOrEmpty(fset) && (fset == "Little / Unsigned") && (s.Codec == "pcm") &&                       (bitdepth == 8))              {                  s.Profile = "pcm_u8";              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,TranslateAudioStream,The following statement contains a magic number: if (!string.IsNullOrEmpty(fset) && (fset == "Little / Signed") && (s.Codec == "pcm") && (bitdepth == 16))              {                  s.Profile = "pcm_s16le";              }              else if (!string.IsNullOrEmpty(fset) && (fset == "Big / Signed") && (s.Codec == "pcm") && (bitdepth == 16))              {                  s.Profile = "pcm_s16be";              }              else if (!string.IsNullOrEmpty(fset) && (fset == "Little / Unsigned") && (s.Codec == "pcm") &&                       (bitdepth == 8))              {                  s.Profile = "pcm_u8";              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,TranslateAudioStream,The following statement contains a magic number: if (!string.IsNullOrEmpty(fset) && (fset == "Little / Signed") && (s.Codec == "pcm") && (bitdepth == 16))              {                  s.Profile = "pcm_s16le";              }              else if (!string.IsNullOrEmpty(fset) && (fset == "Big / Signed") && (s.Codec == "pcm") && (bitdepth == 16))              {                  s.Profile = "pcm_s16be";              }              else if (!string.IsNullOrEmpty(fset) && (fset == "Little / Unsigned") && (s.Codec == "pcm") &&                       (bitdepth == 8))              {                  s.Profile = "pcm_u8";              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The following statement contains a magic number: try              {                  lock (_lock)                  {                      Media m = new Media();                      Part p = new Part();                      Thread mediaInfoThread = new Thread(() =>                      {                          if (minstance == null)                              minstance = new MediaInfoLib.MediaInfo();                          if (minstance.Open(filename) == 0) return; //it's a boolean response.                          Stream VideoStream = null;                          int video_count = minstance.GetInt(StreamKind.General' 0' "VideoCount");                          int audio_count = minstance.GetInt(StreamKind.General' 0' "AudioCount");                          int text_count = minstance.GetInt(StreamKind.General' 0' "TextCount");                          if (int.TryParse(minstance.Get(StreamKind.General' 0' "MenuCount")' out int chaptercount))                              m.Chaptered = chaptercount > 0;                          m.Duration = p.Duration = minstance.Get(StreamKind.General' 0' "Duration");                          m.Container = p.Container = TranslateContainer(minstance.Get(StreamKind.General' 0' "Format"));                          string codid = minstance.Get(StreamKind.General' 0' "CodecID");                          if (!string.IsNullOrEmpty(codid) && (codid.Trim().ToLower() == "qt"))                              m.Container = p.Container = "mov";                            int brate = minstance.GetInt(StreamKind.General' 0' "BitRate");                          if (brate != 0)                              m.Bitrate = Math.Round(brate / 1000F).ToString(CultureInfo.InvariantCulture);                          p.Size = minstance.Get(StreamKind.General' 0' "FileSize");                          List<Stream> streams = new List<Stream>();                          int iidx = 0;                          if (video_count > 0)                          {                              for (int x = 0; x < video_count; x++)                              {                                  Stream s = TranslateVideoStream(minstance' x);                                  if (x == 0)                                  {                                      VideoStream = s;                                      m.Width = s.Width;                                      m.Height = s.Height;                                      if (!string.IsNullOrEmpty(m.Height))                                      {                                          if (!string.IsNullOrEmpty(m.Width))                                          {                                              m.VideoResolution =                                                  GetResolution(float.Parse(m.Width)' float.Parse(m.Height));                                              m.AspectRatio =                                                  GetAspectRatio(float.Parse(m.Width)' float.Parse(m.Height)' s.PA);                                          }                                      }                                      if (!string.IsNullOrEmpty(s.FrameRate))                                      {                                          float fr = System.Convert.ToSingle(s.FrameRate);                                          m.VideoFrameRate =                                              ((int) Math.Round(fr)).ToString(CultureInfo.InvariantCulture);                                          if (!string.IsNullOrEmpty(s.ScanType))                                          {                                              if (s.ScanType.ToLower().Contains("int"))                                                  m.VideoFrameRate += "i";                                              else                                                  m.VideoFrameRate += "p";                                          }                                          else                                              m.VideoFrameRate += "p";                                          if ((m.VideoFrameRate == "25p") || (m.VideoFrameRate == "25i"))                                              m.VideoFrameRate = "PAL";                                          else if ((m.VideoFrameRate == "30p") || (m.VideoFrameRate == "30i"))                                              m.VideoFrameRate = "NTSC";                                      }                                      m.VideoCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (video_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                    if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          int totalsoundrate = 0;                          if (audio_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateAudioStream(minstance' x);                                  if ((s.Codec == "adpcm") && (p.Container == "flv"))                                      s.Codec = "adpcm_swf";                                  if (x == 0)                                  {                                      m.AudioCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      m.AudioChannels = s.Channels;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (audio_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                  if (!string.IsNullOrEmpty(s.Bitrate))                                  {                                      double.TryParse(s.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture'                                          out double birate);                                      totalsoundrate += brate;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          if ((VideoStream != null) && string.IsNullOrEmpty(VideoStream.Bitrate) &&                              !string.IsNullOrEmpty(m.Bitrate))                          {                              double.TryParse(m.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture' out double mrate);                              VideoStream.Bitrate =                                  (((int) mrate) - totalsoundrate).ToString(CultureInfo.InvariantCulture);                          }                          if (text_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateTextStream(minstance' x);                                  streams.Add(s);                                  if (text_count == 1)                                  {                                      s.Default = null;                                      s.Forced = null;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                              }                          }                          m.Parts = new List<Part>();                          m.Parts.Add(p);                          bool over = false;                          if (m.Container == "mkv")                          {                              int val = int.MaxValue;                              foreach (Stream s in streams)                              {                                  if (string.IsNullOrEmpty(s.Index))                                  {                                      over = true;                                      break;                                  }                                  s.idx = int.Parse(s.Index);                                  if (s.idx < val)                                      val = s.idx;                              }                              if ((val != 0) && !over)                              {                                  foreach (Stream s in streams)                                  {                                      s.idx = s.idx - val;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              else if (over)                              {                                  int xx = 0;                                  foreach (Stream s in streams)                                  {                                      s.idx = xx++;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              streams = streams.OrderBy(a => a.idx).ToList();                          }                          p.Streams = streams;                      });                      mediaInfoThread.Start();                      bool finished = mediaInfoThread.Join(TimeSpan.FromMinutes(5)); //TODO Move Timeout to settings                      if (!finished)                      {                          try                          {                              mediaInfoThread.Abort();                          }                          catch                          {                              /*ignored*/                          }                          try                          {                              CloseMediaInfo();                          }                          catch                          {                              /*ignored*/                          }                          return null;                      }                      if ((p.Container == "mp4") || (p.Container == "mov"))                      {                          p.Has64bitOffsets = "0";                          p.OptimizedForStreaming = "0";                          m.OptimizedForStreaming = "0";                          byte[] buffer = new byte[8];                          FileSystemResult<System.IO.Stream> fsr = file.OpenRead();                          if (fsr == null || !fsr.IsOk)                              return null;                          System.IO.Stream fs = fsr.Result;                          fs.Read(buffer' 0' 4);                          int siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];                          fs.Seek(siz' SeekOrigin.Begin);                          fs.Read(buffer' 0' 8);                          if ((buffer[4] == 'f') && (buffer[5] == 'r') && (buffer[6] == 'e') && (buffer[7] == 'e'))                          {                              siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] - 8);                              fs.Seek(siz' SeekOrigin.Current);                              fs.Read(buffer' 0' 8);                          }                          if ((buffer[4] == 'm') && (buffer[5] == 'o') && (buffer[6] == 'o') && (buffer[7] == 'v'))                          {                              p.OptimizedForStreaming = "1";                              m.OptimizedForStreaming = "1";                              siz = ((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]) - 8;                                buffer = new byte[siz];                              fs.Read(buffer' 0' siz);                              if (!FindInBuffer("trak"' 0' siz' buffer' out int opos' out int oposmax)) return m;                              if (!FindInBuffer("mdia"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("minf"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("stbl"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("co64"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              p.Has64bitOffsets = "1";                          }                      }                      return m;                  }              }              finally              {                  minstance?.Close();                    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;                  GC.Collect();              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The following statement contains a magic number: try              {                  lock (_lock)                  {                      Media m = new Media();                      Part p = new Part();                      Thread mediaInfoThread = new Thread(() =>                      {                          if (minstance == null)                              minstance = new MediaInfoLib.MediaInfo();                          if (minstance.Open(filename) == 0) return; //it's a boolean response.                          Stream VideoStream = null;                          int video_count = minstance.GetInt(StreamKind.General' 0' "VideoCount");                          int audio_count = minstance.GetInt(StreamKind.General' 0' "AudioCount");                          int text_count = minstance.GetInt(StreamKind.General' 0' "TextCount");                          if (int.TryParse(minstance.Get(StreamKind.General' 0' "MenuCount")' out int chaptercount))                              m.Chaptered = chaptercount > 0;                          m.Duration = p.Duration = minstance.Get(StreamKind.General' 0' "Duration");                          m.Container = p.Container = TranslateContainer(minstance.Get(StreamKind.General' 0' "Format"));                          string codid = minstance.Get(StreamKind.General' 0' "CodecID");                          if (!string.IsNullOrEmpty(codid) && (codid.Trim().ToLower() == "qt"))                              m.Container = p.Container = "mov";                            int brate = minstance.GetInt(StreamKind.General' 0' "BitRate");                          if (brate != 0)                              m.Bitrate = Math.Round(brate / 1000F).ToString(CultureInfo.InvariantCulture);                          p.Size = minstance.Get(StreamKind.General' 0' "FileSize");                          List<Stream> streams = new List<Stream>();                          int iidx = 0;                          if (video_count > 0)                          {                              for (int x = 0; x < video_count; x++)                              {                                  Stream s = TranslateVideoStream(minstance' x);                                  if (x == 0)                                  {                                      VideoStream = s;                                      m.Width = s.Width;                                      m.Height = s.Height;                                      if (!string.IsNullOrEmpty(m.Height))                                      {                                          if (!string.IsNullOrEmpty(m.Width))                                          {                                              m.VideoResolution =                                                  GetResolution(float.Parse(m.Width)' float.Parse(m.Height));                                              m.AspectRatio =                                                  GetAspectRatio(float.Parse(m.Width)' float.Parse(m.Height)' s.PA);                                          }                                      }                                      if (!string.IsNullOrEmpty(s.FrameRate))                                      {                                          float fr = System.Convert.ToSingle(s.FrameRate);                                          m.VideoFrameRate =                                              ((int) Math.Round(fr)).ToString(CultureInfo.InvariantCulture);                                          if (!string.IsNullOrEmpty(s.ScanType))                                          {                                              if (s.ScanType.ToLower().Contains("int"))                                                  m.VideoFrameRate += "i";                                              else                                                  m.VideoFrameRate += "p";                                          }                                          else                                              m.VideoFrameRate += "p";                                          if ((m.VideoFrameRate == "25p") || (m.VideoFrameRate == "25i"))                                              m.VideoFrameRate = "PAL";                                          else if ((m.VideoFrameRate == "30p") || (m.VideoFrameRate == "30i"))                                              m.VideoFrameRate = "NTSC";                                      }                                      m.VideoCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (video_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                    if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          int totalsoundrate = 0;                          if (audio_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateAudioStream(minstance' x);                                  if ((s.Codec == "adpcm") && (p.Container == "flv"))                                      s.Codec = "adpcm_swf";                                  if (x == 0)                                  {                                      m.AudioCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      m.AudioChannels = s.Channels;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (audio_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                  if (!string.IsNullOrEmpty(s.Bitrate))                                  {                                      double.TryParse(s.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture'                                          out double birate);                                      totalsoundrate += brate;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          if ((VideoStream != null) && string.IsNullOrEmpty(VideoStream.Bitrate) &&                              !string.IsNullOrEmpty(m.Bitrate))                          {                              double.TryParse(m.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture' out double mrate);                              VideoStream.Bitrate =                                  (((int) mrate) - totalsoundrate).ToString(CultureInfo.InvariantCulture);                          }                          if (text_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateTextStream(minstance' x);                                  streams.Add(s);                                  if (text_count == 1)                                  {                                      s.Default = null;                                      s.Forced = null;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                              }                          }                          m.Parts = new List<Part>();                          m.Parts.Add(p);                          bool over = false;                          if (m.Container == "mkv")                          {                              int val = int.MaxValue;                              foreach (Stream s in streams)                              {                                  if (string.IsNullOrEmpty(s.Index))                                  {                                      over = true;                                      break;                                  }                                  s.idx = int.Parse(s.Index);                                  if (s.idx < val)                                      val = s.idx;                              }                              if ((val != 0) && !over)                              {                                  foreach (Stream s in streams)                                  {                                      s.idx = s.idx - val;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              else if (over)                              {                                  int xx = 0;                                  foreach (Stream s in streams)                                  {                                      s.idx = xx++;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              streams = streams.OrderBy(a => a.idx).ToList();                          }                          p.Streams = streams;                      });                      mediaInfoThread.Start();                      bool finished = mediaInfoThread.Join(TimeSpan.FromMinutes(5)); //TODO Move Timeout to settings                      if (!finished)                      {                          try                          {                              mediaInfoThread.Abort();                          }                          catch                          {                              /*ignored*/                          }                          try                          {                              CloseMediaInfo();                          }                          catch                          {                              /*ignored*/                          }                          return null;                      }                      if ((p.Container == "mp4") || (p.Container == "mov"))                      {                          p.Has64bitOffsets = "0";                          p.OptimizedForStreaming = "0";                          m.OptimizedForStreaming = "0";                          byte[] buffer = new byte[8];                          FileSystemResult<System.IO.Stream> fsr = file.OpenRead();                          if (fsr == null || !fsr.IsOk)                              return null;                          System.IO.Stream fs = fsr.Result;                          fs.Read(buffer' 0' 4);                          int siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];                          fs.Seek(siz' SeekOrigin.Begin);                          fs.Read(buffer' 0' 8);                          if ((buffer[4] == 'f') && (buffer[5] == 'r') && (buffer[6] == 'e') && (buffer[7] == 'e'))                          {                              siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] - 8);                              fs.Seek(siz' SeekOrigin.Current);                              fs.Read(buffer' 0' 8);                          }                          if ((buffer[4] == 'm') && (buffer[5] == 'o') && (buffer[6] == 'o') && (buffer[7] == 'v'))                          {                              p.OptimizedForStreaming = "1";                              m.OptimizedForStreaming = "1";                              siz = ((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]) - 8;                                buffer = new byte[siz];                              fs.Read(buffer' 0' siz);                              if (!FindInBuffer("trak"' 0' siz' buffer' out int opos' out int oposmax)) return m;                              if (!FindInBuffer("mdia"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("minf"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("stbl"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("co64"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              p.Has64bitOffsets = "1";                          }                      }                      return m;                  }              }              finally              {                  minstance?.Close();                    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;                  GC.Collect();              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The following statement contains a magic number: try              {                  lock (_lock)                  {                      Media m = new Media();                      Part p = new Part();                      Thread mediaInfoThread = new Thread(() =>                      {                          if (minstance == null)                              minstance = new MediaInfoLib.MediaInfo();                          if (minstance.Open(filename) == 0) return; //it's a boolean response.                          Stream VideoStream = null;                          int video_count = minstance.GetInt(StreamKind.General' 0' "VideoCount");                          int audio_count = minstance.GetInt(StreamKind.General' 0' "AudioCount");                          int text_count = minstance.GetInt(StreamKind.General' 0' "TextCount");                          if (int.TryParse(minstance.Get(StreamKind.General' 0' "MenuCount")' out int chaptercount))                              m.Chaptered = chaptercount > 0;                          m.Duration = p.Duration = minstance.Get(StreamKind.General' 0' "Duration");                          m.Container = p.Container = TranslateContainer(minstance.Get(StreamKind.General' 0' "Format"));                          string codid = minstance.Get(StreamKind.General' 0' "CodecID");                          if (!string.IsNullOrEmpty(codid) && (codid.Trim().ToLower() == "qt"))                              m.Container = p.Container = "mov";                            int brate = minstance.GetInt(StreamKind.General' 0' "BitRate");                          if (brate != 0)                              m.Bitrate = Math.Round(brate / 1000F).ToString(CultureInfo.InvariantCulture);                          p.Size = minstance.Get(StreamKind.General' 0' "FileSize");                          List<Stream> streams = new List<Stream>();                          int iidx = 0;                          if (video_count > 0)                          {                              for (int x = 0; x < video_count; x++)                              {                                  Stream s = TranslateVideoStream(minstance' x);                                  if (x == 0)                                  {                                      VideoStream = s;                                      m.Width = s.Width;                                      m.Height = s.Height;                                      if (!string.IsNullOrEmpty(m.Height))                                      {                                          if (!string.IsNullOrEmpty(m.Width))                                          {                                              m.VideoResolution =                                                  GetResolution(float.Parse(m.Width)' float.Parse(m.Height));                                              m.AspectRatio =                                                  GetAspectRatio(float.Parse(m.Width)' float.Parse(m.Height)' s.PA);                                          }                                      }                                      if (!string.IsNullOrEmpty(s.FrameRate))                                      {                                          float fr = System.Convert.ToSingle(s.FrameRate);                                          m.VideoFrameRate =                                              ((int) Math.Round(fr)).ToString(CultureInfo.InvariantCulture);                                          if (!string.IsNullOrEmpty(s.ScanType))                                          {                                              if (s.ScanType.ToLower().Contains("int"))                                                  m.VideoFrameRate += "i";                                              else                                                  m.VideoFrameRate += "p";                                          }                                          else                                              m.VideoFrameRate += "p";                                          if ((m.VideoFrameRate == "25p") || (m.VideoFrameRate == "25i"))                                              m.VideoFrameRate = "PAL";                                          else if ((m.VideoFrameRate == "30p") || (m.VideoFrameRate == "30i"))                                              m.VideoFrameRate = "NTSC";                                      }                                      m.VideoCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (video_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                    if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          int totalsoundrate = 0;                          if (audio_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateAudioStream(minstance' x);                                  if ((s.Codec == "adpcm") && (p.Container == "flv"))                                      s.Codec = "adpcm_swf";                                  if (x == 0)                                  {                                      m.AudioCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      m.AudioChannels = s.Channels;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (audio_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                  if (!string.IsNullOrEmpty(s.Bitrate))                                  {                                      double.TryParse(s.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture'                                          out double birate);                                      totalsoundrate += brate;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          if ((VideoStream != null) && string.IsNullOrEmpty(VideoStream.Bitrate) &&                              !string.IsNullOrEmpty(m.Bitrate))                          {                              double.TryParse(m.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture' out double mrate);                              VideoStream.Bitrate =                                  (((int) mrate) - totalsoundrate).ToString(CultureInfo.InvariantCulture);                          }                          if (text_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateTextStream(minstance' x);                                  streams.Add(s);                                  if (text_count == 1)                                  {                                      s.Default = null;                                      s.Forced = null;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                              }                          }                          m.Parts = new List<Part>();                          m.Parts.Add(p);                          bool over = false;                          if (m.Container == "mkv")                          {                              int val = int.MaxValue;                              foreach (Stream s in streams)                              {                                  if (string.IsNullOrEmpty(s.Index))                                  {                                      over = true;                                      break;                                  }                                  s.idx = int.Parse(s.Index);                                  if (s.idx < val)                                      val = s.idx;                              }                              if ((val != 0) && !over)                              {                                  foreach (Stream s in streams)                                  {                                      s.idx = s.idx - val;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              else if (over)                              {                                  int xx = 0;                                  foreach (Stream s in streams)                                  {                                      s.idx = xx++;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              streams = streams.OrderBy(a => a.idx).ToList();                          }                          p.Streams = streams;                      });                      mediaInfoThread.Start();                      bool finished = mediaInfoThread.Join(TimeSpan.FromMinutes(5)); //TODO Move Timeout to settings                      if (!finished)                      {                          try                          {                              mediaInfoThread.Abort();                          }                          catch                          {                              /*ignored*/                          }                          try                          {                              CloseMediaInfo();                          }                          catch                          {                              /*ignored*/                          }                          return null;                      }                      if ((p.Container == "mp4") || (p.Container == "mov"))                      {                          p.Has64bitOffsets = "0";                          p.OptimizedForStreaming = "0";                          m.OptimizedForStreaming = "0";                          byte[] buffer = new byte[8];                          FileSystemResult<System.IO.Stream> fsr = file.OpenRead();                          if (fsr == null || !fsr.IsOk)                              return null;                          System.IO.Stream fs = fsr.Result;                          fs.Read(buffer' 0' 4);                          int siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];                          fs.Seek(siz' SeekOrigin.Begin);                          fs.Read(buffer' 0' 8);                          if ((buffer[4] == 'f') && (buffer[5] == 'r') && (buffer[6] == 'e') && (buffer[7] == 'e'))                          {                              siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] - 8);                              fs.Seek(siz' SeekOrigin.Current);                              fs.Read(buffer' 0' 8);                          }                          if ((buffer[4] == 'm') && (buffer[5] == 'o') && (buffer[6] == 'o') && (buffer[7] == 'v'))                          {                              p.OptimizedForStreaming = "1";                              m.OptimizedForStreaming = "1";                              siz = ((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]) - 8;                                buffer = new byte[siz];                              fs.Read(buffer' 0' siz);                              if (!FindInBuffer("trak"' 0' siz' buffer' out int opos' out int oposmax)) return m;                              if (!FindInBuffer("mdia"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("minf"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("stbl"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("co64"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              p.Has64bitOffsets = "1";                          }                      }                      return m;                  }              }              finally              {                  minstance?.Close();                    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;                  GC.Collect();              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The following statement contains a magic number: try              {                  lock (_lock)                  {                      Media m = new Media();                      Part p = new Part();                      Thread mediaInfoThread = new Thread(() =>                      {                          if (minstance == null)                              minstance = new MediaInfoLib.MediaInfo();                          if (minstance.Open(filename) == 0) return; //it's a boolean response.                          Stream VideoStream = null;                          int video_count = minstance.GetInt(StreamKind.General' 0' "VideoCount");                          int audio_count = minstance.GetInt(StreamKind.General' 0' "AudioCount");                          int text_count = minstance.GetInt(StreamKind.General' 0' "TextCount");                          if (int.TryParse(minstance.Get(StreamKind.General' 0' "MenuCount")' out int chaptercount))                              m.Chaptered = chaptercount > 0;                          m.Duration = p.Duration = minstance.Get(StreamKind.General' 0' "Duration");                          m.Container = p.Container = TranslateContainer(minstance.Get(StreamKind.General' 0' "Format"));                          string codid = minstance.Get(StreamKind.General' 0' "CodecID");                          if (!string.IsNullOrEmpty(codid) && (codid.Trim().ToLower() == "qt"))                              m.Container = p.Container = "mov";                            int brate = minstance.GetInt(StreamKind.General' 0' "BitRate");                          if (brate != 0)                              m.Bitrate = Math.Round(brate / 1000F).ToString(CultureInfo.InvariantCulture);                          p.Size = minstance.Get(StreamKind.General' 0' "FileSize");                          List<Stream> streams = new List<Stream>();                          int iidx = 0;                          if (video_count > 0)                          {                              for (int x = 0; x < video_count; x++)                              {                                  Stream s = TranslateVideoStream(minstance' x);                                  if (x == 0)                                  {                                      VideoStream = s;                                      m.Width = s.Width;                                      m.Height = s.Height;                                      if (!string.IsNullOrEmpty(m.Height))                                      {                                          if (!string.IsNullOrEmpty(m.Width))                                          {                                              m.VideoResolution =                                                  GetResolution(float.Parse(m.Width)' float.Parse(m.Height));                                              m.AspectRatio =                                                  GetAspectRatio(float.Parse(m.Width)' float.Parse(m.Height)' s.PA);                                          }                                      }                                      if (!string.IsNullOrEmpty(s.FrameRate))                                      {                                          float fr = System.Convert.ToSingle(s.FrameRate);                                          m.VideoFrameRate =                                              ((int) Math.Round(fr)).ToString(CultureInfo.InvariantCulture);                                          if (!string.IsNullOrEmpty(s.ScanType))                                          {                                              if (s.ScanType.ToLower().Contains("int"))                                                  m.VideoFrameRate += "i";                                              else                                                  m.VideoFrameRate += "p";                                          }                                          else                                              m.VideoFrameRate += "p";                                          if ((m.VideoFrameRate == "25p") || (m.VideoFrameRate == "25i"))                                              m.VideoFrameRate = "PAL";                                          else if ((m.VideoFrameRate == "30p") || (m.VideoFrameRate == "30i"))                                              m.VideoFrameRate = "NTSC";                                      }                                      m.VideoCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (video_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                    if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          int totalsoundrate = 0;                          if (audio_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateAudioStream(minstance' x);                                  if ((s.Codec == "adpcm") && (p.Container == "flv"))                                      s.Codec = "adpcm_swf";                                  if (x == 0)                                  {                                      m.AudioCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      m.AudioChannels = s.Channels;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (audio_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                  if (!string.IsNullOrEmpty(s.Bitrate))                                  {                                      double.TryParse(s.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture'                                          out double birate);                                      totalsoundrate += brate;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          if ((VideoStream != null) && string.IsNullOrEmpty(VideoStream.Bitrate) &&                              !string.IsNullOrEmpty(m.Bitrate))                          {                              double.TryParse(m.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture' out double mrate);                              VideoStream.Bitrate =                                  (((int) mrate) - totalsoundrate).ToString(CultureInfo.InvariantCulture);                          }                          if (text_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateTextStream(minstance' x);                                  streams.Add(s);                                  if (text_count == 1)                                  {                                      s.Default = null;                                      s.Forced = null;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                              }                          }                          m.Parts = new List<Part>();                          m.Parts.Add(p);                          bool over = false;                          if (m.Container == "mkv")                          {                              int val = int.MaxValue;                              foreach (Stream s in streams)                              {                                  if (string.IsNullOrEmpty(s.Index))                                  {                                      over = true;                                      break;                                  }                                  s.idx = int.Parse(s.Index);                                  if (s.idx < val)                                      val = s.idx;                              }                              if ((val != 0) && !over)                              {                                  foreach (Stream s in streams)                                  {                                      s.idx = s.idx - val;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              else if (over)                              {                                  int xx = 0;                                  foreach (Stream s in streams)                                  {                                      s.idx = xx++;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              streams = streams.OrderBy(a => a.idx).ToList();                          }                          p.Streams = streams;                      });                      mediaInfoThread.Start();                      bool finished = mediaInfoThread.Join(TimeSpan.FromMinutes(5)); //TODO Move Timeout to settings                      if (!finished)                      {                          try                          {                              mediaInfoThread.Abort();                          }                          catch                          {                              /*ignored*/                          }                          try                          {                              CloseMediaInfo();                          }                          catch                          {                              /*ignored*/                          }                          return null;                      }                      if ((p.Container == "mp4") || (p.Container == "mov"))                      {                          p.Has64bitOffsets = "0";                          p.OptimizedForStreaming = "0";                          m.OptimizedForStreaming = "0";                          byte[] buffer = new byte[8];                          FileSystemResult<System.IO.Stream> fsr = file.OpenRead();                          if (fsr == null || !fsr.IsOk)                              return null;                          System.IO.Stream fs = fsr.Result;                          fs.Read(buffer' 0' 4);                          int siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];                          fs.Seek(siz' SeekOrigin.Begin);                          fs.Read(buffer' 0' 8);                          if ((buffer[4] == 'f') && (buffer[5] == 'r') && (buffer[6] == 'e') && (buffer[7] == 'e'))                          {                              siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] - 8);                              fs.Seek(siz' SeekOrigin.Current);                              fs.Read(buffer' 0' 8);                          }                          if ((buffer[4] == 'm') && (buffer[5] == 'o') && (buffer[6] == 'o') && (buffer[7] == 'v'))                          {                              p.OptimizedForStreaming = "1";                              m.OptimizedForStreaming = "1";                              siz = ((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]) - 8;                                buffer = new byte[siz];                              fs.Read(buffer' 0' siz);                              if (!FindInBuffer("trak"' 0' siz' buffer' out int opos' out int oposmax)) return m;                              if (!FindInBuffer("mdia"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("minf"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("stbl"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("co64"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              p.Has64bitOffsets = "1";                          }                      }                      return m;                  }              }              finally              {                  minstance?.Close();                    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;                  GC.Collect();              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The following statement contains a magic number: try              {                  lock (_lock)                  {                      Media m = new Media();                      Part p = new Part();                      Thread mediaInfoThread = new Thread(() =>                      {                          if (minstance == null)                              minstance = new MediaInfoLib.MediaInfo();                          if (minstance.Open(filename) == 0) return; //it's a boolean response.                          Stream VideoStream = null;                          int video_count = minstance.GetInt(StreamKind.General' 0' "VideoCount");                          int audio_count = minstance.GetInt(StreamKind.General' 0' "AudioCount");                          int text_count = minstance.GetInt(StreamKind.General' 0' "TextCount");                          if (int.TryParse(minstance.Get(StreamKind.General' 0' "MenuCount")' out int chaptercount))                              m.Chaptered = chaptercount > 0;                          m.Duration = p.Duration = minstance.Get(StreamKind.General' 0' "Duration");                          m.Container = p.Container = TranslateContainer(minstance.Get(StreamKind.General' 0' "Format"));                          string codid = minstance.Get(StreamKind.General' 0' "CodecID");                          if (!string.IsNullOrEmpty(codid) && (codid.Trim().ToLower() == "qt"))                              m.Container = p.Container = "mov";                            int brate = minstance.GetInt(StreamKind.General' 0' "BitRate");                          if (brate != 0)                              m.Bitrate = Math.Round(brate / 1000F).ToString(CultureInfo.InvariantCulture);                          p.Size = minstance.Get(StreamKind.General' 0' "FileSize");                          List<Stream> streams = new List<Stream>();                          int iidx = 0;                          if (video_count > 0)                          {                              for (int x = 0; x < video_count; x++)                              {                                  Stream s = TranslateVideoStream(minstance' x);                                  if (x == 0)                                  {                                      VideoStream = s;                                      m.Width = s.Width;                                      m.Height = s.Height;                                      if (!string.IsNullOrEmpty(m.Height))                                      {                                          if (!string.IsNullOrEmpty(m.Width))                                          {                                              m.VideoResolution =                                                  GetResolution(float.Parse(m.Width)' float.Parse(m.Height));                                              m.AspectRatio =                                                  GetAspectRatio(float.Parse(m.Width)' float.Parse(m.Height)' s.PA);                                          }                                      }                                      if (!string.IsNullOrEmpty(s.FrameRate))                                      {                                          float fr = System.Convert.ToSingle(s.FrameRate);                                          m.VideoFrameRate =                                              ((int) Math.Round(fr)).ToString(CultureInfo.InvariantCulture);                                          if (!string.IsNullOrEmpty(s.ScanType))                                          {                                              if (s.ScanType.ToLower().Contains("int"))                                                  m.VideoFrameRate += "i";                                              else                                                  m.VideoFrameRate += "p";                                          }                                          else                                              m.VideoFrameRate += "p";                                          if ((m.VideoFrameRate == "25p") || (m.VideoFrameRate == "25i"))                                              m.VideoFrameRate = "PAL";                                          else if ((m.VideoFrameRate == "30p") || (m.VideoFrameRate == "30i"))                                              m.VideoFrameRate = "NTSC";                                      }                                      m.VideoCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (video_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                    if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          int totalsoundrate = 0;                          if (audio_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateAudioStream(minstance' x);                                  if ((s.Codec == "adpcm") && (p.Container == "flv"))                                      s.Codec = "adpcm_swf";                                  if (x == 0)                                  {                                      m.AudioCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      m.AudioChannels = s.Channels;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (audio_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                  if (!string.IsNullOrEmpty(s.Bitrate))                                  {                                      double.TryParse(s.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture'                                          out double birate);                                      totalsoundrate += brate;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          if ((VideoStream != null) && string.IsNullOrEmpty(VideoStream.Bitrate) &&                              !string.IsNullOrEmpty(m.Bitrate))                          {                              double.TryParse(m.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture' out double mrate);                              VideoStream.Bitrate =                                  (((int) mrate) - totalsoundrate).ToString(CultureInfo.InvariantCulture);                          }                          if (text_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateTextStream(minstance' x);                                  streams.Add(s);                                  if (text_count == 1)                                  {                                      s.Default = null;                                      s.Forced = null;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                              }                          }                          m.Parts = new List<Part>();                          m.Parts.Add(p);                          bool over = false;                          if (m.Container == "mkv")                          {                              int val = int.MaxValue;                              foreach (Stream s in streams)                              {                                  if (string.IsNullOrEmpty(s.Index))                                  {                                      over = true;                                      break;                                  }                                  s.idx = int.Parse(s.Index);                                  if (s.idx < val)                                      val = s.idx;                              }                              if ((val != 0) && !over)                              {                                  foreach (Stream s in streams)                                  {                                      s.idx = s.idx - val;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              else if (over)                              {                                  int xx = 0;                                  foreach (Stream s in streams)                                  {                                      s.idx = xx++;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              streams = streams.OrderBy(a => a.idx).ToList();                          }                          p.Streams = streams;                      });                      mediaInfoThread.Start();                      bool finished = mediaInfoThread.Join(TimeSpan.FromMinutes(5)); //TODO Move Timeout to settings                      if (!finished)                      {                          try                          {                              mediaInfoThread.Abort();                          }                          catch                          {                              /*ignored*/                          }                          try                          {                              CloseMediaInfo();                          }                          catch                          {                              /*ignored*/                          }                          return null;                      }                      if ((p.Container == "mp4") || (p.Container == "mov"))                      {                          p.Has64bitOffsets = "0";                          p.OptimizedForStreaming = "0";                          m.OptimizedForStreaming = "0";                          byte[] buffer = new byte[8];                          FileSystemResult<System.IO.Stream> fsr = file.OpenRead();                          if (fsr == null || !fsr.IsOk)                              return null;                          System.IO.Stream fs = fsr.Result;                          fs.Read(buffer' 0' 4);                          int siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];                          fs.Seek(siz' SeekOrigin.Begin);                          fs.Read(buffer' 0' 8);                          if ((buffer[4] == 'f') && (buffer[5] == 'r') && (buffer[6] == 'e') && (buffer[7] == 'e'))                          {                              siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] - 8);                              fs.Seek(siz' SeekOrigin.Current);                              fs.Read(buffer' 0' 8);                          }                          if ((buffer[4] == 'm') && (buffer[5] == 'o') && (buffer[6] == 'o') && (buffer[7] == 'v'))                          {                              p.OptimizedForStreaming = "1";                              m.OptimizedForStreaming = "1";                              siz = ((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]) - 8;                                buffer = new byte[siz];                              fs.Read(buffer' 0' siz);                              if (!FindInBuffer("trak"' 0' siz' buffer' out int opos' out int oposmax)) return m;                              if (!FindInBuffer("mdia"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("minf"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("stbl"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("co64"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              p.Has64bitOffsets = "1";                          }                      }                      return m;                  }              }              finally              {                  minstance?.Close();                    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;                  GC.Collect();              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The following statement contains a magic number: try              {                  lock (_lock)                  {                      Media m = new Media();                      Part p = new Part();                      Thread mediaInfoThread = new Thread(() =>                      {                          if (minstance == null)                              minstance = new MediaInfoLib.MediaInfo();                          if (minstance.Open(filename) == 0) return; //it's a boolean response.                          Stream VideoStream = null;                          int video_count = minstance.GetInt(StreamKind.General' 0' "VideoCount");                          int audio_count = minstance.GetInt(StreamKind.General' 0' "AudioCount");                          int text_count = minstance.GetInt(StreamKind.General' 0' "TextCount");                          if (int.TryParse(minstance.Get(StreamKind.General' 0' "MenuCount")' out int chaptercount))                              m.Chaptered = chaptercount > 0;                          m.Duration = p.Duration = minstance.Get(StreamKind.General' 0' "Duration");                          m.Container = p.Container = TranslateContainer(minstance.Get(StreamKind.General' 0' "Format"));                          string codid = minstance.Get(StreamKind.General' 0' "CodecID");                          if (!string.IsNullOrEmpty(codid) && (codid.Trim().ToLower() == "qt"))                              m.Container = p.Container = "mov";                            int brate = minstance.GetInt(StreamKind.General' 0' "BitRate");                          if (brate != 0)                              m.Bitrate = Math.Round(brate / 1000F).ToString(CultureInfo.InvariantCulture);                          p.Size = minstance.Get(StreamKind.General' 0' "FileSize");                          List<Stream> streams = new List<Stream>();                          int iidx = 0;                          if (video_count > 0)                          {                              for (int x = 0; x < video_count; x++)                              {                                  Stream s = TranslateVideoStream(minstance' x);                                  if (x == 0)                                  {                                      VideoStream = s;                                      m.Width = s.Width;                                      m.Height = s.Height;                                      if (!string.IsNullOrEmpty(m.Height))                                      {                                          if (!string.IsNullOrEmpty(m.Width))                                          {                                              m.VideoResolution =                                                  GetResolution(float.Parse(m.Width)' float.Parse(m.Height));                                              m.AspectRatio =                                                  GetAspectRatio(float.Parse(m.Width)' float.Parse(m.Height)' s.PA);                                          }                                      }                                      if (!string.IsNullOrEmpty(s.FrameRate))                                      {                                          float fr = System.Convert.ToSingle(s.FrameRate);                                          m.VideoFrameRate =                                              ((int) Math.Round(fr)).ToString(CultureInfo.InvariantCulture);                                          if (!string.IsNullOrEmpty(s.ScanType))                                          {                                              if (s.ScanType.ToLower().Contains("int"))                                                  m.VideoFrameRate += "i";                                              else                                                  m.VideoFrameRate += "p";                                          }                                          else                                              m.VideoFrameRate += "p";                                          if ((m.VideoFrameRate == "25p") || (m.VideoFrameRate == "25i"))                                              m.VideoFrameRate = "PAL";                                          else if ((m.VideoFrameRate == "30p") || (m.VideoFrameRate == "30i"))                                              m.VideoFrameRate = "NTSC";                                      }                                      m.VideoCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (video_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                    if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          int totalsoundrate = 0;                          if (audio_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateAudioStream(minstance' x);                                  if ((s.Codec == "adpcm") && (p.Container == "flv"))                                      s.Codec = "adpcm_swf";                                  if (x == 0)                                  {                                      m.AudioCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      m.AudioChannels = s.Channels;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (audio_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                  if (!string.IsNullOrEmpty(s.Bitrate))                                  {                                      double.TryParse(s.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture'                                          out double birate);                                      totalsoundrate += brate;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          if ((VideoStream != null) && string.IsNullOrEmpty(VideoStream.Bitrate) &&                              !string.IsNullOrEmpty(m.Bitrate))                          {                              double.TryParse(m.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture' out double mrate);                              VideoStream.Bitrate =                                  (((int) mrate) - totalsoundrate).ToString(CultureInfo.InvariantCulture);                          }                          if (text_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateTextStream(minstance' x);                                  streams.Add(s);                                  if (text_count == 1)                                  {                                      s.Default = null;                                      s.Forced = null;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                              }                          }                          m.Parts = new List<Part>();                          m.Parts.Add(p);                          bool over = false;                          if (m.Container == "mkv")                          {                              int val = int.MaxValue;                              foreach (Stream s in streams)                              {                                  if (string.IsNullOrEmpty(s.Index))                                  {                                      over = true;                                      break;                                  }                                  s.idx = int.Parse(s.Index);                                  if (s.idx < val)                                      val = s.idx;                              }                              if ((val != 0) && !over)                              {                                  foreach (Stream s in streams)                                  {                                      s.idx = s.idx - val;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              else if (over)                              {                                  int xx = 0;                                  foreach (Stream s in streams)                                  {                                      s.idx = xx++;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              streams = streams.OrderBy(a => a.idx).ToList();                          }                          p.Streams = streams;                      });                      mediaInfoThread.Start();                      bool finished = mediaInfoThread.Join(TimeSpan.FromMinutes(5)); //TODO Move Timeout to settings                      if (!finished)                      {                          try                          {                              mediaInfoThread.Abort();                          }                          catch                          {                              /*ignored*/                          }                          try                          {                              CloseMediaInfo();                          }                          catch                          {                              /*ignored*/                          }                          return null;                      }                      if ((p.Container == "mp4") || (p.Container == "mov"))                      {                          p.Has64bitOffsets = "0";                          p.OptimizedForStreaming = "0";                          m.OptimizedForStreaming = "0";                          byte[] buffer = new byte[8];                          FileSystemResult<System.IO.Stream> fsr = file.OpenRead();                          if (fsr == null || !fsr.IsOk)                              return null;                          System.IO.Stream fs = fsr.Result;                          fs.Read(buffer' 0' 4);                          int siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];                          fs.Seek(siz' SeekOrigin.Begin);                          fs.Read(buffer' 0' 8);                          if ((buffer[4] == 'f') && (buffer[5] == 'r') && (buffer[6] == 'e') && (buffer[7] == 'e'))                          {                              siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] - 8);                              fs.Seek(siz' SeekOrigin.Current);                              fs.Read(buffer' 0' 8);                          }                          if ((buffer[4] == 'm') && (buffer[5] == 'o') && (buffer[6] == 'o') && (buffer[7] == 'v'))                          {                              p.OptimizedForStreaming = "1";                              m.OptimizedForStreaming = "1";                              siz = ((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]) - 8;                                buffer = new byte[siz];                              fs.Read(buffer' 0' siz);                              if (!FindInBuffer("trak"' 0' siz' buffer' out int opos' out int oposmax)) return m;                              if (!FindInBuffer("mdia"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("minf"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("stbl"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("co64"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              p.Has64bitOffsets = "1";                          }                      }                      return m;                  }              }              finally              {                  minstance?.Close();                    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;                  GC.Collect();              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The following statement contains a magic number: try              {                  lock (_lock)                  {                      Media m = new Media();                      Part p = new Part();                      Thread mediaInfoThread = new Thread(() =>                      {                          if (minstance == null)                              minstance = new MediaInfoLib.MediaInfo();                          if (minstance.Open(filename) == 0) return; //it's a boolean response.                          Stream VideoStream = null;                          int video_count = minstance.GetInt(StreamKind.General' 0' "VideoCount");                          int audio_count = minstance.GetInt(StreamKind.General' 0' "AudioCount");                          int text_count = minstance.GetInt(StreamKind.General' 0' "TextCount");                          if (int.TryParse(minstance.Get(StreamKind.General' 0' "MenuCount")' out int chaptercount))                              m.Chaptered = chaptercount > 0;                          m.Duration = p.Duration = minstance.Get(StreamKind.General' 0' "Duration");                          m.Container = p.Container = TranslateContainer(minstance.Get(StreamKind.General' 0' "Format"));                          string codid = minstance.Get(StreamKind.General' 0' "CodecID");                          if (!string.IsNullOrEmpty(codid) && (codid.Trim().ToLower() == "qt"))                              m.Container = p.Container = "mov";                            int brate = minstance.GetInt(StreamKind.General' 0' "BitRate");                          if (brate != 0)                              m.Bitrate = Math.Round(brate / 1000F).ToString(CultureInfo.InvariantCulture);                          p.Size = minstance.Get(StreamKind.General' 0' "FileSize");                          List<Stream> streams = new List<Stream>();                          int iidx = 0;                          if (video_count > 0)                          {                              for (int x = 0; x < video_count; x++)                              {                                  Stream s = TranslateVideoStream(minstance' x);                                  if (x == 0)                                  {                                      VideoStream = s;                                      m.Width = s.Width;                                      m.Height = s.Height;                                      if (!string.IsNullOrEmpty(m.Height))                                      {                                          if (!string.IsNullOrEmpty(m.Width))                                          {                                              m.VideoResolution =                                                  GetResolution(float.Parse(m.Width)' float.Parse(m.Height));                                              m.AspectRatio =                                                  GetAspectRatio(float.Parse(m.Width)' float.Parse(m.Height)' s.PA);                                          }                                      }                                      if (!string.IsNullOrEmpty(s.FrameRate))                                      {                                          float fr = System.Convert.ToSingle(s.FrameRate);                                          m.VideoFrameRate =                                              ((int) Math.Round(fr)).ToString(CultureInfo.InvariantCulture);                                          if (!string.IsNullOrEmpty(s.ScanType))                                          {                                              if (s.ScanType.ToLower().Contains("int"))                                                  m.VideoFrameRate += "i";                                              else                                                  m.VideoFrameRate += "p";                                          }                                          else                                              m.VideoFrameRate += "p";                                          if ((m.VideoFrameRate == "25p") || (m.VideoFrameRate == "25i"))                                              m.VideoFrameRate = "PAL";                                          else if ((m.VideoFrameRate == "30p") || (m.VideoFrameRate == "30i"))                                              m.VideoFrameRate = "NTSC";                                      }                                      m.VideoCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (video_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                    if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          int totalsoundrate = 0;                          if (audio_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateAudioStream(minstance' x);                                  if ((s.Codec == "adpcm") && (p.Container == "flv"))                                      s.Codec = "adpcm_swf";                                  if (x == 0)                                  {                                      m.AudioCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      m.AudioChannels = s.Channels;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (audio_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                  if (!string.IsNullOrEmpty(s.Bitrate))                                  {                                      double.TryParse(s.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture'                                          out double birate);                                      totalsoundrate += brate;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          if ((VideoStream != null) && string.IsNullOrEmpty(VideoStream.Bitrate) &&                              !string.IsNullOrEmpty(m.Bitrate))                          {                              double.TryParse(m.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture' out double mrate);                              VideoStream.Bitrate =                                  (((int) mrate) - totalsoundrate).ToString(CultureInfo.InvariantCulture);                          }                          if (text_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateTextStream(minstance' x);                                  streams.Add(s);                                  if (text_count == 1)                                  {                                      s.Default = null;                                      s.Forced = null;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                              }                          }                          m.Parts = new List<Part>();                          m.Parts.Add(p);                          bool over = false;                          if (m.Container == "mkv")                          {                              int val = int.MaxValue;                              foreach (Stream s in streams)                              {                                  if (string.IsNullOrEmpty(s.Index))                                  {                                      over = true;                                      break;                                  }                                  s.idx = int.Parse(s.Index);                                  if (s.idx < val)                                      val = s.idx;                              }                              if ((val != 0) && !over)                              {                                  foreach (Stream s in streams)                                  {                                      s.idx = s.idx - val;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              else if (over)                              {                                  int xx = 0;                                  foreach (Stream s in streams)                                  {                                      s.idx = xx++;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              streams = streams.OrderBy(a => a.idx).ToList();                          }                          p.Streams = streams;                      });                      mediaInfoThread.Start();                      bool finished = mediaInfoThread.Join(TimeSpan.FromMinutes(5)); //TODO Move Timeout to settings                      if (!finished)                      {                          try                          {                              mediaInfoThread.Abort();                          }                          catch                          {                              /*ignored*/                          }                          try                          {                              CloseMediaInfo();                          }                          catch                          {                              /*ignored*/                          }                          return null;                      }                      if ((p.Container == "mp4") || (p.Container == "mov"))                      {                          p.Has64bitOffsets = "0";                          p.OptimizedForStreaming = "0";                          m.OptimizedForStreaming = "0";                          byte[] buffer = new byte[8];                          FileSystemResult<System.IO.Stream> fsr = file.OpenRead();                          if (fsr == null || !fsr.IsOk)                              return null;                          System.IO.Stream fs = fsr.Result;                          fs.Read(buffer' 0' 4);                          int siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];                          fs.Seek(siz' SeekOrigin.Begin);                          fs.Read(buffer' 0' 8);                          if ((buffer[4] == 'f') && (buffer[5] == 'r') && (buffer[6] == 'e') && (buffer[7] == 'e'))                          {                              siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] - 8);                              fs.Seek(siz' SeekOrigin.Current);                              fs.Read(buffer' 0' 8);                          }                          if ((buffer[4] == 'm') && (buffer[5] == 'o') && (buffer[6] == 'o') && (buffer[7] == 'v'))                          {                              p.OptimizedForStreaming = "1";                              m.OptimizedForStreaming = "1";                              siz = ((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]) - 8;                                buffer = new byte[siz];                              fs.Read(buffer' 0' siz);                              if (!FindInBuffer("trak"' 0' siz' buffer' out int opos' out int oposmax)) return m;                              if (!FindInBuffer("mdia"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("minf"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("stbl"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("co64"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              p.Has64bitOffsets = "1";                          }                      }                      return m;                  }              }              finally              {                  minstance?.Close();                    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;                  GC.Collect();              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The following statement contains a magic number: try              {                  lock (_lock)                  {                      Media m = new Media();                      Part p = new Part();                      Thread mediaInfoThread = new Thread(() =>                      {                          if (minstance == null)                              minstance = new MediaInfoLib.MediaInfo();                          if (minstance.Open(filename) == 0) return; //it's a boolean response.                          Stream VideoStream = null;                          int video_count = minstance.GetInt(StreamKind.General' 0' "VideoCount");                          int audio_count = minstance.GetInt(StreamKind.General' 0' "AudioCount");                          int text_count = minstance.GetInt(StreamKind.General' 0' "TextCount");                          if (int.TryParse(minstance.Get(StreamKind.General' 0' "MenuCount")' out int chaptercount))                              m.Chaptered = chaptercount > 0;                          m.Duration = p.Duration = minstance.Get(StreamKind.General' 0' "Duration");                          m.Container = p.Container = TranslateContainer(minstance.Get(StreamKind.General' 0' "Format"));                          string codid = minstance.Get(StreamKind.General' 0' "CodecID");                          if (!string.IsNullOrEmpty(codid) && (codid.Trim().ToLower() == "qt"))                              m.Container = p.Container = "mov";                            int brate = minstance.GetInt(StreamKind.General' 0' "BitRate");                          if (brate != 0)                              m.Bitrate = Math.Round(brate / 1000F).ToString(CultureInfo.InvariantCulture);                          p.Size = minstance.Get(StreamKind.General' 0' "FileSize");                          List<Stream> streams = new List<Stream>();                          int iidx = 0;                          if (video_count > 0)                          {                              for (int x = 0; x < video_count; x++)                              {                                  Stream s = TranslateVideoStream(minstance' x);                                  if (x == 0)                                  {                                      VideoStream = s;                                      m.Width = s.Width;                                      m.Height = s.Height;                                      if (!string.IsNullOrEmpty(m.Height))                                      {                                          if (!string.IsNullOrEmpty(m.Width))                                          {                                              m.VideoResolution =                                                  GetResolution(float.Parse(m.Width)' float.Parse(m.Height));                                              m.AspectRatio =                                                  GetAspectRatio(float.Parse(m.Width)' float.Parse(m.Height)' s.PA);                                          }                                      }                                      if (!string.IsNullOrEmpty(s.FrameRate))                                      {                                          float fr = System.Convert.ToSingle(s.FrameRate);                                          m.VideoFrameRate =                                              ((int) Math.Round(fr)).ToString(CultureInfo.InvariantCulture);                                          if (!string.IsNullOrEmpty(s.ScanType))                                          {                                              if (s.ScanType.ToLower().Contains("int"))                                                  m.VideoFrameRate += "i";                                              else                                                  m.VideoFrameRate += "p";                                          }                                          else                                              m.VideoFrameRate += "p";                                          if ((m.VideoFrameRate == "25p") || (m.VideoFrameRate == "25i"))                                              m.VideoFrameRate = "PAL";                                          else if ((m.VideoFrameRate == "30p") || (m.VideoFrameRate == "30i"))                                              m.VideoFrameRate = "NTSC";                                      }                                      m.VideoCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (video_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                    if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          int totalsoundrate = 0;                          if (audio_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateAudioStream(minstance' x);                                  if ((s.Codec == "adpcm") && (p.Container == "flv"))                                      s.Codec = "adpcm_swf";                                  if (x == 0)                                  {                                      m.AudioCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      m.AudioChannels = s.Channels;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (audio_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                  if (!string.IsNullOrEmpty(s.Bitrate))                                  {                                      double.TryParse(s.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture'                                          out double birate);                                      totalsoundrate += brate;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          if ((VideoStream != null) && string.IsNullOrEmpty(VideoStream.Bitrate) &&                              !string.IsNullOrEmpty(m.Bitrate))                          {                              double.TryParse(m.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture' out double mrate);                              VideoStream.Bitrate =                                  (((int) mrate) - totalsoundrate).ToString(CultureInfo.InvariantCulture);                          }                          if (text_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateTextStream(minstance' x);                                  streams.Add(s);                                  if (text_count == 1)                                  {                                      s.Default = null;                                      s.Forced = null;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                              }                          }                          m.Parts = new List<Part>();                          m.Parts.Add(p);                          bool over = false;                          if (m.Container == "mkv")                          {                              int val = int.MaxValue;                              foreach (Stream s in streams)                              {                                  if (string.IsNullOrEmpty(s.Index))                                  {                                      over = true;                                      break;                                  }                                  s.idx = int.Parse(s.Index);                                  if (s.idx < val)                                      val = s.idx;                              }                              if ((val != 0) && !over)                              {                                  foreach (Stream s in streams)                                  {                                      s.idx = s.idx - val;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              else if (over)                              {                                  int xx = 0;                                  foreach (Stream s in streams)                                  {                                      s.idx = xx++;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              streams = streams.OrderBy(a => a.idx).ToList();                          }                          p.Streams = streams;                      });                      mediaInfoThread.Start();                      bool finished = mediaInfoThread.Join(TimeSpan.FromMinutes(5)); //TODO Move Timeout to settings                      if (!finished)                      {                          try                          {                              mediaInfoThread.Abort();                          }                          catch                          {                              /*ignored*/                          }                          try                          {                              CloseMediaInfo();                          }                          catch                          {                              /*ignored*/                          }                          return null;                      }                      if ((p.Container == "mp4") || (p.Container == "mov"))                      {                          p.Has64bitOffsets = "0";                          p.OptimizedForStreaming = "0";                          m.OptimizedForStreaming = "0";                          byte[] buffer = new byte[8];                          FileSystemResult<System.IO.Stream> fsr = file.OpenRead();                          if (fsr == null || !fsr.IsOk)                              return null;                          System.IO.Stream fs = fsr.Result;                          fs.Read(buffer' 0' 4);                          int siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];                          fs.Seek(siz' SeekOrigin.Begin);                          fs.Read(buffer' 0' 8);                          if ((buffer[4] == 'f') && (buffer[5] == 'r') && (buffer[6] == 'e') && (buffer[7] == 'e'))                          {                              siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] - 8);                              fs.Seek(siz' SeekOrigin.Current);                              fs.Read(buffer' 0' 8);                          }                          if ((buffer[4] == 'm') && (buffer[5] == 'o') && (buffer[6] == 'o') && (buffer[7] == 'v'))                          {                              p.OptimizedForStreaming = "1";                              m.OptimizedForStreaming = "1";                              siz = ((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]) - 8;                                buffer = new byte[siz];                              fs.Read(buffer' 0' siz);                              if (!FindInBuffer("trak"' 0' siz' buffer' out int opos' out int oposmax)) return m;                              if (!FindInBuffer("mdia"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("minf"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("stbl"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("co64"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              p.Has64bitOffsets = "1";                          }                      }                      return m;                  }              }              finally              {                  minstance?.Close();                    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;                  GC.Collect();              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The following statement contains a magic number: try              {                  lock (_lock)                  {                      Media m = new Media();                      Part p = new Part();                      Thread mediaInfoThread = new Thread(() =>                      {                          if (minstance == null)                              minstance = new MediaInfoLib.MediaInfo();                          if (minstance.Open(filename) == 0) return; //it's a boolean response.                          Stream VideoStream = null;                          int video_count = minstance.GetInt(StreamKind.General' 0' "VideoCount");                          int audio_count = minstance.GetInt(StreamKind.General' 0' "AudioCount");                          int text_count = minstance.GetInt(StreamKind.General' 0' "TextCount");                          if (int.TryParse(minstance.Get(StreamKind.General' 0' "MenuCount")' out int chaptercount))                              m.Chaptered = chaptercount > 0;                          m.Duration = p.Duration = minstance.Get(StreamKind.General' 0' "Duration");                          m.Container = p.Container = TranslateContainer(minstance.Get(StreamKind.General' 0' "Format"));                          string codid = minstance.Get(StreamKind.General' 0' "CodecID");                          if (!string.IsNullOrEmpty(codid) && (codid.Trim().ToLower() == "qt"))                              m.Container = p.Container = "mov";                            int brate = minstance.GetInt(StreamKind.General' 0' "BitRate");                          if (brate != 0)                              m.Bitrate = Math.Round(brate / 1000F).ToString(CultureInfo.InvariantCulture);                          p.Size = minstance.Get(StreamKind.General' 0' "FileSize");                          List<Stream> streams = new List<Stream>();                          int iidx = 0;                          if (video_count > 0)                          {                              for (int x = 0; x < video_count; x++)                              {                                  Stream s = TranslateVideoStream(minstance' x);                                  if (x == 0)                                  {                                      VideoStream = s;                                      m.Width = s.Width;                                      m.Height = s.Height;                                      if (!string.IsNullOrEmpty(m.Height))                                      {                                          if (!string.IsNullOrEmpty(m.Width))                                          {                                              m.VideoResolution =                                                  GetResolution(float.Parse(m.Width)' float.Parse(m.Height));                                              m.AspectRatio =                                                  GetAspectRatio(float.Parse(m.Width)' float.Parse(m.Height)' s.PA);                                          }                                      }                                      if (!string.IsNullOrEmpty(s.FrameRate))                                      {                                          float fr = System.Convert.ToSingle(s.FrameRate);                                          m.VideoFrameRate =                                              ((int) Math.Round(fr)).ToString(CultureInfo.InvariantCulture);                                          if (!string.IsNullOrEmpty(s.ScanType))                                          {                                              if (s.ScanType.ToLower().Contains("int"))                                                  m.VideoFrameRate += "i";                                              else                                                  m.VideoFrameRate += "p";                                          }                                          else                                              m.VideoFrameRate += "p";                                          if ((m.VideoFrameRate == "25p") || (m.VideoFrameRate == "25i"))                                              m.VideoFrameRate = "PAL";                                          else if ((m.VideoFrameRate == "30p") || (m.VideoFrameRate == "30i"))                                              m.VideoFrameRate = "NTSC";                                      }                                      m.VideoCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (video_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                    if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          int totalsoundrate = 0;                          if (audio_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateAudioStream(minstance' x);                                  if ((s.Codec == "adpcm") && (p.Container == "flv"))                                      s.Codec = "adpcm_swf";                                  if (x == 0)                                  {                                      m.AudioCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      m.AudioChannels = s.Channels;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (audio_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                  if (!string.IsNullOrEmpty(s.Bitrate))                                  {                                      double.TryParse(s.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture'                                          out double birate);                                      totalsoundrate += brate;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          if ((VideoStream != null) && string.IsNullOrEmpty(VideoStream.Bitrate) &&                              !string.IsNullOrEmpty(m.Bitrate))                          {                              double.TryParse(m.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture' out double mrate);                              VideoStream.Bitrate =                                  (((int) mrate) - totalsoundrate).ToString(CultureInfo.InvariantCulture);                          }                          if (text_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateTextStream(minstance' x);                                  streams.Add(s);                                  if (text_count == 1)                                  {                                      s.Default = null;                                      s.Forced = null;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                              }                          }                          m.Parts = new List<Part>();                          m.Parts.Add(p);                          bool over = false;                          if (m.Container == "mkv")                          {                              int val = int.MaxValue;                              foreach (Stream s in streams)                              {                                  if (string.IsNullOrEmpty(s.Index))                                  {                                      over = true;                                      break;                                  }                                  s.idx = int.Parse(s.Index);                                  if (s.idx < val)                                      val = s.idx;                              }                              if ((val != 0) && !over)                              {                                  foreach (Stream s in streams)                                  {                                      s.idx = s.idx - val;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              else if (over)                              {                                  int xx = 0;                                  foreach (Stream s in streams)                                  {                                      s.idx = xx++;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              streams = streams.OrderBy(a => a.idx).ToList();                          }                          p.Streams = streams;                      });                      mediaInfoThread.Start();                      bool finished = mediaInfoThread.Join(TimeSpan.FromMinutes(5)); //TODO Move Timeout to settings                      if (!finished)                      {                          try                          {                              mediaInfoThread.Abort();                          }                          catch                          {                              /*ignored*/                          }                          try                          {                              CloseMediaInfo();                          }                          catch                          {                              /*ignored*/                          }                          return null;                      }                      if ((p.Container == "mp4") || (p.Container == "mov"))                      {                          p.Has64bitOffsets = "0";                          p.OptimizedForStreaming = "0";                          m.OptimizedForStreaming = "0";                          byte[] buffer = new byte[8];                          FileSystemResult<System.IO.Stream> fsr = file.OpenRead();                          if (fsr == null || !fsr.IsOk)                              return null;                          System.IO.Stream fs = fsr.Result;                          fs.Read(buffer' 0' 4);                          int siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];                          fs.Seek(siz' SeekOrigin.Begin);                          fs.Read(buffer' 0' 8);                          if ((buffer[4] == 'f') && (buffer[5] == 'r') && (buffer[6] == 'e') && (buffer[7] == 'e'))                          {                              siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] - 8);                              fs.Seek(siz' SeekOrigin.Current);                              fs.Read(buffer' 0' 8);                          }                          if ((buffer[4] == 'm') && (buffer[5] == 'o') && (buffer[6] == 'o') && (buffer[7] == 'v'))                          {                              p.OptimizedForStreaming = "1";                              m.OptimizedForStreaming = "1";                              siz = ((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]) - 8;                                buffer = new byte[siz];                              fs.Read(buffer' 0' siz);                              if (!FindInBuffer("trak"' 0' siz' buffer' out int opos' out int oposmax)) return m;                              if (!FindInBuffer("mdia"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("minf"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("stbl"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("co64"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              p.Has64bitOffsets = "1";                          }                      }                      return m;                  }              }              finally              {                  minstance?.Close();                    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;                  GC.Collect();              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The following statement contains a magic number: try              {                  lock (_lock)                  {                      Media m = new Media();                      Part p = new Part();                      Thread mediaInfoThread = new Thread(() =>                      {                          if (minstance == null)                              minstance = new MediaInfoLib.MediaInfo();                          if (minstance.Open(filename) == 0) return; //it's a boolean response.                          Stream VideoStream = null;                          int video_count = minstance.GetInt(StreamKind.General' 0' "VideoCount");                          int audio_count = minstance.GetInt(StreamKind.General' 0' "AudioCount");                          int text_count = minstance.GetInt(StreamKind.General' 0' "TextCount");                          if (int.TryParse(minstance.Get(StreamKind.General' 0' "MenuCount")' out int chaptercount))                              m.Chaptered = chaptercount > 0;                          m.Duration = p.Duration = minstance.Get(StreamKind.General' 0' "Duration");                          m.Container = p.Container = TranslateContainer(minstance.Get(StreamKind.General' 0' "Format"));                          string codid = minstance.Get(StreamKind.General' 0' "CodecID");                          if (!string.IsNullOrEmpty(codid) && (codid.Trim().ToLower() == "qt"))                              m.Container = p.Container = "mov";                            int brate = minstance.GetInt(StreamKind.General' 0' "BitRate");                          if (brate != 0)                              m.Bitrate = Math.Round(brate / 1000F).ToString(CultureInfo.InvariantCulture);                          p.Size = minstance.Get(StreamKind.General' 0' "FileSize");                          List<Stream> streams = new List<Stream>();                          int iidx = 0;                          if (video_count > 0)                          {                              for (int x = 0; x < video_count; x++)                              {                                  Stream s = TranslateVideoStream(minstance' x);                                  if (x == 0)                                  {                                      VideoStream = s;                                      m.Width = s.Width;                                      m.Height = s.Height;                                      if (!string.IsNullOrEmpty(m.Height))                                      {                                          if (!string.IsNullOrEmpty(m.Width))                                          {                                              m.VideoResolution =                                                  GetResolution(float.Parse(m.Width)' float.Parse(m.Height));                                              m.AspectRatio =                                                  GetAspectRatio(float.Parse(m.Width)' float.Parse(m.Height)' s.PA);                                          }                                      }                                      if (!string.IsNullOrEmpty(s.FrameRate))                                      {                                          float fr = System.Convert.ToSingle(s.FrameRate);                                          m.VideoFrameRate =                                              ((int) Math.Round(fr)).ToString(CultureInfo.InvariantCulture);                                          if (!string.IsNullOrEmpty(s.ScanType))                                          {                                              if (s.ScanType.ToLower().Contains("int"))                                                  m.VideoFrameRate += "i";                                              else                                                  m.VideoFrameRate += "p";                                          }                                          else                                              m.VideoFrameRate += "p";                                          if ((m.VideoFrameRate == "25p") || (m.VideoFrameRate == "25i"))                                              m.VideoFrameRate = "PAL";                                          else if ((m.VideoFrameRate == "30p") || (m.VideoFrameRate == "30i"))                                              m.VideoFrameRate = "NTSC";                                      }                                      m.VideoCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (video_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                    if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          int totalsoundrate = 0;                          if (audio_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateAudioStream(minstance' x);                                  if ((s.Codec == "adpcm") && (p.Container == "flv"))                                      s.Codec = "adpcm_swf";                                  if (x == 0)                                  {                                      m.AudioCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      m.AudioChannels = s.Channels;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (audio_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                  if (!string.IsNullOrEmpty(s.Bitrate))                                  {                                      double.TryParse(s.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture'                                          out double birate);                                      totalsoundrate += brate;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          if ((VideoStream != null) && string.IsNullOrEmpty(VideoStream.Bitrate) &&                              !string.IsNullOrEmpty(m.Bitrate))                          {                              double.TryParse(m.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture' out double mrate);                              VideoStream.Bitrate =                                  (((int) mrate) - totalsoundrate).ToString(CultureInfo.InvariantCulture);                          }                          if (text_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateTextStream(minstance' x);                                  streams.Add(s);                                  if (text_count == 1)                                  {                                      s.Default = null;                                      s.Forced = null;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                              }                          }                          m.Parts = new List<Part>();                          m.Parts.Add(p);                          bool over = false;                          if (m.Container == "mkv")                          {                              int val = int.MaxValue;                              foreach (Stream s in streams)                              {                                  if (string.IsNullOrEmpty(s.Index))                                  {                                      over = true;                                      break;                                  }                                  s.idx = int.Parse(s.Index);                                  if (s.idx < val)                                      val = s.idx;                              }                              if ((val != 0) && !over)                              {                                  foreach (Stream s in streams)                                  {                                      s.idx = s.idx - val;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              else if (over)                              {                                  int xx = 0;                                  foreach (Stream s in streams)                                  {                                      s.idx = xx++;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              streams = streams.OrderBy(a => a.idx).ToList();                          }                          p.Streams = streams;                      });                      mediaInfoThread.Start();                      bool finished = mediaInfoThread.Join(TimeSpan.FromMinutes(5)); //TODO Move Timeout to settings                      if (!finished)                      {                          try                          {                              mediaInfoThread.Abort();                          }                          catch                          {                              /*ignored*/                          }                          try                          {                              CloseMediaInfo();                          }                          catch                          {                              /*ignored*/                          }                          return null;                      }                      if ((p.Container == "mp4") || (p.Container == "mov"))                      {                          p.Has64bitOffsets = "0";                          p.OptimizedForStreaming = "0";                          m.OptimizedForStreaming = "0";                          byte[] buffer = new byte[8];                          FileSystemResult<System.IO.Stream> fsr = file.OpenRead();                          if (fsr == null || !fsr.IsOk)                              return null;                          System.IO.Stream fs = fsr.Result;                          fs.Read(buffer' 0' 4);                          int siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];                          fs.Seek(siz' SeekOrigin.Begin);                          fs.Read(buffer' 0' 8);                          if ((buffer[4] == 'f') && (buffer[5] == 'r') && (buffer[6] == 'e') && (buffer[7] == 'e'))                          {                              siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] - 8);                              fs.Seek(siz' SeekOrigin.Current);                              fs.Read(buffer' 0' 8);                          }                          if ((buffer[4] == 'm') && (buffer[5] == 'o') && (buffer[6] == 'o') && (buffer[7] == 'v'))                          {                              p.OptimizedForStreaming = "1";                              m.OptimizedForStreaming = "1";                              siz = ((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]) - 8;                                buffer = new byte[siz];                              fs.Read(buffer' 0' siz);                              if (!FindInBuffer("trak"' 0' siz' buffer' out int opos' out int oposmax)) return m;                              if (!FindInBuffer("mdia"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("minf"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("stbl"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("co64"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              p.Has64bitOffsets = "1";                          }                      }                      return m;                  }              }              finally              {                  minstance?.Close();                    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;                  GC.Collect();              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The following statement contains a magic number: try              {                  lock (_lock)                  {                      Media m = new Media();                      Part p = new Part();                      Thread mediaInfoThread = new Thread(() =>                      {                          if (minstance == null)                              minstance = new MediaInfoLib.MediaInfo();                          if (minstance.Open(filename) == 0) return; //it's a boolean response.                          Stream VideoStream = null;                          int video_count = minstance.GetInt(StreamKind.General' 0' "VideoCount");                          int audio_count = minstance.GetInt(StreamKind.General' 0' "AudioCount");                          int text_count = minstance.GetInt(StreamKind.General' 0' "TextCount");                          if (int.TryParse(minstance.Get(StreamKind.General' 0' "MenuCount")' out int chaptercount))                              m.Chaptered = chaptercount > 0;                          m.Duration = p.Duration = minstance.Get(StreamKind.General' 0' "Duration");                          m.Container = p.Container = TranslateContainer(minstance.Get(StreamKind.General' 0' "Format"));                          string codid = minstance.Get(StreamKind.General' 0' "CodecID");                          if (!string.IsNullOrEmpty(codid) && (codid.Trim().ToLower() == "qt"))                              m.Container = p.Container = "mov";                            int brate = minstance.GetInt(StreamKind.General' 0' "BitRate");                          if (brate != 0)                              m.Bitrate = Math.Round(brate / 1000F).ToString(CultureInfo.InvariantCulture);                          p.Size = minstance.Get(StreamKind.General' 0' "FileSize");                          List<Stream> streams = new List<Stream>();                          int iidx = 0;                          if (video_count > 0)                          {                              for (int x = 0; x < video_count; x++)                              {                                  Stream s = TranslateVideoStream(minstance' x);                                  if (x == 0)                                  {                                      VideoStream = s;                                      m.Width = s.Width;                                      m.Height = s.Height;                                      if (!string.IsNullOrEmpty(m.Height))                                      {                                          if (!string.IsNullOrEmpty(m.Width))                                          {                                              m.VideoResolution =                                                  GetResolution(float.Parse(m.Width)' float.Parse(m.Height));                                              m.AspectRatio =                                                  GetAspectRatio(float.Parse(m.Width)' float.Parse(m.Height)' s.PA);                                          }                                      }                                      if (!string.IsNullOrEmpty(s.FrameRate))                                      {                                          float fr = System.Convert.ToSingle(s.FrameRate);                                          m.VideoFrameRate =                                              ((int) Math.Round(fr)).ToString(CultureInfo.InvariantCulture);                                          if (!string.IsNullOrEmpty(s.ScanType))                                          {                                              if (s.ScanType.ToLower().Contains("int"))                                                  m.VideoFrameRate += "i";                                              else                                                  m.VideoFrameRate += "p";                                          }                                          else                                              m.VideoFrameRate += "p";                                          if ((m.VideoFrameRate == "25p") || (m.VideoFrameRate == "25i"))                                              m.VideoFrameRate = "PAL";                                          else if ((m.VideoFrameRate == "30p") || (m.VideoFrameRate == "30i"))                                              m.VideoFrameRate = "NTSC";                                      }                                      m.VideoCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (video_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                    if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          int totalsoundrate = 0;                          if (audio_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateAudioStream(minstance' x);                                  if ((s.Codec == "adpcm") && (p.Container == "flv"))                                      s.Codec = "adpcm_swf";                                  if (x == 0)                                  {                                      m.AudioCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      m.AudioChannels = s.Channels;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (audio_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                  if (!string.IsNullOrEmpty(s.Bitrate))                                  {                                      double.TryParse(s.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture'                                          out double birate);                                      totalsoundrate += brate;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          if ((VideoStream != null) && string.IsNullOrEmpty(VideoStream.Bitrate) &&                              !string.IsNullOrEmpty(m.Bitrate))                          {                              double.TryParse(m.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture' out double mrate);                              VideoStream.Bitrate =                                  (((int) mrate) - totalsoundrate).ToString(CultureInfo.InvariantCulture);                          }                          if (text_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateTextStream(minstance' x);                                  streams.Add(s);                                  if (text_count == 1)                                  {                                      s.Default = null;                                      s.Forced = null;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                              }                          }                          m.Parts = new List<Part>();                          m.Parts.Add(p);                          bool over = false;                          if (m.Container == "mkv")                          {                              int val = int.MaxValue;                              foreach (Stream s in streams)                              {                                  if (string.IsNullOrEmpty(s.Index))                                  {                                      over = true;                                      break;                                  }                                  s.idx = int.Parse(s.Index);                                  if (s.idx < val)                                      val = s.idx;                              }                              if ((val != 0) && !over)                              {                                  foreach (Stream s in streams)                                  {                                      s.idx = s.idx - val;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              else if (over)                              {                                  int xx = 0;                                  foreach (Stream s in streams)                                  {                                      s.idx = xx++;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              streams = streams.OrderBy(a => a.idx).ToList();                          }                          p.Streams = streams;                      });                      mediaInfoThread.Start();                      bool finished = mediaInfoThread.Join(TimeSpan.FromMinutes(5)); //TODO Move Timeout to settings                      if (!finished)                      {                          try                          {                              mediaInfoThread.Abort();                          }                          catch                          {                              /*ignored*/                          }                          try                          {                              CloseMediaInfo();                          }                          catch                          {                              /*ignored*/                          }                          return null;                      }                      if ((p.Container == "mp4") || (p.Container == "mov"))                      {                          p.Has64bitOffsets = "0";                          p.OptimizedForStreaming = "0";                          m.OptimizedForStreaming = "0";                          byte[] buffer = new byte[8];                          FileSystemResult<System.IO.Stream> fsr = file.OpenRead();                          if (fsr == null || !fsr.IsOk)                              return null;                          System.IO.Stream fs = fsr.Result;                          fs.Read(buffer' 0' 4);                          int siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];                          fs.Seek(siz' SeekOrigin.Begin);                          fs.Read(buffer' 0' 8);                          if ((buffer[4] == 'f') && (buffer[5] == 'r') && (buffer[6] == 'e') && (buffer[7] == 'e'))                          {                              siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] - 8);                              fs.Seek(siz' SeekOrigin.Current);                              fs.Read(buffer' 0' 8);                          }                          if ((buffer[4] == 'm') && (buffer[5] == 'o') && (buffer[6] == 'o') && (buffer[7] == 'v'))                          {                              p.OptimizedForStreaming = "1";                              m.OptimizedForStreaming = "1";                              siz = ((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]) - 8;                                buffer = new byte[siz];                              fs.Read(buffer' 0' siz);                              if (!FindInBuffer("trak"' 0' siz' buffer' out int opos' out int oposmax)) return m;                              if (!FindInBuffer("mdia"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("minf"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("stbl"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("co64"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              p.Has64bitOffsets = "1";                          }                      }                      return m;                  }              }              finally              {                  minstance?.Close();                    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;                  GC.Collect();              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The following statement contains a magic number: try              {                  lock (_lock)                  {                      Media m = new Media();                      Part p = new Part();                      Thread mediaInfoThread = new Thread(() =>                      {                          if (minstance == null)                              minstance = new MediaInfoLib.MediaInfo();                          if (minstance.Open(filename) == 0) return; //it's a boolean response.                          Stream VideoStream = null;                          int video_count = minstance.GetInt(StreamKind.General' 0' "VideoCount");                          int audio_count = minstance.GetInt(StreamKind.General' 0' "AudioCount");                          int text_count = minstance.GetInt(StreamKind.General' 0' "TextCount");                          if (int.TryParse(minstance.Get(StreamKind.General' 0' "MenuCount")' out int chaptercount))                              m.Chaptered = chaptercount > 0;                          m.Duration = p.Duration = minstance.Get(StreamKind.General' 0' "Duration");                          m.Container = p.Container = TranslateContainer(minstance.Get(StreamKind.General' 0' "Format"));                          string codid = minstance.Get(StreamKind.General' 0' "CodecID");                          if (!string.IsNullOrEmpty(codid) && (codid.Trim().ToLower() == "qt"))                              m.Container = p.Container = "mov";                            int brate = minstance.GetInt(StreamKind.General' 0' "BitRate");                          if (brate != 0)                              m.Bitrate = Math.Round(brate / 1000F).ToString(CultureInfo.InvariantCulture);                          p.Size = minstance.Get(StreamKind.General' 0' "FileSize");                          List<Stream> streams = new List<Stream>();                          int iidx = 0;                          if (video_count > 0)                          {                              for (int x = 0; x < video_count; x++)                              {                                  Stream s = TranslateVideoStream(minstance' x);                                  if (x == 0)                                  {                                      VideoStream = s;                                      m.Width = s.Width;                                      m.Height = s.Height;                                      if (!string.IsNullOrEmpty(m.Height))                                      {                                          if (!string.IsNullOrEmpty(m.Width))                                          {                                              m.VideoResolution =                                                  GetResolution(float.Parse(m.Width)' float.Parse(m.Height));                                              m.AspectRatio =                                                  GetAspectRatio(float.Parse(m.Width)' float.Parse(m.Height)' s.PA);                                          }                                      }                                      if (!string.IsNullOrEmpty(s.FrameRate))                                      {                                          float fr = System.Convert.ToSingle(s.FrameRate);                                          m.VideoFrameRate =                                              ((int) Math.Round(fr)).ToString(CultureInfo.InvariantCulture);                                          if (!string.IsNullOrEmpty(s.ScanType))                                          {                                              if (s.ScanType.ToLower().Contains("int"))                                                  m.VideoFrameRate += "i";                                              else                                                  m.VideoFrameRate += "p";                                          }                                          else                                              m.VideoFrameRate += "p";                                          if ((m.VideoFrameRate == "25p") || (m.VideoFrameRate == "25i"))                                              m.VideoFrameRate = "PAL";                                          else if ((m.VideoFrameRate == "30p") || (m.VideoFrameRate == "30i"))                                              m.VideoFrameRate = "NTSC";                                      }                                      m.VideoCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (video_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                    if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          int totalsoundrate = 0;                          if (audio_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateAudioStream(minstance' x);                                  if ((s.Codec == "adpcm") && (p.Container == "flv"))                                      s.Codec = "adpcm_swf";                                  if (x == 0)                                  {                                      m.AudioCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      m.AudioChannels = s.Channels;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (audio_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                  if (!string.IsNullOrEmpty(s.Bitrate))                                  {                                      double.TryParse(s.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture'                                          out double birate);                                      totalsoundrate += brate;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          if ((VideoStream != null) && string.IsNullOrEmpty(VideoStream.Bitrate) &&                              !string.IsNullOrEmpty(m.Bitrate))                          {                              double.TryParse(m.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture' out double mrate);                              VideoStream.Bitrate =                                  (((int) mrate) - totalsoundrate).ToString(CultureInfo.InvariantCulture);                          }                          if (text_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateTextStream(minstance' x);                                  streams.Add(s);                                  if (text_count == 1)                                  {                                      s.Default = null;                                      s.Forced = null;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                              }                          }                          m.Parts = new List<Part>();                          m.Parts.Add(p);                          bool over = false;                          if (m.Container == "mkv")                          {                              int val = int.MaxValue;                              foreach (Stream s in streams)                              {                                  if (string.IsNullOrEmpty(s.Index))                                  {                                      over = true;                                      break;                                  }                                  s.idx = int.Parse(s.Index);                                  if (s.idx < val)                                      val = s.idx;                              }                              if ((val != 0) && !over)                              {                                  foreach (Stream s in streams)                                  {                                      s.idx = s.idx - val;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              else if (over)                              {                                  int xx = 0;                                  foreach (Stream s in streams)                                  {                                      s.idx = xx++;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              streams = streams.OrderBy(a => a.idx).ToList();                          }                          p.Streams = streams;                      });                      mediaInfoThread.Start();                      bool finished = mediaInfoThread.Join(TimeSpan.FromMinutes(5)); //TODO Move Timeout to settings                      if (!finished)                      {                          try                          {                              mediaInfoThread.Abort();                          }                          catch                          {                              /*ignored*/                          }                          try                          {                              CloseMediaInfo();                          }                          catch                          {                              /*ignored*/                          }                          return null;                      }                      if ((p.Container == "mp4") || (p.Container == "mov"))                      {                          p.Has64bitOffsets = "0";                          p.OptimizedForStreaming = "0";                          m.OptimizedForStreaming = "0";                          byte[] buffer = new byte[8];                          FileSystemResult<System.IO.Stream> fsr = file.OpenRead();                          if (fsr == null || !fsr.IsOk)                              return null;                          System.IO.Stream fs = fsr.Result;                          fs.Read(buffer' 0' 4);                          int siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];                          fs.Seek(siz' SeekOrigin.Begin);                          fs.Read(buffer' 0' 8);                          if ((buffer[4] == 'f') && (buffer[5] == 'r') && (buffer[6] == 'e') && (buffer[7] == 'e'))                          {                              siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] - 8);                              fs.Seek(siz' SeekOrigin.Current);                              fs.Read(buffer' 0' 8);                          }                          if ((buffer[4] == 'm') && (buffer[5] == 'o') && (buffer[6] == 'o') && (buffer[7] == 'v'))                          {                              p.OptimizedForStreaming = "1";                              m.OptimizedForStreaming = "1";                              siz = ((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]) - 8;                                buffer = new byte[siz];                              fs.Read(buffer' 0' siz);                              if (!FindInBuffer("trak"' 0' siz' buffer' out int opos' out int oposmax)) return m;                              if (!FindInBuffer("mdia"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("minf"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("stbl"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("co64"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              p.Has64bitOffsets = "1";                          }                      }                      return m;                  }              }              finally              {                  minstance?.Close();                    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;                  GC.Collect();              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The following statement contains a magic number: try              {                  lock (_lock)                  {                      Media m = new Media();                      Part p = new Part();                      Thread mediaInfoThread = new Thread(() =>                      {                          if (minstance == null)                              minstance = new MediaInfoLib.MediaInfo();                          if (minstance.Open(filename) == 0) return; //it's a boolean response.                          Stream VideoStream = null;                          int video_count = minstance.GetInt(StreamKind.General' 0' "VideoCount");                          int audio_count = minstance.GetInt(StreamKind.General' 0' "AudioCount");                          int text_count = minstance.GetInt(StreamKind.General' 0' "TextCount");                          if (int.TryParse(minstance.Get(StreamKind.General' 0' "MenuCount")' out int chaptercount))                              m.Chaptered = chaptercount > 0;                          m.Duration = p.Duration = minstance.Get(StreamKind.General' 0' "Duration");                          m.Container = p.Container = TranslateContainer(minstance.Get(StreamKind.General' 0' "Format"));                          string codid = minstance.Get(StreamKind.General' 0' "CodecID");                          if (!string.IsNullOrEmpty(codid) && (codid.Trim().ToLower() == "qt"))                              m.Container = p.Container = "mov";                            int brate = minstance.GetInt(StreamKind.General' 0' "BitRate");                          if (brate != 0)                              m.Bitrate = Math.Round(brate / 1000F).ToString(CultureInfo.InvariantCulture);                          p.Size = minstance.Get(StreamKind.General' 0' "FileSize");                          List<Stream> streams = new List<Stream>();                          int iidx = 0;                          if (video_count > 0)                          {                              for (int x = 0; x < video_count; x++)                              {                                  Stream s = TranslateVideoStream(minstance' x);                                  if (x == 0)                                  {                                      VideoStream = s;                                      m.Width = s.Width;                                      m.Height = s.Height;                                      if (!string.IsNullOrEmpty(m.Height))                                      {                                          if (!string.IsNullOrEmpty(m.Width))                                          {                                              m.VideoResolution =                                                  GetResolution(float.Parse(m.Width)' float.Parse(m.Height));                                              m.AspectRatio =                                                  GetAspectRatio(float.Parse(m.Width)' float.Parse(m.Height)' s.PA);                                          }                                      }                                      if (!string.IsNullOrEmpty(s.FrameRate))                                      {                                          float fr = System.Convert.ToSingle(s.FrameRate);                                          m.VideoFrameRate =                                              ((int) Math.Round(fr)).ToString(CultureInfo.InvariantCulture);                                          if (!string.IsNullOrEmpty(s.ScanType))                                          {                                              if (s.ScanType.ToLower().Contains("int"))                                                  m.VideoFrameRate += "i";                                              else                                                  m.VideoFrameRate += "p";                                          }                                          else                                              m.VideoFrameRate += "p";                                          if ((m.VideoFrameRate == "25p") || (m.VideoFrameRate == "25i"))                                              m.VideoFrameRate = "PAL";                                          else if ((m.VideoFrameRate == "30p") || (m.VideoFrameRate == "30i"))                                              m.VideoFrameRate = "NTSC";                                      }                                      m.VideoCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (video_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                    if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          int totalsoundrate = 0;                          if (audio_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateAudioStream(minstance' x);                                  if ((s.Codec == "adpcm") && (p.Container == "flv"))                                      s.Codec = "adpcm_swf";                                  if (x == 0)                                  {                                      m.AudioCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      m.AudioChannels = s.Channels;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (audio_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                  if (!string.IsNullOrEmpty(s.Bitrate))                                  {                                      double.TryParse(s.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture'                                          out double birate);                                      totalsoundrate += brate;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          if ((VideoStream != null) && string.IsNullOrEmpty(VideoStream.Bitrate) &&                              !string.IsNullOrEmpty(m.Bitrate))                          {                              double.TryParse(m.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture' out double mrate);                              VideoStream.Bitrate =                                  (((int) mrate) - totalsoundrate).ToString(CultureInfo.InvariantCulture);                          }                          if (text_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateTextStream(minstance' x);                                  streams.Add(s);                                  if (text_count == 1)                                  {                                      s.Default = null;                                      s.Forced = null;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                              }                          }                          m.Parts = new List<Part>();                          m.Parts.Add(p);                          bool over = false;                          if (m.Container == "mkv")                          {                              int val = int.MaxValue;                              foreach (Stream s in streams)                              {                                  if (string.IsNullOrEmpty(s.Index))                                  {                                      over = true;                                      break;                                  }                                  s.idx = int.Parse(s.Index);                                  if (s.idx < val)                                      val = s.idx;                              }                              if ((val != 0) && !over)                              {                                  foreach (Stream s in streams)                                  {                                      s.idx = s.idx - val;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              else if (over)                              {                                  int xx = 0;                                  foreach (Stream s in streams)                                  {                                      s.idx = xx++;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              streams = streams.OrderBy(a => a.idx).ToList();                          }                          p.Streams = streams;                      });                      mediaInfoThread.Start();                      bool finished = mediaInfoThread.Join(TimeSpan.FromMinutes(5)); //TODO Move Timeout to settings                      if (!finished)                      {                          try                          {                              mediaInfoThread.Abort();                          }                          catch                          {                              /*ignored*/                          }                          try                          {                              CloseMediaInfo();                          }                          catch                          {                              /*ignored*/                          }                          return null;                      }                      if ((p.Container == "mp4") || (p.Container == "mov"))                      {                          p.Has64bitOffsets = "0";                          p.OptimizedForStreaming = "0";                          m.OptimizedForStreaming = "0";                          byte[] buffer = new byte[8];                          FileSystemResult<System.IO.Stream> fsr = file.OpenRead();                          if (fsr == null || !fsr.IsOk)                              return null;                          System.IO.Stream fs = fsr.Result;                          fs.Read(buffer' 0' 4);                          int siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];                          fs.Seek(siz' SeekOrigin.Begin);                          fs.Read(buffer' 0' 8);                          if ((buffer[4] == 'f') && (buffer[5] == 'r') && (buffer[6] == 'e') && (buffer[7] == 'e'))                          {                              siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] - 8);                              fs.Seek(siz' SeekOrigin.Current);                              fs.Read(buffer' 0' 8);                          }                          if ((buffer[4] == 'm') && (buffer[5] == 'o') && (buffer[6] == 'o') && (buffer[7] == 'v'))                          {                              p.OptimizedForStreaming = "1";                              m.OptimizedForStreaming = "1";                              siz = ((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]) - 8;                                buffer = new byte[siz];                              fs.Read(buffer' 0' siz);                              if (!FindInBuffer("trak"' 0' siz' buffer' out int opos' out int oposmax)) return m;                              if (!FindInBuffer("mdia"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("minf"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("stbl"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("co64"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              p.Has64bitOffsets = "1";                          }                      }                      return m;                  }              }              finally              {                  minstance?.Close();                    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;                  GC.Collect();              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The following statement contains a magic number: try              {                  lock (_lock)                  {                      Media m = new Media();                      Part p = new Part();                      Thread mediaInfoThread = new Thread(() =>                      {                          if (minstance == null)                              minstance = new MediaInfoLib.MediaInfo();                          if (minstance.Open(filename) == 0) return; //it's a boolean response.                          Stream VideoStream = null;                          int video_count = minstance.GetInt(StreamKind.General' 0' "VideoCount");                          int audio_count = minstance.GetInt(StreamKind.General' 0' "AudioCount");                          int text_count = minstance.GetInt(StreamKind.General' 0' "TextCount");                          if (int.TryParse(minstance.Get(StreamKind.General' 0' "MenuCount")' out int chaptercount))                              m.Chaptered = chaptercount > 0;                          m.Duration = p.Duration = minstance.Get(StreamKind.General' 0' "Duration");                          m.Container = p.Container = TranslateContainer(minstance.Get(StreamKind.General' 0' "Format"));                          string codid = minstance.Get(StreamKind.General' 0' "CodecID");                          if (!string.IsNullOrEmpty(codid) && (codid.Trim().ToLower() == "qt"))                              m.Container = p.Container = "mov";                            int brate = minstance.GetInt(StreamKind.General' 0' "BitRate");                          if (brate != 0)                              m.Bitrate = Math.Round(brate / 1000F).ToString(CultureInfo.InvariantCulture);                          p.Size = minstance.Get(StreamKind.General' 0' "FileSize");                          List<Stream> streams = new List<Stream>();                          int iidx = 0;                          if (video_count > 0)                          {                              for (int x = 0; x < video_count; x++)                              {                                  Stream s = TranslateVideoStream(minstance' x);                                  if (x == 0)                                  {                                      VideoStream = s;                                      m.Width = s.Width;                                      m.Height = s.Height;                                      if (!string.IsNullOrEmpty(m.Height))                                      {                                          if (!string.IsNullOrEmpty(m.Width))                                          {                                              m.VideoResolution =                                                  GetResolution(float.Parse(m.Width)' float.Parse(m.Height));                                              m.AspectRatio =                                                  GetAspectRatio(float.Parse(m.Width)' float.Parse(m.Height)' s.PA);                                          }                                      }                                      if (!string.IsNullOrEmpty(s.FrameRate))                                      {                                          float fr = System.Convert.ToSingle(s.FrameRate);                                          m.VideoFrameRate =                                              ((int) Math.Round(fr)).ToString(CultureInfo.InvariantCulture);                                          if (!string.IsNullOrEmpty(s.ScanType))                                          {                                              if (s.ScanType.ToLower().Contains("int"))                                                  m.VideoFrameRate += "i";                                              else                                                  m.VideoFrameRate += "p";                                          }                                          else                                              m.VideoFrameRate += "p";                                          if ((m.VideoFrameRate == "25p") || (m.VideoFrameRate == "25i"))                                              m.VideoFrameRate = "PAL";                                          else if ((m.VideoFrameRate == "30p") || (m.VideoFrameRate == "30i"))                                              m.VideoFrameRate = "NTSC";                                      }                                      m.VideoCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (video_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                    if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          int totalsoundrate = 0;                          if (audio_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateAudioStream(minstance' x);                                  if ((s.Codec == "adpcm") && (p.Container == "flv"))                                      s.Codec = "adpcm_swf";                                  if (x == 0)                                  {                                      m.AudioCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      m.AudioChannels = s.Channels;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (audio_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                  if (!string.IsNullOrEmpty(s.Bitrate))                                  {                                      double.TryParse(s.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture'                                          out double birate);                                      totalsoundrate += brate;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          if ((VideoStream != null) && string.IsNullOrEmpty(VideoStream.Bitrate) &&                              !string.IsNullOrEmpty(m.Bitrate))                          {                              double.TryParse(m.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture' out double mrate);                              VideoStream.Bitrate =                                  (((int) mrate) - totalsoundrate).ToString(CultureInfo.InvariantCulture);                          }                          if (text_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateTextStream(minstance' x);                                  streams.Add(s);                                  if (text_count == 1)                                  {                                      s.Default = null;                                      s.Forced = null;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                              }                          }                          m.Parts = new List<Part>();                          m.Parts.Add(p);                          bool over = false;                          if (m.Container == "mkv")                          {                              int val = int.MaxValue;                              foreach (Stream s in streams)                              {                                  if (string.IsNullOrEmpty(s.Index))                                  {                                      over = true;                                      break;                                  }                                  s.idx = int.Parse(s.Index);                                  if (s.idx < val)                                      val = s.idx;                              }                              if ((val != 0) && !over)                              {                                  foreach (Stream s in streams)                                  {                                      s.idx = s.idx - val;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              else if (over)                              {                                  int xx = 0;                                  foreach (Stream s in streams)                                  {                                      s.idx = xx++;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              streams = streams.OrderBy(a => a.idx).ToList();                          }                          p.Streams = streams;                      });                      mediaInfoThread.Start();                      bool finished = mediaInfoThread.Join(TimeSpan.FromMinutes(5)); //TODO Move Timeout to settings                      if (!finished)                      {                          try                          {                              mediaInfoThread.Abort();                          }                          catch                          {                              /*ignored*/                          }                          try                          {                              CloseMediaInfo();                          }                          catch                          {                              /*ignored*/                          }                          return null;                      }                      if ((p.Container == "mp4") || (p.Container == "mov"))                      {                          p.Has64bitOffsets = "0";                          p.OptimizedForStreaming = "0";                          m.OptimizedForStreaming = "0";                          byte[] buffer = new byte[8];                          FileSystemResult<System.IO.Stream> fsr = file.OpenRead();                          if (fsr == null || !fsr.IsOk)                              return null;                          System.IO.Stream fs = fsr.Result;                          fs.Read(buffer' 0' 4);                          int siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];                          fs.Seek(siz' SeekOrigin.Begin);                          fs.Read(buffer' 0' 8);                          if ((buffer[4] == 'f') && (buffer[5] == 'r') && (buffer[6] == 'e') && (buffer[7] == 'e'))                          {                              siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] - 8);                              fs.Seek(siz' SeekOrigin.Current);                              fs.Read(buffer' 0' 8);                          }                          if ((buffer[4] == 'm') && (buffer[5] == 'o') && (buffer[6] == 'o') && (buffer[7] == 'v'))                          {                              p.OptimizedForStreaming = "1";                              m.OptimizedForStreaming = "1";                              siz = ((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]) - 8;                                buffer = new byte[siz];                              fs.Read(buffer' 0' siz);                              if (!FindInBuffer("trak"' 0' siz' buffer' out int opos' out int oposmax)) return m;                              if (!FindInBuffer("mdia"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("minf"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("stbl"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("co64"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              p.Has64bitOffsets = "1";                          }                      }                      return m;                  }              }              finally              {                  minstance?.Close();                    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;                  GC.Collect();              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The following statement contains a magic number: try              {                  lock (_lock)                  {                      Media m = new Media();                      Part p = new Part();                      Thread mediaInfoThread = new Thread(() =>                      {                          if (minstance == null)                              minstance = new MediaInfoLib.MediaInfo();                          if (minstance.Open(filename) == 0) return; //it's a boolean response.                          Stream VideoStream = null;                          int video_count = minstance.GetInt(StreamKind.General' 0' "VideoCount");                          int audio_count = minstance.GetInt(StreamKind.General' 0' "AudioCount");                          int text_count = minstance.GetInt(StreamKind.General' 0' "TextCount");                          if (int.TryParse(minstance.Get(StreamKind.General' 0' "MenuCount")' out int chaptercount))                              m.Chaptered = chaptercount > 0;                          m.Duration = p.Duration = minstance.Get(StreamKind.General' 0' "Duration");                          m.Container = p.Container = TranslateContainer(minstance.Get(StreamKind.General' 0' "Format"));                          string codid = minstance.Get(StreamKind.General' 0' "CodecID");                          if (!string.IsNullOrEmpty(codid) && (codid.Trim().ToLower() == "qt"))                              m.Container = p.Container = "mov";                            int brate = minstance.GetInt(StreamKind.General' 0' "BitRate");                          if (brate != 0)                              m.Bitrate = Math.Round(brate / 1000F).ToString(CultureInfo.InvariantCulture);                          p.Size = minstance.Get(StreamKind.General' 0' "FileSize");                          List<Stream> streams = new List<Stream>();                          int iidx = 0;                          if (video_count > 0)                          {                              for (int x = 0; x < video_count; x++)                              {                                  Stream s = TranslateVideoStream(minstance' x);                                  if (x == 0)                                  {                                      VideoStream = s;                                      m.Width = s.Width;                                      m.Height = s.Height;                                      if (!string.IsNullOrEmpty(m.Height))                                      {                                          if (!string.IsNullOrEmpty(m.Width))                                          {                                              m.VideoResolution =                                                  GetResolution(float.Parse(m.Width)' float.Parse(m.Height));                                              m.AspectRatio =                                                  GetAspectRatio(float.Parse(m.Width)' float.Parse(m.Height)' s.PA);                                          }                                      }                                      if (!string.IsNullOrEmpty(s.FrameRate))                                      {                                          float fr = System.Convert.ToSingle(s.FrameRate);                                          m.VideoFrameRate =                                              ((int) Math.Round(fr)).ToString(CultureInfo.InvariantCulture);                                          if (!string.IsNullOrEmpty(s.ScanType))                                          {                                              if (s.ScanType.ToLower().Contains("int"))                                                  m.VideoFrameRate += "i";                                              else                                                  m.VideoFrameRate += "p";                                          }                                          else                                              m.VideoFrameRate += "p";                                          if ((m.VideoFrameRate == "25p") || (m.VideoFrameRate == "25i"))                                              m.VideoFrameRate = "PAL";                                          else if ((m.VideoFrameRate == "30p") || (m.VideoFrameRate == "30i"))                                              m.VideoFrameRate = "NTSC";                                      }                                      m.VideoCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (video_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                    if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          int totalsoundrate = 0;                          if (audio_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateAudioStream(minstance' x);                                  if ((s.Codec == "adpcm") && (p.Container == "flv"))                                      s.Codec = "adpcm_swf";                                  if (x == 0)                                  {                                      m.AudioCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      m.AudioChannels = s.Channels;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (audio_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                  if (!string.IsNullOrEmpty(s.Bitrate))                                  {                                      double.TryParse(s.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture'                                          out double birate);                                      totalsoundrate += brate;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          if ((VideoStream != null) && string.IsNullOrEmpty(VideoStream.Bitrate) &&                              !string.IsNullOrEmpty(m.Bitrate))                          {                              double.TryParse(m.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture' out double mrate);                              VideoStream.Bitrate =                                  (((int) mrate) - totalsoundrate).ToString(CultureInfo.InvariantCulture);                          }                          if (text_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateTextStream(minstance' x);                                  streams.Add(s);                                  if (text_count == 1)                                  {                                      s.Default = null;                                      s.Forced = null;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                              }                          }                          m.Parts = new List<Part>();                          m.Parts.Add(p);                          bool over = false;                          if (m.Container == "mkv")                          {                              int val = int.MaxValue;                              foreach (Stream s in streams)                              {                                  if (string.IsNullOrEmpty(s.Index))                                  {                                      over = true;                                      break;                                  }                                  s.idx = int.Parse(s.Index);                                  if (s.idx < val)                                      val = s.idx;                              }                              if ((val != 0) && !over)                              {                                  foreach (Stream s in streams)                                  {                                      s.idx = s.idx - val;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              else if (over)                              {                                  int xx = 0;                                  foreach (Stream s in streams)                                  {                                      s.idx = xx++;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              streams = streams.OrderBy(a => a.idx).ToList();                          }                          p.Streams = streams;                      });                      mediaInfoThread.Start();                      bool finished = mediaInfoThread.Join(TimeSpan.FromMinutes(5)); //TODO Move Timeout to settings                      if (!finished)                      {                          try                          {                              mediaInfoThread.Abort();                          }                          catch                          {                              /*ignored*/                          }                          try                          {                              CloseMediaInfo();                          }                          catch                          {                              /*ignored*/                          }                          return null;                      }                      if ((p.Container == "mp4") || (p.Container == "mov"))                      {                          p.Has64bitOffsets = "0";                          p.OptimizedForStreaming = "0";                          m.OptimizedForStreaming = "0";                          byte[] buffer = new byte[8];                          FileSystemResult<System.IO.Stream> fsr = file.OpenRead();                          if (fsr == null || !fsr.IsOk)                              return null;                          System.IO.Stream fs = fsr.Result;                          fs.Read(buffer' 0' 4);                          int siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];                          fs.Seek(siz' SeekOrigin.Begin);                          fs.Read(buffer' 0' 8);                          if ((buffer[4] == 'f') && (buffer[5] == 'r') && (buffer[6] == 'e') && (buffer[7] == 'e'))                          {                              siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] - 8);                              fs.Seek(siz' SeekOrigin.Current);                              fs.Read(buffer' 0' 8);                          }                          if ((buffer[4] == 'm') && (buffer[5] == 'o') && (buffer[6] == 'o') && (buffer[7] == 'v'))                          {                              p.OptimizedForStreaming = "1";                              m.OptimizedForStreaming = "1";                              siz = ((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]) - 8;                                buffer = new byte[siz];                              fs.Read(buffer' 0' siz);                              if (!FindInBuffer("trak"' 0' siz' buffer' out int opos' out int oposmax)) return m;                              if (!FindInBuffer("mdia"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("minf"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("stbl"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("co64"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              p.Has64bitOffsets = "1";                          }                      }                      return m;                  }              }              finally              {                  minstance?.Close();                    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;                  GC.Collect();              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The following statement contains a magic number: try              {                  lock (_lock)                  {                      Media m = new Media();                      Part p = new Part();                      Thread mediaInfoThread = new Thread(() =>                      {                          if (minstance == null)                              minstance = new MediaInfoLib.MediaInfo();                          if (minstance.Open(filename) == 0) return; //it's a boolean response.                          Stream VideoStream = null;                          int video_count = minstance.GetInt(StreamKind.General' 0' "VideoCount");                          int audio_count = minstance.GetInt(StreamKind.General' 0' "AudioCount");                          int text_count = minstance.GetInt(StreamKind.General' 0' "TextCount");                          if (int.TryParse(minstance.Get(StreamKind.General' 0' "MenuCount")' out int chaptercount))                              m.Chaptered = chaptercount > 0;                          m.Duration = p.Duration = minstance.Get(StreamKind.General' 0' "Duration");                          m.Container = p.Container = TranslateContainer(minstance.Get(StreamKind.General' 0' "Format"));                          string codid = minstance.Get(StreamKind.General' 0' "CodecID");                          if (!string.IsNullOrEmpty(codid) && (codid.Trim().ToLower() == "qt"))                              m.Container = p.Container = "mov";                            int brate = minstance.GetInt(StreamKind.General' 0' "BitRate");                          if (brate != 0)                              m.Bitrate = Math.Round(brate / 1000F).ToString(CultureInfo.InvariantCulture);                          p.Size = minstance.Get(StreamKind.General' 0' "FileSize");                          List<Stream> streams = new List<Stream>();                          int iidx = 0;                          if (video_count > 0)                          {                              for (int x = 0; x < video_count; x++)                              {                                  Stream s = TranslateVideoStream(minstance' x);                                  if (x == 0)                                  {                                      VideoStream = s;                                      m.Width = s.Width;                                      m.Height = s.Height;                                      if (!string.IsNullOrEmpty(m.Height))                                      {                                          if (!string.IsNullOrEmpty(m.Width))                                          {                                              m.VideoResolution =                                                  GetResolution(float.Parse(m.Width)' float.Parse(m.Height));                                              m.AspectRatio =                                                  GetAspectRatio(float.Parse(m.Width)' float.Parse(m.Height)' s.PA);                                          }                                      }                                      if (!string.IsNullOrEmpty(s.FrameRate))                                      {                                          float fr = System.Convert.ToSingle(s.FrameRate);                                          m.VideoFrameRate =                                              ((int) Math.Round(fr)).ToString(CultureInfo.InvariantCulture);                                          if (!string.IsNullOrEmpty(s.ScanType))                                          {                                              if (s.ScanType.ToLower().Contains("int"))                                                  m.VideoFrameRate += "i";                                              else                                                  m.VideoFrameRate += "p";                                          }                                          else                                              m.VideoFrameRate += "p";                                          if ((m.VideoFrameRate == "25p") || (m.VideoFrameRate == "25i"))                                              m.VideoFrameRate = "PAL";                                          else if ((m.VideoFrameRate == "30p") || (m.VideoFrameRate == "30i"))                                              m.VideoFrameRate = "NTSC";                                      }                                      m.VideoCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (video_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                    if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          int totalsoundrate = 0;                          if (audio_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateAudioStream(minstance' x);                                  if ((s.Codec == "adpcm") && (p.Container == "flv"))                                      s.Codec = "adpcm_swf";                                  if (x == 0)                                  {                                      m.AudioCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      m.AudioChannels = s.Channels;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (audio_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                  if (!string.IsNullOrEmpty(s.Bitrate))                                  {                                      double.TryParse(s.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture'                                          out double birate);                                      totalsoundrate += brate;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          if ((VideoStream != null) && string.IsNullOrEmpty(VideoStream.Bitrate) &&                              !string.IsNullOrEmpty(m.Bitrate))                          {                              double.TryParse(m.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture' out double mrate);                              VideoStream.Bitrate =                                  (((int) mrate) - totalsoundrate).ToString(CultureInfo.InvariantCulture);                          }                          if (text_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateTextStream(minstance' x);                                  streams.Add(s);                                  if (text_count == 1)                                  {                                      s.Default = null;                                      s.Forced = null;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                              }                          }                          m.Parts = new List<Part>();                          m.Parts.Add(p);                          bool over = false;                          if (m.Container == "mkv")                          {                              int val = int.MaxValue;                              foreach (Stream s in streams)                              {                                  if (string.IsNullOrEmpty(s.Index))                                  {                                      over = true;                                      break;                                  }                                  s.idx = int.Parse(s.Index);                                  if (s.idx < val)                                      val = s.idx;                              }                              if ((val != 0) && !over)                              {                                  foreach (Stream s in streams)                                  {                                      s.idx = s.idx - val;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              else if (over)                              {                                  int xx = 0;                                  foreach (Stream s in streams)                                  {                                      s.idx = xx++;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              streams = streams.OrderBy(a => a.idx).ToList();                          }                          p.Streams = streams;                      });                      mediaInfoThread.Start();                      bool finished = mediaInfoThread.Join(TimeSpan.FromMinutes(5)); //TODO Move Timeout to settings                      if (!finished)                      {                          try                          {                              mediaInfoThread.Abort();                          }                          catch                          {                              /*ignored*/                          }                          try                          {                              CloseMediaInfo();                          }                          catch                          {                              /*ignored*/                          }                          return null;                      }                      if ((p.Container == "mp4") || (p.Container == "mov"))                      {                          p.Has64bitOffsets = "0";                          p.OptimizedForStreaming = "0";                          m.OptimizedForStreaming = "0";                          byte[] buffer = new byte[8];                          FileSystemResult<System.IO.Stream> fsr = file.OpenRead();                          if (fsr == null || !fsr.IsOk)                              return null;                          System.IO.Stream fs = fsr.Result;                          fs.Read(buffer' 0' 4);                          int siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];                          fs.Seek(siz' SeekOrigin.Begin);                          fs.Read(buffer' 0' 8);                          if ((buffer[4] == 'f') && (buffer[5] == 'r') && (buffer[6] == 'e') && (buffer[7] == 'e'))                          {                              siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] - 8);                              fs.Seek(siz' SeekOrigin.Current);                              fs.Read(buffer' 0' 8);                          }                          if ((buffer[4] == 'm') && (buffer[5] == 'o') && (buffer[6] == 'o') && (buffer[7] == 'v'))                          {                              p.OptimizedForStreaming = "1";                              m.OptimizedForStreaming = "1";                              siz = ((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]) - 8;                                buffer = new byte[siz];                              fs.Read(buffer' 0' siz);                              if (!FindInBuffer("trak"' 0' siz' buffer' out int opos' out int oposmax)) return m;                              if (!FindInBuffer("mdia"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("minf"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("stbl"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("co64"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              p.Has64bitOffsets = "1";                          }                      }                      return m;                  }              }              finally              {                  minstance?.Close();                    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;                  GC.Collect();              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The following statement contains a magic number: try              {                  lock (_lock)                  {                      Media m = new Media();                      Part p = new Part();                      Thread mediaInfoThread = new Thread(() =>                      {                          if (minstance == null)                              minstance = new MediaInfoLib.MediaInfo();                          if (minstance.Open(filename) == 0) return; //it's a boolean response.                          Stream VideoStream = null;                          int video_count = minstance.GetInt(StreamKind.General' 0' "VideoCount");                          int audio_count = minstance.GetInt(StreamKind.General' 0' "AudioCount");                          int text_count = minstance.GetInt(StreamKind.General' 0' "TextCount");                          if (int.TryParse(minstance.Get(StreamKind.General' 0' "MenuCount")' out int chaptercount))                              m.Chaptered = chaptercount > 0;                          m.Duration = p.Duration = minstance.Get(StreamKind.General' 0' "Duration");                          m.Container = p.Container = TranslateContainer(minstance.Get(StreamKind.General' 0' "Format"));                          string codid = minstance.Get(StreamKind.General' 0' "CodecID");                          if (!string.IsNullOrEmpty(codid) && (codid.Trim().ToLower() == "qt"))                              m.Container = p.Container = "mov";                            int brate = minstance.GetInt(StreamKind.General' 0' "BitRate");                          if (brate != 0)                              m.Bitrate = Math.Round(brate / 1000F).ToString(CultureInfo.InvariantCulture);                          p.Size = minstance.Get(StreamKind.General' 0' "FileSize");                          List<Stream> streams = new List<Stream>();                          int iidx = 0;                          if (video_count > 0)                          {                              for (int x = 0; x < video_count; x++)                              {                                  Stream s = TranslateVideoStream(minstance' x);                                  if (x == 0)                                  {                                      VideoStream = s;                                      m.Width = s.Width;                                      m.Height = s.Height;                                      if (!string.IsNullOrEmpty(m.Height))                                      {                                          if (!string.IsNullOrEmpty(m.Width))                                          {                                              m.VideoResolution =                                                  GetResolution(float.Parse(m.Width)' float.Parse(m.Height));                                              m.AspectRatio =                                                  GetAspectRatio(float.Parse(m.Width)' float.Parse(m.Height)' s.PA);                                          }                                      }                                      if (!string.IsNullOrEmpty(s.FrameRate))                                      {                                          float fr = System.Convert.ToSingle(s.FrameRate);                                          m.VideoFrameRate =                                              ((int) Math.Round(fr)).ToString(CultureInfo.InvariantCulture);                                          if (!string.IsNullOrEmpty(s.ScanType))                                          {                                              if (s.ScanType.ToLower().Contains("int"))                                                  m.VideoFrameRate += "i";                                              else                                                  m.VideoFrameRate += "p";                                          }                                          else                                              m.VideoFrameRate += "p";                                          if ((m.VideoFrameRate == "25p") || (m.VideoFrameRate == "25i"))                                              m.VideoFrameRate = "PAL";                                          else if ((m.VideoFrameRate == "30p") || (m.VideoFrameRate == "30i"))                                              m.VideoFrameRate = "NTSC";                                      }                                      m.VideoCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (video_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                    if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          int totalsoundrate = 0;                          if (audio_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateAudioStream(minstance' x);                                  if ((s.Codec == "adpcm") && (p.Container == "flv"))                                      s.Codec = "adpcm_swf";                                  if (x == 0)                                  {                                      m.AudioCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      m.AudioChannels = s.Channels;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (audio_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                  if (!string.IsNullOrEmpty(s.Bitrate))                                  {                                      double.TryParse(s.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture'                                          out double birate);                                      totalsoundrate += brate;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          if ((VideoStream != null) && string.IsNullOrEmpty(VideoStream.Bitrate) &&                              !string.IsNullOrEmpty(m.Bitrate))                          {                              double.TryParse(m.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture' out double mrate);                              VideoStream.Bitrate =                                  (((int) mrate) - totalsoundrate).ToString(CultureInfo.InvariantCulture);                          }                          if (text_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateTextStream(minstance' x);                                  streams.Add(s);                                  if (text_count == 1)                                  {                                      s.Default = null;                                      s.Forced = null;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                              }                          }                          m.Parts = new List<Part>();                          m.Parts.Add(p);                          bool over = false;                          if (m.Container == "mkv")                          {                              int val = int.MaxValue;                              foreach (Stream s in streams)                              {                                  if (string.IsNullOrEmpty(s.Index))                                  {                                      over = true;                                      break;                                  }                                  s.idx = int.Parse(s.Index);                                  if (s.idx < val)                                      val = s.idx;                              }                              if ((val != 0) && !over)                              {                                  foreach (Stream s in streams)                                  {                                      s.idx = s.idx - val;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              else if (over)                              {                                  int xx = 0;                                  foreach (Stream s in streams)                                  {                                      s.idx = xx++;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              streams = streams.OrderBy(a => a.idx).ToList();                          }                          p.Streams = streams;                      });                      mediaInfoThread.Start();                      bool finished = mediaInfoThread.Join(TimeSpan.FromMinutes(5)); //TODO Move Timeout to settings                      if (!finished)                      {                          try                          {                              mediaInfoThread.Abort();                          }                          catch                          {                              /*ignored*/                          }                          try                          {                              CloseMediaInfo();                          }                          catch                          {                              /*ignored*/                          }                          return null;                      }                      if ((p.Container == "mp4") || (p.Container == "mov"))                      {                          p.Has64bitOffsets = "0";                          p.OptimizedForStreaming = "0";                          m.OptimizedForStreaming = "0";                          byte[] buffer = new byte[8];                          FileSystemResult<System.IO.Stream> fsr = file.OpenRead();                          if (fsr == null || !fsr.IsOk)                              return null;                          System.IO.Stream fs = fsr.Result;                          fs.Read(buffer' 0' 4);                          int siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];                          fs.Seek(siz' SeekOrigin.Begin);                          fs.Read(buffer' 0' 8);                          if ((buffer[4] == 'f') && (buffer[5] == 'r') && (buffer[6] == 'e') && (buffer[7] == 'e'))                          {                              siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] - 8);                              fs.Seek(siz' SeekOrigin.Current);                              fs.Read(buffer' 0' 8);                          }                          if ((buffer[4] == 'm') && (buffer[5] == 'o') && (buffer[6] == 'o') && (buffer[7] == 'v'))                          {                              p.OptimizedForStreaming = "1";                              m.OptimizedForStreaming = "1";                              siz = ((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]) - 8;                                buffer = new byte[siz];                              fs.Read(buffer' 0' siz);                              if (!FindInBuffer("trak"' 0' siz' buffer' out int opos' out int oposmax)) return m;                              if (!FindInBuffer("mdia"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("minf"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("stbl"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("co64"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              p.Has64bitOffsets = "1";                          }                      }                      return m;                  }              }              finally              {                  minstance?.Close();                    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;                  GC.Collect();              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The following statement contains a magic number: try              {                  lock (_lock)                  {                      Media m = new Media();                      Part p = new Part();                      Thread mediaInfoThread = new Thread(() =>                      {                          if (minstance == null)                              minstance = new MediaInfoLib.MediaInfo();                          if (minstance.Open(filename) == 0) return; //it's a boolean response.                          Stream VideoStream = null;                          int video_count = minstance.GetInt(StreamKind.General' 0' "VideoCount");                          int audio_count = minstance.GetInt(StreamKind.General' 0' "AudioCount");                          int text_count = minstance.GetInt(StreamKind.General' 0' "TextCount");                          if (int.TryParse(minstance.Get(StreamKind.General' 0' "MenuCount")' out int chaptercount))                              m.Chaptered = chaptercount > 0;                          m.Duration = p.Duration = minstance.Get(StreamKind.General' 0' "Duration");                          m.Container = p.Container = TranslateContainer(minstance.Get(StreamKind.General' 0' "Format"));                          string codid = minstance.Get(StreamKind.General' 0' "CodecID");                          if (!string.IsNullOrEmpty(codid) && (codid.Trim().ToLower() == "qt"))                              m.Container = p.Container = "mov";                            int brate = minstance.GetInt(StreamKind.General' 0' "BitRate");                          if (brate != 0)                              m.Bitrate = Math.Round(brate / 1000F).ToString(CultureInfo.InvariantCulture);                          p.Size = minstance.Get(StreamKind.General' 0' "FileSize");                          List<Stream> streams = new List<Stream>();                          int iidx = 0;                          if (video_count > 0)                          {                              for (int x = 0; x < video_count; x++)                              {                                  Stream s = TranslateVideoStream(minstance' x);                                  if (x == 0)                                  {                                      VideoStream = s;                                      m.Width = s.Width;                                      m.Height = s.Height;                                      if (!string.IsNullOrEmpty(m.Height))                                      {                                          if (!string.IsNullOrEmpty(m.Width))                                          {                                              m.VideoResolution =                                                  GetResolution(float.Parse(m.Width)' float.Parse(m.Height));                                              m.AspectRatio =                                                  GetAspectRatio(float.Parse(m.Width)' float.Parse(m.Height)' s.PA);                                          }                                      }                                      if (!string.IsNullOrEmpty(s.FrameRate))                                      {                                          float fr = System.Convert.ToSingle(s.FrameRate);                                          m.VideoFrameRate =                                              ((int) Math.Round(fr)).ToString(CultureInfo.InvariantCulture);                                          if (!string.IsNullOrEmpty(s.ScanType))                                          {                                              if (s.ScanType.ToLower().Contains("int"))                                                  m.VideoFrameRate += "i";                                              else                                                  m.VideoFrameRate += "p";                                          }                                          else                                              m.VideoFrameRate += "p";                                          if ((m.VideoFrameRate == "25p") || (m.VideoFrameRate == "25i"))                                              m.VideoFrameRate = "PAL";                                          else if ((m.VideoFrameRate == "30p") || (m.VideoFrameRate == "30i"))                                              m.VideoFrameRate = "NTSC";                                      }                                      m.VideoCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (video_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                    if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          int totalsoundrate = 0;                          if (audio_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateAudioStream(minstance' x);                                  if ((s.Codec == "adpcm") && (p.Container == "flv"))                                      s.Codec = "adpcm_swf";                                  if (x == 0)                                  {                                      m.AudioCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      m.AudioChannels = s.Channels;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (audio_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                  if (!string.IsNullOrEmpty(s.Bitrate))                                  {                                      double.TryParse(s.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture'                                          out double birate);                                      totalsoundrate += brate;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          if ((VideoStream != null) && string.IsNullOrEmpty(VideoStream.Bitrate) &&                              !string.IsNullOrEmpty(m.Bitrate))                          {                              double.TryParse(m.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture' out double mrate);                              VideoStream.Bitrate =                                  (((int) mrate) - totalsoundrate).ToString(CultureInfo.InvariantCulture);                          }                          if (text_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateTextStream(minstance' x);                                  streams.Add(s);                                  if (text_count == 1)                                  {                                      s.Default = null;                                      s.Forced = null;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                              }                          }                          m.Parts = new List<Part>();                          m.Parts.Add(p);                          bool over = false;                          if (m.Container == "mkv")                          {                              int val = int.MaxValue;                              foreach (Stream s in streams)                              {                                  if (string.IsNullOrEmpty(s.Index))                                  {                                      over = true;                                      break;                                  }                                  s.idx = int.Parse(s.Index);                                  if (s.idx < val)                                      val = s.idx;                              }                              if ((val != 0) && !over)                              {                                  foreach (Stream s in streams)                                  {                                      s.idx = s.idx - val;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              else if (over)                              {                                  int xx = 0;                                  foreach (Stream s in streams)                                  {                                      s.idx = xx++;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              streams = streams.OrderBy(a => a.idx).ToList();                          }                          p.Streams = streams;                      });                      mediaInfoThread.Start();                      bool finished = mediaInfoThread.Join(TimeSpan.FromMinutes(5)); //TODO Move Timeout to settings                      if (!finished)                      {                          try                          {                              mediaInfoThread.Abort();                          }                          catch                          {                              /*ignored*/                          }                          try                          {                              CloseMediaInfo();                          }                          catch                          {                              /*ignored*/                          }                          return null;                      }                      if ((p.Container == "mp4") || (p.Container == "mov"))                      {                          p.Has64bitOffsets = "0";                          p.OptimizedForStreaming = "0";                          m.OptimizedForStreaming = "0";                          byte[] buffer = new byte[8];                          FileSystemResult<System.IO.Stream> fsr = file.OpenRead();                          if (fsr == null || !fsr.IsOk)                              return null;                          System.IO.Stream fs = fsr.Result;                          fs.Read(buffer' 0' 4);                          int siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];                          fs.Seek(siz' SeekOrigin.Begin);                          fs.Read(buffer' 0' 8);                          if ((buffer[4] == 'f') && (buffer[5] == 'r') && (buffer[6] == 'e') && (buffer[7] == 'e'))                          {                              siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] - 8);                              fs.Seek(siz' SeekOrigin.Current);                              fs.Read(buffer' 0' 8);                          }                          if ((buffer[4] == 'm') && (buffer[5] == 'o') && (buffer[6] == 'o') && (buffer[7] == 'v'))                          {                              p.OptimizedForStreaming = "1";                              m.OptimizedForStreaming = "1";                              siz = ((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]) - 8;                                buffer = new byte[siz];                              fs.Read(buffer' 0' siz);                              if (!FindInBuffer("trak"' 0' siz' buffer' out int opos' out int oposmax)) return m;                              if (!FindInBuffer("mdia"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("minf"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("stbl"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("co64"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              p.Has64bitOffsets = "1";                          }                      }                      return m;                  }              }              finally              {                  minstance?.Close();                    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;                  GC.Collect();              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The following statement contains a magic number: try              {                  lock (_lock)                  {                      Media m = new Media();                      Part p = new Part();                      Thread mediaInfoThread = new Thread(() =>                      {                          if (minstance == null)                              minstance = new MediaInfoLib.MediaInfo();                          if (minstance.Open(filename) == 0) return; //it's a boolean response.                          Stream VideoStream = null;                          int video_count = minstance.GetInt(StreamKind.General' 0' "VideoCount");                          int audio_count = minstance.GetInt(StreamKind.General' 0' "AudioCount");                          int text_count = minstance.GetInt(StreamKind.General' 0' "TextCount");                          if (int.TryParse(minstance.Get(StreamKind.General' 0' "MenuCount")' out int chaptercount))                              m.Chaptered = chaptercount > 0;                          m.Duration = p.Duration = minstance.Get(StreamKind.General' 0' "Duration");                          m.Container = p.Container = TranslateContainer(minstance.Get(StreamKind.General' 0' "Format"));                          string codid = minstance.Get(StreamKind.General' 0' "CodecID");                          if (!string.IsNullOrEmpty(codid) && (codid.Trim().ToLower() == "qt"))                              m.Container = p.Container = "mov";                            int brate = minstance.GetInt(StreamKind.General' 0' "BitRate");                          if (brate != 0)                              m.Bitrate = Math.Round(brate / 1000F).ToString(CultureInfo.InvariantCulture);                          p.Size = minstance.Get(StreamKind.General' 0' "FileSize");                          List<Stream> streams = new List<Stream>();                          int iidx = 0;                          if (video_count > 0)                          {                              for (int x = 0; x < video_count; x++)                              {                                  Stream s = TranslateVideoStream(minstance' x);                                  if (x == 0)                                  {                                      VideoStream = s;                                      m.Width = s.Width;                                      m.Height = s.Height;                                      if (!string.IsNullOrEmpty(m.Height))                                      {                                          if (!string.IsNullOrEmpty(m.Width))                                          {                                              m.VideoResolution =                                                  GetResolution(float.Parse(m.Width)' float.Parse(m.Height));                                              m.AspectRatio =                                                  GetAspectRatio(float.Parse(m.Width)' float.Parse(m.Height)' s.PA);                                          }                                      }                                      if (!string.IsNullOrEmpty(s.FrameRate))                                      {                                          float fr = System.Convert.ToSingle(s.FrameRate);                                          m.VideoFrameRate =                                              ((int) Math.Round(fr)).ToString(CultureInfo.InvariantCulture);                                          if (!string.IsNullOrEmpty(s.ScanType))                                          {                                              if (s.ScanType.ToLower().Contains("int"))                                                  m.VideoFrameRate += "i";                                              else                                                  m.VideoFrameRate += "p";                                          }                                          else                                              m.VideoFrameRate += "p";                                          if ((m.VideoFrameRate == "25p") || (m.VideoFrameRate == "25i"))                                              m.VideoFrameRate = "PAL";                                          else if ((m.VideoFrameRate == "30p") || (m.VideoFrameRate == "30i"))                                              m.VideoFrameRate = "NTSC";                                      }                                      m.VideoCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (video_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                    if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          int totalsoundrate = 0;                          if (audio_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateAudioStream(minstance' x);                                  if ((s.Codec == "adpcm") && (p.Container == "flv"))                                      s.Codec = "adpcm_swf";                                  if (x == 0)                                  {                                      m.AudioCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      m.AudioChannels = s.Channels;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (audio_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                  if (!string.IsNullOrEmpty(s.Bitrate))                                  {                                      double.TryParse(s.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture'                                          out double birate);                                      totalsoundrate += brate;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          if ((VideoStream != null) && string.IsNullOrEmpty(VideoStream.Bitrate) &&                              !string.IsNullOrEmpty(m.Bitrate))                          {                              double.TryParse(m.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture' out double mrate);                              VideoStream.Bitrate =                                  (((int) mrate) - totalsoundrate).ToString(CultureInfo.InvariantCulture);                          }                          if (text_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateTextStream(minstance' x);                                  streams.Add(s);                                  if (text_count == 1)                                  {                                      s.Default = null;                                      s.Forced = null;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                              }                          }                          m.Parts = new List<Part>();                          m.Parts.Add(p);                          bool over = false;                          if (m.Container == "mkv")                          {                              int val = int.MaxValue;                              foreach (Stream s in streams)                              {                                  if (string.IsNullOrEmpty(s.Index))                                  {                                      over = true;                                      break;                                  }                                  s.idx = int.Parse(s.Index);                                  if (s.idx < val)                                      val = s.idx;                              }                              if ((val != 0) && !over)                              {                                  foreach (Stream s in streams)                                  {                                      s.idx = s.idx - val;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              else if (over)                              {                                  int xx = 0;                                  foreach (Stream s in streams)                                  {                                      s.idx = xx++;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              streams = streams.OrderBy(a => a.idx).ToList();                          }                          p.Streams = streams;                      });                      mediaInfoThread.Start();                      bool finished = mediaInfoThread.Join(TimeSpan.FromMinutes(5)); //TODO Move Timeout to settings                      if (!finished)                      {                          try                          {                              mediaInfoThread.Abort();                          }                          catch                          {                              /*ignored*/                          }                          try                          {                              CloseMediaInfo();                          }                          catch                          {                              /*ignored*/                          }                          return null;                      }                      if ((p.Container == "mp4") || (p.Container == "mov"))                      {                          p.Has64bitOffsets = "0";                          p.OptimizedForStreaming = "0";                          m.OptimizedForStreaming = "0";                          byte[] buffer = new byte[8];                          FileSystemResult<System.IO.Stream> fsr = file.OpenRead();                          if (fsr == null || !fsr.IsOk)                              return null;                          System.IO.Stream fs = fsr.Result;                          fs.Read(buffer' 0' 4);                          int siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];                          fs.Seek(siz' SeekOrigin.Begin);                          fs.Read(buffer' 0' 8);                          if ((buffer[4] == 'f') && (buffer[5] == 'r') && (buffer[6] == 'e') && (buffer[7] == 'e'))                          {                              siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] - 8);                              fs.Seek(siz' SeekOrigin.Current);                              fs.Read(buffer' 0' 8);                          }                          if ((buffer[4] == 'm') && (buffer[5] == 'o') && (buffer[6] == 'o') && (buffer[7] == 'v'))                          {                              p.OptimizedForStreaming = "1";                              m.OptimizedForStreaming = "1";                              siz = ((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]) - 8;                                buffer = new byte[siz];                              fs.Read(buffer' 0' siz);                              if (!FindInBuffer("trak"' 0' siz' buffer' out int opos' out int oposmax)) return m;                              if (!FindInBuffer("mdia"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("minf"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("stbl"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("co64"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              p.Has64bitOffsets = "1";                          }                      }                      return m;                  }              }              finally              {                  minstance?.Close();                    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;                  GC.Collect();              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The following statement contains a magic number: try              {                  lock (_lock)                  {                      Media m = new Media();                      Part p = new Part();                      Thread mediaInfoThread = new Thread(() =>                      {                          if (minstance == null)                              minstance = new MediaInfoLib.MediaInfo();                          if (minstance.Open(filename) == 0) return; //it's a boolean response.                          Stream VideoStream = null;                          int video_count = minstance.GetInt(StreamKind.General' 0' "VideoCount");                          int audio_count = minstance.GetInt(StreamKind.General' 0' "AudioCount");                          int text_count = minstance.GetInt(StreamKind.General' 0' "TextCount");                          if (int.TryParse(minstance.Get(StreamKind.General' 0' "MenuCount")' out int chaptercount))                              m.Chaptered = chaptercount > 0;                          m.Duration = p.Duration = minstance.Get(StreamKind.General' 0' "Duration");                          m.Container = p.Container = TranslateContainer(minstance.Get(StreamKind.General' 0' "Format"));                          string codid = minstance.Get(StreamKind.General' 0' "CodecID");                          if (!string.IsNullOrEmpty(codid) && (codid.Trim().ToLower() == "qt"))                              m.Container = p.Container = "mov";                            int brate = minstance.GetInt(StreamKind.General' 0' "BitRate");                          if (brate != 0)                              m.Bitrate = Math.Round(brate / 1000F).ToString(CultureInfo.InvariantCulture);                          p.Size = minstance.Get(StreamKind.General' 0' "FileSize");                          List<Stream> streams = new List<Stream>();                          int iidx = 0;                          if (video_count > 0)                          {                              for (int x = 0; x < video_count; x++)                              {                                  Stream s = TranslateVideoStream(minstance' x);                                  if (x == 0)                                  {                                      VideoStream = s;                                      m.Width = s.Width;                                      m.Height = s.Height;                                      if (!string.IsNullOrEmpty(m.Height))                                      {                                          if (!string.IsNullOrEmpty(m.Width))                                          {                                              m.VideoResolution =                                                  GetResolution(float.Parse(m.Width)' float.Parse(m.Height));                                              m.AspectRatio =                                                  GetAspectRatio(float.Parse(m.Width)' float.Parse(m.Height)' s.PA);                                          }                                      }                                      if (!string.IsNullOrEmpty(s.FrameRate))                                      {                                          float fr = System.Convert.ToSingle(s.FrameRate);                                          m.VideoFrameRate =                                              ((int) Math.Round(fr)).ToString(CultureInfo.InvariantCulture);                                          if (!string.IsNullOrEmpty(s.ScanType))                                          {                                              if (s.ScanType.ToLower().Contains("int"))                                                  m.VideoFrameRate += "i";                                              else                                                  m.VideoFrameRate += "p";                                          }                                          else                                              m.VideoFrameRate += "p";                                          if ((m.VideoFrameRate == "25p") || (m.VideoFrameRate == "25i"))                                              m.VideoFrameRate = "PAL";                                          else if ((m.VideoFrameRate == "30p") || (m.VideoFrameRate == "30i"))                                              m.VideoFrameRate = "NTSC";                                      }                                      m.VideoCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (video_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                    if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          int totalsoundrate = 0;                          if (audio_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateAudioStream(minstance' x);                                  if ((s.Codec == "adpcm") && (p.Container == "flv"))                                      s.Codec = "adpcm_swf";                                  if (x == 0)                                  {                                      m.AudioCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      m.AudioChannels = s.Channels;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (audio_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                  if (!string.IsNullOrEmpty(s.Bitrate))                                  {                                      double.TryParse(s.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture'                                          out double birate);                                      totalsoundrate += brate;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          if ((VideoStream != null) && string.IsNullOrEmpty(VideoStream.Bitrate) &&                              !string.IsNullOrEmpty(m.Bitrate))                          {                              double.TryParse(m.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture' out double mrate);                              VideoStream.Bitrate =                                  (((int) mrate) - totalsoundrate).ToString(CultureInfo.InvariantCulture);                          }                          if (text_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateTextStream(minstance' x);                                  streams.Add(s);                                  if (text_count == 1)                                  {                                      s.Default = null;                                      s.Forced = null;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                              }                          }                          m.Parts = new List<Part>();                          m.Parts.Add(p);                          bool over = false;                          if (m.Container == "mkv")                          {                              int val = int.MaxValue;                              foreach (Stream s in streams)                              {                                  if (string.IsNullOrEmpty(s.Index))                                  {                                      over = true;                                      break;                                  }                                  s.idx = int.Parse(s.Index);                                  if (s.idx < val)                                      val = s.idx;                              }                              if ((val != 0) && !over)                              {                                  foreach (Stream s in streams)                                  {                                      s.idx = s.idx - val;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              else if (over)                              {                                  int xx = 0;                                  foreach (Stream s in streams)                                  {                                      s.idx = xx++;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              streams = streams.OrderBy(a => a.idx).ToList();                          }                          p.Streams = streams;                      });                      mediaInfoThread.Start();                      bool finished = mediaInfoThread.Join(TimeSpan.FromMinutes(5)); //TODO Move Timeout to settings                      if (!finished)                      {                          try                          {                              mediaInfoThread.Abort();                          }                          catch                          {                              /*ignored*/                          }                          try                          {                              CloseMediaInfo();                          }                          catch                          {                              /*ignored*/                          }                          return null;                      }                      if ((p.Container == "mp4") || (p.Container == "mov"))                      {                          p.Has64bitOffsets = "0";                          p.OptimizedForStreaming = "0";                          m.OptimizedForStreaming = "0";                          byte[] buffer = new byte[8];                          FileSystemResult<System.IO.Stream> fsr = file.OpenRead();                          if (fsr == null || !fsr.IsOk)                              return null;                          System.IO.Stream fs = fsr.Result;                          fs.Read(buffer' 0' 4);                          int siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];                          fs.Seek(siz' SeekOrigin.Begin);                          fs.Read(buffer' 0' 8);                          if ((buffer[4] == 'f') && (buffer[5] == 'r') && (buffer[6] == 'e') && (buffer[7] == 'e'))                          {                              siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] - 8);                              fs.Seek(siz' SeekOrigin.Current);                              fs.Read(buffer' 0' 8);                          }                          if ((buffer[4] == 'm') && (buffer[5] == 'o') && (buffer[6] == 'o') && (buffer[7] == 'v'))                          {                              p.OptimizedForStreaming = "1";                              m.OptimizedForStreaming = "1";                              siz = ((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]) - 8;                                buffer = new byte[siz];                              fs.Read(buffer' 0' siz);                              if (!FindInBuffer("trak"' 0' siz' buffer' out int opos' out int oposmax)) return m;                              if (!FindInBuffer("mdia"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("minf"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("stbl"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("co64"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              p.Has64bitOffsets = "1";                          }                      }                      return m;                  }              }              finally              {                  minstance?.Close();                    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;                  GC.Collect();              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The following statement contains a magic number: try              {                  lock (_lock)                  {                      Media m = new Media();                      Part p = new Part();                      Thread mediaInfoThread = new Thread(() =>                      {                          if (minstance == null)                              minstance = new MediaInfoLib.MediaInfo();                          if (minstance.Open(filename) == 0) return; //it's a boolean response.                          Stream VideoStream = null;                          int video_count = minstance.GetInt(StreamKind.General' 0' "VideoCount");                          int audio_count = minstance.GetInt(StreamKind.General' 0' "AudioCount");                          int text_count = minstance.GetInt(StreamKind.General' 0' "TextCount");                          if (int.TryParse(minstance.Get(StreamKind.General' 0' "MenuCount")' out int chaptercount))                              m.Chaptered = chaptercount > 0;                          m.Duration = p.Duration = minstance.Get(StreamKind.General' 0' "Duration");                          m.Container = p.Container = TranslateContainer(minstance.Get(StreamKind.General' 0' "Format"));                          string codid = minstance.Get(StreamKind.General' 0' "CodecID");                          if (!string.IsNullOrEmpty(codid) && (codid.Trim().ToLower() == "qt"))                              m.Container = p.Container = "mov";                            int brate = minstance.GetInt(StreamKind.General' 0' "BitRate");                          if (brate != 0)                              m.Bitrate = Math.Round(brate / 1000F).ToString(CultureInfo.InvariantCulture);                          p.Size = minstance.Get(StreamKind.General' 0' "FileSize");                          List<Stream> streams = new List<Stream>();                          int iidx = 0;                          if (video_count > 0)                          {                              for (int x = 0; x < video_count; x++)                              {                                  Stream s = TranslateVideoStream(minstance' x);                                  if (x == 0)                                  {                                      VideoStream = s;                                      m.Width = s.Width;                                      m.Height = s.Height;                                      if (!string.IsNullOrEmpty(m.Height))                                      {                                          if (!string.IsNullOrEmpty(m.Width))                                          {                                              m.VideoResolution =                                                  GetResolution(float.Parse(m.Width)' float.Parse(m.Height));                                              m.AspectRatio =                                                  GetAspectRatio(float.Parse(m.Width)' float.Parse(m.Height)' s.PA);                                          }                                      }                                      if (!string.IsNullOrEmpty(s.FrameRate))                                      {                                          float fr = System.Convert.ToSingle(s.FrameRate);                                          m.VideoFrameRate =                                              ((int) Math.Round(fr)).ToString(CultureInfo.InvariantCulture);                                          if (!string.IsNullOrEmpty(s.ScanType))                                          {                                              if (s.ScanType.ToLower().Contains("int"))                                                  m.VideoFrameRate += "i";                                              else                                                  m.VideoFrameRate += "p";                                          }                                          else                                              m.VideoFrameRate += "p";                                          if ((m.VideoFrameRate == "25p") || (m.VideoFrameRate == "25i"))                                              m.VideoFrameRate = "PAL";                                          else if ((m.VideoFrameRate == "30p") || (m.VideoFrameRate == "30i"))                                              m.VideoFrameRate = "NTSC";                                      }                                      m.VideoCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (video_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                    if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          int totalsoundrate = 0;                          if (audio_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateAudioStream(minstance' x);                                  if ((s.Codec == "adpcm") && (p.Container == "flv"))                                      s.Codec = "adpcm_swf";                                  if (x == 0)                                  {                                      m.AudioCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      m.AudioChannels = s.Channels;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (audio_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                  if (!string.IsNullOrEmpty(s.Bitrate))                                  {                                      double.TryParse(s.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture'                                          out double birate);                                      totalsoundrate += brate;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          if ((VideoStream != null) && string.IsNullOrEmpty(VideoStream.Bitrate) &&                              !string.IsNullOrEmpty(m.Bitrate))                          {                              double.TryParse(m.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture' out double mrate);                              VideoStream.Bitrate =                                  (((int) mrate) - totalsoundrate).ToString(CultureInfo.InvariantCulture);                          }                          if (text_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateTextStream(minstance' x);                                  streams.Add(s);                                  if (text_count == 1)                                  {                                      s.Default = null;                                      s.Forced = null;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                              }                          }                          m.Parts = new List<Part>();                          m.Parts.Add(p);                          bool over = false;                          if (m.Container == "mkv")                          {                              int val = int.MaxValue;                              foreach (Stream s in streams)                              {                                  if (string.IsNullOrEmpty(s.Index))                                  {                                      over = true;                                      break;                                  }                                  s.idx = int.Parse(s.Index);                                  if (s.idx < val)                                      val = s.idx;                              }                              if ((val != 0) && !over)                              {                                  foreach (Stream s in streams)                                  {                                      s.idx = s.idx - val;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              else if (over)                              {                                  int xx = 0;                                  foreach (Stream s in streams)                                  {                                      s.idx = xx++;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              streams = streams.OrderBy(a => a.idx).ToList();                          }                          p.Streams = streams;                      });                      mediaInfoThread.Start();                      bool finished = mediaInfoThread.Join(TimeSpan.FromMinutes(5)); //TODO Move Timeout to settings                      if (!finished)                      {                          try                          {                              mediaInfoThread.Abort();                          }                          catch                          {                              /*ignored*/                          }                          try                          {                              CloseMediaInfo();                          }                          catch                          {                              /*ignored*/                          }                          return null;                      }                      if ((p.Container == "mp4") || (p.Container == "mov"))                      {                          p.Has64bitOffsets = "0";                          p.OptimizedForStreaming = "0";                          m.OptimizedForStreaming = "0";                          byte[] buffer = new byte[8];                          FileSystemResult<System.IO.Stream> fsr = file.OpenRead();                          if (fsr == null || !fsr.IsOk)                              return null;                          System.IO.Stream fs = fsr.Result;                          fs.Read(buffer' 0' 4);                          int siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];                          fs.Seek(siz' SeekOrigin.Begin);                          fs.Read(buffer' 0' 8);                          if ((buffer[4] == 'f') && (buffer[5] == 'r') && (buffer[6] == 'e') && (buffer[7] == 'e'))                          {                              siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] - 8);                              fs.Seek(siz' SeekOrigin.Current);                              fs.Read(buffer' 0' 8);                          }                          if ((buffer[4] == 'm') && (buffer[5] == 'o') && (buffer[6] == 'o') && (buffer[7] == 'v'))                          {                              p.OptimizedForStreaming = "1";                              m.OptimizedForStreaming = "1";                              siz = ((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]) - 8;                                buffer = new byte[siz];                              fs.Read(buffer' 0' siz);                              if (!FindInBuffer("trak"' 0' siz' buffer' out int opos' out int oposmax)) return m;                              if (!FindInBuffer("mdia"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("minf"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("stbl"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("co64"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              p.Has64bitOffsets = "1";                          }                      }                      return m;                  }              }              finally              {                  minstance?.Close();                    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;                  GC.Collect();              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The following statement contains a magic number: try              {                  lock (_lock)                  {                      Media m = new Media();                      Part p = new Part();                      Thread mediaInfoThread = new Thread(() =>                      {                          if (minstance == null)                              minstance = new MediaInfoLib.MediaInfo();                          if (minstance.Open(filename) == 0) return; //it's a boolean response.                          Stream VideoStream = null;                          int video_count = minstance.GetInt(StreamKind.General' 0' "VideoCount");                          int audio_count = minstance.GetInt(StreamKind.General' 0' "AudioCount");                          int text_count = minstance.GetInt(StreamKind.General' 0' "TextCount");                          if (int.TryParse(minstance.Get(StreamKind.General' 0' "MenuCount")' out int chaptercount))                              m.Chaptered = chaptercount > 0;                          m.Duration = p.Duration = minstance.Get(StreamKind.General' 0' "Duration");                          m.Container = p.Container = TranslateContainer(minstance.Get(StreamKind.General' 0' "Format"));                          string codid = minstance.Get(StreamKind.General' 0' "CodecID");                          if (!string.IsNullOrEmpty(codid) && (codid.Trim().ToLower() == "qt"))                              m.Container = p.Container = "mov";                            int brate = minstance.GetInt(StreamKind.General' 0' "BitRate");                          if (brate != 0)                              m.Bitrate = Math.Round(brate / 1000F).ToString(CultureInfo.InvariantCulture);                          p.Size = minstance.Get(StreamKind.General' 0' "FileSize");                          List<Stream> streams = new List<Stream>();                          int iidx = 0;                          if (video_count > 0)                          {                              for (int x = 0; x < video_count; x++)                              {                                  Stream s = TranslateVideoStream(minstance' x);                                  if (x == 0)                                  {                                      VideoStream = s;                                      m.Width = s.Width;                                      m.Height = s.Height;                                      if (!string.IsNullOrEmpty(m.Height))                                      {                                          if (!string.IsNullOrEmpty(m.Width))                                          {                                              m.VideoResolution =                                                  GetResolution(float.Parse(m.Width)' float.Parse(m.Height));                                              m.AspectRatio =                                                  GetAspectRatio(float.Parse(m.Width)' float.Parse(m.Height)' s.PA);                                          }                                      }                                      if (!string.IsNullOrEmpty(s.FrameRate))                                      {                                          float fr = System.Convert.ToSingle(s.FrameRate);                                          m.VideoFrameRate =                                              ((int) Math.Round(fr)).ToString(CultureInfo.InvariantCulture);                                          if (!string.IsNullOrEmpty(s.ScanType))                                          {                                              if (s.ScanType.ToLower().Contains("int"))                                                  m.VideoFrameRate += "i";                                              else                                                  m.VideoFrameRate += "p";                                          }                                          else                                              m.VideoFrameRate += "p";                                          if ((m.VideoFrameRate == "25p") || (m.VideoFrameRate == "25i"))                                              m.VideoFrameRate = "PAL";                                          else if ((m.VideoFrameRate == "30p") || (m.VideoFrameRate == "30i"))                                              m.VideoFrameRate = "NTSC";                                      }                                      m.VideoCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (video_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                    if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          int totalsoundrate = 0;                          if (audio_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateAudioStream(minstance' x);                                  if ((s.Codec == "adpcm") && (p.Container == "flv"))                                      s.Codec = "adpcm_swf";                                  if (x == 0)                                  {                                      m.AudioCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      m.AudioChannels = s.Channels;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (audio_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                  if (!string.IsNullOrEmpty(s.Bitrate))                                  {                                      double.TryParse(s.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture'                                          out double birate);                                      totalsoundrate += brate;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          if ((VideoStream != null) && string.IsNullOrEmpty(VideoStream.Bitrate) &&                              !string.IsNullOrEmpty(m.Bitrate))                          {                              double.TryParse(m.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture' out double mrate);                              VideoStream.Bitrate =                                  (((int) mrate) - totalsoundrate).ToString(CultureInfo.InvariantCulture);                          }                          if (text_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateTextStream(minstance' x);                                  streams.Add(s);                                  if (text_count == 1)                                  {                                      s.Default = null;                                      s.Forced = null;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                              }                          }                          m.Parts = new List<Part>();                          m.Parts.Add(p);                          bool over = false;                          if (m.Container == "mkv")                          {                              int val = int.MaxValue;                              foreach (Stream s in streams)                              {                                  if (string.IsNullOrEmpty(s.Index))                                  {                                      over = true;                                      break;                                  }                                  s.idx = int.Parse(s.Index);                                  if (s.idx < val)                                      val = s.idx;                              }                              if ((val != 0) && !over)                              {                                  foreach (Stream s in streams)                                  {                                      s.idx = s.idx - val;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              else if (over)                              {                                  int xx = 0;                                  foreach (Stream s in streams)                                  {                                      s.idx = xx++;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              streams = streams.OrderBy(a => a.idx).ToList();                          }                          p.Streams = streams;                      });                      mediaInfoThread.Start();                      bool finished = mediaInfoThread.Join(TimeSpan.FromMinutes(5)); //TODO Move Timeout to settings                      if (!finished)                      {                          try                          {                              mediaInfoThread.Abort();                          }                          catch                          {                              /*ignored*/                          }                          try                          {                              CloseMediaInfo();                          }                          catch                          {                              /*ignored*/                          }                          return null;                      }                      if ((p.Container == "mp4") || (p.Container == "mov"))                      {                          p.Has64bitOffsets = "0";                          p.OptimizedForStreaming = "0";                          m.OptimizedForStreaming = "0";                          byte[] buffer = new byte[8];                          FileSystemResult<System.IO.Stream> fsr = file.OpenRead();                          if (fsr == null || !fsr.IsOk)                              return null;                          System.IO.Stream fs = fsr.Result;                          fs.Read(buffer' 0' 4);                          int siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];                          fs.Seek(siz' SeekOrigin.Begin);                          fs.Read(buffer' 0' 8);                          if ((buffer[4] == 'f') && (buffer[5] == 'r') && (buffer[6] == 'e') && (buffer[7] == 'e'))                          {                              siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] - 8);                              fs.Seek(siz' SeekOrigin.Current);                              fs.Read(buffer' 0' 8);                          }                          if ((buffer[4] == 'm') && (buffer[5] == 'o') && (buffer[6] == 'o') && (buffer[7] == 'v'))                          {                              p.OptimizedForStreaming = "1";                              m.OptimizedForStreaming = "1";                              siz = ((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]) - 8;                                buffer = new byte[siz];                              fs.Read(buffer' 0' siz);                              if (!FindInBuffer("trak"' 0' siz' buffer' out int opos' out int oposmax)) return m;                              if (!FindInBuffer("mdia"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("minf"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("stbl"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("co64"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              p.Has64bitOffsets = "1";                          }                      }                      return m;                  }              }              finally              {                  minstance?.Close();                    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;                  GC.Collect();              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The following statement contains a magic number: try              {                  lock (_lock)                  {                      Media m = new Media();                      Part p = new Part();                      Thread mediaInfoThread = new Thread(() =>                      {                          if (minstance == null)                              minstance = new MediaInfoLib.MediaInfo();                          if (minstance.Open(filename) == 0) return; //it's a boolean response.                          Stream VideoStream = null;                          int video_count = minstance.GetInt(StreamKind.General' 0' "VideoCount");                          int audio_count = minstance.GetInt(StreamKind.General' 0' "AudioCount");                          int text_count = minstance.GetInt(StreamKind.General' 0' "TextCount");                          if (int.TryParse(minstance.Get(StreamKind.General' 0' "MenuCount")' out int chaptercount))                              m.Chaptered = chaptercount > 0;                          m.Duration = p.Duration = minstance.Get(StreamKind.General' 0' "Duration");                          m.Container = p.Container = TranslateContainer(minstance.Get(StreamKind.General' 0' "Format"));                          string codid = minstance.Get(StreamKind.General' 0' "CodecID");                          if (!string.IsNullOrEmpty(codid) && (codid.Trim().ToLower() == "qt"))                              m.Container = p.Container = "mov";                            int brate = minstance.GetInt(StreamKind.General' 0' "BitRate");                          if (brate != 0)                              m.Bitrate = Math.Round(brate / 1000F).ToString(CultureInfo.InvariantCulture);                          p.Size = minstance.Get(StreamKind.General' 0' "FileSize");                          List<Stream> streams = new List<Stream>();                          int iidx = 0;                          if (video_count > 0)                          {                              for (int x = 0; x < video_count; x++)                              {                                  Stream s = TranslateVideoStream(minstance' x);                                  if (x == 0)                                  {                                      VideoStream = s;                                      m.Width = s.Width;                                      m.Height = s.Height;                                      if (!string.IsNullOrEmpty(m.Height))                                      {                                          if (!string.IsNullOrEmpty(m.Width))                                          {                                              m.VideoResolution =                                                  GetResolution(float.Parse(m.Width)' float.Parse(m.Height));                                              m.AspectRatio =                                                  GetAspectRatio(float.Parse(m.Width)' float.Parse(m.Height)' s.PA);                                          }                                      }                                      if (!string.IsNullOrEmpty(s.FrameRate))                                      {                                          float fr = System.Convert.ToSingle(s.FrameRate);                                          m.VideoFrameRate =                                              ((int) Math.Round(fr)).ToString(CultureInfo.InvariantCulture);                                          if (!string.IsNullOrEmpty(s.ScanType))                                          {                                              if (s.ScanType.ToLower().Contains("int"))                                                  m.VideoFrameRate += "i";                                              else                                                  m.VideoFrameRate += "p";                                          }                                          else                                              m.VideoFrameRate += "p";                                          if ((m.VideoFrameRate == "25p") || (m.VideoFrameRate == "25i"))                                              m.VideoFrameRate = "PAL";                                          else if ((m.VideoFrameRate == "30p") || (m.VideoFrameRate == "30i"))                                              m.VideoFrameRate = "NTSC";                                      }                                      m.VideoCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (video_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                    if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          int totalsoundrate = 0;                          if (audio_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateAudioStream(minstance' x);                                  if ((s.Codec == "adpcm") && (p.Container == "flv"))                                      s.Codec = "adpcm_swf";                                  if (x == 0)                                  {                                      m.AudioCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      m.AudioChannels = s.Channels;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (audio_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                  if (!string.IsNullOrEmpty(s.Bitrate))                                  {                                      double.TryParse(s.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture'                                          out double birate);                                      totalsoundrate += brate;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          if ((VideoStream != null) && string.IsNullOrEmpty(VideoStream.Bitrate) &&                              !string.IsNullOrEmpty(m.Bitrate))                          {                              double.TryParse(m.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture' out double mrate);                              VideoStream.Bitrate =                                  (((int) mrate) - totalsoundrate).ToString(CultureInfo.InvariantCulture);                          }                          if (text_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateTextStream(minstance' x);                                  streams.Add(s);                                  if (text_count == 1)                                  {                                      s.Default = null;                                      s.Forced = null;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                              }                          }                          m.Parts = new List<Part>();                          m.Parts.Add(p);                          bool over = false;                          if (m.Container == "mkv")                          {                              int val = int.MaxValue;                              foreach (Stream s in streams)                              {                                  if (string.IsNullOrEmpty(s.Index))                                  {                                      over = true;                                      break;                                  }                                  s.idx = int.Parse(s.Index);                                  if (s.idx < val)                                      val = s.idx;                              }                              if ((val != 0) && !over)                              {                                  foreach (Stream s in streams)                                  {                                      s.idx = s.idx - val;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              else if (over)                              {                                  int xx = 0;                                  foreach (Stream s in streams)                                  {                                      s.idx = xx++;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              streams = streams.OrderBy(a => a.idx).ToList();                          }                          p.Streams = streams;                      });                      mediaInfoThread.Start();                      bool finished = mediaInfoThread.Join(TimeSpan.FromMinutes(5)); //TODO Move Timeout to settings                      if (!finished)                      {                          try                          {                              mediaInfoThread.Abort();                          }                          catch                          {                              /*ignored*/                          }                          try                          {                              CloseMediaInfo();                          }                          catch                          {                              /*ignored*/                          }                          return null;                      }                      if ((p.Container == "mp4") || (p.Container == "mov"))                      {                          p.Has64bitOffsets = "0";                          p.OptimizedForStreaming = "0";                          m.OptimizedForStreaming = "0";                          byte[] buffer = new byte[8];                          FileSystemResult<System.IO.Stream> fsr = file.OpenRead();                          if (fsr == null || !fsr.IsOk)                              return null;                          System.IO.Stream fs = fsr.Result;                          fs.Read(buffer' 0' 4);                          int siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];                          fs.Seek(siz' SeekOrigin.Begin);                          fs.Read(buffer' 0' 8);                          if ((buffer[4] == 'f') && (buffer[5] == 'r') && (buffer[6] == 'e') && (buffer[7] == 'e'))                          {                              siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] - 8);                              fs.Seek(siz' SeekOrigin.Current);                              fs.Read(buffer' 0' 8);                          }                          if ((buffer[4] == 'm') && (buffer[5] == 'o') && (buffer[6] == 'o') && (buffer[7] == 'v'))                          {                              p.OptimizedForStreaming = "1";                              m.OptimizedForStreaming = "1";                              siz = ((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]) - 8;                                buffer = new byte[siz];                              fs.Read(buffer' 0' siz);                              if (!FindInBuffer("trak"' 0' siz' buffer' out int opos' out int oposmax)) return m;                              if (!FindInBuffer("mdia"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("minf"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("stbl"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("co64"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              p.Has64bitOffsets = "1";                          }                      }                      return m;                  }              }              finally              {                  minstance?.Close();                    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;                  GC.Collect();              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The following statement contains a magic number: try              {                  lock (_lock)                  {                      Media m = new Media();                      Part p = new Part();                      Thread mediaInfoThread = new Thread(() =>                      {                          if (minstance == null)                              minstance = new MediaInfoLib.MediaInfo();                          if (minstance.Open(filename) == 0) return; //it's a boolean response.                          Stream VideoStream = null;                          int video_count = minstance.GetInt(StreamKind.General' 0' "VideoCount");                          int audio_count = minstance.GetInt(StreamKind.General' 0' "AudioCount");                          int text_count = minstance.GetInt(StreamKind.General' 0' "TextCount");                          if (int.TryParse(minstance.Get(StreamKind.General' 0' "MenuCount")' out int chaptercount))                              m.Chaptered = chaptercount > 0;                          m.Duration = p.Duration = minstance.Get(StreamKind.General' 0' "Duration");                          m.Container = p.Container = TranslateContainer(minstance.Get(StreamKind.General' 0' "Format"));                          string codid = minstance.Get(StreamKind.General' 0' "CodecID");                          if (!string.IsNullOrEmpty(codid) && (codid.Trim().ToLower() == "qt"))                              m.Container = p.Container = "mov";                            int brate = minstance.GetInt(StreamKind.General' 0' "BitRate");                          if (brate != 0)                              m.Bitrate = Math.Round(brate / 1000F).ToString(CultureInfo.InvariantCulture);                          p.Size = minstance.Get(StreamKind.General' 0' "FileSize");                          List<Stream> streams = new List<Stream>();                          int iidx = 0;                          if (video_count > 0)                          {                              for (int x = 0; x < video_count; x++)                              {                                  Stream s = TranslateVideoStream(minstance' x);                                  if (x == 0)                                  {                                      VideoStream = s;                                      m.Width = s.Width;                                      m.Height = s.Height;                                      if (!string.IsNullOrEmpty(m.Height))                                      {                                          if (!string.IsNullOrEmpty(m.Width))                                          {                                              m.VideoResolution =                                                  GetResolution(float.Parse(m.Width)' float.Parse(m.Height));                                              m.AspectRatio =                                                  GetAspectRatio(float.Parse(m.Width)' float.Parse(m.Height)' s.PA);                                          }                                      }                                      if (!string.IsNullOrEmpty(s.FrameRate))                                      {                                          float fr = System.Convert.ToSingle(s.FrameRate);                                          m.VideoFrameRate =                                              ((int) Math.Round(fr)).ToString(CultureInfo.InvariantCulture);                                          if (!string.IsNullOrEmpty(s.ScanType))                                          {                                              if (s.ScanType.ToLower().Contains("int"))                                                  m.VideoFrameRate += "i";                                              else                                                  m.VideoFrameRate += "p";                                          }                                          else                                              m.VideoFrameRate += "p";                                          if ((m.VideoFrameRate == "25p") || (m.VideoFrameRate == "25i"))                                              m.VideoFrameRate = "PAL";                                          else if ((m.VideoFrameRate == "30p") || (m.VideoFrameRate == "30i"))                                              m.VideoFrameRate = "NTSC";                                      }                                      m.VideoCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (video_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                    if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          int totalsoundrate = 0;                          if (audio_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateAudioStream(minstance' x);                                  if ((s.Codec == "adpcm") && (p.Container == "flv"))                                      s.Codec = "adpcm_swf";                                  if (x == 0)                                  {                                      m.AudioCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      m.AudioChannels = s.Channels;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (audio_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                  if (!string.IsNullOrEmpty(s.Bitrate))                                  {                                      double.TryParse(s.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture'                                          out double birate);                                      totalsoundrate += brate;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          if ((VideoStream != null) && string.IsNullOrEmpty(VideoStream.Bitrate) &&                              !string.IsNullOrEmpty(m.Bitrate))                          {                              double.TryParse(m.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture' out double mrate);                              VideoStream.Bitrate =                                  (((int) mrate) - totalsoundrate).ToString(CultureInfo.InvariantCulture);                          }                          if (text_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateTextStream(minstance' x);                                  streams.Add(s);                                  if (text_count == 1)                                  {                                      s.Default = null;                                      s.Forced = null;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                              }                          }                          m.Parts = new List<Part>();                          m.Parts.Add(p);                          bool over = false;                          if (m.Container == "mkv")                          {                              int val = int.MaxValue;                              foreach (Stream s in streams)                              {                                  if (string.IsNullOrEmpty(s.Index))                                  {                                      over = true;                                      break;                                  }                                  s.idx = int.Parse(s.Index);                                  if (s.idx < val)                                      val = s.idx;                              }                              if ((val != 0) && !over)                              {                                  foreach (Stream s in streams)                                  {                                      s.idx = s.idx - val;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              else if (over)                              {                                  int xx = 0;                                  foreach (Stream s in streams)                                  {                                      s.idx = xx++;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              streams = streams.OrderBy(a => a.idx).ToList();                          }                          p.Streams = streams;                      });                      mediaInfoThread.Start();                      bool finished = mediaInfoThread.Join(TimeSpan.FromMinutes(5)); //TODO Move Timeout to settings                      if (!finished)                      {                          try                          {                              mediaInfoThread.Abort();                          }                          catch                          {                              /*ignored*/                          }                          try                          {                              CloseMediaInfo();                          }                          catch                          {                              /*ignored*/                          }                          return null;                      }                      if ((p.Container == "mp4") || (p.Container == "mov"))                      {                          p.Has64bitOffsets = "0";                          p.OptimizedForStreaming = "0";                          m.OptimizedForStreaming = "0";                          byte[] buffer = new byte[8];                          FileSystemResult<System.IO.Stream> fsr = file.OpenRead();                          if (fsr == null || !fsr.IsOk)                              return null;                          System.IO.Stream fs = fsr.Result;                          fs.Read(buffer' 0' 4);                          int siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];                          fs.Seek(siz' SeekOrigin.Begin);                          fs.Read(buffer' 0' 8);                          if ((buffer[4] == 'f') && (buffer[5] == 'r') && (buffer[6] == 'e') && (buffer[7] == 'e'))                          {                              siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] - 8);                              fs.Seek(siz' SeekOrigin.Current);                              fs.Read(buffer' 0' 8);                          }                          if ((buffer[4] == 'm') && (buffer[5] == 'o') && (buffer[6] == 'o') && (buffer[7] == 'v'))                          {                              p.OptimizedForStreaming = "1";                              m.OptimizedForStreaming = "1";                              siz = ((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]) - 8;                                buffer = new byte[siz];                              fs.Read(buffer' 0' siz);                              if (!FindInBuffer("trak"' 0' siz' buffer' out int opos' out int oposmax)) return m;                              if (!FindInBuffer("mdia"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("minf"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("stbl"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("co64"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              p.Has64bitOffsets = "1";                          }                      }                      return m;                  }              }              finally              {                  minstance?.Close();                    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;                  GC.Collect();              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The following statement contains a magic number: try              {                  lock (_lock)                  {                      Media m = new Media();                      Part p = new Part();                      Thread mediaInfoThread = new Thread(() =>                      {                          if (minstance == null)                              minstance = new MediaInfoLib.MediaInfo();                          if (minstance.Open(filename) == 0) return; //it's a boolean response.                          Stream VideoStream = null;                          int video_count = minstance.GetInt(StreamKind.General' 0' "VideoCount");                          int audio_count = minstance.GetInt(StreamKind.General' 0' "AudioCount");                          int text_count = minstance.GetInt(StreamKind.General' 0' "TextCount");                          if (int.TryParse(minstance.Get(StreamKind.General' 0' "MenuCount")' out int chaptercount))                              m.Chaptered = chaptercount > 0;                          m.Duration = p.Duration = minstance.Get(StreamKind.General' 0' "Duration");                          m.Container = p.Container = TranslateContainer(minstance.Get(StreamKind.General' 0' "Format"));                          string codid = minstance.Get(StreamKind.General' 0' "CodecID");                          if (!string.IsNullOrEmpty(codid) && (codid.Trim().ToLower() == "qt"))                              m.Container = p.Container = "mov";                            int brate = minstance.GetInt(StreamKind.General' 0' "BitRate");                          if (brate != 0)                              m.Bitrate = Math.Round(brate / 1000F).ToString(CultureInfo.InvariantCulture);                          p.Size = minstance.Get(StreamKind.General' 0' "FileSize");                          List<Stream> streams = new List<Stream>();                          int iidx = 0;                          if (video_count > 0)                          {                              for (int x = 0; x < video_count; x++)                              {                                  Stream s = TranslateVideoStream(minstance' x);                                  if (x == 0)                                  {                                      VideoStream = s;                                      m.Width = s.Width;                                      m.Height = s.Height;                                      if (!string.IsNullOrEmpty(m.Height))                                      {                                          if (!string.IsNullOrEmpty(m.Width))                                          {                                              m.VideoResolution =                                                  GetResolution(float.Parse(m.Width)' float.Parse(m.Height));                                              m.AspectRatio =                                                  GetAspectRatio(float.Parse(m.Width)' float.Parse(m.Height)' s.PA);                                          }                                      }                                      if (!string.IsNullOrEmpty(s.FrameRate))                                      {                                          float fr = System.Convert.ToSingle(s.FrameRate);                                          m.VideoFrameRate =                                              ((int) Math.Round(fr)).ToString(CultureInfo.InvariantCulture);                                          if (!string.IsNullOrEmpty(s.ScanType))                                          {                                              if (s.ScanType.ToLower().Contains("int"))                                                  m.VideoFrameRate += "i";                                              else                                                  m.VideoFrameRate += "p";                                          }                                          else                                              m.VideoFrameRate += "p";                                          if ((m.VideoFrameRate == "25p") || (m.VideoFrameRate == "25i"))                                              m.VideoFrameRate = "PAL";                                          else if ((m.VideoFrameRate == "30p") || (m.VideoFrameRate == "30i"))                                              m.VideoFrameRate = "NTSC";                                      }                                      m.VideoCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (video_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                    if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          int totalsoundrate = 0;                          if (audio_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateAudioStream(minstance' x);                                  if ((s.Codec == "adpcm") && (p.Container == "flv"))                                      s.Codec = "adpcm_swf";                                  if (x == 0)                                  {                                      m.AudioCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      m.AudioChannels = s.Channels;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (audio_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                  if (!string.IsNullOrEmpty(s.Bitrate))                                  {                                      double.TryParse(s.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture'                                          out double birate);                                      totalsoundrate += brate;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          if ((VideoStream != null) && string.IsNullOrEmpty(VideoStream.Bitrate) &&                              !string.IsNullOrEmpty(m.Bitrate))                          {                              double.TryParse(m.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture' out double mrate);                              VideoStream.Bitrate =                                  (((int) mrate) - totalsoundrate).ToString(CultureInfo.InvariantCulture);                          }                          if (text_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateTextStream(minstance' x);                                  streams.Add(s);                                  if (text_count == 1)                                  {                                      s.Default = null;                                      s.Forced = null;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                              }                          }                          m.Parts = new List<Part>();                          m.Parts.Add(p);                          bool over = false;                          if (m.Container == "mkv")                          {                              int val = int.MaxValue;                              foreach (Stream s in streams)                              {                                  if (string.IsNullOrEmpty(s.Index))                                  {                                      over = true;                                      break;                                  }                                  s.idx = int.Parse(s.Index);                                  if (s.idx < val)                                      val = s.idx;                              }                              if ((val != 0) && !over)                              {                                  foreach (Stream s in streams)                                  {                                      s.idx = s.idx - val;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              else if (over)                              {                                  int xx = 0;                                  foreach (Stream s in streams)                                  {                                      s.idx = xx++;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              streams = streams.OrderBy(a => a.idx).ToList();                          }                          p.Streams = streams;                      });                      mediaInfoThread.Start();                      bool finished = mediaInfoThread.Join(TimeSpan.FromMinutes(5)); //TODO Move Timeout to settings                      if (!finished)                      {                          try                          {                              mediaInfoThread.Abort();                          }                          catch                          {                              /*ignored*/                          }                          try                          {                              CloseMediaInfo();                          }                          catch                          {                              /*ignored*/                          }                          return null;                      }                      if ((p.Container == "mp4") || (p.Container == "mov"))                      {                          p.Has64bitOffsets = "0";                          p.OptimizedForStreaming = "0";                          m.OptimizedForStreaming = "0";                          byte[] buffer = new byte[8];                          FileSystemResult<System.IO.Stream> fsr = file.OpenRead();                          if (fsr == null || !fsr.IsOk)                              return null;                          System.IO.Stream fs = fsr.Result;                          fs.Read(buffer' 0' 4);                          int siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];                          fs.Seek(siz' SeekOrigin.Begin);                          fs.Read(buffer' 0' 8);                          if ((buffer[4] == 'f') && (buffer[5] == 'r') && (buffer[6] == 'e') && (buffer[7] == 'e'))                          {                              siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] - 8);                              fs.Seek(siz' SeekOrigin.Current);                              fs.Read(buffer' 0' 8);                          }                          if ((buffer[4] == 'm') && (buffer[5] == 'o') && (buffer[6] == 'o') && (buffer[7] == 'v'))                          {                              p.OptimizedForStreaming = "1";                              m.OptimizedForStreaming = "1";                              siz = ((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]) - 8;                                buffer = new byte[siz];                              fs.Read(buffer' 0' siz);                              if (!FindInBuffer("trak"' 0' siz' buffer' out int opos' out int oposmax)) return m;                              if (!FindInBuffer("mdia"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("minf"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("stbl"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("co64"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              p.Has64bitOffsets = "1";                          }                      }                      return m;                  }              }              finally              {                  minstance?.Close();                    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;                  GC.Collect();              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The following statement contains a magic number: try              {                  lock (_lock)                  {                      Media m = new Media();                      Part p = new Part();                      Thread mediaInfoThread = new Thread(() =>                      {                          if (minstance == null)                              minstance = new MediaInfoLib.MediaInfo();                          if (minstance.Open(filename) == 0) return; //it's a boolean response.                          Stream VideoStream = null;                          int video_count = minstance.GetInt(StreamKind.General' 0' "VideoCount");                          int audio_count = minstance.GetInt(StreamKind.General' 0' "AudioCount");                          int text_count = minstance.GetInt(StreamKind.General' 0' "TextCount");                          if (int.TryParse(minstance.Get(StreamKind.General' 0' "MenuCount")' out int chaptercount))                              m.Chaptered = chaptercount > 0;                          m.Duration = p.Duration = minstance.Get(StreamKind.General' 0' "Duration");                          m.Container = p.Container = TranslateContainer(minstance.Get(StreamKind.General' 0' "Format"));                          string codid = minstance.Get(StreamKind.General' 0' "CodecID");                          if (!string.IsNullOrEmpty(codid) && (codid.Trim().ToLower() == "qt"))                              m.Container = p.Container = "mov";                            int brate = minstance.GetInt(StreamKind.General' 0' "BitRate");                          if (brate != 0)                              m.Bitrate = Math.Round(brate / 1000F).ToString(CultureInfo.InvariantCulture);                          p.Size = minstance.Get(StreamKind.General' 0' "FileSize");                          List<Stream> streams = new List<Stream>();                          int iidx = 0;                          if (video_count > 0)                          {                              for (int x = 0; x < video_count; x++)                              {                                  Stream s = TranslateVideoStream(minstance' x);                                  if (x == 0)                                  {                                      VideoStream = s;                                      m.Width = s.Width;                                      m.Height = s.Height;                                      if (!string.IsNullOrEmpty(m.Height))                                      {                                          if (!string.IsNullOrEmpty(m.Width))                                          {                                              m.VideoResolution =                                                  GetResolution(float.Parse(m.Width)' float.Parse(m.Height));                                              m.AspectRatio =                                                  GetAspectRatio(float.Parse(m.Width)' float.Parse(m.Height)' s.PA);                                          }                                      }                                      if (!string.IsNullOrEmpty(s.FrameRate))                                      {                                          float fr = System.Convert.ToSingle(s.FrameRate);                                          m.VideoFrameRate =                                              ((int) Math.Round(fr)).ToString(CultureInfo.InvariantCulture);                                          if (!string.IsNullOrEmpty(s.ScanType))                                          {                                              if (s.ScanType.ToLower().Contains("int"))                                                  m.VideoFrameRate += "i";                                              else                                                  m.VideoFrameRate += "p";                                          }                                          else                                              m.VideoFrameRate += "p";                                          if ((m.VideoFrameRate == "25p") || (m.VideoFrameRate == "25i"))                                              m.VideoFrameRate = "PAL";                                          else if ((m.VideoFrameRate == "30p") || (m.VideoFrameRate == "30i"))                                              m.VideoFrameRate = "NTSC";                                      }                                      m.VideoCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (video_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                    if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          int totalsoundrate = 0;                          if (audio_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateAudioStream(minstance' x);                                  if ((s.Codec == "adpcm") && (p.Container == "flv"))                                      s.Codec = "adpcm_swf";                                  if (x == 0)                                  {                                      m.AudioCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      m.AudioChannels = s.Channels;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (audio_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                  if (!string.IsNullOrEmpty(s.Bitrate))                                  {                                      double.TryParse(s.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture'                                          out double birate);                                      totalsoundrate += brate;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          if ((VideoStream != null) && string.IsNullOrEmpty(VideoStream.Bitrate) &&                              !string.IsNullOrEmpty(m.Bitrate))                          {                              double.TryParse(m.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture' out double mrate);                              VideoStream.Bitrate =                                  (((int) mrate) - totalsoundrate).ToString(CultureInfo.InvariantCulture);                          }                          if (text_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateTextStream(minstance' x);                                  streams.Add(s);                                  if (text_count == 1)                                  {                                      s.Default = null;                                      s.Forced = null;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                              }                          }                          m.Parts = new List<Part>();                          m.Parts.Add(p);                          bool over = false;                          if (m.Container == "mkv")                          {                              int val = int.MaxValue;                              foreach (Stream s in streams)                              {                                  if (string.IsNullOrEmpty(s.Index))                                  {                                      over = true;                                      break;                                  }                                  s.idx = int.Parse(s.Index);                                  if (s.idx < val)                                      val = s.idx;                              }                              if ((val != 0) && !over)                              {                                  foreach (Stream s in streams)                                  {                                      s.idx = s.idx - val;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              else if (over)                              {                                  int xx = 0;                                  foreach (Stream s in streams)                                  {                                      s.idx = xx++;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              streams = streams.OrderBy(a => a.idx).ToList();                          }                          p.Streams = streams;                      });                      mediaInfoThread.Start();                      bool finished = mediaInfoThread.Join(TimeSpan.FromMinutes(5)); //TODO Move Timeout to settings                      if (!finished)                      {                          try                          {                              mediaInfoThread.Abort();                          }                          catch                          {                              /*ignored*/                          }                          try                          {                              CloseMediaInfo();                          }                          catch                          {                              /*ignored*/                          }                          return null;                      }                      if ((p.Container == "mp4") || (p.Container == "mov"))                      {                          p.Has64bitOffsets = "0";                          p.OptimizedForStreaming = "0";                          m.OptimizedForStreaming = "0";                          byte[] buffer = new byte[8];                          FileSystemResult<System.IO.Stream> fsr = file.OpenRead();                          if (fsr == null || !fsr.IsOk)                              return null;                          System.IO.Stream fs = fsr.Result;                          fs.Read(buffer' 0' 4);                          int siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];                          fs.Seek(siz' SeekOrigin.Begin);                          fs.Read(buffer' 0' 8);                          if ((buffer[4] == 'f') && (buffer[5] == 'r') && (buffer[6] == 'e') && (buffer[7] == 'e'))                          {                              siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] - 8);                              fs.Seek(siz' SeekOrigin.Current);                              fs.Read(buffer' 0' 8);                          }                          if ((buffer[4] == 'm') && (buffer[5] == 'o') && (buffer[6] == 'o') && (buffer[7] == 'v'))                          {                              p.OptimizedForStreaming = "1";                              m.OptimizedForStreaming = "1";                              siz = ((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]) - 8;                                buffer = new byte[siz];                              fs.Read(buffer' 0' siz);                              if (!FindInBuffer("trak"' 0' siz' buffer' out int opos' out int oposmax)) return m;                              if (!FindInBuffer("mdia"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("minf"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("stbl"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("co64"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              p.Has64bitOffsets = "1";                          }                      }                      return m;                  }              }              finally              {                  minstance?.Close();                    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;                  GC.Collect();              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The following statement contains a magic number: try              {                  lock (_lock)                  {                      Media m = new Media();                      Part p = new Part();                      Thread mediaInfoThread = new Thread(() =>                      {                          if (minstance == null)                              minstance = new MediaInfoLib.MediaInfo();                          if (minstance.Open(filename) == 0) return; //it's a boolean response.                          Stream VideoStream = null;                          int video_count = minstance.GetInt(StreamKind.General' 0' "VideoCount");                          int audio_count = minstance.GetInt(StreamKind.General' 0' "AudioCount");                          int text_count = minstance.GetInt(StreamKind.General' 0' "TextCount");                          if (int.TryParse(minstance.Get(StreamKind.General' 0' "MenuCount")' out int chaptercount))                              m.Chaptered = chaptercount > 0;                          m.Duration = p.Duration = minstance.Get(StreamKind.General' 0' "Duration");                          m.Container = p.Container = TranslateContainer(minstance.Get(StreamKind.General' 0' "Format"));                          string codid = minstance.Get(StreamKind.General' 0' "CodecID");                          if (!string.IsNullOrEmpty(codid) && (codid.Trim().ToLower() == "qt"))                              m.Container = p.Container = "mov";                            int brate = minstance.GetInt(StreamKind.General' 0' "BitRate");                          if (brate != 0)                              m.Bitrate = Math.Round(brate / 1000F).ToString(CultureInfo.InvariantCulture);                          p.Size = minstance.Get(StreamKind.General' 0' "FileSize");                          List<Stream> streams = new List<Stream>();                          int iidx = 0;                          if (video_count > 0)                          {                              for (int x = 0; x < video_count; x++)                              {                                  Stream s = TranslateVideoStream(minstance' x);                                  if (x == 0)                                  {                                      VideoStream = s;                                      m.Width = s.Width;                                      m.Height = s.Height;                                      if (!string.IsNullOrEmpty(m.Height))                                      {                                          if (!string.IsNullOrEmpty(m.Width))                                          {                                              m.VideoResolution =                                                  GetResolution(float.Parse(m.Width)' float.Parse(m.Height));                                              m.AspectRatio =                                                  GetAspectRatio(float.Parse(m.Width)' float.Parse(m.Height)' s.PA);                                          }                                      }                                      if (!string.IsNullOrEmpty(s.FrameRate))                                      {                                          float fr = System.Convert.ToSingle(s.FrameRate);                                          m.VideoFrameRate =                                              ((int) Math.Round(fr)).ToString(CultureInfo.InvariantCulture);                                          if (!string.IsNullOrEmpty(s.ScanType))                                          {                                              if (s.ScanType.ToLower().Contains("int"))                                                  m.VideoFrameRate += "i";                                              else                                                  m.VideoFrameRate += "p";                                          }                                          else                                              m.VideoFrameRate += "p";                                          if ((m.VideoFrameRate == "25p") || (m.VideoFrameRate == "25i"))                                              m.VideoFrameRate = "PAL";                                          else if ((m.VideoFrameRate == "30p") || (m.VideoFrameRate == "30i"))                                              m.VideoFrameRate = "NTSC";                                      }                                      m.VideoCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (video_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                    if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          int totalsoundrate = 0;                          if (audio_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateAudioStream(minstance' x);                                  if ((s.Codec == "adpcm") && (p.Container == "flv"))                                      s.Codec = "adpcm_swf";                                  if (x == 0)                                  {                                      m.AudioCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      m.AudioChannels = s.Channels;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (audio_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                  if (!string.IsNullOrEmpty(s.Bitrate))                                  {                                      double.TryParse(s.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture'                                          out double birate);                                      totalsoundrate += brate;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          if ((VideoStream != null) && string.IsNullOrEmpty(VideoStream.Bitrate) &&                              !string.IsNullOrEmpty(m.Bitrate))                          {                              double.TryParse(m.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture' out double mrate);                              VideoStream.Bitrate =                                  (((int) mrate) - totalsoundrate).ToString(CultureInfo.InvariantCulture);                          }                          if (text_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateTextStream(minstance' x);                                  streams.Add(s);                                  if (text_count == 1)                                  {                                      s.Default = null;                                      s.Forced = null;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                              }                          }                          m.Parts = new List<Part>();                          m.Parts.Add(p);                          bool over = false;                          if (m.Container == "mkv")                          {                              int val = int.MaxValue;                              foreach (Stream s in streams)                              {                                  if (string.IsNullOrEmpty(s.Index))                                  {                                      over = true;                                      break;                                  }                                  s.idx = int.Parse(s.Index);                                  if (s.idx < val)                                      val = s.idx;                              }                              if ((val != 0) && !over)                              {                                  foreach (Stream s in streams)                                  {                                      s.idx = s.idx - val;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              else if (over)                              {                                  int xx = 0;                                  foreach (Stream s in streams)                                  {                                      s.idx = xx++;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              streams = streams.OrderBy(a => a.idx).ToList();                          }                          p.Streams = streams;                      });                      mediaInfoThread.Start();                      bool finished = mediaInfoThread.Join(TimeSpan.FromMinutes(5)); //TODO Move Timeout to settings                      if (!finished)                      {                          try                          {                              mediaInfoThread.Abort();                          }                          catch                          {                              /*ignored*/                          }                          try                          {                              CloseMediaInfo();                          }                          catch                          {                              /*ignored*/                          }                          return null;                      }                      if ((p.Container == "mp4") || (p.Container == "mov"))                      {                          p.Has64bitOffsets = "0";                          p.OptimizedForStreaming = "0";                          m.OptimizedForStreaming = "0";                          byte[] buffer = new byte[8];                          FileSystemResult<System.IO.Stream> fsr = file.OpenRead();                          if (fsr == null || !fsr.IsOk)                              return null;                          System.IO.Stream fs = fsr.Result;                          fs.Read(buffer' 0' 4);                          int siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];                          fs.Seek(siz' SeekOrigin.Begin);                          fs.Read(buffer' 0' 8);                          if ((buffer[4] == 'f') && (buffer[5] == 'r') && (buffer[6] == 'e') && (buffer[7] == 'e'))                          {                              siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] - 8);                              fs.Seek(siz' SeekOrigin.Current);                              fs.Read(buffer' 0' 8);                          }                          if ((buffer[4] == 'm') && (buffer[5] == 'o') && (buffer[6] == 'o') && (buffer[7] == 'v'))                          {                              p.OptimizedForStreaming = "1";                              m.OptimizedForStreaming = "1";                              siz = ((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]) - 8;                                buffer = new byte[siz];                              fs.Read(buffer' 0' siz);                              if (!FindInBuffer("trak"' 0' siz' buffer' out int opos' out int oposmax)) return m;                              if (!FindInBuffer("mdia"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("minf"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("stbl"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("co64"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              p.Has64bitOffsets = "1";                          }                      }                      return m;                  }              }              finally              {                  minstance?.Close();                    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;                  GC.Collect();              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The following statement contains a magic number: try              {                  lock (_lock)                  {                      Media m = new Media();                      Part p = new Part();                      Thread mediaInfoThread = new Thread(() =>                      {                          if (minstance == null)                              minstance = new MediaInfoLib.MediaInfo();                          if (minstance.Open(filename) == 0) return; //it's a boolean response.                          Stream VideoStream = null;                          int video_count = minstance.GetInt(StreamKind.General' 0' "VideoCount");                          int audio_count = minstance.GetInt(StreamKind.General' 0' "AudioCount");                          int text_count = minstance.GetInt(StreamKind.General' 0' "TextCount");                          if (int.TryParse(minstance.Get(StreamKind.General' 0' "MenuCount")' out int chaptercount))                              m.Chaptered = chaptercount > 0;                          m.Duration = p.Duration = minstance.Get(StreamKind.General' 0' "Duration");                          m.Container = p.Container = TranslateContainer(minstance.Get(StreamKind.General' 0' "Format"));                          string codid = minstance.Get(StreamKind.General' 0' "CodecID");                          if (!string.IsNullOrEmpty(codid) && (codid.Trim().ToLower() == "qt"))                              m.Container = p.Container = "mov";                            int brate = minstance.GetInt(StreamKind.General' 0' "BitRate");                          if (brate != 0)                              m.Bitrate = Math.Round(brate / 1000F).ToString(CultureInfo.InvariantCulture);                          p.Size = minstance.Get(StreamKind.General' 0' "FileSize");                          List<Stream> streams = new List<Stream>();                          int iidx = 0;                          if (video_count > 0)                          {                              for (int x = 0; x < video_count; x++)                              {                                  Stream s = TranslateVideoStream(minstance' x);                                  if (x == 0)                                  {                                      VideoStream = s;                                      m.Width = s.Width;                                      m.Height = s.Height;                                      if (!string.IsNullOrEmpty(m.Height))                                      {                                          if (!string.IsNullOrEmpty(m.Width))                                          {                                              m.VideoResolution =                                                  GetResolution(float.Parse(m.Width)' float.Parse(m.Height));                                              m.AspectRatio =                                                  GetAspectRatio(float.Parse(m.Width)' float.Parse(m.Height)' s.PA);                                          }                                      }                                      if (!string.IsNullOrEmpty(s.FrameRate))                                      {                                          float fr = System.Convert.ToSingle(s.FrameRate);                                          m.VideoFrameRate =                                              ((int) Math.Round(fr)).ToString(CultureInfo.InvariantCulture);                                          if (!string.IsNullOrEmpty(s.ScanType))                                          {                                              if (s.ScanType.ToLower().Contains("int"))                                                  m.VideoFrameRate += "i";                                              else                                                  m.VideoFrameRate += "p";                                          }                                          else                                              m.VideoFrameRate += "p";                                          if ((m.VideoFrameRate == "25p") || (m.VideoFrameRate == "25i"))                                              m.VideoFrameRate = "PAL";                                          else if ((m.VideoFrameRate == "30p") || (m.VideoFrameRate == "30i"))                                              m.VideoFrameRate = "NTSC";                                      }                                      m.VideoCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (video_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                    if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          int totalsoundrate = 0;                          if (audio_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateAudioStream(minstance' x);                                  if ((s.Codec == "adpcm") && (p.Container == "flv"))                                      s.Codec = "adpcm_swf";                                  if (x == 0)                                  {                                      m.AudioCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      m.AudioChannels = s.Channels;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (audio_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                  if (!string.IsNullOrEmpty(s.Bitrate))                                  {                                      double.TryParse(s.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture'                                          out double birate);                                      totalsoundrate += brate;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          if ((VideoStream != null) && string.IsNullOrEmpty(VideoStream.Bitrate) &&                              !string.IsNullOrEmpty(m.Bitrate))                          {                              double.TryParse(m.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture' out double mrate);                              VideoStream.Bitrate =                                  (((int) mrate) - totalsoundrate).ToString(CultureInfo.InvariantCulture);                          }                          if (text_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateTextStream(minstance' x);                                  streams.Add(s);                                  if (text_count == 1)                                  {                                      s.Default = null;                                      s.Forced = null;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                              }                          }                          m.Parts = new List<Part>();                          m.Parts.Add(p);                          bool over = false;                          if (m.Container == "mkv")                          {                              int val = int.MaxValue;                              foreach (Stream s in streams)                              {                                  if (string.IsNullOrEmpty(s.Index))                                  {                                      over = true;                                      break;                                  }                                  s.idx = int.Parse(s.Index);                                  if (s.idx < val)                                      val = s.idx;                              }                              if ((val != 0) && !over)                              {                                  foreach (Stream s in streams)                                  {                                      s.idx = s.idx - val;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              else if (over)                              {                                  int xx = 0;                                  foreach (Stream s in streams)                                  {                                      s.idx = xx++;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              streams = streams.OrderBy(a => a.idx).ToList();                          }                          p.Streams = streams;                      });                      mediaInfoThread.Start();                      bool finished = mediaInfoThread.Join(TimeSpan.FromMinutes(5)); //TODO Move Timeout to settings                      if (!finished)                      {                          try                          {                              mediaInfoThread.Abort();                          }                          catch                          {                              /*ignored*/                          }                          try                          {                              CloseMediaInfo();                          }                          catch                          {                              /*ignored*/                          }                          return null;                      }                      if ((p.Container == "mp4") || (p.Container == "mov"))                      {                          p.Has64bitOffsets = "0";                          p.OptimizedForStreaming = "0";                          m.OptimizedForStreaming = "0";                          byte[] buffer = new byte[8];                          FileSystemResult<System.IO.Stream> fsr = file.OpenRead();                          if (fsr == null || !fsr.IsOk)                              return null;                          System.IO.Stream fs = fsr.Result;                          fs.Read(buffer' 0' 4);                          int siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];                          fs.Seek(siz' SeekOrigin.Begin);                          fs.Read(buffer' 0' 8);                          if ((buffer[4] == 'f') && (buffer[5] == 'r') && (buffer[6] == 'e') && (buffer[7] == 'e'))                          {                              siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] - 8);                              fs.Seek(siz' SeekOrigin.Current);                              fs.Read(buffer' 0' 8);                          }                          if ((buffer[4] == 'm') && (buffer[5] == 'o') && (buffer[6] == 'o') && (buffer[7] == 'v'))                          {                              p.OptimizedForStreaming = "1";                              m.OptimizedForStreaming = "1";                              siz = ((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]) - 8;                                buffer = new byte[siz];                              fs.Read(buffer' 0' siz);                              if (!FindInBuffer("trak"' 0' siz' buffer' out int opos' out int oposmax)) return m;                              if (!FindInBuffer("mdia"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("minf"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("stbl"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("co64"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              p.Has64bitOffsets = "1";                          }                      }                      return m;                  }              }              finally              {                  minstance?.Close();                    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;                  GC.Collect();              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The following statement contains a magic number: try              {                  lock (_lock)                  {                      Media m = new Media();                      Part p = new Part();                      Thread mediaInfoThread = new Thread(() =>                      {                          if (minstance == null)                              minstance = new MediaInfoLib.MediaInfo();                          if (minstance.Open(filename) == 0) return; //it's a boolean response.                          Stream VideoStream = null;                          int video_count = minstance.GetInt(StreamKind.General' 0' "VideoCount");                          int audio_count = minstance.GetInt(StreamKind.General' 0' "AudioCount");                          int text_count = minstance.GetInt(StreamKind.General' 0' "TextCount");                          if (int.TryParse(minstance.Get(StreamKind.General' 0' "MenuCount")' out int chaptercount))                              m.Chaptered = chaptercount > 0;                          m.Duration = p.Duration = minstance.Get(StreamKind.General' 0' "Duration");                          m.Container = p.Container = TranslateContainer(minstance.Get(StreamKind.General' 0' "Format"));                          string codid = minstance.Get(StreamKind.General' 0' "CodecID");                          if (!string.IsNullOrEmpty(codid) && (codid.Trim().ToLower() == "qt"))                              m.Container = p.Container = "mov";                            int brate = minstance.GetInt(StreamKind.General' 0' "BitRate");                          if (brate != 0)                              m.Bitrate = Math.Round(brate / 1000F).ToString(CultureInfo.InvariantCulture);                          p.Size = minstance.Get(StreamKind.General' 0' "FileSize");                          List<Stream> streams = new List<Stream>();                          int iidx = 0;                          if (video_count > 0)                          {                              for (int x = 0; x < video_count; x++)                              {                                  Stream s = TranslateVideoStream(minstance' x);                                  if (x == 0)                                  {                                      VideoStream = s;                                      m.Width = s.Width;                                      m.Height = s.Height;                                      if (!string.IsNullOrEmpty(m.Height))                                      {                                          if (!string.IsNullOrEmpty(m.Width))                                          {                                              m.VideoResolution =                                                  GetResolution(float.Parse(m.Width)' float.Parse(m.Height));                                              m.AspectRatio =                                                  GetAspectRatio(float.Parse(m.Width)' float.Parse(m.Height)' s.PA);                                          }                                      }                                      if (!string.IsNullOrEmpty(s.FrameRate))                                      {                                          float fr = System.Convert.ToSingle(s.FrameRate);                                          m.VideoFrameRate =                                              ((int) Math.Round(fr)).ToString(CultureInfo.InvariantCulture);                                          if (!string.IsNullOrEmpty(s.ScanType))                                          {                                              if (s.ScanType.ToLower().Contains("int"))                                                  m.VideoFrameRate += "i";                                              else                                                  m.VideoFrameRate += "p";                                          }                                          else                                              m.VideoFrameRate += "p";                                          if ((m.VideoFrameRate == "25p") || (m.VideoFrameRate == "25i"))                                              m.VideoFrameRate = "PAL";                                          else if ((m.VideoFrameRate == "30p") || (m.VideoFrameRate == "30i"))                                              m.VideoFrameRate = "NTSC";                                      }                                      m.VideoCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (video_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                    if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          int totalsoundrate = 0;                          if (audio_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateAudioStream(minstance' x);                                  if ((s.Codec == "adpcm") && (p.Container == "flv"))                                      s.Codec = "adpcm_swf";                                  if (x == 0)                                  {                                      m.AudioCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      m.AudioChannels = s.Channels;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (audio_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                  if (!string.IsNullOrEmpty(s.Bitrate))                                  {                                      double.TryParse(s.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture'                                          out double birate);                                      totalsoundrate += brate;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          if ((VideoStream != null) && string.IsNullOrEmpty(VideoStream.Bitrate) &&                              !string.IsNullOrEmpty(m.Bitrate))                          {                              double.TryParse(m.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture' out double mrate);                              VideoStream.Bitrate =                                  (((int) mrate) - totalsoundrate).ToString(CultureInfo.InvariantCulture);                          }                          if (text_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateTextStream(minstance' x);                                  streams.Add(s);                                  if (text_count == 1)                                  {                                      s.Default = null;                                      s.Forced = null;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                              }                          }                          m.Parts = new List<Part>();                          m.Parts.Add(p);                          bool over = false;                          if (m.Container == "mkv")                          {                              int val = int.MaxValue;                              foreach (Stream s in streams)                              {                                  if (string.IsNullOrEmpty(s.Index))                                  {                                      over = true;                                      break;                                  }                                  s.idx = int.Parse(s.Index);                                  if (s.idx < val)                                      val = s.idx;                              }                              if ((val != 0) && !over)                              {                                  foreach (Stream s in streams)                                  {                                      s.idx = s.idx - val;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              else if (over)                              {                                  int xx = 0;                                  foreach (Stream s in streams)                                  {                                      s.idx = xx++;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              streams = streams.OrderBy(a => a.idx).ToList();                          }                          p.Streams = streams;                      });                      mediaInfoThread.Start();                      bool finished = mediaInfoThread.Join(TimeSpan.FromMinutes(5)); //TODO Move Timeout to settings                      if (!finished)                      {                          try                          {                              mediaInfoThread.Abort();                          }                          catch                          {                              /*ignored*/                          }                          try                          {                              CloseMediaInfo();                          }                          catch                          {                              /*ignored*/                          }                          return null;                      }                      if ((p.Container == "mp4") || (p.Container == "mov"))                      {                          p.Has64bitOffsets = "0";                          p.OptimizedForStreaming = "0";                          m.OptimizedForStreaming = "0";                          byte[] buffer = new byte[8];                          FileSystemResult<System.IO.Stream> fsr = file.OpenRead();                          if (fsr == null || !fsr.IsOk)                              return null;                          System.IO.Stream fs = fsr.Result;                          fs.Read(buffer' 0' 4);                          int siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];                          fs.Seek(siz' SeekOrigin.Begin);                          fs.Read(buffer' 0' 8);                          if ((buffer[4] == 'f') && (buffer[5] == 'r') && (buffer[6] == 'e') && (buffer[7] == 'e'))                          {                              siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] - 8);                              fs.Seek(siz' SeekOrigin.Current);                              fs.Read(buffer' 0' 8);                          }                          if ((buffer[4] == 'm') && (buffer[5] == 'o') && (buffer[6] == 'o') && (buffer[7] == 'v'))                          {                              p.OptimizedForStreaming = "1";                              m.OptimizedForStreaming = "1";                              siz = ((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]) - 8;                                buffer = new byte[siz];                              fs.Read(buffer' 0' siz);                              if (!FindInBuffer("trak"' 0' siz' buffer' out int opos' out int oposmax)) return m;                              if (!FindInBuffer("mdia"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("minf"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("stbl"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("co64"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              p.Has64bitOffsets = "1";                          }                      }                      return m;                  }              }              finally              {                  minstance?.Close();                    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;                  GC.Collect();              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,Convert,The following statement contains a magic number: try              {                  lock (_lock)                  {                      Media m = new Media();                      Part p = new Part();                      Thread mediaInfoThread = new Thread(() =>                      {                          if (minstance == null)                              minstance = new MediaInfoLib.MediaInfo();                          if (minstance.Open(filename) == 0) return; //it's a boolean response.                          Stream VideoStream = null;                          int video_count = minstance.GetInt(StreamKind.General' 0' "VideoCount");                          int audio_count = minstance.GetInt(StreamKind.General' 0' "AudioCount");                          int text_count = minstance.GetInt(StreamKind.General' 0' "TextCount");                          if (int.TryParse(minstance.Get(StreamKind.General' 0' "MenuCount")' out int chaptercount))                              m.Chaptered = chaptercount > 0;                          m.Duration = p.Duration = minstance.Get(StreamKind.General' 0' "Duration");                          m.Container = p.Container = TranslateContainer(minstance.Get(StreamKind.General' 0' "Format"));                          string codid = minstance.Get(StreamKind.General' 0' "CodecID");                          if (!string.IsNullOrEmpty(codid) && (codid.Trim().ToLower() == "qt"))                              m.Container = p.Container = "mov";                            int brate = minstance.GetInt(StreamKind.General' 0' "BitRate");                          if (brate != 0)                              m.Bitrate = Math.Round(brate / 1000F).ToString(CultureInfo.InvariantCulture);                          p.Size = minstance.Get(StreamKind.General' 0' "FileSize");                          List<Stream> streams = new List<Stream>();                          int iidx = 0;                          if (video_count > 0)                          {                              for (int x = 0; x < video_count; x++)                              {                                  Stream s = TranslateVideoStream(minstance' x);                                  if (x == 0)                                  {                                      VideoStream = s;                                      m.Width = s.Width;                                      m.Height = s.Height;                                      if (!string.IsNullOrEmpty(m.Height))                                      {                                          if (!string.IsNullOrEmpty(m.Width))                                          {                                              m.VideoResolution =                                                  GetResolution(float.Parse(m.Width)' float.Parse(m.Height));                                              m.AspectRatio =                                                  GetAspectRatio(float.Parse(m.Width)' float.Parse(m.Height)' s.PA);                                          }                                      }                                      if (!string.IsNullOrEmpty(s.FrameRate))                                      {                                          float fr = System.Convert.ToSingle(s.FrameRate);                                          m.VideoFrameRate =                                              ((int) Math.Round(fr)).ToString(CultureInfo.InvariantCulture);                                          if (!string.IsNullOrEmpty(s.ScanType))                                          {                                              if (s.ScanType.ToLower().Contains("int"))                                                  m.VideoFrameRate += "i";                                              else                                                  m.VideoFrameRate += "p";                                          }                                          else                                              m.VideoFrameRate += "p";                                          if ((m.VideoFrameRate == "25p") || (m.VideoFrameRate == "25i"))                                              m.VideoFrameRate = "PAL";                                          else if ((m.VideoFrameRate == "30p") || (m.VideoFrameRate == "30i"))                                              m.VideoFrameRate = "NTSC";                                      }                                      m.VideoCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (video_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                    if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          int totalsoundrate = 0;                          if (audio_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateAudioStream(minstance' x);                                  if ((s.Codec == "adpcm") && (p.Container == "flv"))                                      s.Codec = "adpcm_swf";                                  if (x == 0)                                  {                                      m.AudioCodec = string.IsNullOrEmpty(s.CodecID) ? s.Codec : s.CodecID;                                      m.AudioChannels = s.Channels;                                      if (!string.IsNullOrEmpty(m.Duration) && !string.IsNullOrEmpty(s.Duration))                                      {                                          double.TryParse(s.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double sdur);                                          double.TryParse(m.Duration' NumberStyles.Any' CultureInfo.InvariantCulture'                                              out double mdur);                                          if (sdur > mdur)                                              m.Duration = p.Duration = ((int) sdur).ToString();                                      }                                      if (audio_count == 1)                                      {                                          s.Default = null;                                          s.Forced = null;                                      }                                  }                                  if (!string.IsNullOrEmpty(s.Bitrate))                                  {                                      double.TryParse(s.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture'                                          out double birate);                                      totalsoundrate += brate;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                                  streams.Add(s);                              }                          }                          if ((VideoStream != null) && string.IsNullOrEmpty(VideoStream.Bitrate) &&                              !string.IsNullOrEmpty(m.Bitrate))                          {                              double.TryParse(m.Bitrate' NumberStyles.Any' CultureInfo.InvariantCulture' out double mrate);                              VideoStream.Bitrate =                                  (((int) mrate) - totalsoundrate).ToString(CultureInfo.InvariantCulture);                          }                          if (text_count > 0)                          {                              for (int x = 0; x < audio_count; x++)                              {                                  Stream s = TranslateTextStream(minstance' x);                                  streams.Add(s);                                  if (text_count == 1)                                  {                                      s.Default = null;                                      s.Forced = null;                                  }                                  if (m.Container != "mkv")                                  {                                      s.Index = iidx.ToString(CultureInfo.InvariantCulture);                                      iidx++;                                  }                              }                          }                          m.Parts = new List<Part>();                          m.Parts.Add(p);                          bool over = false;                          if (m.Container == "mkv")                          {                              int val = int.MaxValue;                              foreach (Stream s in streams)                              {                                  if (string.IsNullOrEmpty(s.Index))                                  {                                      over = true;                                      break;                                  }                                  s.idx = int.Parse(s.Index);                                  if (s.idx < val)                                      val = s.idx;                              }                              if ((val != 0) && !over)                              {                                  foreach (Stream s in streams)                                  {                                      s.idx = s.idx - val;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              else if (over)                              {                                  int xx = 0;                                  foreach (Stream s in streams)                                  {                                      s.idx = xx++;                                      s.Index = s.idx.ToString(CultureInfo.InvariantCulture);                                  }                              }                              streams = streams.OrderBy(a => a.idx).ToList();                          }                          p.Streams = streams;                      });                      mediaInfoThread.Start();                      bool finished = mediaInfoThread.Join(TimeSpan.FromMinutes(5)); //TODO Move Timeout to settings                      if (!finished)                      {                          try                          {                              mediaInfoThread.Abort();                          }                          catch                          {                              /*ignored*/                          }                          try                          {                              CloseMediaInfo();                          }                          catch                          {                              /*ignored*/                          }                          return null;                      }                      if ((p.Container == "mp4") || (p.Container == "mov"))                      {                          p.Has64bitOffsets = "0";                          p.OptimizedForStreaming = "0";                          m.OptimizedForStreaming = "0";                          byte[] buffer = new byte[8];                          FileSystemResult<System.IO.Stream> fsr = file.OpenRead();                          if (fsr == null || !fsr.IsOk)                              return null;                          System.IO.Stream fs = fsr.Result;                          fs.Read(buffer' 0' 4);                          int siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];                          fs.Seek(siz' SeekOrigin.Begin);                          fs.Read(buffer' 0' 8);                          if ((buffer[4] == 'f') && (buffer[5] == 'r') && (buffer[6] == 'e') && (buffer[7] == 'e'))                          {                              siz = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] - 8);                              fs.Seek(siz' SeekOrigin.Current);                              fs.Read(buffer' 0' 8);                          }                          if ((buffer[4] == 'm') && (buffer[5] == 'o') && (buffer[6] == 'o') && (buffer[7] == 'v'))                          {                              p.OptimizedForStreaming = "1";                              m.OptimizedForStreaming = "1";                              siz = ((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]) - 8;                                buffer = new byte[siz];                              fs.Read(buffer' 0' siz);                              if (!FindInBuffer("trak"' 0' siz' buffer' out int opos' out int oposmax)) return m;                              if (!FindInBuffer("mdia"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("minf"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("stbl"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              if (!FindInBuffer("co64"' opos' oposmax' buffer' out opos' out oposmax)) return m;                              p.Has64bitOffsets = "1";                          }                      }                      return m;                  }              }              finally              {                  minstance?.Close();                    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;                  GC.Collect();              }
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,FindInBuffer,The following statement contains a magic number: if (start + 8 >= max)                  return false;
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,FindInBuffer,The following statement contains a magic number: do              {                  if ((buffer[start + 4] == atom[0]) && (buffer[start + 5] == atom[1]) &&                      (buffer[start + 6] == atom[2]) &&                      (buffer[start + 7] == atom[3]))                  {                      pos = start + 8;                      posmax =                          ((buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3]) +                          start;                      return true;                  }                  start += (buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3];              } while (start < max);
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,FindInBuffer,The following statement contains a magic number: do              {                  if ((buffer[start + 4] == atom[0]) && (buffer[start + 5] == atom[1]) &&                      (buffer[start + 6] == atom[2]) &&                      (buffer[start + 7] == atom[3]))                  {                      pos = start + 8;                      posmax =                          ((buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3]) +                          start;                      return true;                  }                  start += (buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3];              } while (start < max);
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,FindInBuffer,The following statement contains a magic number: do              {                  if ((buffer[start + 4] == atom[0]) && (buffer[start + 5] == atom[1]) &&                      (buffer[start + 6] == atom[2]) &&                      (buffer[start + 7] == atom[3]))                  {                      pos = start + 8;                      posmax =                          ((buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3]) +                          start;                      return true;                  }                  start += (buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3];              } while (start < max);
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,FindInBuffer,The following statement contains a magic number: do              {                  if ((buffer[start + 4] == atom[0]) && (buffer[start + 5] == atom[1]) &&                      (buffer[start + 6] == atom[2]) &&                      (buffer[start + 7] == atom[3]))                  {                      pos = start + 8;                      posmax =                          ((buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3]) +                          start;                      return true;                  }                  start += (buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3];              } while (start < max);
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,FindInBuffer,The following statement contains a magic number: do              {                  if ((buffer[start + 4] == atom[0]) && (buffer[start + 5] == atom[1]) &&                      (buffer[start + 6] == atom[2]) &&                      (buffer[start + 7] == atom[3]))                  {                      pos = start + 8;                      posmax =                          ((buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3]) +                          start;                      return true;                  }                  start += (buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3];              } while (start < max);
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,FindInBuffer,The following statement contains a magic number: do              {                  if ((buffer[start + 4] == atom[0]) && (buffer[start + 5] == atom[1]) &&                      (buffer[start + 6] == atom[2]) &&                      (buffer[start + 7] == atom[3]))                  {                      pos = start + 8;                      posmax =                          ((buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3]) +                          start;                      return true;                  }                  start += (buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3];              } while (start < max);
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,FindInBuffer,The following statement contains a magic number: do              {                  if ((buffer[start + 4] == atom[0]) && (buffer[start + 5] == atom[1]) &&                      (buffer[start + 6] == atom[2]) &&                      (buffer[start + 7] == atom[3]))                  {                      pos = start + 8;                      posmax =                          ((buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3]) +                          start;                      return true;                  }                  start += (buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3];              } while (start < max);
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,FindInBuffer,The following statement contains a magic number: do              {                  if ((buffer[start + 4] == atom[0]) && (buffer[start + 5] == atom[1]) &&                      (buffer[start + 6] == atom[2]) &&                      (buffer[start + 7] == atom[3]))                  {                      pos = start + 8;                      posmax =                          ((buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3]) +                          start;                      return true;                  }                  start += (buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3];              } while (start < max);
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,FindInBuffer,The following statement contains a magic number: do              {                  if ((buffer[start + 4] == atom[0]) && (buffer[start + 5] == atom[1]) &&                      (buffer[start + 6] == atom[2]) &&                      (buffer[start + 7] == atom[3]))                  {                      pos = start + 8;                      posmax =                          ((buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3]) +                          start;                      return true;                  }                  start += (buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3];              } while (start < max);
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,FindInBuffer,The following statement contains a magic number: do              {                  if ((buffer[start + 4] == atom[0]) && (buffer[start + 5] == atom[1]) &&                      (buffer[start + 6] == atom[2]) &&                      (buffer[start + 7] == atom[3]))                  {                      pos = start + 8;                      posmax =                          ((buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3]) +                          start;                      return true;                  }                  start += (buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3];              } while (start < max);
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,FindInBuffer,The following statement contains a magic number: do              {                  if ((buffer[start + 4] == atom[0]) && (buffer[start + 5] == atom[1]) &&                      (buffer[start + 6] == atom[2]) &&                      (buffer[start + 7] == atom[3]))                  {                      pos = start + 8;                      posmax =                          ((buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3]) +                          start;                      return true;                  }                  start += (buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3];              } while (start < max);
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,FindInBuffer,The following statement contains a magic number: do              {                  if ((buffer[start + 4] == atom[0]) && (buffer[start + 5] == atom[1]) &&                      (buffer[start + 6] == atom[2]) &&                      (buffer[start + 7] == atom[3]))                  {                      pos = start + 8;                      posmax =                          ((buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3]) +                          start;                      return true;                  }                  start += (buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3];              } while (start < max);
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,FindInBuffer,The following statement contains a magic number: do              {                  if ((buffer[start + 4] == atom[0]) && (buffer[start + 5] == atom[1]) &&                      (buffer[start + 6] == atom[2]) &&                      (buffer[start + 7] == atom[3]))                  {                      pos = start + 8;                      posmax =                          ((buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3]) +                          start;                      return true;                  }                  start += (buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3];              } while (start < max);
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,FindInBuffer,The following statement contains a magic number: do              {                  if ((buffer[start + 4] == atom[0]) && (buffer[start + 5] == atom[1]) &&                      (buffer[start + 6] == atom[2]) &&                      (buffer[start + 7] == atom[3]))                  {                      pos = start + 8;                      posmax =                          ((buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3]) +                          start;                      return true;                  }                  start += (buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3];              } while (start < max);
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,FindInBuffer,The following statement contains a magic number: do              {                  if ((buffer[start + 4] == atom[0]) && (buffer[start + 5] == atom[1]) &&                      (buffer[start + 6] == atom[2]) &&                      (buffer[start + 7] == atom[3]))                  {                      pos = start + 8;                      posmax =                          ((buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3]) +                          start;                      return true;                  }                  start += (buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3];              } while (start < max);
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,FindInBuffer,The following statement contains a magic number: do              {                  if ((buffer[start + 4] == atom[0]) && (buffer[start + 5] == atom[1]) &&                      (buffer[start + 6] == atom[2]) &&                      (buffer[start + 7] == atom[3]))                  {                      pos = start + 8;                      posmax =                          ((buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3]) +                          start;                      return true;                  }                  start += (buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3];              } while (start < max);
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,FindInBuffer,The following statement contains a magic number: do              {                  if ((buffer[start + 4] == atom[0]) && (buffer[start + 5] == atom[1]) &&                      (buffer[start + 6] == atom[2]) &&                      (buffer[start + 7] == atom[3]))                  {                      pos = start + 8;                      posmax =                          ((buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3]) +                          start;                      return true;                  }                  start += (buffer[start] << 24) | (buffer[start + 1] << 16) | (buffer[start + 2] << 8) | buffer[start + 3];              } while (start < max);
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,GetResolution,The following statement contains a magic number: if (h > 720)                  return "1080";
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,GetResolution,The following statement contains a magic number: if (h > 576)                  return "720";
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,GetResolution,The following statement contains a magic number: if (h > 480)                  return "576";
Magic Number,Shoko.Server.FileHelper.MediaInfo,MediaConvert,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\FileHelper\MediaInfo\Convert.cs,GetResolution,The following statement contains a magic number: if (h > 360)                  return "480";
Magic Number,Shoko.Server.PlexAndKodi,CommonImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\CommonImplementation.cs,Search,The following statement contains a magic number: if (lim == 0)                  lim = 100;
Magic Number,Shoko.Server.PlexAndKodi,CommonImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\CommonImplementation.cs,VoteAnime,The following statement contains a magic number: try              {                  if (!int.TryParse(userid' out int usid))                      return rsp;                    if (vt == (int) AniDBVoteType.Episode)                  {                      SVR_AnimeEpisode ep = RepoFactory.AnimeEpisode.GetByID(objid);                      if (ep == null)                      {                          rsp.Code = "404";                          rsp.Message = "Episode Not Found";                          return rsp;                      }                      SVR_AniDB_Anime anime = ep.GetAnimeSeries().GetAnime();                      if (anime == null)                      {                          rsp.Code = "404";                          rsp.Message = "Anime Not Found";                          return rsp;                      }                      string msg = string.Format("Voting for anime episode: {0} - Value: {1}"' ep.AnimeEpisodeID'                          vvalue);                      logger.Info(msg);                        // lets save to the database and assume it will work                      AniDB_Vote thisVote = RepoFactory.AniDB_Vote.GetByEntityAndType(ep.AnimeEpisodeID' AniDBVoteType.Episode);                        if (thisVote == null)                      {                          thisVote = new AniDB_Vote                          {                              EntityID = ep.AnimeEpisodeID                          };                      }                      thisVote.VoteType = vt;                        int iVoteValue = 0;                      if (vvalue > 0)                          iVoteValue = (int) (vvalue * 100);                      else                          iVoteValue = (int) vvalue;                        msg = string.Format("Voting for anime episode Formatted: {0} - Value: {1}"' ep.AnimeEpisodeID'                          iVoteValue);                      logger.Info(msg);                      thisVote.VoteValue = iVoteValue;                      RepoFactory.AniDB_Vote.Save(thisVote);                        CommandRequest_VoteAnime cmdVote = new CommandRequest_VoteAnime(anime.AnimeID' vt'                          Convert.ToDecimal(vvalue));                      cmdVote.Save();                  }                    if (vt == (int) AniDBVoteType.Anime)                  {                      SVR_AnimeSeries ser = RepoFactory.AnimeSeries.GetByID(objid);                      SVR_AniDB_Anime anime = ser.GetAnime();                      if (anime == null)                      {                          rsp.Code = "404";                          rsp.Message = "Anime Not Found";                          return rsp;                      }                      string msg = string.Format("Voting for anime: {0} - Value: {1}"' anime.AnimeID' vvalue);                      logger.Info(msg);                        // lets save to the database and assume it will work                      AniDB_Vote thisVote =                          RepoFactory.AniDB_Vote.GetByEntityAndType(anime.AnimeID' AniDBVoteType.AnimeTemp) ??                          RepoFactory.AniDB_Vote.GetByEntityAndType(anime.AnimeID' AniDBVoteType.Anime);                        if (thisVote == null)                      {                          thisVote = new AniDB_Vote                          {                              EntityID = anime.AnimeID                          };                      }                      thisVote.VoteType = vt;                        int iVoteValue = 0;                      if (vvalue > 0)                          iVoteValue = (int) (vvalue * 100);                      else                          iVoteValue = (int) vvalue;                        msg = string.Format("Voting for anime Formatted: {0} - Value: {1}"' anime.AnimeID' iVoteValue);                      logger.Info(msg);                      thisVote.VoteValue = iVoteValue;                      RepoFactory.AniDB_Vote.Save(thisVote);                      CommandRequest_VoteAnime cmdVote = new CommandRequest_VoteAnime(anime.AnimeID' vt'                          Convert.ToDecimal(vvalue));                      cmdVote.Save();                  }                  rsp.Code = "200";                  rsp.Message = null;              }              catch (Exception ex)              {                  rsp.Code = "500";                  rsp.Message = "Internal Error : " + ex;                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server.PlexAndKodi,CommonImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\CommonImplementation.cs,VoteAnime,The following statement contains a magic number: try              {                  if (!int.TryParse(userid' out int usid))                      return rsp;                    if (vt == (int) AniDBVoteType.Episode)                  {                      SVR_AnimeEpisode ep = RepoFactory.AnimeEpisode.GetByID(objid);                      if (ep == null)                      {                          rsp.Code = "404";                          rsp.Message = "Episode Not Found";                          return rsp;                      }                      SVR_AniDB_Anime anime = ep.GetAnimeSeries().GetAnime();                      if (anime == null)                      {                          rsp.Code = "404";                          rsp.Message = "Anime Not Found";                          return rsp;                      }                      string msg = string.Format("Voting for anime episode: {0} - Value: {1}"' ep.AnimeEpisodeID'                          vvalue);                      logger.Info(msg);                        // lets save to the database and assume it will work                      AniDB_Vote thisVote = RepoFactory.AniDB_Vote.GetByEntityAndType(ep.AnimeEpisodeID' AniDBVoteType.Episode);                        if (thisVote == null)                      {                          thisVote = new AniDB_Vote                          {                              EntityID = ep.AnimeEpisodeID                          };                      }                      thisVote.VoteType = vt;                        int iVoteValue = 0;                      if (vvalue > 0)                          iVoteValue = (int) (vvalue * 100);                      else                          iVoteValue = (int) vvalue;                        msg = string.Format("Voting for anime episode Formatted: {0} - Value: {1}"' ep.AnimeEpisodeID'                          iVoteValue);                      logger.Info(msg);                      thisVote.VoteValue = iVoteValue;                      RepoFactory.AniDB_Vote.Save(thisVote);                        CommandRequest_VoteAnime cmdVote = new CommandRequest_VoteAnime(anime.AnimeID' vt'                          Convert.ToDecimal(vvalue));                      cmdVote.Save();                  }                    if (vt == (int) AniDBVoteType.Anime)                  {                      SVR_AnimeSeries ser = RepoFactory.AnimeSeries.GetByID(objid);                      SVR_AniDB_Anime anime = ser.GetAnime();                      if (anime == null)                      {                          rsp.Code = "404";                          rsp.Message = "Anime Not Found";                          return rsp;                      }                      string msg = string.Format("Voting for anime: {0} - Value: {1}"' anime.AnimeID' vvalue);                      logger.Info(msg);                        // lets save to the database and assume it will work                      AniDB_Vote thisVote =                          RepoFactory.AniDB_Vote.GetByEntityAndType(anime.AnimeID' AniDBVoteType.AnimeTemp) ??                          RepoFactory.AniDB_Vote.GetByEntityAndType(anime.AnimeID' AniDBVoteType.Anime);                        if (thisVote == null)                      {                          thisVote = new AniDB_Vote                          {                              EntityID = anime.AnimeID                          };                      }                      thisVote.VoteType = vt;                        int iVoteValue = 0;                      if (vvalue > 0)                          iVoteValue = (int) (vvalue * 100);                      else                          iVoteValue = (int) vvalue;                        msg = string.Format("Voting for anime Formatted: {0} - Value: {1}"' anime.AnimeID' iVoteValue);                      logger.Info(msg);                      thisVote.VoteValue = iVoteValue;                      RepoFactory.AniDB_Vote.Save(thisVote);                      CommandRequest_VoteAnime cmdVote = new CommandRequest_VoteAnime(anime.AnimeID' vt'                          Convert.ToDecimal(vvalue));                      cmdVote.Save();                  }                  rsp.Code = "200";                  rsp.Message = null;              }              catch (Exception ex)              {                  rsp.Code = "500";                  rsp.Message = "Internal Error : " + ex;                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server.PlexAndKodi,CommonImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\CommonImplementation.cs,TraktScrobble,The following statement contains a magic number: try              {                  Providers.TraktTV.ScrobblePlayingStatus statusTraktV2 = Providers.TraktTV.ScrobblePlayingStatus.Start;                  switch (status)                  {                      case (int) Providers.TraktTV.ScrobblePlayingStatus.Start:                          statusTraktV2 = Providers.TraktTV.ScrobblePlayingStatus.Start;                          break;                      case (int) Providers.TraktTV.ScrobblePlayingStatus.Pause:                          statusTraktV2 = Providers.TraktTV.ScrobblePlayingStatus.Pause;                          break;                      case (int) Providers.TraktTV.ScrobblePlayingStatus.Stop:                          statusTraktV2 = Providers.TraktTV.ScrobblePlayingStatus.Stop;                          break;                  }                    progressTrakt = progressTrakt / 10;                    switch (typeTrakt)                  {                      // Movie                      case (int) Providers.TraktTV.ScrobblePlayingType.movie:                          rsp.Code = Providers.TraktTV.TraktTVHelper.Scrobble(                                  Providers.TraktTV.ScrobblePlayingType.movie' animeId'                                  statusTraktV2' progressTrakt)                              .ToString();                          rsp.Message = "Movie Scrobbled";                          break;                      // TV episode                      case (int) Providers.TraktTV.ScrobblePlayingType.episode:                          rsp.Code =                              Providers.TraktTV.TraktTVHelper.Scrobble(Providers.TraktTV.ScrobblePlayingType.episode'                                      animeId'                                      statusTraktV2' progressTrakt)                                  .ToString();                          rsp.Message = "Episode Scrobbled";                          break;                      //error                  }              }              catch (Exception ex)              {                  rsp.Code = "500";                  rsp.Message = "Internal Error : " + ex;                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server.PlexAndKodi,Extensions,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Extensions.cs,ToUnixTime,The following statement contains a magic number: return ((long) v.Subtract(new DateTime(1970' 1' 1)).TotalSeconds).ToString(CultureInfo.InvariantCulture);
Magic Number,Shoko.Server.PlexAndKodi,Helper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Helper.cs,CreateRelationsMap,The following statement contains a magic number: for (int x = 0; x < aspects.Length; x += 2)              {                  string key = aspects[x].Trim().ToUpper();                    double.TryParse(aspects[x + 1].Trim()' NumberStyles.Any' CultureInfo.InvariantCulture' out double val);                  relations.Add(key' val);              }
Magic Number,Shoko.Server.PlexAndKodi,Helper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Helper.cs,GenerateFromAnimeGroup,The following statement contains a magic number: if ((cgrp.Stat_SeriesCount == 1) && (subgrpcnt == 0))              {                  SVR_AnimeSeries ser = ShokoServiceImplementation.GetSeriesForGroup(grp.AnimeGroupID' allSeries);                  CL_AnimeSeries_User cserie = ser?.GetUserContract(userid);                  if (cserie == null) return null;                  Video v = GenerateFromSeries(cserie' ser' ser.GetAnime()' userid' session);                  v.AirDate = ser.AirDate;                  v.UpdatedAt = ser.LatestEpisodeAirDate.HasValue                      ? ser.LatestEpisodeAirDate.Value.ToUnixTime()                      : null;                  v.Group = cgrp;                  return v;              }              else              {                  SVR_AnimeSeries ser = grp.DefaultAnimeSeriesID.HasValue                      ? allSeries.FirstOrDefault(a => a.AnimeSeriesID == grp.DefaultAnimeSeriesID.Value)                      : allSeries.Find(a => a.AirDate != DateTime.MinValue);                  if (ser == null && allSeries.Count > 0)                      ser = allSeries[0];                  CL_AnimeSeries_User cserie = ser?.GetUserContract(userid);                  Video v = FromGroup(cgrp' cserie' userid' subgrpcnt);                  v.Group = cgrp;                  v.AirDate = cgrp.Stat_AirDate_Min ?? DateTime.MinValue;                  v.UpdatedAt = cgrp.LatestEpisodeAirDate?.ToUnixTime();                  v.Rating = Math.Round((grp.AniDBRating / 100)' 1).ToString(CultureInfo.InvariantCulture);                  List<Tag> newTags = new List<Tag>();                  foreach (AniDB_Tag tag in grp.Tags)                  {                      Tag newTag = new Tag();                      TextInfo textInfo = new CultureInfo("en-US"' false).TextInfo;                      newTag.Value = textInfo.ToTitleCase(tag.TagName.Trim());                      if (!newTags.Contains(newTag)) newTags.Add(newTag);                  }                  v.Genres = newTags;                  if (ser == null) return v;                  List<AnimeTitle> newTitles = ser.GetAnime()                      .GetTitles()                      .Select(title => new AnimeTitle                      {                          Title = title.Title'                          Language = title.Language'                          Type = title.TitleType                      })                      .ToList();                  v.Titles = newTitles;                    v.Roles = new List<RoleTag>();                    //TODO Character implementation is limited in JMM' One Character' could have more than one Seiyuu                  if (ser.GetAnime()?.Contract?.AniDBAnime?.Characters != null)                  {                      foreach (CL_AniDB_Character c in ser.GetAnime().Contract.AniDBAnime.Characters)                      {                          string ch = c?.CharName;                          AniDB_Seiyuu seiyuu = c?.Seiyuu;                          if (string.IsNullOrEmpty(ch)) continue;                          RoleTag t = new RoleTag                          {                              Value = seiyuu?.SeiyuuName                          };                          if (seiyuu != null)                              t.TagPicture = Helper.ConstructSeiyuuImage(null' seiyuu.AniDB_SeiyuuID);                          t.Role = ch;                          t.RoleDescription = c?.CharDescription;                          t.RolePicture = Helper.ConstructCharacterImage(null' c.CharID);                          v.Roles.Add(t);                      }                  }                  if (cserie?.AniDBAnime?.AniDBAnime?.Fanarts != null)                  {                      v.Fanarts = new List<Contract_ImageDetails>();                      cserie?.AniDBAnime?.AniDBAnime?.Fanarts.ForEach(                          a =>                              v.Fanarts.Add(new Contract_ImageDetails()                              {                                  ImageID = a.AniDB_Anime_DefaultImageID'                                  ImageType = a.ImageType                              }));                  }                  if (cserie?.AniDBAnime?.AniDBAnime?.Banners == null) return v;                  v.Banners = new List<Contract_ImageDetails>();                  cserie?.AniDBAnime?.AniDBAnime?.Banners.ForEach(                      a =>                          v.Banners.Add(new Contract_ImageDetails()                          {                              ImageID = a.AniDB_Anime_DefaultImageID'                              ImageType = a.ImageType                          }));                  return v;              }
Magic Number,Shoko.Server.PlexAndKodi.Plex,PlexProvider,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Plex\PlexProvider.cs,ToHex,The following statement contains a magic number: StringBuilder hex = new StringBuilder(ba.Length * 2);
Magic Number,Shoko.Server.PlexAndKodi.Plex,PlexProvider,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Plex\PlexProvider.cs,FromHex,The following statement contains a magic number: byte[] raw = new byte[hex.Length / 2];
Magic Number,Shoko.Server.PlexAndKodi.Plex,PlexProvider,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Plex\PlexProvider.cs,FromHex,The following statement contains a magic number: for (int i = 0; i < raw.Length; i++)              {                  raw[i] = Convert.ToByte(hex.Substring(i * 2' 2)' 16);              }
Magic Number,Shoko.Server.PlexAndKodi.Plex,PlexProvider,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Plex\PlexProvider.cs,FromHex,The following statement contains a magic number: for (int i = 0; i < raw.Length; i++)              {                  raw[i] = Convert.ToByte(hex.Substring(i * 2' 2)' 16);              }
Magic Number,Shoko.Server.PlexAndKodi.Plex,PlexProvider,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Plex\PlexProvider.cs,FromHex,The following statement contains a magic number: for (int i = 0; i < raw.Length; i++)              {                  raw[i] = Convert.ToByte(hex.Substring(i * 2' 2)' 16);              }
Magic Number,Shoko.Server.Tasks,AutoAnimeGroupCalculator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Tasks\AutoAnimeGroupCalculator.cs,Create,The following statement contains a magic number: var relationshipMap = session.CreateSQLQuery(@"                  SELECT    fromAnime.AnimeID AS fromAnimeId                          ' toAnime.AnimeID AS toAnimeId                          ' fromAnime.AnimeType AS fromAnimeType                          ' toAnime.AnimeType AS toAnimeType                          ' fromAnime.MainTitle AS fromMainTitle                          ' toAnime.MainTitle AS toMainTitle                          ' fromAnime.AirDate AS fromAirDate                          ' toAnime.AirDate AS toAirDate                          ' rel.RelationType AS relationType                      FROM AniDB_Anime_Relation rel                          INNER JOIN AniDB_Anime fromAnime                              ON fromAnime.AnimeID = rel.AnimeID                          INNER JOIN AniDB_Anime toAnime                              ON toAnime.AnimeID = rel.RelatedAnimeID")                  .AddScalar("fromAnimeId"' NHibernateUtil.Int32)                  .AddScalar("toAnimeId"' NHibernateUtil.Int32)                  .AddScalar("fromAnimeType"' NHibernateUtil.Int32)                  .AddScalar("toAnimeType"' NHibernateUtil.Int32)                  .AddScalar("fromMainTitle"' NHibernateUtil.String)                  .AddScalar("toMainTitle"' NHibernateUtil.String)                  .AddScalar("fromAirDate"' NHibernateUtil.DateTime)                  .AddScalar("toAirDate"' NHibernateUtil.DateTime)                  .AddScalar("relationType"' NHibernateUtil.String)                  .List<object[]>()                  .Select(r =>                  {                      var relation = new AnimeRelation                      {                          FromId = (int) r[0]'                          ToId = (int) r[1]'                          FromType = (AnimeType) r[2]'                          ToType = (AnimeType) r[3]'                          FromMainTitle = (string) r[4]'                          ToMainTitle = (string) r[5]'                          FromAirDate = (DateTime?) r[6]'                          ToAirDate = (DateTime?) r[7]                      };                        switch (((string) r[8]).ToLowerInvariant())                      {                          case "full story":                              relation.RelationType = AnimeRelationType.FullStory;                              break;                          case "summary":                              relation.RelationType = AnimeRelationType.Summary;                              break;                          case "parent story":                              relation.RelationType = AnimeRelationType.ParentStory;                              break;                          case "side story":                              relation.RelationType = AnimeRelationType.SideStory;                              break;                          case "prequel":                              relation.RelationType = AnimeRelationType.Prequel;                              break;                          case "sequel":                              relation.RelationType = AnimeRelationType.Sequel;                              break;                          case "alternative setting":                              relation.RelationType = AnimeRelationType.AlternateSetting;                              break;                          case "alternative version":                              relation.RelationType = AnimeRelationType.AlternateVersion;                              break;                          case "same setting":                              relation.RelationType = AnimeRelationType.SameSetting;                              break;                          case "character":                              relation.RelationType = AnimeRelationType.Character;                              break;                          default:                              relation.RelationType = AnimeRelationType.Other;                              break;                      }                        return relation;                  })                  .ToLookup(k => k.FromId);
Magic Number,Shoko.Server.Tasks,AutoAnimeGroupCalculator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Tasks\AutoAnimeGroupCalculator.cs,Create,The following statement contains a magic number: var relationshipMap = session.CreateSQLQuery(@"                  SELECT    fromAnime.AnimeID AS fromAnimeId                          ' toAnime.AnimeID AS toAnimeId                          ' fromAnime.AnimeType AS fromAnimeType                          ' toAnime.AnimeType AS toAnimeType                          ' fromAnime.MainTitle AS fromMainTitle                          ' toAnime.MainTitle AS toMainTitle                          ' fromAnime.AirDate AS fromAirDate                          ' toAnime.AirDate AS toAirDate                          ' rel.RelationType AS relationType                      FROM AniDB_Anime_Relation rel                          INNER JOIN AniDB_Anime fromAnime                              ON fromAnime.AnimeID = rel.AnimeID                          INNER JOIN AniDB_Anime toAnime                              ON toAnime.AnimeID = rel.RelatedAnimeID")                  .AddScalar("fromAnimeId"' NHibernateUtil.Int32)                  .AddScalar("toAnimeId"' NHibernateUtil.Int32)                  .AddScalar("fromAnimeType"' NHibernateUtil.Int32)                  .AddScalar("toAnimeType"' NHibernateUtil.Int32)                  .AddScalar("fromMainTitle"' NHibernateUtil.String)                  .AddScalar("toMainTitle"' NHibernateUtil.String)                  .AddScalar("fromAirDate"' NHibernateUtil.DateTime)                  .AddScalar("toAirDate"' NHibernateUtil.DateTime)                  .AddScalar("relationType"' NHibernateUtil.String)                  .List<object[]>()                  .Select(r =>                  {                      var relation = new AnimeRelation                      {                          FromId = (int) r[0]'                          ToId = (int) r[1]'                          FromType = (AnimeType) r[2]'                          ToType = (AnimeType) r[3]'                          FromMainTitle = (string) r[4]'                          ToMainTitle = (string) r[5]'                          FromAirDate = (DateTime?) r[6]'                          ToAirDate = (DateTime?) r[7]                      };                        switch (((string) r[8]).ToLowerInvariant())                      {                          case "full story":                              relation.RelationType = AnimeRelationType.FullStory;                              break;                          case "summary":                              relation.RelationType = AnimeRelationType.Summary;                              break;                          case "parent story":                              relation.RelationType = AnimeRelationType.ParentStory;                              break;                          case "side story":                              relation.RelationType = AnimeRelationType.SideStory;                              break;                          case "prequel":                              relation.RelationType = AnimeRelationType.Prequel;                              break;                          case "sequel":                              relation.RelationType = AnimeRelationType.Sequel;                              break;                          case "alternative setting":                              relation.RelationType = AnimeRelationType.AlternateSetting;                              break;                          case "alternative version":                              relation.RelationType = AnimeRelationType.AlternateVersion;                              break;                          case "same setting":                              relation.RelationType = AnimeRelationType.SameSetting;                              break;                          case "character":                              relation.RelationType = AnimeRelationType.Character;                              break;                          default:                              relation.RelationType = AnimeRelationType.Other;                              break;                      }                        return relation;                  })                  .ToLookup(k => k.FromId);
Magic Number,Shoko.Server.Tasks,AutoAnimeGroupCalculator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Tasks\AutoAnimeGroupCalculator.cs,Create,The following statement contains a magic number: var relationshipMap = session.CreateSQLQuery(@"                  SELECT    fromAnime.AnimeID AS fromAnimeId                          ' toAnime.AnimeID AS toAnimeId                          ' fromAnime.AnimeType AS fromAnimeType                          ' toAnime.AnimeType AS toAnimeType                          ' fromAnime.MainTitle AS fromMainTitle                          ' toAnime.MainTitle AS toMainTitle                          ' fromAnime.AirDate AS fromAirDate                          ' toAnime.AirDate AS toAirDate                          ' rel.RelationType AS relationType                      FROM AniDB_Anime_Relation rel                          INNER JOIN AniDB_Anime fromAnime                              ON fromAnime.AnimeID = rel.AnimeID                          INNER JOIN AniDB_Anime toAnime                              ON toAnime.AnimeID = rel.RelatedAnimeID")                  .AddScalar("fromAnimeId"' NHibernateUtil.Int32)                  .AddScalar("toAnimeId"' NHibernateUtil.Int32)                  .AddScalar("fromAnimeType"' NHibernateUtil.Int32)                  .AddScalar("toAnimeType"' NHibernateUtil.Int32)                  .AddScalar("fromMainTitle"' NHibernateUtil.String)                  .AddScalar("toMainTitle"' NHibernateUtil.String)                  .AddScalar("fromAirDate"' NHibernateUtil.DateTime)                  .AddScalar("toAirDate"' NHibernateUtil.DateTime)                  .AddScalar("relationType"' NHibernateUtil.String)                  .List<object[]>()                  .Select(r =>                  {                      var relation = new AnimeRelation                      {                          FromId = (int) r[0]'                          ToId = (int) r[1]'                          FromType = (AnimeType) r[2]'                          ToType = (AnimeType) r[3]'                          FromMainTitle = (string) r[4]'                          ToMainTitle = (string) r[5]'                          FromAirDate = (DateTime?) r[6]'                          ToAirDate = (DateTime?) r[7]                      };                        switch (((string) r[8]).ToLowerInvariant())                      {                          case "full story":                              relation.RelationType = AnimeRelationType.FullStory;                              break;                          case "summary":                              relation.RelationType = AnimeRelationType.Summary;                              break;                          case "parent story":                              relation.RelationType = AnimeRelationType.ParentStory;                              break;                          case "side story":                              relation.RelationType = AnimeRelationType.SideStory;                              break;                          case "prequel":                              relation.RelationType = AnimeRelationType.Prequel;                              break;                          case "sequel":                              relation.RelationType = AnimeRelationType.Sequel;                              break;                          case "alternative setting":                              relation.RelationType = AnimeRelationType.AlternateSetting;                              break;                          case "alternative version":                              relation.RelationType = AnimeRelationType.AlternateVersion;                              break;                          case "same setting":                              relation.RelationType = AnimeRelationType.SameSetting;                              break;                          case "character":                              relation.RelationType = AnimeRelationType.Character;                              break;                          default:                              relation.RelationType = AnimeRelationType.Other;                              break;                      }                        return relation;                  })                  .ToLookup(k => k.FromId);
Magic Number,Shoko.Server.Tasks,AutoAnimeGroupCalculator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Tasks\AutoAnimeGroupCalculator.cs,Create,The following statement contains a magic number: var relationshipMap = session.CreateSQLQuery(@"                  SELECT    fromAnime.AnimeID AS fromAnimeId                          ' toAnime.AnimeID AS toAnimeId                          ' fromAnime.AnimeType AS fromAnimeType                          ' toAnime.AnimeType AS toAnimeType                          ' fromAnime.MainTitle AS fromMainTitle                          ' toAnime.MainTitle AS toMainTitle                          ' fromAnime.AirDate AS fromAirDate                          ' toAnime.AirDate AS toAirDate                          ' rel.RelationType AS relationType                      FROM AniDB_Anime_Relation rel                          INNER JOIN AniDB_Anime fromAnime                              ON fromAnime.AnimeID = rel.AnimeID                          INNER JOIN AniDB_Anime toAnime                              ON toAnime.AnimeID = rel.RelatedAnimeID")                  .AddScalar("fromAnimeId"' NHibernateUtil.Int32)                  .AddScalar("toAnimeId"' NHibernateUtil.Int32)                  .AddScalar("fromAnimeType"' NHibernateUtil.Int32)                  .AddScalar("toAnimeType"' NHibernateUtil.Int32)                  .AddScalar("fromMainTitle"' NHibernateUtil.String)                  .AddScalar("toMainTitle"' NHibernateUtil.String)                  .AddScalar("fromAirDate"' NHibernateUtil.DateTime)                  .AddScalar("toAirDate"' NHibernateUtil.DateTime)                  .AddScalar("relationType"' NHibernateUtil.String)                  .List<object[]>()                  .Select(r =>                  {                      var relation = new AnimeRelation                      {                          FromId = (int) r[0]'                          ToId = (int) r[1]'                          FromType = (AnimeType) r[2]'                          ToType = (AnimeType) r[3]'                          FromMainTitle = (string) r[4]'                          ToMainTitle = (string) r[5]'                          FromAirDate = (DateTime?) r[6]'                          ToAirDate = (DateTime?) r[7]                      };                        switch (((string) r[8]).ToLowerInvariant())                      {                          case "full story":                              relation.RelationType = AnimeRelationType.FullStory;                              break;                          case "summary":                              relation.RelationType = AnimeRelationType.Summary;                              break;                          case "parent story":                              relation.RelationType = AnimeRelationType.ParentStory;                              break;                          case "side story":                              relation.RelationType = AnimeRelationType.SideStory;                              break;                          case "prequel":                              relation.RelationType = AnimeRelationType.Prequel;                              break;                          case "sequel":                              relation.RelationType = AnimeRelationType.Sequel;                              break;                          case "alternative setting":                              relation.RelationType = AnimeRelationType.AlternateSetting;                              break;                          case "alternative version":                              relation.RelationType = AnimeRelationType.AlternateVersion;                              break;                          case "same setting":                              relation.RelationType = AnimeRelationType.SameSetting;                              break;                          case "character":                              relation.RelationType = AnimeRelationType.Character;                              break;                          default:                              relation.RelationType = AnimeRelationType.Other;                              break;                      }                        return relation;                  })                  .ToLookup(k => k.FromId);
Magic Number,Shoko.Server.Tasks,AutoAnimeGroupCalculator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Tasks\AutoAnimeGroupCalculator.cs,Create,The following statement contains a magic number: var relationshipMap = session.CreateSQLQuery(@"                  SELECT    fromAnime.AnimeID AS fromAnimeId                          ' toAnime.AnimeID AS toAnimeId                          ' fromAnime.AnimeType AS fromAnimeType                          ' toAnime.AnimeType AS toAnimeType                          ' fromAnime.MainTitle AS fromMainTitle                          ' toAnime.MainTitle AS toMainTitle                          ' fromAnime.AirDate AS fromAirDate                          ' toAnime.AirDate AS toAirDate                          ' rel.RelationType AS relationType                      FROM AniDB_Anime_Relation rel                          INNER JOIN AniDB_Anime fromAnime                              ON fromAnime.AnimeID = rel.AnimeID                          INNER JOIN AniDB_Anime toAnime                              ON toAnime.AnimeID = rel.RelatedAnimeID")                  .AddScalar("fromAnimeId"' NHibernateUtil.Int32)                  .AddScalar("toAnimeId"' NHibernateUtil.Int32)                  .AddScalar("fromAnimeType"' NHibernateUtil.Int32)                  .AddScalar("toAnimeType"' NHibernateUtil.Int32)                  .AddScalar("fromMainTitle"' NHibernateUtil.String)                  .AddScalar("toMainTitle"' NHibernateUtil.String)                  .AddScalar("fromAirDate"' NHibernateUtil.DateTime)                  .AddScalar("toAirDate"' NHibernateUtil.DateTime)                  .AddScalar("relationType"' NHibernateUtil.String)                  .List<object[]>()                  .Select(r =>                  {                      var relation = new AnimeRelation                      {                          FromId = (int) r[0]'                          ToId = (int) r[1]'                          FromType = (AnimeType) r[2]'                          ToType = (AnimeType) r[3]'                          FromMainTitle = (string) r[4]'                          ToMainTitle = (string) r[5]'                          FromAirDate = (DateTime?) r[6]'                          ToAirDate = (DateTime?) r[7]                      };                        switch (((string) r[8]).ToLowerInvariant())                      {                          case "full story":                              relation.RelationType = AnimeRelationType.FullStory;                              break;                          case "summary":                              relation.RelationType = AnimeRelationType.Summary;                              break;                          case "parent story":                              relation.RelationType = AnimeRelationType.ParentStory;                              break;                          case "side story":                              relation.RelationType = AnimeRelationType.SideStory;                              break;                          case "prequel":                              relation.RelationType = AnimeRelationType.Prequel;                              break;                          case "sequel":                              relation.RelationType = AnimeRelationType.Sequel;                              break;                          case "alternative setting":                              relation.RelationType = AnimeRelationType.AlternateSetting;                              break;                          case "alternative version":                              relation.RelationType = AnimeRelationType.AlternateVersion;                              break;                          case "same setting":                              relation.RelationType = AnimeRelationType.SameSetting;                              break;                          case "character":                              relation.RelationType = AnimeRelationType.Character;                              break;                          default:                              relation.RelationType = AnimeRelationType.Other;                              break;                      }                        return relation;                  })                  .ToLookup(k => k.FromId);
Magic Number,Shoko.Server.Tasks,AutoAnimeGroupCalculator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Tasks\AutoAnimeGroupCalculator.cs,Create,The following statement contains a magic number: var relationshipMap = session.CreateSQLQuery(@"                  SELECT    fromAnime.AnimeID AS fromAnimeId                          ' toAnime.AnimeID AS toAnimeId                          ' fromAnime.AnimeType AS fromAnimeType                          ' toAnime.AnimeType AS toAnimeType                          ' fromAnime.MainTitle AS fromMainTitle                          ' toAnime.MainTitle AS toMainTitle                          ' fromAnime.AirDate AS fromAirDate                          ' toAnime.AirDate AS toAirDate                          ' rel.RelationType AS relationType                      FROM AniDB_Anime_Relation rel                          INNER JOIN AniDB_Anime fromAnime                              ON fromAnime.AnimeID = rel.AnimeID                          INNER JOIN AniDB_Anime toAnime                              ON toAnime.AnimeID = rel.RelatedAnimeID")                  .AddScalar("fromAnimeId"' NHibernateUtil.Int32)                  .AddScalar("toAnimeId"' NHibernateUtil.Int32)                  .AddScalar("fromAnimeType"' NHibernateUtil.Int32)                  .AddScalar("toAnimeType"' NHibernateUtil.Int32)                  .AddScalar("fromMainTitle"' NHibernateUtil.String)                  .AddScalar("toMainTitle"' NHibernateUtil.String)                  .AddScalar("fromAirDate"' NHibernateUtil.DateTime)                  .AddScalar("toAirDate"' NHibernateUtil.DateTime)                  .AddScalar("relationType"' NHibernateUtil.String)                  .List<object[]>()                  .Select(r =>                  {                      var relation = new AnimeRelation                      {                          FromId = (int) r[0]'                          ToId = (int) r[1]'                          FromType = (AnimeType) r[2]'                          ToType = (AnimeType) r[3]'                          FromMainTitle = (string) r[4]'                          ToMainTitle = (string) r[5]'                          FromAirDate = (DateTime?) r[6]'                          ToAirDate = (DateTime?) r[7]                      };                        switch (((string) r[8]).ToLowerInvariant())                      {                          case "full story":                              relation.RelationType = AnimeRelationType.FullStory;                              break;                          case "summary":                              relation.RelationType = AnimeRelationType.Summary;                              break;                          case "parent story":                              relation.RelationType = AnimeRelationType.ParentStory;                              break;                          case "side story":                              relation.RelationType = AnimeRelationType.SideStory;                              break;                          case "prequel":                              relation.RelationType = AnimeRelationType.Prequel;                              break;                          case "sequel":                              relation.RelationType = AnimeRelationType.Sequel;                              break;                          case "alternative setting":                              relation.RelationType = AnimeRelationType.AlternateSetting;                              break;                          case "alternative version":                              relation.RelationType = AnimeRelationType.AlternateVersion;                              break;                          case "same setting":                              relation.RelationType = AnimeRelationType.SameSetting;                              break;                          case "character":                              relation.RelationType = AnimeRelationType.Character;                              break;                          default:                              relation.RelationType = AnimeRelationType.Other;                              break;                      }                        return relation;                  })                  .ToLookup(k => k.FromId);
Magic Number,Shoko.Server.Tasks,AutoAnimeGroupCalculator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Tasks\AutoAnimeGroupCalculator.cs,Create,The following statement contains a magic number: var relationshipMap = session.CreateSQLQuery(@"                  SELECT    fromAnime.AnimeID AS fromAnimeId                          ' toAnime.AnimeID AS toAnimeId                          ' fromAnime.AnimeType AS fromAnimeType                          ' toAnime.AnimeType AS toAnimeType                          ' fromAnime.MainTitle AS fromMainTitle                          ' toAnime.MainTitle AS toMainTitle                          ' fromAnime.AirDate AS fromAirDate                          ' toAnime.AirDate AS toAirDate                          ' rel.RelationType AS relationType                      FROM AniDB_Anime_Relation rel                          INNER JOIN AniDB_Anime fromAnime                              ON fromAnime.AnimeID = rel.AnimeID                          INNER JOIN AniDB_Anime toAnime                              ON toAnime.AnimeID = rel.RelatedAnimeID")                  .AddScalar("fromAnimeId"' NHibernateUtil.Int32)                  .AddScalar("toAnimeId"' NHibernateUtil.Int32)                  .AddScalar("fromAnimeType"' NHibernateUtil.Int32)                  .AddScalar("toAnimeType"' NHibernateUtil.Int32)                  .AddScalar("fromMainTitle"' NHibernateUtil.String)                  .AddScalar("toMainTitle"' NHibernateUtil.String)                  .AddScalar("fromAirDate"' NHibernateUtil.DateTime)                  .AddScalar("toAirDate"' NHibernateUtil.DateTime)                  .AddScalar("relationType"' NHibernateUtil.String)                  .List<object[]>()                  .Select(r =>                  {                      var relation = new AnimeRelation                      {                          FromId = (int) r[0]'                          ToId = (int) r[1]'                          FromType = (AnimeType) r[2]'                          ToType = (AnimeType) r[3]'                          FromMainTitle = (string) r[4]'                          ToMainTitle = (string) r[5]'                          FromAirDate = (DateTime?) r[6]'                          ToAirDate = (DateTime?) r[7]                      };                        switch (((string) r[8]).ToLowerInvariant())                      {                          case "full story":                              relation.RelationType = AnimeRelationType.FullStory;                              break;                          case "summary":                              relation.RelationType = AnimeRelationType.Summary;                              break;                          case "parent story":                              relation.RelationType = AnimeRelationType.ParentStory;                              break;                          case "side story":                              relation.RelationType = AnimeRelationType.SideStory;                              break;                          case "prequel":                              relation.RelationType = AnimeRelationType.Prequel;                              break;                          case "sequel":                              relation.RelationType = AnimeRelationType.Sequel;                              break;                          case "alternative setting":                              relation.RelationType = AnimeRelationType.AlternateSetting;                              break;                          case "alternative version":                              relation.RelationType = AnimeRelationType.AlternateVersion;                              break;                          case "same setting":                              relation.RelationType = AnimeRelationType.SameSetting;                              break;                          case "character":                              relation.RelationType = AnimeRelationType.Character;                              break;                          default:                              relation.RelationType = AnimeRelationType.Other;                              break;                      }                        return relation;                  })                  .ToLookup(k => k.FromId);
Magic Number,Shoko.Server.Tasks,AutoAnimeGroupCalculator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Tasks\AutoAnimeGroupCalculator.cs,ShouldConsiderAnimeRelation,The following statement contains a magic number: return (matches >= minTokenCount / 2) || matchLen >= Math.Max(1' (int) (shortestTitleLen * 0.4));
Magic Number,Shoko.Server.Tasks,AutoAnimeGroupCalculator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Tasks\AutoAnimeGroupCalculator.cs,ShouldConsiderAnimeRelation,The following statement contains a magic number: return (matches >= minTokenCount / 2) || matchLen >= Math.Max(1' (int) (shortestTitleLen * 0.4));
Magic Number,Shoko.Server.Tasks,RelationEdge,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Tasks\AutoAnimeGroupCalculator.cs,GetHashCode,The following statement contains a magic number: unchecked                  {                      int hashCode = AnimeId1;                        hashCode = (hashCode * 397) ^ (int) RelationType1;                      hashCode = (hashCode * 397) ^ AnimeId2;                      hashCode = (hashCode * 397) ^ (int) RelationType2;                        return hashCode;                  }
Magic Number,Shoko.Server.Tasks,RelationEdge,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Tasks\AutoAnimeGroupCalculator.cs,GetHashCode,The following statement contains a magic number: unchecked                  {                      int hashCode = AnimeId1;                        hashCode = (hashCode * 397) ^ (int) RelationType1;                      hashCode = (hashCode * 397) ^ AnimeId2;                      hashCode = (hashCode * 397) ^ (int) RelationType2;                        return hashCode;                  }
Magic Number,Shoko.Server.Tasks,RelationEdge,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Tasks\AutoAnimeGroupCalculator.cs,GetHashCode,The following statement contains a magic number: unchecked                  {                      int hashCode = AnimeId1;                        hashCode = (hashCode * 397) ^ (int) RelationType1;                      hashCode = (hashCode * 397) ^ AnimeId2;                      hashCode = (hashCode * 397) ^ (int) RelationType2;                        return hashCode;                  }
Magic Number,Shoko.Server.Tasks,AnimeGroupCreator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Tasks\AnimeGroupCreator.cs,UpdateAnimeSeriesContractsAndSave,The following statement contains a magic number: Parallel.ForEach(series.Batch(DefaultBatchSize)' new ParallelOptions {MaxDegreeOfParallelism = 4}'                  localInit: () => DatabaseFactory.SessionFactory.OpenStatelessSession()'                  body: (seriesBatch' state' localSession) =>                  {                      SVR_AnimeSeries.BatchUpdateContracts(localSession.Wrap()' seriesBatch);                      return localSession;                  }'                  localFinally: localSession => { localSession.Dispose(); });
Magic Number,Shoko.Server.Tasks,AnimeGroupCreator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Tasks\AnimeGroupCreator.cs,UpdateAnimeGroupsAndTheirContracts,The following statement contains a magic number: Parallel.ForEach(groups.Batch(DefaultBatchSize)' new ParallelOptions {MaxDegreeOfParallelism = 4}'                  localInit: () => DatabaseFactory.SessionFactory.OpenStatelessSession()'                  body: (groupBatch' state' localSession) =>                  {                      var createdGroupUsers = new List<SVR_AnimeGroup_User>(groupBatch.Length);                        // We shouldn't need to keep track of updates to AnimeGroup_Users in the below call' because they should have all been deleted'                      // therefore they should all be new                      SVR_AnimeGroup.BatchUpdateStats(groupBatch' watchedStats: true' missingEpsStats: true'                          createdGroupUsers: createdGroupUsers);                      allCreatedGroupUsers.Add(createdGroupUsers);                      SVR_AnimeGroup.BatchUpdateContracts(localSession.Wrap()' groupBatch' updateStats: true);                        return localSession;                  }'                  localFinally: localSession => { localSession.Dispose(); });
Magic Number,Shoko.Server.Tasks,ContractExtractor,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Tasks\ContractExtractor.cs,ExtractContracts,The following statement contains a magic number: Parallel.ForEach(records' new ParallelOptions {MaxDegreeOfParallelism = 2}' record =>              {                  string zipEntryName = record[0].ToString();                  int contractLen = (int) record[1];                  byte[] contractBinary = (byte[]) record[2];                    if (contractLen > 0 && contractBinary != null)                  {                      TContract contract = CompressionHelper.DeserializeObject<TContract>(contractBinary' contractLen);                        lock (zipLock)                      {                          ZipArchiveEntry archiveEntry = zip.CreateEntry(zipEntryName' CompressionLevel.Optimal);                            using (StreamWriter writer = new StreamWriter(archiveEntry.Open()' Encoding.UTF8))                          {                              jsonSerializer.Serialize(writer' contract);                          }                      }                  }              });
Magic Number,Shoko.Server.Tasks,ContractExtractor,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Tasks\ContractExtractor.cs,ExtractContracts,The following statement contains a magic number: Parallel.ForEach(records' new ParallelOptions {MaxDegreeOfParallelism = 2}' record =>              {                  string zipEntryName = record[0].ToString();                  int contractLen = (int) record[1];                  byte[] contractBinary = (byte[]) record[2];                    if (contractLen > 0 && contractBinary != null)                  {                      TContract contract = CompressionHelper.DeserializeObject<TContract>(contractBinary' contractLen);                        lock (zipLock)                      {                          ZipArchiveEntry archiveEntry = zip.CreateEntry(zipEntryName' CompressionLevel.Optimal);                            using (StreamWriter writer = new StreamWriter(archiveEntry.Open()' Encoding.UTF8))                          {                              jsonSerializer.Serialize(writer' contract);                          }                      }                  }              });
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,MaximumOutputLength,The following statement contains a magic number: return inputLength + inputLength / 255 + 16;
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,MaximumOutputLength,The following statement contains a magic number: return inputLength + inputLength / 255 + 16;
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Poke2,The following statement contains a magic number: buffer[offset + 1] = (byte)(value >> 8);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Peek2,The following statement contains a magic number: return (ushort)(((uint)buffer[offset]) | ((uint)buffer[offset + 1] << 8));
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Peek4,The following statement contains a magic number: return  				((uint)buffer[offset]) |  				((uint)buffer[offset + 1] << 8) |  				((uint)buffer[offset + 2] << 16) |  				((uint)buffer[offset + 3] << 24);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Peek4,The following statement contains a magic number: return  				((uint)buffer[offset]) |  				((uint)buffer[offset + 1] << 8) |  				((uint)buffer[offset + 2] << 16) |  				((uint)buffer[offset + 3] << 24);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Peek4,The following statement contains a magic number: return  				((uint)buffer[offset]) |  				((uint)buffer[offset + 1] << 8) |  				((uint)buffer[offset + 2] << 16) |  				((uint)buffer[offset + 3] << 24);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Peek4,The following statement contains a magic number: return  				((uint)buffer[offset]) |  				((uint)buffer[offset + 1] << 8) |  				((uint)buffer[offset + 2] << 16) |  				((uint)buffer[offset + 3] << 24);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Peek4,The following statement contains a magic number: return  				((uint)buffer[offset]) |  				((uint)buffer[offset + 1] << 8) |  				((uint)buffer[offset + 2] << 16) |  				((uint)buffer[offset + 3] << 24);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor4,The following statement contains a magic number: var value1 =  				((uint)buffer[offset1]) |  				((uint)buffer[offset1 + 1] << 8) |  				((uint)buffer[offset1 + 2] << 16) |  				((uint)buffer[offset1 + 3] << 24);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor4,The following statement contains a magic number: var value1 =  				((uint)buffer[offset1]) |  				((uint)buffer[offset1 + 1] << 8) |  				((uint)buffer[offset1 + 2] << 16) |  				((uint)buffer[offset1 + 3] << 24);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor4,The following statement contains a magic number: var value1 =  				((uint)buffer[offset1]) |  				((uint)buffer[offset1 + 1] << 8) |  				((uint)buffer[offset1 + 2] << 16) |  				((uint)buffer[offset1 + 3] << 24);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor4,The following statement contains a magic number: var value1 =  				((uint)buffer[offset1]) |  				((uint)buffer[offset1 + 1] << 8) |  				((uint)buffer[offset1 + 2] << 16) |  				((uint)buffer[offset1 + 3] << 24);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor4,The following statement contains a magic number: var value1 =  				((uint)buffer[offset1]) |  				((uint)buffer[offset1 + 1] << 8) |  				((uint)buffer[offset1 + 2] << 16) |  				((uint)buffer[offset1 + 3] << 24);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor4,The following statement contains a magic number: var value2 =  				((uint)buffer[offset2]) |  				((uint)buffer[offset2 + 1] << 8) |  				((uint)buffer[offset2 + 2] << 16) |  				((uint)buffer[offset2 + 3] << 24);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor4,The following statement contains a magic number: var value2 =  				((uint)buffer[offset2]) |  				((uint)buffer[offset2 + 1] << 8) |  				((uint)buffer[offset2 + 2] << 16) |  				((uint)buffer[offset2 + 3] << 24);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor4,The following statement contains a magic number: var value2 =  				((uint)buffer[offset2]) |  				((uint)buffer[offset2 + 1] << 8) |  				((uint)buffer[offset2 + 2] << 16) |  				((uint)buffer[offset2 + 3] << 24);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor4,The following statement contains a magic number: var value2 =  				((uint)buffer[offset2]) |  				((uint)buffer[offset2 + 1] << 8) |  				((uint)buffer[offset2 + 2] << 16) |  				((uint)buffer[offset2 + 3] << 24);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor4,The following statement contains a magic number: var value2 =  				((uint)buffer[offset2]) |  				((uint)buffer[offset2 + 1] << 8) |  				((uint)buffer[offset2 + 2] << 16) |  				((uint)buffer[offset2 + 3] << 24);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor8,The following statement contains a magic number: var value1 =  				((ulong)buffer[offset1]) |  				((ulong)buffer[offset1 + 1] << 8) |  				((ulong)buffer[offset1 + 2] << 16) |  				((ulong)buffer[offset1 + 3] << 24) |  				((ulong)buffer[offset1 + 4] << 32) |  				((ulong)buffer[offset1 + 5] << 40) |  				((ulong)buffer[offset1 + 6] << 48) |  				((ulong)buffer[offset1 + 7] << 56);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor8,The following statement contains a magic number: var value1 =  				((ulong)buffer[offset1]) |  				((ulong)buffer[offset1 + 1] << 8) |  				((ulong)buffer[offset1 + 2] << 16) |  				((ulong)buffer[offset1 + 3] << 24) |  				((ulong)buffer[offset1 + 4] << 32) |  				((ulong)buffer[offset1 + 5] << 40) |  				((ulong)buffer[offset1 + 6] << 48) |  				((ulong)buffer[offset1 + 7] << 56);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor8,The following statement contains a magic number: var value1 =  				((ulong)buffer[offset1]) |  				((ulong)buffer[offset1 + 1] << 8) |  				((ulong)buffer[offset1 + 2] << 16) |  				((ulong)buffer[offset1 + 3] << 24) |  				((ulong)buffer[offset1 + 4] << 32) |  				((ulong)buffer[offset1 + 5] << 40) |  				((ulong)buffer[offset1 + 6] << 48) |  				((ulong)buffer[offset1 + 7] << 56);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor8,The following statement contains a magic number: var value1 =  				((ulong)buffer[offset1]) |  				((ulong)buffer[offset1 + 1] << 8) |  				((ulong)buffer[offset1 + 2] << 16) |  				((ulong)buffer[offset1 + 3] << 24) |  				((ulong)buffer[offset1 + 4] << 32) |  				((ulong)buffer[offset1 + 5] << 40) |  				((ulong)buffer[offset1 + 6] << 48) |  				((ulong)buffer[offset1 + 7] << 56);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor8,The following statement contains a magic number: var value1 =  				((ulong)buffer[offset1]) |  				((ulong)buffer[offset1 + 1] << 8) |  				((ulong)buffer[offset1 + 2] << 16) |  				((ulong)buffer[offset1 + 3] << 24) |  				((ulong)buffer[offset1 + 4] << 32) |  				((ulong)buffer[offset1 + 5] << 40) |  				((ulong)buffer[offset1 + 6] << 48) |  				((ulong)buffer[offset1 + 7] << 56);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor8,The following statement contains a magic number: var value1 =  				((ulong)buffer[offset1]) |  				((ulong)buffer[offset1 + 1] << 8) |  				((ulong)buffer[offset1 + 2] << 16) |  				((ulong)buffer[offset1 + 3] << 24) |  				((ulong)buffer[offset1 + 4] << 32) |  				((ulong)buffer[offset1 + 5] << 40) |  				((ulong)buffer[offset1 + 6] << 48) |  				((ulong)buffer[offset1 + 7] << 56);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor8,The following statement contains a magic number: var value1 =  				((ulong)buffer[offset1]) |  				((ulong)buffer[offset1 + 1] << 8) |  				((ulong)buffer[offset1 + 2] << 16) |  				((ulong)buffer[offset1 + 3] << 24) |  				((ulong)buffer[offset1 + 4] << 32) |  				((ulong)buffer[offset1 + 5] << 40) |  				((ulong)buffer[offset1 + 6] << 48) |  				((ulong)buffer[offset1 + 7] << 56);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor8,The following statement contains a magic number: var value1 =  				((ulong)buffer[offset1]) |  				((ulong)buffer[offset1 + 1] << 8) |  				((ulong)buffer[offset1 + 2] << 16) |  				((ulong)buffer[offset1 + 3] << 24) |  				((ulong)buffer[offset1 + 4] << 32) |  				((ulong)buffer[offset1 + 5] << 40) |  				((ulong)buffer[offset1 + 6] << 48) |  				((ulong)buffer[offset1 + 7] << 56);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor8,The following statement contains a magic number: var value1 =  				((ulong)buffer[offset1]) |  				((ulong)buffer[offset1 + 1] << 8) |  				((ulong)buffer[offset1 + 2] << 16) |  				((ulong)buffer[offset1 + 3] << 24) |  				((ulong)buffer[offset1 + 4] << 32) |  				((ulong)buffer[offset1 + 5] << 40) |  				((ulong)buffer[offset1 + 6] << 48) |  				((ulong)buffer[offset1 + 7] << 56);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor8,The following statement contains a magic number: var value1 =  				((ulong)buffer[offset1]) |  				((ulong)buffer[offset1 + 1] << 8) |  				((ulong)buffer[offset1 + 2] << 16) |  				((ulong)buffer[offset1 + 3] << 24) |  				((ulong)buffer[offset1 + 4] << 32) |  				((ulong)buffer[offset1 + 5] << 40) |  				((ulong)buffer[offset1 + 6] << 48) |  				((ulong)buffer[offset1 + 7] << 56);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor8,The following statement contains a magic number: var value1 =  				((ulong)buffer[offset1]) |  				((ulong)buffer[offset1 + 1] << 8) |  				((ulong)buffer[offset1 + 2] << 16) |  				((ulong)buffer[offset1 + 3] << 24) |  				((ulong)buffer[offset1 + 4] << 32) |  				((ulong)buffer[offset1 + 5] << 40) |  				((ulong)buffer[offset1 + 6] << 48) |  				((ulong)buffer[offset1 + 7] << 56);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor8,The following statement contains a magic number: var value1 =  				((ulong)buffer[offset1]) |  				((ulong)buffer[offset1 + 1] << 8) |  				((ulong)buffer[offset1 + 2] << 16) |  				((ulong)buffer[offset1 + 3] << 24) |  				((ulong)buffer[offset1 + 4] << 32) |  				((ulong)buffer[offset1 + 5] << 40) |  				((ulong)buffer[offset1 + 6] << 48) |  				((ulong)buffer[offset1 + 7] << 56);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor8,The following statement contains a magic number: var value1 =  				((ulong)buffer[offset1]) |  				((ulong)buffer[offset1 + 1] << 8) |  				((ulong)buffer[offset1 + 2] << 16) |  				((ulong)buffer[offset1 + 3] << 24) |  				((ulong)buffer[offset1 + 4] << 32) |  				((ulong)buffer[offset1 + 5] << 40) |  				((ulong)buffer[offset1 + 6] << 48) |  				((ulong)buffer[offset1 + 7] << 56);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor8,The following statement contains a magic number: var value2 =  				((ulong)buffer[offset2]) |  				((ulong)buffer[offset2 + 1] << 8) |  				((ulong)buffer[offset2 + 2] << 16) |  				((ulong)buffer[offset2 + 3] << 24) |  				((ulong)buffer[offset2 + 4] << 32) |  				((ulong)buffer[offset2 + 5] << 40) |  				((ulong)buffer[offset2 + 6] << 48) |  				((ulong)buffer[offset2 + 7] << 56);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor8,The following statement contains a magic number: var value2 =  				((ulong)buffer[offset2]) |  				((ulong)buffer[offset2 + 1] << 8) |  				((ulong)buffer[offset2 + 2] << 16) |  				((ulong)buffer[offset2 + 3] << 24) |  				((ulong)buffer[offset2 + 4] << 32) |  				((ulong)buffer[offset2 + 5] << 40) |  				((ulong)buffer[offset2 + 6] << 48) |  				((ulong)buffer[offset2 + 7] << 56);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor8,The following statement contains a magic number: var value2 =  				((ulong)buffer[offset2]) |  				((ulong)buffer[offset2 + 1] << 8) |  				((ulong)buffer[offset2 + 2] << 16) |  				((ulong)buffer[offset2 + 3] << 24) |  				((ulong)buffer[offset2 + 4] << 32) |  				((ulong)buffer[offset2 + 5] << 40) |  				((ulong)buffer[offset2 + 6] << 48) |  				((ulong)buffer[offset2 + 7] << 56);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor8,The following statement contains a magic number: var value2 =  				((ulong)buffer[offset2]) |  				((ulong)buffer[offset2 + 1] << 8) |  				((ulong)buffer[offset2 + 2] << 16) |  				((ulong)buffer[offset2 + 3] << 24) |  				((ulong)buffer[offset2 + 4] << 32) |  				((ulong)buffer[offset2 + 5] << 40) |  				((ulong)buffer[offset2 + 6] << 48) |  				((ulong)buffer[offset2 + 7] << 56);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor8,The following statement contains a magic number: var value2 =  				((ulong)buffer[offset2]) |  				((ulong)buffer[offset2 + 1] << 8) |  				((ulong)buffer[offset2 + 2] << 16) |  				((ulong)buffer[offset2 + 3] << 24) |  				((ulong)buffer[offset2 + 4] << 32) |  				((ulong)buffer[offset2 + 5] << 40) |  				((ulong)buffer[offset2 + 6] << 48) |  				((ulong)buffer[offset2 + 7] << 56);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor8,The following statement contains a magic number: var value2 =  				((ulong)buffer[offset2]) |  				((ulong)buffer[offset2 + 1] << 8) |  				((ulong)buffer[offset2 + 2] << 16) |  				((ulong)buffer[offset2 + 3] << 24) |  				((ulong)buffer[offset2 + 4] << 32) |  				((ulong)buffer[offset2 + 5] << 40) |  				((ulong)buffer[offset2 + 6] << 48) |  				((ulong)buffer[offset2 + 7] << 56);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor8,The following statement contains a magic number: var value2 =  				((ulong)buffer[offset2]) |  				((ulong)buffer[offset2 + 1] << 8) |  				((ulong)buffer[offset2 + 2] << 16) |  				((ulong)buffer[offset2 + 3] << 24) |  				((ulong)buffer[offset2 + 4] << 32) |  				((ulong)buffer[offset2 + 5] << 40) |  				((ulong)buffer[offset2 + 6] << 48) |  				((ulong)buffer[offset2 + 7] << 56);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor8,The following statement contains a magic number: var value2 =  				((ulong)buffer[offset2]) |  				((ulong)buffer[offset2 + 1] << 8) |  				((ulong)buffer[offset2 + 2] << 16) |  				((ulong)buffer[offset2 + 3] << 24) |  				((ulong)buffer[offset2 + 4] << 32) |  				((ulong)buffer[offset2 + 5] << 40) |  				((ulong)buffer[offset2 + 6] << 48) |  				((ulong)buffer[offset2 + 7] << 56);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor8,The following statement contains a magic number: var value2 =  				((ulong)buffer[offset2]) |  				((ulong)buffer[offset2 + 1] << 8) |  				((ulong)buffer[offset2 + 2] << 16) |  				((ulong)buffer[offset2 + 3] << 24) |  				((ulong)buffer[offset2 + 4] << 32) |  				((ulong)buffer[offset2 + 5] << 40) |  				((ulong)buffer[offset2 + 6] << 48) |  				((ulong)buffer[offset2 + 7] << 56);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor8,The following statement contains a magic number: var value2 =  				((ulong)buffer[offset2]) |  				((ulong)buffer[offset2 + 1] << 8) |  				((ulong)buffer[offset2 + 2] << 16) |  				((ulong)buffer[offset2 + 3] << 24) |  				((ulong)buffer[offset2 + 4] << 32) |  				((ulong)buffer[offset2 + 5] << 40) |  				((ulong)buffer[offset2 + 6] << 48) |  				((ulong)buffer[offset2 + 7] << 56);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor8,The following statement contains a magic number: var value2 =  				((ulong)buffer[offset2]) |  				((ulong)buffer[offset2 + 1] << 8) |  				((ulong)buffer[offset2 + 2] << 16) |  				((ulong)buffer[offset2 + 3] << 24) |  				((ulong)buffer[offset2 + 4] << 32) |  				((ulong)buffer[offset2 + 5] << 40) |  				((ulong)buffer[offset2 + 6] << 48) |  				((ulong)buffer[offset2 + 7] << 56);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor8,The following statement contains a magic number: var value2 =  				((ulong)buffer[offset2]) |  				((ulong)buffer[offset2 + 1] << 8) |  				((ulong)buffer[offset2 + 2] << 16) |  				((ulong)buffer[offset2 + 3] << 24) |  				((ulong)buffer[offset2 + 4] << 32) |  				((ulong)buffer[offset2 + 5] << 40) |  				((ulong)buffer[offset2 + 6] << 48) |  				((ulong)buffer[offset2 + 7] << 56);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Xor8,The following statement contains a magic number: var value2 =  				((ulong)buffer[offset2]) |  				((ulong)buffer[offset2 + 1] << 8) |  				((ulong)buffer[offset2 + 2] << 16) |  				((ulong)buffer[offset2 + 3] << 24) |  				((ulong)buffer[offset2 + 4] << 32) |  				((ulong)buffer[offset2 + 5] << 40) |  				((ulong)buffer[offset2 + 6] << 48) |  				((ulong)buffer[offset2 + 7] << 56);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Equal4,The following statement contains a magic number: if (buffer[offset1 + 2] != buffer[offset2 + 2]) return false;
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Equal4,The following statement contains a magic number: if (buffer[offset1 + 2] != buffer[offset2 + 2]) return false;
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Equal4,The following statement contains a magic number: return buffer[offset1 + 3] == buffer[offset2 + 3];
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Equal4,The following statement contains a magic number: return buffer[offset1 + 3] == buffer[offset2 + 3];
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Copy4,The following statement contains a magic number: buf[dst + 3] = buf[src + 3];
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Copy4,The following statement contains a magic number: buf[dst + 3] = buf[src + 3];
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Copy4,The following statement contains a magic number: buf[dst + 2] = buf[src + 2];
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Copy4,The following statement contains a magic number: buf[dst + 2] = buf[src + 2];
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Copy8,The following statement contains a magic number: buf[dst + 7] = buf[src + 7];
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Copy8,The following statement contains a magic number: buf[dst + 7] = buf[src + 7];
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Copy8,The following statement contains a magic number: buf[dst + 6] = buf[src + 6];
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Copy8,The following statement contains a magic number: buf[dst + 6] = buf[src + 6];
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Copy8,The following statement contains a magic number: buf[dst + 5] = buf[src + 5];
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Copy8,The following statement contains a magic number: buf[dst + 5] = buf[src + 5];
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Copy8,The following statement contains a magic number: buf[dst + 4] = buf[src + 4];
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Copy8,The following statement contains a magic number: buf[dst + 4] = buf[src + 4];
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Copy8,The following statement contains a magic number: buf[dst + 3] = buf[src + 3];
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Copy8,The following statement contains a magic number: buf[dst + 3] = buf[src + 3];
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Copy8,The following statement contains a magic number: buf[dst + 2] = buf[src + 2];
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,Copy8,The following statement contains a magic number: buf[dst + 2] = buf[src + 2];
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: if (len >= BLOCK_COPY_LIMIT)  			{  				Buffer.BlockCopy(src' src_0' dst' dst_0' len);  			}  			else  			{  				while (len >= 8)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					dst[dst_0 + 4] = src[src_0 + 4];  					dst[dst_0 + 5] = src[src_0 + 5];  					dst[dst_0 + 6] = src[src_0 + 6];  					dst[dst_0 + 7] = src[src_0 + 7];  					len -= 8;  					src_0 += 8;  					dst_0 += 8;  				}    				while (len >= 4)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					len -= 4;  					src_0 += 4;  					dst_0 += 4;  				}    				while (len-- > 0)  				{  					dst[dst_0++] = src[src_0++];  				}  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: if (len >= BLOCK_COPY_LIMIT)  			{  				Buffer.BlockCopy(src' src_0' dst' dst_0' len);  			}  			else  			{  				while (len >= 8)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					dst[dst_0 + 4] = src[src_0 + 4];  					dst[dst_0 + 5] = src[src_0 + 5];  					dst[dst_0 + 6] = src[src_0 + 6];  					dst[dst_0 + 7] = src[src_0 + 7];  					len -= 8;  					src_0 += 8;  					dst_0 += 8;  				}    				while (len >= 4)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					len -= 4;  					src_0 += 4;  					dst_0 += 4;  				}    				while (len-- > 0)  				{  					dst[dst_0++] = src[src_0++];  				}  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: if (len >= BLOCK_COPY_LIMIT)  			{  				Buffer.BlockCopy(src' src_0' dst' dst_0' len);  			}  			else  			{  				while (len >= 8)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					dst[dst_0 + 4] = src[src_0 + 4];  					dst[dst_0 + 5] = src[src_0 + 5];  					dst[dst_0 + 6] = src[src_0 + 6];  					dst[dst_0 + 7] = src[src_0 + 7];  					len -= 8;  					src_0 += 8;  					dst_0 += 8;  				}    				while (len >= 4)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					len -= 4;  					src_0 += 4;  					dst_0 += 4;  				}    				while (len-- > 0)  				{  					dst[dst_0++] = src[src_0++];  				}  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: if (len >= BLOCK_COPY_LIMIT)  			{  				Buffer.BlockCopy(src' src_0' dst' dst_0' len);  			}  			else  			{  				while (len >= 8)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					dst[dst_0 + 4] = src[src_0 + 4];  					dst[dst_0 + 5] = src[src_0 + 5];  					dst[dst_0 + 6] = src[src_0 + 6];  					dst[dst_0 + 7] = src[src_0 + 7];  					len -= 8;  					src_0 += 8;  					dst_0 += 8;  				}    				while (len >= 4)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					len -= 4;  					src_0 += 4;  					dst_0 += 4;  				}    				while (len-- > 0)  				{  					dst[dst_0++] = src[src_0++];  				}  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: if (len >= BLOCK_COPY_LIMIT)  			{  				Buffer.BlockCopy(src' src_0' dst' dst_0' len);  			}  			else  			{  				while (len >= 8)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					dst[dst_0 + 4] = src[src_0 + 4];  					dst[dst_0 + 5] = src[src_0 + 5];  					dst[dst_0 + 6] = src[src_0 + 6];  					dst[dst_0 + 7] = src[src_0 + 7];  					len -= 8;  					src_0 += 8;  					dst_0 += 8;  				}    				while (len >= 4)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					len -= 4;  					src_0 += 4;  					dst_0 += 4;  				}    				while (len-- > 0)  				{  					dst[dst_0++] = src[src_0++];  				}  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: if (len >= BLOCK_COPY_LIMIT)  			{  				Buffer.BlockCopy(src' src_0' dst' dst_0' len);  			}  			else  			{  				while (len >= 8)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					dst[dst_0 + 4] = src[src_0 + 4];  					dst[dst_0 + 5] = src[src_0 + 5];  					dst[dst_0 + 6] = src[src_0 + 6];  					dst[dst_0 + 7] = src[src_0 + 7];  					len -= 8;  					src_0 += 8;  					dst_0 += 8;  				}    				while (len >= 4)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					len -= 4;  					src_0 += 4;  					dst_0 += 4;  				}    				while (len-- > 0)  				{  					dst[dst_0++] = src[src_0++];  				}  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: if (len >= BLOCK_COPY_LIMIT)  			{  				Buffer.BlockCopy(src' src_0' dst' dst_0' len);  			}  			else  			{  				while (len >= 8)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					dst[dst_0 + 4] = src[src_0 + 4];  					dst[dst_0 + 5] = src[src_0 + 5];  					dst[dst_0 + 6] = src[src_0 + 6];  					dst[dst_0 + 7] = src[src_0 + 7];  					len -= 8;  					src_0 += 8;  					dst_0 += 8;  				}    				while (len >= 4)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					len -= 4;  					src_0 += 4;  					dst_0 += 4;  				}    				while (len-- > 0)  				{  					dst[dst_0++] = src[src_0++];  				}  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: if (len >= BLOCK_COPY_LIMIT)  			{  				Buffer.BlockCopy(src' src_0' dst' dst_0' len);  			}  			else  			{  				while (len >= 8)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					dst[dst_0 + 4] = src[src_0 + 4];  					dst[dst_0 + 5] = src[src_0 + 5];  					dst[dst_0 + 6] = src[src_0 + 6];  					dst[dst_0 + 7] = src[src_0 + 7];  					len -= 8;  					src_0 += 8;  					dst_0 += 8;  				}    				while (len >= 4)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					len -= 4;  					src_0 += 4;  					dst_0 += 4;  				}    				while (len-- > 0)  				{  					dst[dst_0++] = src[src_0++];  				}  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: if (len >= BLOCK_COPY_LIMIT)  			{  				Buffer.BlockCopy(src' src_0' dst' dst_0' len);  			}  			else  			{  				while (len >= 8)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					dst[dst_0 + 4] = src[src_0 + 4];  					dst[dst_0 + 5] = src[src_0 + 5];  					dst[dst_0 + 6] = src[src_0 + 6];  					dst[dst_0 + 7] = src[src_0 + 7];  					len -= 8;  					src_0 += 8;  					dst_0 += 8;  				}    				while (len >= 4)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					len -= 4;  					src_0 += 4;  					dst_0 += 4;  				}    				while (len-- > 0)  				{  					dst[dst_0++] = src[src_0++];  				}  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: if (len >= BLOCK_COPY_LIMIT)  			{  				Buffer.BlockCopy(src' src_0' dst' dst_0' len);  			}  			else  			{  				while (len >= 8)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					dst[dst_0 + 4] = src[src_0 + 4];  					dst[dst_0 + 5] = src[src_0 + 5];  					dst[dst_0 + 6] = src[src_0 + 6];  					dst[dst_0 + 7] = src[src_0 + 7];  					len -= 8;  					src_0 += 8;  					dst_0 += 8;  				}    				while (len >= 4)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					len -= 4;  					src_0 += 4;  					dst_0 += 4;  				}    				while (len-- > 0)  				{  					dst[dst_0++] = src[src_0++];  				}  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: if (len >= BLOCK_COPY_LIMIT)  			{  				Buffer.BlockCopy(src' src_0' dst' dst_0' len);  			}  			else  			{  				while (len >= 8)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					dst[dst_0 + 4] = src[src_0 + 4];  					dst[dst_0 + 5] = src[src_0 + 5];  					dst[dst_0 + 6] = src[src_0 + 6];  					dst[dst_0 + 7] = src[src_0 + 7];  					len -= 8;  					src_0 += 8;  					dst_0 += 8;  				}    				while (len >= 4)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					len -= 4;  					src_0 += 4;  					dst_0 += 4;  				}    				while (len-- > 0)  				{  					dst[dst_0++] = src[src_0++];  				}  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: if (len >= BLOCK_COPY_LIMIT)  			{  				Buffer.BlockCopy(src' src_0' dst' dst_0' len);  			}  			else  			{  				while (len >= 8)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					dst[dst_0 + 4] = src[src_0 + 4];  					dst[dst_0 + 5] = src[src_0 + 5];  					dst[dst_0 + 6] = src[src_0 + 6];  					dst[dst_0 + 7] = src[src_0 + 7];  					len -= 8;  					src_0 += 8;  					dst_0 += 8;  				}    				while (len >= 4)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					len -= 4;  					src_0 += 4;  					dst_0 += 4;  				}    				while (len-- > 0)  				{  					dst[dst_0++] = src[src_0++];  				}  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: if (len >= BLOCK_COPY_LIMIT)  			{  				Buffer.BlockCopy(src' src_0' dst' dst_0' len);  			}  			else  			{  				while (len >= 8)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					dst[dst_0 + 4] = src[src_0 + 4];  					dst[dst_0 + 5] = src[src_0 + 5];  					dst[dst_0 + 6] = src[src_0 + 6];  					dst[dst_0 + 7] = src[src_0 + 7];  					len -= 8;  					src_0 += 8;  					dst_0 += 8;  				}    				while (len >= 4)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					len -= 4;  					src_0 += 4;  					dst_0 += 4;  				}    				while (len-- > 0)  				{  					dst[dst_0++] = src[src_0++];  				}  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: if (len >= BLOCK_COPY_LIMIT)  			{  				Buffer.BlockCopy(src' src_0' dst' dst_0' len);  			}  			else  			{  				while (len >= 8)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					dst[dst_0 + 4] = src[src_0 + 4];  					dst[dst_0 + 5] = src[src_0 + 5];  					dst[dst_0 + 6] = src[src_0 + 6];  					dst[dst_0 + 7] = src[src_0 + 7];  					len -= 8;  					src_0 += 8;  					dst_0 += 8;  				}    				while (len >= 4)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					len -= 4;  					src_0 += 4;  					dst_0 += 4;  				}    				while (len-- > 0)  				{  					dst[dst_0++] = src[src_0++];  				}  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: if (len >= BLOCK_COPY_LIMIT)  			{  				Buffer.BlockCopy(src' src_0' dst' dst_0' len);  			}  			else  			{  				while (len >= 8)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					dst[dst_0 + 4] = src[src_0 + 4];  					dst[dst_0 + 5] = src[src_0 + 5];  					dst[dst_0 + 6] = src[src_0 + 6];  					dst[dst_0 + 7] = src[src_0 + 7];  					len -= 8;  					src_0 += 8;  					dst_0 += 8;  				}    				while (len >= 4)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					len -= 4;  					src_0 += 4;  					dst_0 += 4;  				}    				while (len-- > 0)  				{  					dst[dst_0++] = src[src_0++];  				}  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: if (len >= BLOCK_COPY_LIMIT)  			{  				Buffer.BlockCopy(src' src_0' dst' dst_0' len);  			}  			else  			{  				while (len >= 8)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					dst[dst_0 + 4] = src[src_0 + 4];  					dst[dst_0 + 5] = src[src_0 + 5];  					dst[dst_0 + 6] = src[src_0 + 6];  					dst[dst_0 + 7] = src[src_0 + 7];  					len -= 8;  					src_0 += 8;  					dst_0 += 8;  				}    				while (len >= 4)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					len -= 4;  					src_0 += 4;  					dst_0 += 4;  				}    				while (len-- > 0)  				{  					dst[dst_0++] = src[src_0++];  				}  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: if (len >= BLOCK_COPY_LIMIT)  			{  				Buffer.BlockCopy(src' src_0' dst' dst_0' len);  			}  			else  			{  				while (len >= 8)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					dst[dst_0 + 4] = src[src_0 + 4];  					dst[dst_0 + 5] = src[src_0 + 5];  					dst[dst_0 + 6] = src[src_0 + 6];  					dst[dst_0 + 7] = src[src_0 + 7];  					len -= 8;  					src_0 += 8;  					dst_0 += 8;  				}    				while (len >= 4)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					len -= 4;  					src_0 += 4;  					dst_0 += 4;  				}    				while (len-- > 0)  				{  					dst[dst_0++] = src[src_0++];  				}  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: if (len >= BLOCK_COPY_LIMIT)  			{  				Buffer.BlockCopy(src' src_0' dst' dst_0' len);  			}  			else  			{  				while (len >= 8)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					dst[dst_0 + 4] = src[src_0 + 4];  					dst[dst_0 + 5] = src[src_0 + 5];  					dst[dst_0 + 6] = src[src_0 + 6];  					dst[dst_0 + 7] = src[src_0 + 7];  					len -= 8;  					src_0 += 8;  					dst_0 += 8;  				}    				while (len >= 4)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					len -= 4;  					src_0 += 4;  					dst_0 += 4;  				}    				while (len-- > 0)  				{  					dst[dst_0++] = src[src_0++];  				}  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: if (len >= BLOCK_COPY_LIMIT)  			{  				Buffer.BlockCopy(src' src_0' dst' dst_0' len);  			}  			else  			{  				while (len >= 8)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					dst[dst_0 + 4] = src[src_0 + 4];  					dst[dst_0 + 5] = src[src_0 + 5];  					dst[dst_0 + 6] = src[src_0 + 6];  					dst[dst_0 + 7] = src[src_0 + 7];  					len -= 8;  					src_0 += 8;  					dst_0 += 8;  				}    				while (len >= 4)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					len -= 4;  					src_0 += 4;  					dst_0 += 4;  				}    				while (len-- > 0)  				{  					dst[dst_0++] = src[src_0++];  				}  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: if (len >= BLOCK_COPY_LIMIT)  			{  				Buffer.BlockCopy(src' src_0' dst' dst_0' len);  			}  			else  			{  				while (len >= 8)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					dst[dst_0 + 4] = src[src_0 + 4];  					dst[dst_0 + 5] = src[src_0 + 5];  					dst[dst_0 + 6] = src[src_0 + 6];  					dst[dst_0 + 7] = src[src_0 + 7];  					len -= 8;  					src_0 += 8;  					dst_0 += 8;  				}    				while (len >= 4)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					len -= 4;  					src_0 += 4;  					dst_0 += 4;  				}    				while (len-- > 0)  				{  					dst[dst_0++] = src[src_0++];  				}  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: if (len >= BLOCK_COPY_LIMIT)  			{  				Buffer.BlockCopy(src' src_0' dst' dst_0' len);  			}  			else  			{  				while (len >= 8)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					dst[dst_0 + 4] = src[src_0 + 4];  					dst[dst_0 + 5] = src[src_0 + 5];  					dst[dst_0 + 6] = src[src_0 + 6];  					dst[dst_0 + 7] = src[src_0 + 7];  					len -= 8;  					src_0 += 8;  					dst_0 += 8;  				}    				while (len >= 4)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					len -= 4;  					src_0 += 4;  					dst_0 += 4;  				}    				while (len-- > 0)  				{  					dst[dst_0++] = src[src_0++];  				}  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: if (len >= BLOCK_COPY_LIMIT)  			{  				Buffer.BlockCopy(src' src_0' dst' dst_0' len);  			}  			else  			{  				while (len >= 8)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					dst[dst_0 + 4] = src[src_0 + 4];  					dst[dst_0 + 5] = src[src_0 + 5];  					dst[dst_0 + 6] = src[src_0 + 6];  					dst[dst_0 + 7] = src[src_0 + 7];  					len -= 8;  					src_0 += 8;  					dst_0 += 8;  				}    				while (len >= 4)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					len -= 4;  					src_0 += 4;  					dst_0 += 4;  				}    				while (len-- > 0)  				{  					dst[dst_0++] = src[src_0++];  				}  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: if (len >= BLOCK_COPY_LIMIT)  			{  				Buffer.BlockCopy(src' src_0' dst' dst_0' len);  			}  			else  			{  				while (len >= 8)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					dst[dst_0 + 4] = src[src_0 + 4];  					dst[dst_0 + 5] = src[src_0 + 5];  					dst[dst_0 + 6] = src[src_0 + 6];  					dst[dst_0 + 7] = src[src_0 + 7];  					len -= 8;  					src_0 += 8;  					dst_0 += 8;  				}    				while (len >= 4)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					len -= 4;  					src_0 += 4;  					dst_0 += 4;  				}    				while (len-- > 0)  				{  					dst[dst_0++] = src[src_0++];  				}  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: if (len >= BLOCK_COPY_LIMIT)  			{  				Buffer.BlockCopy(src' src_0' dst' dst_0' len);  			}  			else  			{  				while (len >= 8)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					dst[dst_0 + 4] = src[src_0 + 4];  					dst[dst_0 + 5] = src[src_0 + 5];  					dst[dst_0 + 6] = src[src_0 + 6];  					dst[dst_0 + 7] = src[src_0 + 7];  					len -= 8;  					src_0 += 8;  					dst_0 += 8;  				}    				while (len >= 4)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					len -= 4;  					src_0 += 4;  					dst_0 += 4;  				}    				while (len-- > 0)  				{  					dst[dst_0++] = src[src_0++];  				}  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,WildCopy,The following statement contains a magic number: if (len >= BLOCK_COPY_LIMIT)  			{  				Buffer.BlockCopy(src' src_0' dst' dst_0' len);  			}  			else  			{  				// apparently (tested) this is an overkill  				// it seems to be faster without this 8-byte loop  				//while (len >= 8)  				//{  				//	dst[dst_0] = src[src_0];  				//	dst[dst_0 + 1] = src[src_0 + 1];  				//	dst[dst_0 + 2] = src[src_0 + 2];  				//	dst[dst_0 + 3] = src[src_0 + 3];  				//	dst[dst_0 + 4] = src[src_0 + 4];  				//	dst[dst_0 + 5] = src[src_0 + 5];  				//	dst[dst_0 + 6] = src[src_0 + 6];  				//	dst[dst_0 + 7] = src[src_0 + 7];  				//	len -= 8; src_0 += 8; dst_0 += 8;  				//}    				while (len >= 4)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					len -= 4;  					src_0 += 4;  					dst_0 += 4;  				}    				while (len-- > 0)  				{  					dst[dst_0++] = src[src_0++];  				}  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,WildCopy,The following statement contains a magic number: if (len >= BLOCK_COPY_LIMIT)  			{  				Buffer.BlockCopy(src' src_0' dst' dst_0' len);  			}  			else  			{  				// apparently (tested) this is an overkill  				// it seems to be faster without this 8-byte loop  				//while (len >= 8)  				//{  				//	dst[dst_0] = src[src_0];  				//	dst[dst_0 + 1] = src[src_0 + 1];  				//	dst[dst_0 + 2] = src[src_0 + 2];  				//	dst[dst_0 + 3] = src[src_0 + 3];  				//	dst[dst_0 + 4] = src[src_0 + 4];  				//	dst[dst_0 + 5] = src[src_0 + 5];  				//	dst[dst_0 + 6] = src[src_0 + 6];  				//	dst[dst_0 + 7] = src[src_0 + 7];  				//	len -= 8; src_0 += 8; dst_0 += 8;  				//}    				while (len >= 4)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					len -= 4;  					src_0 += 4;  					dst_0 += 4;  				}    				while (len-- > 0)  				{  					dst[dst_0++] = src[src_0++];  				}  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,WildCopy,The following statement contains a magic number: if (len >= BLOCK_COPY_LIMIT)  			{  				Buffer.BlockCopy(src' src_0' dst' dst_0' len);  			}  			else  			{  				// apparently (tested) this is an overkill  				// it seems to be faster without this 8-byte loop  				//while (len >= 8)  				//{  				//	dst[dst_0] = src[src_0];  				//	dst[dst_0 + 1] = src[src_0 + 1];  				//	dst[dst_0 + 2] = src[src_0 + 2];  				//	dst[dst_0 + 3] = src[src_0 + 3];  				//	dst[dst_0 + 4] = src[src_0 + 4];  				//	dst[dst_0 + 5] = src[src_0 + 5];  				//	dst[dst_0 + 6] = src[src_0 + 6];  				//	dst[dst_0 + 7] = src[src_0 + 7];  				//	len -= 8; src_0 += 8; dst_0 += 8;  				//}    				while (len >= 4)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					len -= 4;  					src_0 += 4;  					dst_0 += 4;  				}    				while (len-- > 0)  				{  					dst[dst_0++] = src[src_0++];  				}  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,WildCopy,The following statement contains a magic number: if (len >= BLOCK_COPY_LIMIT)  			{  				Buffer.BlockCopy(src' src_0' dst' dst_0' len);  			}  			else  			{  				// apparently (tested) this is an overkill  				// it seems to be faster without this 8-byte loop  				//while (len >= 8)  				//{  				//	dst[dst_0] = src[src_0];  				//	dst[dst_0 + 1] = src[src_0 + 1];  				//	dst[dst_0 + 2] = src[src_0 + 2];  				//	dst[dst_0 + 3] = src[src_0 + 3];  				//	dst[dst_0 + 4] = src[src_0 + 4];  				//	dst[dst_0 + 5] = src[src_0 + 5];  				//	dst[dst_0 + 6] = src[src_0 + 6];  				//	dst[dst_0 + 7] = src[src_0 + 7];  				//	len -= 8; src_0 += 8; dst_0 += 8;  				//}    				while (len >= 4)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					len -= 4;  					src_0 += 4;  					dst_0 += 4;  				}    				while (len-- > 0)  				{  					dst[dst_0++] = src[src_0++];  				}  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,WildCopy,The following statement contains a magic number: if (len >= BLOCK_COPY_LIMIT)  			{  				Buffer.BlockCopy(src' src_0' dst' dst_0' len);  			}  			else  			{  				// apparently (tested) this is an overkill  				// it seems to be faster without this 8-byte loop  				//while (len >= 8)  				//{  				//	dst[dst_0] = src[src_0];  				//	dst[dst_0 + 1] = src[src_0 + 1];  				//	dst[dst_0 + 2] = src[src_0 + 2];  				//	dst[dst_0 + 3] = src[src_0 + 3];  				//	dst[dst_0 + 4] = src[src_0 + 4];  				//	dst[dst_0 + 5] = src[src_0 + 5];  				//	dst[dst_0 + 6] = src[src_0 + 6];  				//	dst[dst_0 + 7] = src[src_0 + 7];  				//	len -= 8; src_0 += 8; dst_0 += 8;  				//}    				while (len >= 4)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					len -= 4;  					src_0 += 4;  					dst_0 += 4;  				}    				while (len-- > 0)  				{  					dst[dst_0++] = src[src_0++];  				}  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,WildCopy,The following statement contains a magic number: if (len >= BLOCK_COPY_LIMIT)  			{  				Buffer.BlockCopy(src' src_0' dst' dst_0' len);  			}  			else  			{  				// apparently (tested) this is an overkill  				// it seems to be faster without this 8-byte loop  				//while (len >= 8)  				//{  				//	dst[dst_0] = src[src_0];  				//	dst[dst_0 + 1] = src[src_0 + 1];  				//	dst[dst_0 + 2] = src[src_0 + 2];  				//	dst[dst_0 + 3] = src[src_0 + 3];  				//	dst[dst_0 + 4] = src[src_0 + 4];  				//	dst[dst_0 + 5] = src[src_0 + 5];  				//	dst[dst_0 + 6] = src[src_0 + 6];  				//	dst[dst_0 + 7] = src[src_0 + 7];  				//	len -= 8; src_0 += 8; dst_0 += 8;  				//}    				while (len >= 4)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					len -= 4;  					src_0 += 4;  					dst_0 += 4;  				}    				while (len-- > 0)  				{  					dst[dst_0++] = src[src_0++];  				}  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,WildCopy,The following statement contains a magic number: if (len >= BLOCK_COPY_LIMIT)  			{  				Buffer.BlockCopy(src' src_0' dst' dst_0' len);  			}  			else  			{  				// apparently (tested) this is an overkill  				// it seems to be faster without this 8-byte loop  				//while (len >= 8)  				//{  				//	dst[dst_0] = src[src_0];  				//	dst[dst_0 + 1] = src[src_0 + 1];  				//	dst[dst_0 + 2] = src[src_0 + 2];  				//	dst[dst_0 + 3] = src[src_0 + 3];  				//	dst[dst_0 + 4] = src[src_0 + 4];  				//	dst[dst_0 + 5] = src[src_0 + 5];  				//	dst[dst_0 + 6] = src[src_0 + 6];  				//	dst[dst_0 + 7] = src[src_0 + 7];  				//	len -= 8; src_0 += 8; dst_0 += 8;  				//}    				while (len >= 4)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					len -= 4;  					src_0 += 4;  					dst_0 += 4;  				}    				while (len-- > 0)  				{  					dst[dst_0++] = src[src_0++];  				}  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,WildCopy,The following statement contains a magic number: if (len >= BLOCK_COPY_LIMIT)  			{  				Buffer.BlockCopy(src' src_0' dst' dst_0' len);  			}  			else  			{  				// apparently (tested) this is an overkill  				// it seems to be faster without this 8-byte loop  				//while (len >= 8)  				//{  				//	dst[dst_0] = src[src_0];  				//	dst[dst_0 + 1] = src[src_0 + 1];  				//	dst[dst_0 + 2] = src[src_0 + 2];  				//	dst[dst_0 + 3] = src[src_0 + 3];  				//	dst[dst_0 + 4] = src[src_0 + 4];  				//	dst[dst_0 + 5] = src[src_0 + 5];  				//	dst[dst_0 + 6] = src[src_0 + 6];  				//	dst[dst_0 + 7] = src[src_0 + 7];  				//	len -= 8; src_0 += 8; dst_0 += 8;  				//}    				while (len >= 4)  				{  					dst[dst_0] = src[src_0];  					dst[dst_0 + 1] = src[src_0 + 1];  					dst[dst_0 + 2] = src[src_0 + 2];  					dst[dst_0 + 3] = src[src_0 + 3];  					len -= 4;  					src_0 += 4;  					dst_0 += 4;  				}    				while (len-- > 0)  				{  					dst[dst_0++] = src[src_0++];  				}  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,SecureCopy,The following statement contains a magic number: Assert(diff >= 4' "Target must be at least 4 bytes further than source");
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,SecureCopy,The following statement contains a magic number: Assert(BLOCK_COPY_LIMIT > 4' "This method requires BLOCK_COPY_LIMIT > 4");
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,SecureCopy,The following statement contains a magic number: while (len >= 4)  			{  				buffer[dst] = buffer[src];  				buffer[dst + 1] = buffer[src + 1];  				buffer[dst + 2] = buffer[src + 2];  				buffer[dst + 3] = buffer[src + 3];  				dst += 4;  				src += 4;  				len -= 4;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,SecureCopy,The following statement contains a magic number: while (len >= 4)  			{  				buffer[dst] = buffer[src];  				buffer[dst + 1] = buffer[src + 1];  				buffer[dst + 2] = buffer[src + 2];  				buffer[dst + 3] = buffer[src + 3];  				dst += 4;  				src += 4;  				len -= 4;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,SecureCopy,The following statement contains a magic number: while (len >= 4)  			{  				buffer[dst] = buffer[src];  				buffer[dst + 1] = buffer[src + 1];  				buffer[dst + 2] = buffer[src + 2];  				buffer[dst + 3] = buffer[src + 3];  				dst += 4;  				src += 4;  				len -= 4;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,SecureCopy,The following statement contains a magic number: while (len >= 4)  			{  				buffer[dst] = buffer[src];  				buffer[dst + 1] = buffer[src + 1];  				buffer[dst + 2] = buffer[src + 2];  				buffer[dst + 3] = buffer[src + 3];  				dst += 4;  				src += 4;  				len -= 4;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,SecureCopy,The following statement contains a magic number: while (len >= 4)  			{  				buffer[dst] = buffer[src];  				buffer[dst + 1] = buffer[src + 1];  				buffer[dst + 2] = buffer[src + 2];  				buffer[dst + 3] = buffer[src + 3];  				dst += 4;  				src += 4;  				len -= 4;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,SecureCopy,The following statement contains a magic number: while (len >= 4)  			{  				buffer[dst] = buffer[src];  				buffer[dst + 1] = buffer[src + 1];  				buffer[dst + 2] = buffer[src + 2];  				buffer[dst + 3] = buffer[src + 3];  				dst += 4;  				src += 4;  				len -= 4;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,SecureCopy,The following statement contains a magic number: while (len >= 4)  			{  				buffer[dst] = buffer[src];  				buffer[dst + 1] = buffer[src + 1];  				buffer[dst + 2] = buffer[src + 2];  				buffer[dst + 3] = buffer[src + 3];  				dst += 4;  				src += 4;  				len -= 4;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,SecureCopy,The following statement contains a magic number: while (len >= 4)  			{  				buffer[dst] = buffer[src];  				buffer[dst + 1] = buffer[src + 1];  				buffer[dst + 2] = buffer[src + 2];  				buffer[dst + 3] = buffer[src + 3];  				dst += 4;  				src += 4;  				len -= 4;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe32,The following statement contains a magic number: var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe32,The following statement contains a magic number: _last_literals:  			// Encode Last Literals  			{  				var lastRun = (src_end - src_anchor);    				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;    				if (lastRun >= RUN_MASK)  				{  					dst[dst_p++] = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) dst[dst_p++] = 255;  					dst[dst_p++] = (byte)lastRun;  				}  				else dst[dst_p++] = (byte)(lastRun << ML_BITS);  				BlockCopy(src' src_anchor' dst' dst_p' src_end - src_anchor);  				dst_p += src_end - src_anchor;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe32,The following statement contains a magic number: _last_literals:  			// Encode Last Literals  			{  				var lastRun = (src_end - src_anchor);    				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;    				if (lastRun >= RUN_MASK)  				{  					dst[dst_p++] = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) dst[dst_p++] = 255;  					dst[dst_p++] = (byte)lastRun;  				}  				else dst[dst_p++] = (byte)(lastRun << ML_BITS);  				BlockCopy(src' src_anchor' dst' dst_p' src_end - src_anchor);  				dst_p += src_end - src_anchor;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe32,The following statement contains a magic number: _last_literals:  			// Encode Last Literals  			{  				var lastRun = (src_end - src_anchor);    				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;    				if (lastRun >= RUN_MASK)  				{  					dst[dst_p++] = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) dst[dst_p++] = 255;  					dst[dst_p++] = (byte)lastRun;  				}  				else dst[dst_p++] = (byte)(lastRun << ML_BITS);  				BlockCopy(src' src_anchor' dst' dst_p' src_end - src_anchor);  				dst_p += src_end - src_anchor;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe32,The following statement contains a magic number: _last_literals:  			// Encode Last Literals  			{  				var lastRun = (src_end - src_anchor);    				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;    				if (lastRun >= RUN_MASK)  				{  					dst[dst_p++] = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) dst[dst_p++] = 255;  					dst[dst_p++] = (byte)lastRun;  				}  				else dst[dst_p++] = (byte)(lastRun << ML_BITS);  				BlockCopy(src' src_anchor' dst' dst_p' src_end - src_anchor);  				dst_p += src_end - src_anchor;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe32,The following statement contains a magic number: _last_literals:  			// Encode Last Literals  			{  				var lastRun = (src_end - src_anchor);    				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;    				if (lastRun >= RUN_MASK)  				{  					dst[dst_p++] = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) dst[dst_p++] = 255;  					dst[dst_p++] = (byte)lastRun;  				}  				else dst[dst_p++] = (byte)(lastRun << ML_BITS);  				BlockCopy(src' src_anchor' dst' dst_p' src_end - src_anchor);  				dst_p += src_end - src_anchor;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe32,The following statement contains a magic number: var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  					{  						dst[dst_p++] = (byte)len;  					}  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  					{  						dst[dst_p++] = (byte)len;  					}  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  					{  						dst[dst_p++] = (byte)len;  					}  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  					{  						dst[dst_p++] = (byte)len;  					}  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  					{  						dst[dst_p++] = (byte)len;  					}  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  					{  						dst[dst_p++] = (byte)len;  					}  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  					{  						dst[dst_p++] = (byte)len;  					}  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  					{  						dst[dst_p++] = (byte)len;  					}  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  					{  						dst[dst_p++] = (byte)len;  					}  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  					{  						dst[dst_p++] = (byte)len;  					}  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  					{  						dst[dst_p++] = (byte)len;  					}  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  					{  						dst[dst_p++] = (byte)len;  					}  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  					{  						dst[dst_p++] = (byte)len;  					}  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  					{  						dst[dst_p++] = (byte)len;  					}  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  					{  						dst[dst_p++] = (byte)len;  					}  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  					{  						dst[dst_p++] = (byte)len;  					}  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  					{  						dst[dst_p++] = (byte)len;  					}  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  					{  						dst[dst_p++] = (byte)len;  					}  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  					{  						dst[dst_p++] = (byte)len;  					}  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe32,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  					{  						dst[dst_p++] = (byte)len;  					}  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (int)Xor4(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_32;  						src_ref += STEPSIZE_32;  						continue;  					}  					src_p += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe32,The following statement contains a magic number: if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe32,The following statement contains a magic number: if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe32,The following statement contains a magic number: if (lastRun >= RUN_MASK)  			{  				dst[dst_p++] = (RUN_MASK << ML_BITS);  				lastRun -= RUN_MASK;  				for (; lastRun > 254; lastRun -= 255) dst[dst_p++] = 255;  				dst[dst_p++] = (byte)lastRun;  			}  			else  			{  				dst[dst_p++] = (byte)(lastRun << ML_BITS);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe32,The following statement contains a magic number: if (lastRun >= RUN_MASK)  			{  				dst[dst_p++] = (RUN_MASK << ML_BITS);  				lastRun -= RUN_MASK;  				for (; lastRun > 254; lastRun -= 255) dst[dst_p++] = 255;  				dst[dst_p++] = (byte)lastRun;  			}  			else  			{  				dst[dst_p++] = (byte)(lastRun << ML_BITS);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe32,The following statement contains a magic number: if (lastRun >= RUN_MASK)  			{  				dst[dst_p++] = (RUN_MASK << ML_BITS);  				lastRun -= RUN_MASK;  				for (; lastRun > 254; lastRun -= 255) dst[dst_p++] = 255;  				dst[dst_p++] = (byte)lastRun;  			}  			else  			{  				dst[dst_p++] = (byte)(lastRun << ML_BITS);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe32,The following statement contains a magic number: var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_32 - 4);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe32,The following statement contains a magic number: while (true)  			{  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					int len;  					for (; (len = src[src_p++]) == 255; length += 255)  					{  						/* do nothing */  					}  					length += len;  				}    				// copy literals  				dst_cpy = dst_p + length;    				if (dst_cpy > dst_COPYLENGTH)  				{  					if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  					BlockCopy(src' src_p' dst' dst_p' length);  					src_p += length;  					break; // EOF  				}  				if (dst_p < dst_cpy)  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					for (; src[src_p] == 255; length += 255) src_p++;  					length += src[src_p++];  				}    				// copy repeated sequence  				if ((dst_p - dst_ref) < STEPSIZE_32)  				{  					const int dec64 = 0;  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_32 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy4(dst' dst_ref' dst_p);  					dst_p += 4;  					dst_ref += 4;  				}  				dst_cpy = dst_p + length - (STEPSIZE_32 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe32,The following statement contains a magic number: while (true)  			{  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					int len;  					for (; (len = src[src_p++]) == 255; length += 255)  					{  						/* do nothing */  					}  					length += len;  				}    				// copy literals  				dst_cpy = dst_p + length;    				if (dst_cpy > dst_COPYLENGTH)  				{  					if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  					BlockCopy(src' src_p' dst' dst_p' length);  					src_p += length;  					break; // EOF  				}  				if (dst_p < dst_cpy)  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					for (; src[src_p] == 255; length += 255) src_p++;  					length += src[src_p++];  				}    				// copy repeated sequence  				if ((dst_p - dst_ref) < STEPSIZE_32)  				{  					const int dec64 = 0;  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_32 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy4(dst' dst_ref' dst_p);  					dst_p += 4;  					dst_ref += 4;  				}  				dst_cpy = dst_p + length - (STEPSIZE_32 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe32,The following statement contains a magic number: while (true)  			{  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					int len;  					for (; (len = src[src_p++]) == 255; length += 255)  					{  						/* do nothing */  					}  					length += len;  				}    				// copy literals  				dst_cpy = dst_p + length;    				if (dst_cpy > dst_COPYLENGTH)  				{  					if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  					BlockCopy(src' src_p' dst' dst_p' length);  					src_p += length;  					break; // EOF  				}  				if (dst_p < dst_cpy)  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					for (; src[src_p] == 255; length += 255) src_p++;  					length += src[src_p++];  				}    				// copy repeated sequence  				if ((dst_p - dst_ref) < STEPSIZE_32)  				{  					const int dec64 = 0;  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_32 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy4(dst' dst_ref' dst_p);  					dst_p += 4;  					dst_ref += 4;  				}  				dst_cpy = dst_p + length - (STEPSIZE_32 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe32,The following statement contains a magic number: while (true)  			{  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					int len;  					for (; (len = src[src_p++]) == 255; length += 255)  					{  						/* do nothing */  					}  					length += len;  				}    				// copy literals  				dst_cpy = dst_p + length;    				if (dst_cpy > dst_COPYLENGTH)  				{  					if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  					BlockCopy(src' src_p' dst' dst_p' length);  					src_p += length;  					break; // EOF  				}  				if (dst_p < dst_cpy)  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					for (; src[src_p] == 255; length += 255) src_p++;  					length += src[src_p++];  				}    				// copy repeated sequence  				if ((dst_p - dst_ref) < STEPSIZE_32)  				{  					const int dec64 = 0;  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_32 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy4(dst' dst_ref' dst_p);  					dst_p += 4;  					dst_ref += 4;  				}  				dst_cpy = dst_p + length - (STEPSIZE_32 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe32,The following statement contains a magic number: while (true)  			{  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					int len;  					for (; (len = src[src_p++]) == 255; length += 255)  					{  						/* do nothing */  					}  					length += len;  				}    				// copy literals  				dst_cpy = dst_p + length;    				if (dst_cpy > dst_COPYLENGTH)  				{  					if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  					BlockCopy(src' src_p' dst' dst_p' length);  					src_p += length;  					break; // EOF  				}  				if (dst_p < dst_cpy)  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					for (; src[src_p] == 255; length += 255) src_p++;  					length += src[src_p++];  				}    				// copy repeated sequence  				if ((dst_p - dst_ref) < STEPSIZE_32)  				{  					const int dec64 = 0;  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_32 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy4(dst' dst_ref' dst_p);  					dst_p += 4;  					dst_ref += 4;  				}  				dst_cpy = dst_p + length - (STEPSIZE_32 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe32,The following statement contains a magic number: while (true)  			{  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					int len;  					for (; (len = src[src_p++]) == 255; length += 255)  					{  						/* do nothing */  					}  					length += len;  				}    				// copy literals  				dst_cpy = dst_p + length;    				if (dst_cpy > dst_COPYLENGTH)  				{  					if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  					BlockCopy(src' src_p' dst' dst_p' length);  					src_p += length;  					break; // EOF  				}  				if (dst_p < dst_cpy)  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					for (; src[src_p] == 255; length += 255) src_p++;  					length += src[src_p++];  				}    				// copy repeated sequence  				if ((dst_p - dst_ref) < STEPSIZE_32)  				{  					const int dec64 = 0;  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_32 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy4(dst' dst_ref' dst_p);  					dst_p += 4;  					dst_ref += 4;  				}  				dst_cpy = dst_p + length - (STEPSIZE_32 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe32,The following statement contains a magic number: while (true)  			{  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					int len;  					for (; (len = src[src_p++]) == 255; length += 255)  					{  						/* do nothing */  					}  					length += len;  				}    				// copy literals  				dst_cpy = dst_p + length;    				if (dst_cpy > dst_COPYLENGTH)  				{  					if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  					BlockCopy(src' src_p' dst' dst_p' length);  					src_p += length;  					break; // EOF  				}  				if (dst_p < dst_cpy)  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					for (; src[src_p] == 255; length += 255) src_p++;  					length += src[src_p++];  				}    				// copy repeated sequence  				if ((dst_p - dst_ref) < STEPSIZE_32)  				{  					const int dec64 = 0;  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_32 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy4(dst' dst_ref' dst_p);  					dst_p += 4;  					dst_ref += 4;  				}  				dst_cpy = dst_p + length - (STEPSIZE_32 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe32,The following statement contains a magic number: while (true)  			{  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					int len;  					for (; (len = src[src_p++]) == 255; length += 255)  					{  						/* do nothing */  					}  					length += len;  				}    				// copy literals  				dst_cpy = dst_p + length;    				if (dst_cpy > dst_COPYLENGTH)  				{  					if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  					BlockCopy(src' src_p' dst' dst_p' length);  					src_p += length;  					break; // EOF  				}  				if (dst_p < dst_cpy)  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					for (; src[src_p] == 255; length += 255) src_p++;  					length += src[src_p++];  				}    				// copy repeated sequence  				if ((dst_p - dst_ref) < STEPSIZE_32)  				{  					const int dec64 = 0;  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_32 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy4(dst' dst_ref' dst_p);  					dst_p += 4;  					dst_ref += 4;  				}  				dst_cpy = dst_p + length - (STEPSIZE_32 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe32,The following statement contains a magic number: while (true)  			{  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					int len;  					for (; (len = src[src_p++]) == 255; length += 255)  					{  						/* do nothing */  					}  					length += len;  				}    				// copy literals  				dst_cpy = dst_p + length;    				if (dst_cpy > dst_COPYLENGTH)  				{  					if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  					BlockCopy(src' src_p' dst' dst_p' length);  					src_p += length;  					break; // EOF  				}  				if (dst_p < dst_cpy)  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					for (; src[src_p] == 255; length += 255) src_p++;  					length += src[src_p++];  				}    				// copy repeated sequence  				if ((dst_p - dst_ref) < STEPSIZE_32)  				{  					const int dec64 = 0;  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_32 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy4(dst' dst_ref' dst_p);  					dst_p += 4;  					dst_ref += 4;  				}  				dst_cpy = dst_p + length - (STEPSIZE_32 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe32,The following statement contains a magic number: while (true)  			{  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					int len;  					for (; (len = src[src_p++]) == 255; length += 255)  					{  						/* do nothing */  					}  					length += len;  				}    				// copy literals  				dst_cpy = dst_p + length;    				if (dst_cpy > dst_COPYLENGTH)  				{  					if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  					BlockCopy(src' src_p' dst' dst_p' length);  					src_p += length;  					break; // EOF  				}  				if (dst_p < dst_cpy)  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					for (; src[src_p] == 255; length += 255) src_p++;  					length += src[src_p++];  				}    				// copy repeated sequence  				if ((dst_p - dst_ref) < STEPSIZE_32)  				{  					const int dec64 = 0;  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_32 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy4(dst' dst_ref' dst_p);  					dst_p += 4;  					dst_ref += 4;  				}  				dst_cpy = dst_p + length - (STEPSIZE_32 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe32,The following statement contains a magic number: while (true)  			{  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					int len;  					for (; (len = src[src_p++]) == 255; length += 255)  					{  						/* do nothing */  					}  					length += len;  				}    				// copy literals  				dst_cpy = dst_p + length;    				if (dst_cpy > dst_COPYLENGTH)  				{  					if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  					BlockCopy(src' src_p' dst' dst_p' length);  					src_p += length;  					break; // EOF  				}  				if (dst_p < dst_cpy)  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					for (; src[src_p] == 255; length += 255) src_p++;  					length += src[src_p++];  				}    				// copy repeated sequence  				if ((dst_p - dst_ref) < STEPSIZE_32)  				{  					const int dec64 = 0;  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_32 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy4(dst' dst_ref' dst_p);  					dst_p += 4;  					dst_ref += 4;  				}  				dst_cpy = dst_p + length - (STEPSIZE_32 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe32,The following statement contains a magic number: while (true)  			{  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					int len;  					for (; (len = src[src_p++]) == 255; length += 255)  					{  						/* do nothing */  					}  					length += len;  				}    				// copy literals  				dst_cpy = dst_p + length;    				if (dst_cpy > dst_COPYLENGTH)  				{  					if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  					BlockCopy(src' src_p' dst' dst_p' length);  					src_p += length;  					break; // EOF  				}  				if (dst_p < dst_cpy)  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					for (; src[src_p] == 255; length += 255) src_p++;  					length += src[src_p++];  				}    				// copy repeated sequence  				if ((dst_p - dst_ref) < STEPSIZE_32)  				{  					const int dec64 = 0;  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_32 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy4(dst' dst_ref' dst_p);  					dst_p += 4;  					dst_ref += 4;  				}  				dst_cpy = dst_p + length - (STEPSIZE_32 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe32,The following statement contains a magic number: while (true)  			{  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					int len;  					for (; (len = src[src_p++]) == 255; length += 255)  					{  						/* do nothing */  					}  					length += len;  				}    				// copy literals  				dst_cpy = dst_p + length;    				if (dst_cpy > dst_COPYLENGTH)  				{  					if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  					BlockCopy(src' src_p' dst' dst_p' length);  					src_p += length;  					break; // EOF  				}  				if (dst_p < dst_cpy)  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					for (; src[src_p] == 255; length += 255) src_p++;  					length += src[src_p++];  				}    				// copy repeated sequence  				if ((dst_p - dst_ref) < STEPSIZE_32)  				{  					const int dec64 = 0;  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_32 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy4(dst' dst_ref' dst_p);  					dst_p += 4;  					dst_ref += 4;  				}  				dst_cpy = dst_p + length - (STEPSIZE_32 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe32,The following statement contains a magic number: while (true)  			{  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					int len;  					for (; (len = src[src_p++]) == 255; length += 255)  					{  						/* do nothing */  					}  					length += len;  				}    				// copy literals  				dst_cpy = dst_p + length;    				if (dst_cpy > dst_COPYLENGTH)  				{  					if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  					BlockCopy(src' src_p' dst' dst_p' length);  					src_p += length;  					break; // EOF  				}  				if (dst_p < dst_cpy)  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					for (; src[src_p] == 255; length += 255) src_p++;  					length += src[src_p++];  				}    				// copy repeated sequence  				if ((dst_p - dst_ref) < STEPSIZE_32)  				{  					const int dec64 = 0;  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_32 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy4(dst' dst_ref' dst_p);  					dst_p += 4;  					dst_ref += 4;  				}  				dst_cpy = dst_p + length - (STEPSIZE_32 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe32,The following statement contains a magic number: while (true)  			{  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					int len;  					for (; (len = src[src_p++]) == 255; length += 255)  					{  						/* do nothing */  					}  					length += len;  				}    				// copy literals  				dst_cpy = dst_p + length;    				if (dst_cpy > dst_COPYLENGTH)  				{  					if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  					BlockCopy(src' src_p' dst' dst_p' length);  					src_p += length;  					break; // EOF  				}  				if (dst_p < dst_cpy)  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					for (; src[src_p] == 255; length += 255) src_p++;  					length += src[src_p++];  				}    				// copy repeated sequence  				if ((dst_p - dst_ref) < STEPSIZE_32)  				{  					const int dec64 = 0;  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_32 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy4(dst' dst_ref' dst_p);  					dst_p += 4;  					dst_ref += 4;  				}  				dst_cpy = dst_p + length - (STEPSIZE_32 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe32,The following statement contains a magic number: var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe32,The following statement contains a magic number: var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_32 - 4)));
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe32,The following statement contains a magic number: while (true)  			{  				byte token;  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					var s = 255;  					while ((src_p < src_end) && (s == 255)) length += (s = src[src_p++]);  				}    				// copy literals  				dst_cpy = dst_p + length;    				if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  				{  					if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  					if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  					BlockCopy(src' src_p' dst' dst_p' length);  					dst_p += length;  					break; // Necessarily EOF' due to parsing restrictions  				}  				if (dst_p < dst_cpy)  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside of destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  					{  						int s = src[src_p++];  						length += s;  						if (s == 255) continue;  						break;  					}  				}    				// copy repeated sequence  				if (dst_p - dst_ref < STEPSIZE_32)  				{  					const int dec64 = 0;  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_32 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy4(dst' dst_ref' dst_p);  					dst_p += 4;  					dst_ref += 4;  				}  				dst_cpy = dst_p + length - (STEPSIZE_32 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe32,The following statement contains a magic number: while (true)  			{  				byte token;  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					var s = 255;  					while ((src_p < src_end) && (s == 255)) length += (s = src[src_p++]);  				}    				// copy literals  				dst_cpy = dst_p + length;    				if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  				{  					if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  					if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  					BlockCopy(src' src_p' dst' dst_p' length);  					dst_p += length;  					break; // Necessarily EOF' due to parsing restrictions  				}  				if (dst_p < dst_cpy)  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside of destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  					{  						int s = src[src_p++];  						length += s;  						if (s == 255) continue;  						break;  					}  				}    				// copy repeated sequence  				if (dst_p - dst_ref < STEPSIZE_32)  				{  					const int dec64 = 0;  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_32 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy4(dst' dst_ref' dst_p);  					dst_p += 4;  					dst_ref += 4;  				}  				dst_cpy = dst_p + length - (STEPSIZE_32 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe32,The following statement contains a magic number: while (true)  			{  				byte token;  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					var s = 255;  					while ((src_p < src_end) && (s == 255)) length += (s = src[src_p++]);  				}    				// copy literals  				dst_cpy = dst_p + length;    				if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  				{  					if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  					if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  					BlockCopy(src' src_p' dst' dst_p' length);  					dst_p += length;  					break; // Necessarily EOF' due to parsing restrictions  				}  				if (dst_p < dst_cpy)  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside of destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  					{  						int s = src[src_p++];  						length += s;  						if (s == 255) continue;  						break;  					}  				}    				// copy repeated sequence  				if (dst_p - dst_ref < STEPSIZE_32)  				{  					const int dec64 = 0;  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_32 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy4(dst' dst_ref' dst_p);  					dst_p += 4;  					dst_ref += 4;  				}  				dst_cpy = dst_p + length - (STEPSIZE_32 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe32,The following statement contains a magic number: while (true)  			{  				byte token;  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					var s = 255;  					while ((src_p < src_end) && (s == 255)) length += (s = src[src_p++]);  				}    				// copy literals  				dst_cpy = dst_p + length;    				if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  				{  					if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  					if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  					BlockCopy(src' src_p' dst' dst_p' length);  					dst_p += length;  					break; // Necessarily EOF' due to parsing restrictions  				}  				if (dst_p < dst_cpy)  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside of destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  					{  						int s = src[src_p++];  						length += s;  						if (s == 255) continue;  						break;  					}  				}    				// copy repeated sequence  				if (dst_p - dst_ref < STEPSIZE_32)  				{  					const int dec64 = 0;  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_32 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy4(dst' dst_ref' dst_p);  					dst_p += 4;  					dst_ref += 4;  				}  				dst_cpy = dst_p + length - (STEPSIZE_32 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe32,The following statement contains a magic number: while (true)  			{  				byte token;  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					var s = 255;  					while ((src_p < src_end) && (s == 255)) length += (s = src[src_p++]);  				}    				// copy literals  				dst_cpy = dst_p + length;    				if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  				{  					if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  					if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  					BlockCopy(src' src_p' dst' dst_p' length);  					dst_p += length;  					break; // Necessarily EOF' due to parsing restrictions  				}  				if (dst_p < dst_cpy)  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside of destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  					{  						int s = src[src_p++];  						length += s;  						if (s == 255) continue;  						break;  					}  				}    				// copy repeated sequence  				if (dst_p - dst_ref < STEPSIZE_32)  				{  					const int dec64 = 0;  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_32 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy4(dst' dst_ref' dst_p);  					dst_p += 4;  					dst_ref += 4;  				}  				dst_cpy = dst_p + length - (STEPSIZE_32 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe32,The following statement contains a magic number: while (true)  			{  				byte token;  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					var s = 255;  					while ((src_p < src_end) && (s == 255)) length += (s = src[src_p++]);  				}    				// copy literals  				dst_cpy = dst_p + length;    				if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  				{  					if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  					if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  					BlockCopy(src' src_p' dst' dst_p' length);  					dst_p += length;  					break; // Necessarily EOF' due to parsing restrictions  				}  				if (dst_p < dst_cpy)  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside of destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  					{  						int s = src[src_p++];  						length += s;  						if (s == 255) continue;  						break;  					}  				}    				// copy repeated sequence  				if (dst_p - dst_ref < STEPSIZE_32)  				{  					const int dec64 = 0;  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_32 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy4(dst' dst_ref' dst_p);  					dst_p += 4;  					dst_ref += 4;  				}  				dst_cpy = dst_p + length - (STEPSIZE_32 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe32,The following statement contains a magic number: while (true)  			{  				byte token;  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					var s = 255;  					while ((src_p < src_end) && (s == 255)) length += (s = src[src_p++]);  				}    				// copy literals  				dst_cpy = dst_p + length;    				if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  				{  					if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  					if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  					BlockCopy(src' src_p' dst' dst_p' length);  					dst_p += length;  					break; // Necessarily EOF' due to parsing restrictions  				}  				if (dst_p < dst_cpy)  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside of destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  					{  						int s = src[src_p++];  						length += s;  						if (s == 255) continue;  						break;  					}  				}    				// copy repeated sequence  				if (dst_p - dst_ref < STEPSIZE_32)  				{  					const int dec64 = 0;  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_32 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy4(dst' dst_ref' dst_p);  					dst_p += 4;  					dst_ref += 4;  				}  				dst_cpy = dst_p + length - (STEPSIZE_32 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe32,The following statement contains a magic number: while (true)  			{  				byte token;  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					var s = 255;  					while ((src_p < src_end) && (s == 255)) length += (s = src[src_p++]);  				}    				// copy literals  				dst_cpy = dst_p + length;    				if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  				{  					if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  					if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  					BlockCopy(src' src_p' dst' dst_p' length);  					dst_p += length;  					break; // Necessarily EOF' due to parsing restrictions  				}  				if (dst_p < dst_cpy)  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside of destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  					{  						int s = src[src_p++];  						length += s;  						if (s == 255) continue;  						break;  					}  				}    				// copy repeated sequence  				if (dst_p - dst_ref < STEPSIZE_32)  				{  					const int dec64 = 0;  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_32 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy4(dst' dst_ref' dst_p);  					dst_p += 4;  					dst_ref += 4;  				}  				dst_cpy = dst_p + length - (STEPSIZE_32 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe32,The following statement contains a magic number: while (true)  			{  				byte token;  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					var s = 255;  					while ((src_p < src_end) && (s == 255)) length += (s = src[src_p++]);  				}    				// copy literals  				dst_cpy = dst_p + length;    				if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  				{  					if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  					if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  					BlockCopy(src' src_p' dst' dst_p' length);  					dst_p += length;  					break; // Necessarily EOF' due to parsing restrictions  				}  				if (dst_p < dst_cpy)  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside of destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  					{  						int s = src[src_p++];  						length += s;  						if (s == 255) continue;  						break;  					}  				}    				// copy repeated sequence  				if (dst_p - dst_ref < STEPSIZE_32)  				{  					const int dec64 = 0;  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_32 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy4(dst' dst_ref' dst_p);  					dst_p += 4;  					dst_ref += 4;  				}  				dst_cpy = dst_p + length - (STEPSIZE_32 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe32,The following statement contains a magic number: while (true)  			{  				byte token;  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					var s = 255;  					while ((src_p < src_end) && (s == 255)) length += (s = src[src_p++]);  				}    				// copy literals  				dst_cpy = dst_p + length;    				if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  				{  					if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  					if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  					BlockCopy(src' src_p' dst' dst_p' length);  					dst_p += length;  					break; // Necessarily EOF' due to parsing restrictions  				}  				if (dst_p < dst_cpy)  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside of destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  					{  						int s = src[src_p++];  						length += s;  						if (s == 255) continue;  						break;  					}  				}    				// copy repeated sequence  				if (dst_p - dst_ref < STEPSIZE_32)  				{  					const int dec64 = 0;  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_32 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy4(dst' dst_ref' dst_p);  					dst_p += 4;  					dst_ref += 4;  				}  				dst_cpy = dst_p + length - (STEPSIZE_32 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe32,The following statement contains a magic number: while (true)  			{  				byte token;  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					var s = 255;  					while ((src_p < src_end) && (s == 255)) length += (s = src[src_p++]);  				}    				// copy literals  				dst_cpy = dst_p + length;    				if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  				{  					if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  					if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  					BlockCopy(src' src_p' dst' dst_p' length);  					dst_p += length;  					break; // Necessarily EOF' due to parsing restrictions  				}  				if (dst_p < dst_cpy)  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside of destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  					{  						int s = src[src_p++];  						length += s;  						if (s == 255) continue;  						break;  					}  				}    				// copy repeated sequence  				if (dst_p - dst_ref < STEPSIZE_32)  				{  					const int dec64 = 0;  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_32 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy4(dst' dst_ref' dst_p);  					dst_p += 4;  					dst_ref += 4;  				}  				dst_cpy = dst_p + length - (STEPSIZE_32 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe32,The following statement contains a magic number: while (true)  			{  				byte token;  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					var s = 255;  					while ((src_p < src_end) && (s == 255)) length += (s = src[src_p++]);  				}    				// copy literals  				dst_cpy = dst_p + length;    				if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  				{  					if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  					if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  					BlockCopy(src' src_p' dst' dst_p' length);  					dst_p += length;  					break; // Necessarily EOF' due to parsing restrictions  				}  				if (dst_p < dst_cpy)  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside of destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  					{  						int s = src[src_p++];  						length += s;  						if (s == 255) continue;  						break;  					}  				}    				// copy repeated sequence  				if (dst_p - dst_ref < STEPSIZE_32)  				{  					const int dec64 = 0;  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_32 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy4(dst' dst_ref' dst_p);  					dst_p += 4;  					dst_ref += 4;  				}  				dst_cpy = dst_p + length - (STEPSIZE_32 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe32,The following statement contains a magic number: while (true)  			{  				byte token;  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					var s = 255;  					while ((src_p < src_end) && (s == 255)) length += (s = src[src_p++]);  				}    				// copy literals  				dst_cpy = dst_p + length;    				if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  				{  					if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  					if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  					BlockCopy(src' src_p' dst' dst_p' length);  					dst_p += length;  					break; // Necessarily EOF' due to parsing restrictions  				}  				if (dst_p < dst_cpy)  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside of destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  					{  						int s = src[src_p++];  						length += s;  						if (s == 255) continue;  						break;  					}  				}    				// copy repeated sequence  				if (dst_p - dst_ref < STEPSIZE_32)  				{  					const int dec64 = 0;  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_32 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy4(dst' dst_ref' dst_p);  					dst_p += 4;  					dst_ref += 4;  				}  				dst_cpy = dst_p + length - (STEPSIZE_32 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe32,The following statement contains a magic number: while (true)  			{  				byte token;  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					var s = 255;  					while ((src_p < src_end) && (s == 255)) length += (s = src[src_p++]);  				}    				// copy literals  				dst_cpy = dst_p + length;    				if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  				{  					if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  					if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  					BlockCopy(src' src_p' dst' dst_p' length);  					dst_p += length;  					break; // Necessarily EOF' due to parsing restrictions  				}  				if (dst_p < dst_cpy)  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside of destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  					{  						int s = src[src_p++];  						length += s;  						if (s == 255) continue;  						break;  					}  				}    				// copy repeated sequence  				if (dst_p - dst_ref < STEPSIZE_32)  				{  					const int dec64 = 0;  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_32 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy4(dst' dst_ref' dst_p);  					dst_p += 4;  					dst_ref += 4;  				}  				dst_cpy = dst_p + length - (STEPSIZE_32 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4HC_CommonLength_32,The following statement contains a magic number: while (p1t < src_LASTLITERALS - (STEPSIZE_32 - 1))  			{  				var diff = (int)Xor4(src' p2' p1t);  				if (diff == 0)  				{  					p1t += STEPSIZE_32;  					p2 += STEPSIZE_32;  					continue;  				}  				p1t += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  				return (p1t - p1);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4HC_CommonLength_32,The following statement contains a magic number: if ((p1t < (src_LASTLITERALS - 1)) && (Equal2(src' p2' p1t)))  			{  				p1t += 2;  				p2 += 2;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4HC_CommonLength_32,The following statement contains a magic number: if ((p1t < (src_LASTLITERALS - 1)) && (Equal2(src' p2' p1t)))  			{  				p1t += 2;  				p2 += 2;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4HC_InsertAndFindBestMatch_32,The following statement contains a magic number: if (src_ref >= src_p - 4) // potential repetition  			{  				if (Equal4(src' src_ref' src_p)) // confirmed  				{  					delta = (ushort)(src_p - src_ref);  					repl = ml = LZ4HC_CommonLength_32(ctx' src_p + MINMATCH' src_ref + MINMATCH) + MINMATCH;  					src_match = src_ref;  				}  				src_ref = ((src_ref) - chainTable[(src_ref) & MAXD_MASK]);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4HC_InsertAndGetWiderMatch_32,The following statement contains a magic number: while ((src_ref >= src_p - MAX_DISTANCE) && (nbAttempts != 0))  			{  				nbAttempts--;  				if (src[(startLimit + longest)] == src[(src_ref - delta + longest)])  				{  					if (Equal4(src' src_ref' src_p))  					{  						var reft = src_ref + MINMATCH;  						var ipt = src_p + MINMATCH;  						var startt = src_p;    						while (ipt < src_LASTLITERALS - (STEPSIZE_32 - 1))  						{  							var diff = (int)Xor4(src' reft' ipt);  							if (diff == 0)  							{  								ipt += STEPSIZE_32;  								reft += STEPSIZE_32;  								continue;  							}  							ipt += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  							goto _endCount;  						}  						if ((ipt < (src_LASTLITERALS - 1)) && (Equal2(src' reft' ipt)))  						{  							ipt += 2;  							reft += 2;  						}  						if ((ipt < src_LASTLITERALS) && (src[reft] == src[ipt])) ipt++;    					_endCount:  						reft = src_ref;    						while ((startt > startLimit) && (reft > src_base) && (src[startt - 1] == src[reft - 1]))  						{  							startt--;  							reft--;  						}    						if ((ipt - startt) > longest)  						{  							longest = (ipt - startt);  							matchpos = reft;  							startpos = startt;  						}  					}  				}  				src_ref = ((src_ref) - chainTable[(src_ref) & MAXD_MASK]);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4HC_InsertAndGetWiderMatch_32,The following statement contains a magic number: while ((src_ref >= src_p - MAX_DISTANCE) && (nbAttempts != 0))  			{  				nbAttempts--;  				if (src[(startLimit + longest)] == src[(src_ref - delta + longest)])  				{  					if (Equal4(src' src_ref' src_p))  					{  						var reft = src_ref + MINMATCH;  						var ipt = src_p + MINMATCH;  						var startt = src_p;    						while (ipt < src_LASTLITERALS - (STEPSIZE_32 - 1))  						{  							var diff = (int)Xor4(src' reft' ipt);  							if (diff == 0)  							{  								ipt += STEPSIZE_32;  								reft += STEPSIZE_32;  								continue;  							}  							ipt += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  							goto _endCount;  						}  						if ((ipt < (src_LASTLITERALS - 1)) && (Equal2(src' reft' ipt)))  						{  							ipt += 2;  							reft += 2;  						}  						if ((ipt < src_LASTLITERALS) && (src[reft] == src[ipt])) ipt++;    					_endCount:  						reft = src_ref;    						while ((startt > startLimit) && (reft > src_base) && (src[startt - 1] == src[reft - 1]))  						{  							startt--;  							reft--;  						}    						if ((ipt - startt) > longest)  						{  							longest = (ipt - startt);  							matchpos = reft;  							startpos = startt;  						}  					}  				}  				src_ref = ((src_ref) - chainTable[(src_ref) & MAXD_MASK]);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4HC_InsertAndGetWiderMatch_32,The following statement contains a magic number: while ((src_ref >= src_p - MAX_DISTANCE) && (nbAttempts != 0))  			{  				nbAttempts--;  				if (src[(startLimit + longest)] == src[(src_ref - delta + longest)])  				{  					if (Equal4(src' src_ref' src_p))  					{  						var reft = src_ref + MINMATCH;  						var ipt = src_p + MINMATCH;  						var startt = src_p;    						while (ipt < src_LASTLITERALS - (STEPSIZE_32 - 1))  						{  							var diff = (int)Xor4(src' reft' ipt);  							if (diff == 0)  							{  								ipt += STEPSIZE_32;  								reft += STEPSIZE_32;  								continue;  							}  							ipt += debruijn32[((uint)((diff) & -(diff)) * 0x077CB531u) >> 27];  							goto _endCount;  						}  						if ((ipt < (src_LASTLITERALS - 1)) && (Equal2(src' reft' ipt)))  						{  							ipt += 2;  							reft += 2;  						}  						if ((ipt < src_LASTLITERALS) && (src[reft] == src[ipt])) ipt++;    					_endCount:  						reft = src_ref;    						while ((startt > startLimit) && (reft > src_base) && (src[startt - 1] == src[reft - 1]))  						{  							startt--;  							reft--;  						}    						if ((ipt - startt) > longest)  						{  							longest = (ipt - startt);  							matchpos = reft;  							startpos = startt;  						}  					}  				}  				src_ref = ((src_ref) - chainTable[(src_ref) & MAXD_MASK]);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_encodeSequence_32,The following statement contains a magic number: if ((dst_p + length + (2 + 1 + LASTLITERALS) + (length >> 8)) > dst_end) return 1;
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_encodeSequence_32,The following statement contains a magic number: if ((dst_p + length + (2 + 1 + LASTLITERALS) + (length >> 8)) > dst_end) return 1;
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_encodeSequence_32,The following statement contains a magic number: if (length >= RUN_MASK)  			{  				dst[dst_token] = (RUN_MASK << ML_BITS);  				len = length - RUN_MASK;  				for (; len > 254; len -= 255) dst[dst_p++] = 255;  				dst[dst_p++] = (byte)len;  			}  			else  			{  				dst[dst_token] = (byte)(length << ML_BITS);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_encodeSequence_32,The following statement contains a magic number: if (length >= RUN_MASK)  			{  				dst[dst_token] = (RUN_MASK << ML_BITS);  				len = length - RUN_MASK;  				for (; len > 254; len -= 255) dst[dst_p++] = 255;  				dst[dst_p++] = (byte)len;  			}  			else  			{  				dst[dst_token] = (byte)(length << ML_BITS);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_encodeSequence_32,The following statement contains a magic number: if (length >= RUN_MASK)  			{  				dst[dst_token] = (RUN_MASK << ML_BITS);  				len = length - RUN_MASK;  				for (; len > 254; len -= 255) dst[dst_p++] = 255;  				dst[dst_p++] = (byte)len;  			}  			else  			{  				dst[dst_token] = (byte)(length << ML_BITS);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_encodeSequence_32,The following statement contains a magic number: dst_p += 2;
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_encodeSequence_32,The following statement contains a magic number: if (dst_p + (1 + LASTLITERALS) + (length >> 8) > dst_end) return 1;
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_encodeSequence_32,The following statement contains a magic number: if (len >= ML_MASK)  			{  				dst[dst_token] += ML_MASK;  				len -= ML_MASK;  				for (; len > 509; len -= 510)  				{  					dst[(dst_p)++] = 255;  					dst[(dst_p)++] = 255;  				}  				if (len > 254)  				{  					len -= 255;  					dst[(dst_p)++] = 255;  				}  				dst[(dst_p)++] = (byte)len;  			}  			else  			{  				dst[dst_token] += (byte)len;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_encodeSequence_32,The following statement contains a magic number: if (len >= ML_MASK)  			{  				dst[dst_token] += ML_MASK;  				len -= ML_MASK;  				for (; len > 509; len -= 510)  				{  					dst[(dst_p)++] = 255;  					dst[(dst_p)++] = 255;  				}  				if (len > 254)  				{  					len -= 255;  					dst[(dst_p)++] = 255;  				}  				dst[(dst_p)++] = (byte)len;  			}  			else  			{  				dst[dst_token] += (byte)len;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_encodeSequence_32,The following statement contains a magic number: if (len >= ML_MASK)  			{  				dst[dst_token] += ML_MASK;  				len -= ML_MASK;  				for (; len > 509; len -= 510)  				{  					dst[(dst_p)++] = 255;  					dst[(dst_p)++] = 255;  				}  				if (len > 254)  				{  					len -= 255;  					dst[(dst_p)++] = 255;  				}  				dst[(dst_p)++] = (byte)len;  			}  			else  			{  				dst[dst_token] += (byte)len;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_encodeSequence_32,The following statement contains a magic number: if (len >= ML_MASK)  			{  				dst[dst_token] += ML_MASK;  				len -= ML_MASK;  				for (; len > 509; len -= 510)  				{  					dst[(dst_p)++] = 255;  					dst[(dst_p)++] = 255;  				}  				if (len > 254)  				{  					len -= 255;  					dst[(dst_p)++] = 255;  				}  				dst[(dst_p)++] = (byte)len;  			}  			else  			{  				dst[dst_token] += (byte)len;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_encodeSequence_32,The following statement contains a magic number: if (len >= ML_MASK)  			{  				dst[dst_token] += ML_MASK;  				len -= ML_MASK;  				for (; len > 509; len -= 510)  				{  					dst[(dst_p)++] = 255;  					dst[(dst_p)++] = 255;  				}  				if (len > 254)  				{  					len -= 255;  					dst[(dst_p)++] = 255;  				}  				dst[(dst_p)++] = (byte)len;  			}  			else  			{  				dst[dst_token] += (byte)len;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_encodeSequence_32,The following statement contains a magic number: if (len >= ML_MASK)  			{  				dst[dst_token] += ML_MASK;  				len -= ML_MASK;  				for (; len > 509; len -= 510)  				{  					dst[(dst_p)++] = 255;  					dst[(dst_p)++] = 255;  				}  				if (len > 254)  				{  					len -= 255;  					dst[(dst_p)++] = 255;  				}  				dst[(dst_p)++] = (byte)len;  			}  			else  			{  				dst[dst_token] += (byte)len;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_encodeSequence_32,The following statement contains a magic number: if (len >= ML_MASK)  			{  				dst[dst_token] += ML_MASK;  				len -= ML_MASK;  				for (; len > 509; len -= 510)  				{  					dst[(dst_p)++] = 255;  					dst[(dst_p)++] = 255;  				}  				if (len > 254)  				{  					len -= 255;  					dst[(dst_p)++] = 255;  				}  				dst[(dst_p)++] = (byte)len;  			}  			else  			{  				dst[dst_token] += (byte)len;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressHCCtx_32,The following statement contains a magic number: while (src_p < src_mflimit)  			{  				var ml = LZ4HC_InsertAndFindBestMatch_32(ctx' src_p' ref src_ref);  				if (ml == 0)  				{  					src_p++;  					continue;  				}    				// saved' in case we would skip too much  				var start0 = src_p;  				var ref0 = src_ref;  				var ml0 = ml;    			_Search2:  				var ml2 = src_p + ml < src_mflimit  					? LZ4HC_InsertAndGetWiderMatch_32(ctx' src_p + ml - 2' src_p + 1' ml' ref ref2' ref start2)  					: ml;    				if (ml2 == ml) // No better match  				{  					if (LZ4_encodeSequence_32(ctx' ref src_p' ref dst_p' ref src_anchor' ml' src_ref' dst_end) != 0) return 0;  					continue;  				}    				if (start0 < src_p)  				{  					if (start2 < src_p + ml0) // empirical  					{  						src_p = start0;  						src_ref = ref0;  						ml = ml0;  					}  				}    				// Here' start0==ip  				if ((start2 - src_p) < 3) // First Match too small : removed  				{  					ml = ml2;  					src_p = start2;  					src_ref = ref2;  					goto _Search2;  				}    			_Search3:  				// Currently we have :  				// ml2 > ml1' and  				// ip1+3 <= ip2 (usually < ip1+ml1)  				if ((start2 - src_p) < OPTIMAL_ML)  				{  					var new_ml = ml;  					if (new_ml > OPTIMAL_ML) new_ml = OPTIMAL_ML;  					if (src_p + new_ml > start2 + ml2 - MINMATCH) new_ml = (start2 - src_p) + ml2 - MINMATCH;  					var correction = new_ml - (start2 - src_p);  					if (correction > 0)  					{  						start2 += correction;  						ref2 += correction;  						ml2 -= correction;  					}  				}  				// Now' we have start2 = ip+new_ml' with new_ml=min(ml' OPTIMAL_ML=18)    				var ml3 = start2 + ml2 < src_mflimit  					? LZ4HC_InsertAndGetWiderMatch_32(ctx' start2 + ml2 - 3' start2' ml2' ref ref3' ref start3)  					: ml2;    				if (ml3 == ml2) // No better match : 2 sequences to encode  				{  					// ip & ref are known; Now for ml  					if (start2 < src_p + ml) ml = (start2 - src_p);  					// Now' encode 2 sequences  					if (LZ4_encodeSequence_32(ctx' ref src_p' ref dst_p' ref src_anchor' ml' src_ref' dst_end) != 0) return 0;  					src_p = start2;  					if (LZ4_encodeSequence_32(ctx' ref src_p' ref dst_p' ref src_anchor' ml2' ref2' dst_end) != 0) return 0;  					continue;  				}    				if (start3 < src_p + ml + 3) // Not enough space for match 2 : remove it  				{  					if (start3 >= (src_p + ml)) // can write Seq1 immediately ==> Seq2 is removed' so Seq3 becomes Seq1  					{  						if (start2 < src_p + ml)  						{  							var correction = (src_p + ml - start2);  							start2 += correction;  							ref2 += correction;  							ml2 -= correction;  							if (ml2 < MINMATCH)  							{  								start2 = start3;  								ref2 = ref3;  								ml2 = ml3;  							}  						}    						if (LZ4_encodeSequence_32(ctx' ref src_p' ref dst_p' ref src_anchor' ml' src_ref' dst_end) != 0) return 0;  						src_p = start3;  						src_ref = ref3;  						ml = ml3;    						start0 = start2;  						ref0 = ref2;  						ml0 = ml2;  						goto _Search2;  					}    					start2 = start3;  					ref2 = ref3;  					ml2 = ml3;  					goto _Search3;  				}    				// OK' now we have 3 ascending matches; let's write at least the first one  				// ip & ref are known; Now for ml  				if (start2 < src_p + ml)  				{  					if ((start2 - src_p) < ML_MASK)  					{  						if (ml > OPTIMAL_ML) ml = OPTIMAL_ML;  						if (src_p + ml > start2 + ml2 - MINMATCH) ml = (start2 - src_p) + ml2 - MINMATCH;  						var correction = ml - (start2 - src_p);  						if (correction > 0)  						{  							start2 += correction;  							ref2 += correction;  							ml2 -= correction;  						}  					}  					else  					{  						ml = (start2 - src_p);  					}  				}  				if (LZ4_encodeSequence_32(ctx' ref src_p' ref dst_p' ref src_anchor' ml' src_ref' dst_end) != 0) return 0;    				src_p = start2;  				src_ref = ref2;  				ml = ml2;    				start2 = start3;  				ref2 = ref3;  				ml2 = ml3;    				goto _Search3;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressHCCtx_32,The following statement contains a magic number: while (src_p < src_mflimit)  			{  				var ml = LZ4HC_InsertAndFindBestMatch_32(ctx' src_p' ref src_ref);  				if (ml == 0)  				{  					src_p++;  					continue;  				}    				// saved' in case we would skip too much  				var start0 = src_p;  				var ref0 = src_ref;  				var ml0 = ml;    			_Search2:  				var ml2 = src_p + ml < src_mflimit  					? LZ4HC_InsertAndGetWiderMatch_32(ctx' src_p + ml - 2' src_p + 1' ml' ref ref2' ref start2)  					: ml;    				if (ml2 == ml) // No better match  				{  					if (LZ4_encodeSequence_32(ctx' ref src_p' ref dst_p' ref src_anchor' ml' src_ref' dst_end) != 0) return 0;  					continue;  				}    				if (start0 < src_p)  				{  					if (start2 < src_p + ml0) // empirical  					{  						src_p = start0;  						src_ref = ref0;  						ml = ml0;  					}  				}    				// Here' start0==ip  				if ((start2 - src_p) < 3) // First Match too small : removed  				{  					ml = ml2;  					src_p = start2;  					src_ref = ref2;  					goto _Search2;  				}    			_Search3:  				// Currently we have :  				// ml2 > ml1' and  				// ip1+3 <= ip2 (usually < ip1+ml1)  				if ((start2 - src_p) < OPTIMAL_ML)  				{  					var new_ml = ml;  					if (new_ml > OPTIMAL_ML) new_ml = OPTIMAL_ML;  					if (src_p + new_ml > start2 + ml2 - MINMATCH) new_ml = (start2 - src_p) + ml2 - MINMATCH;  					var correction = new_ml - (start2 - src_p);  					if (correction > 0)  					{  						start2 += correction;  						ref2 += correction;  						ml2 -= correction;  					}  				}  				// Now' we have start2 = ip+new_ml' with new_ml=min(ml' OPTIMAL_ML=18)    				var ml3 = start2 + ml2 < src_mflimit  					? LZ4HC_InsertAndGetWiderMatch_32(ctx' start2 + ml2 - 3' start2' ml2' ref ref3' ref start3)  					: ml2;    				if (ml3 == ml2) // No better match : 2 sequences to encode  				{  					// ip & ref are known; Now for ml  					if (start2 < src_p + ml) ml = (start2 - src_p);  					// Now' encode 2 sequences  					if (LZ4_encodeSequence_32(ctx' ref src_p' ref dst_p' ref src_anchor' ml' src_ref' dst_end) != 0) return 0;  					src_p = start2;  					if (LZ4_encodeSequence_32(ctx' ref src_p' ref dst_p' ref src_anchor' ml2' ref2' dst_end) != 0) return 0;  					continue;  				}    				if (start3 < src_p + ml + 3) // Not enough space for match 2 : remove it  				{  					if (start3 >= (src_p + ml)) // can write Seq1 immediately ==> Seq2 is removed' so Seq3 becomes Seq1  					{  						if (start2 < src_p + ml)  						{  							var correction = (src_p + ml - start2);  							start2 += correction;  							ref2 += correction;  							ml2 -= correction;  							if (ml2 < MINMATCH)  							{  								start2 = start3;  								ref2 = ref3;  								ml2 = ml3;  							}  						}    						if (LZ4_encodeSequence_32(ctx' ref src_p' ref dst_p' ref src_anchor' ml' src_ref' dst_end) != 0) return 0;  						src_p = start3;  						src_ref = ref3;  						ml = ml3;    						start0 = start2;  						ref0 = ref2;  						ml0 = ml2;  						goto _Search2;  					}    					start2 = start3;  					ref2 = ref3;  					ml2 = ml3;  					goto _Search3;  				}    				// OK' now we have 3 ascending matches; let's write at least the first one  				// ip & ref are known; Now for ml  				if (start2 < src_p + ml)  				{  					if ((start2 - src_p) < ML_MASK)  					{  						if (ml > OPTIMAL_ML) ml = OPTIMAL_ML;  						if (src_p + ml > start2 + ml2 - MINMATCH) ml = (start2 - src_p) + ml2 - MINMATCH;  						var correction = ml - (start2 - src_p);  						if (correction > 0)  						{  							start2 += correction;  							ref2 += correction;  							ml2 -= correction;  						}  					}  					else  					{  						ml = (start2 - src_p);  					}  				}  				if (LZ4_encodeSequence_32(ctx' ref src_p' ref dst_p' ref src_anchor' ml' src_ref' dst_end) != 0) return 0;    				src_p = start2;  				src_ref = ref2;  				ml = ml2;    				start2 = start3;  				ref2 = ref3;  				ml2 = ml3;    				goto _Search3;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressHCCtx_32,The following statement contains a magic number: while (src_p < src_mflimit)  			{  				var ml = LZ4HC_InsertAndFindBestMatch_32(ctx' src_p' ref src_ref);  				if (ml == 0)  				{  					src_p++;  					continue;  				}    				// saved' in case we would skip too much  				var start0 = src_p;  				var ref0 = src_ref;  				var ml0 = ml;    			_Search2:  				var ml2 = src_p + ml < src_mflimit  					? LZ4HC_InsertAndGetWiderMatch_32(ctx' src_p + ml - 2' src_p + 1' ml' ref ref2' ref start2)  					: ml;    				if (ml2 == ml) // No better match  				{  					if (LZ4_encodeSequence_32(ctx' ref src_p' ref dst_p' ref src_anchor' ml' src_ref' dst_end) != 0) return 0;  					continue;  				}    				if (start0 < src_p)  				{  					if (start2 < src_p + ml0) // empirical  					{  						src_p = start0;  						src_ref = ref0;  						ml = ml0;  					}  				}    				// Here' start0==ip  				if ((start2 - src_p) < 3) // First Match too small : removed  				{  					ml = ml2;  					src_p = start2;  					src_ref = ref2;  					goto _Search2;  				}    			_Search3:  				// Currently we have :  				// ml2 > ml1' and  				// ip1+3 <= ip2 (usually < ip1+ml1)  				if ((start2 - src_p) < OPTIMAL_ML)  				{  					var new_ml = ml;  					if (new_ml > OPTIMAL_ML) new_ml = OPTIMAL_ML;  					if (src_p + new_ml > start2 + ml2 - MINMATCH) new_ml = (start2 - src_p) + ml2 - MINMATCH;  					var correction = new_ml - (start2 - src_p);  					if (correction > 0)  					{  						start2 += correction;  						ref2 += correction;  						ml2 -= correction;  					}  				}  				// Now' we have start2 = ip+new_ml' with new_ml=min(ml' OPTIMAL_ML=18)    				var ml3 = start2 + ml2 < src_mflimit  					? LZ4HC_InsertAndGetWiderMatch_32(ctx' start2 + ml2 - 3' start2' ml2' ref ref3' ref start3)  					: ml2;    				if (ml3 == ml2) // No better match : 2 sequences to encode  				{  					// ip & ref are known; Now for ml  					if (start2 < src_p + ml) ml = (start2 - src_p);  					// Now' encode 2 sequences  					if (LZ4_encodeSequence_32(ctx' ref src_p' ref dst_p' ref src_anchor' ml' src_ref' dst_end) != 0) return 0;  					src_p = start2;  					if (LZ4_encodeSequence_32(ctx' ref src_p' ref dst_p' ref src_anchor' ml2' ref2' dst_end) != 0) return 0;  					continue;  				}    				if (start3 < src_p + ml + 3) // Not enough space for match 2 : remove it  				{  					if (start3 >= (src_p + ml)) // can write Seq1 immediately ==> Seq2 is removed' so Seq3 becomes Seq1  					{  						if (start2 < src_p + ml)  						{  							var correction = (src_p + ml - start2);  							start2 += correction;  							ref2 += correction;  							ml2 -= correction;  							if (ml2 < MINMATCH)  							{  								start2 = start3;  								ref2 = ref3;  								ml2 = ml3;  							}  						}    						if (LZ4_encodeSequence_32(ctx' ref src_p' ref dst_p' ref src_anchor' ml' src_ref' dst_end) != 0) return 0;  						src_p = start3;  						src_ref = ref3;  						ml = ml3;    						start0 = start2;  						ref0 = ref2;  						ml0 = ml2;  						goto _Search2;  					}    					start2 = start3;  					ref2 = ref3;  					ml2 = ml3;  					goto _Search3;  				}    				// OK' now we have 3 ascending matches; let's write at least the first one  				// ip & ref are known; Now for ml  				if (start2 < src_p + ml)  				{  					if ((start2 - src_p) < ML_MASK)  					{  						if (ml > OPTIMAL_ML) ml = OPTIMAL_ML;  						if (src_p + ml > start2 + ml2 - MINMATCH) ml = (start2 - src_p) + ml2 - MINMATCH;  						var correction = ml - (start2 - src_p);  						if (correction > 0)  						{  							start2 += correction;  							ref2 += correction;  							ml2 -= correction;  						}  					}  					else  					{  						ml = (start2 - src_p);  					}  				}  				if (LZ4_encodeSequence_32(ctx' ref src_p' ref dst_p' ref src_anchor' ml' src_ref' dst_end) != 0) return 0;    				src_p = start2;  				src_ref = ref2;  				ml = ml2;    				start2 = start3;  				ref2 = ref3;  				ml2 = ml3;    				goto _Search3;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressHCCtx_32,The following statement contains a magic number: while (src_p < src_mflimit)  			{  				var ml = LZ4HC_InsertAndFindBestMatch_32(ctx' src_p' ref src_ref);  				if (ml == 0)  				{  					src_p++;  					continue;  				}    				// saved' in case we would skip too much  				var start0 = src_p;  				var ref0 = src_ref;  				var ml0 = ml;    			_Search2:  				var ml2 = src_p + ml < src_mflimit  					? LZ4HC_InsertAndGetWiderMatch_32(ctx' src_p + ml - 2' src_p + 1' ml' ref ref2' ref start2)  					: ml;    				if (ml2 == ml) // No better match  				{  					if (LZ4_encodeSequence_32(ctx' ref src_p' ref dst_p' ref src_anchor' ml' src_ref' dst_end) != 0) return 0;  					continue;  				}    				if (start0 < src_p)  				{  					if (start2 < src_p + ml0) // empirical  					{  						src_p = start0;  						src_ref = ref0;  						ml = ml0;  					}  				}    				// Here' start0==ip  				if ((start2 - src_p) < 3) // First Match too small : removed  				{  					ml = ml2;  					src_p = start2;  					src_ref = ref2;  					goto _Search2;  				}    			_Search3:  				// Currently we have :  				// ml2 > ml1' and  				// ip1+3 <= ip2 (usually < ip1+ml1)  				if ((start2 - src_p) < OPTIMAL_ML)  				{  					var new_ml = ml;  					if (new_ml > OPTIMAL_ML) new_ml = OPTIMAL_ML;  					if (src_p + new_ml > start2 + ml2 - MINMATCH) new_ml = (start2 - src_p) + ml2 - MINMATCH;  					var correction = new_ml - (start2 - src_p);  					if (correction > 0)  					{  						start2 += correction;  						ref2 += correction;  						ml2 -= correction;  					}  				}  				// Now' we have start2 = ip+new_ml' with new_ml=min(ml' OPTIMAL_ML=18)    				var ml3 = start2 + ml2 < src_mflimit  					? LZ4HC_InsertAndGetWiderMatch_32(ctx' start2 + ml2 - 3' start2' ml2' ref ref3' ref start3)  					: ml2;    				if (ml3 == ml2) // No better match : 2 sequences to encode  				{  					// ip & ref are known; Now for ml  					if (start2 < src_p + ml) ml = (start2 - src_p);  					// Now' encode 2 sequences  					if (LZ4_encodeSequence_32(ctx' ref src_p' ref dst_p' ref src_anchor' ml' src_ref' dst_end) != 0) return 0;  					src_p = start2;  					if (LZ4_encodeSequence_32(ctx' ref src_p' ref dst_p' ref src_anchor' ml2' ref2' dst_end) != 0) return 0;  					continue;  				}    				if (start3 < src_p + ml + 3) // Not enough space for match 2 : remove it  				{  					if (start3 >= (src_p + ml)) // can write Seq1 immediately ==> Seq2 is removed' so Seq3 becomes Seq1  					{  						if (start2 < src_p + ml)  						{  							var correction = (src_p + ml - start2);  							start2 += correction;  							ref2 += correction;  							ml2 -= correction;  							if (ml2 < MINMATCH)  							{  								start2 = start3;  								ref2 = ref3;  								ml2 = ml3;  							}  						}    						if (LZ4_encodeSequence_32(ctx' ref src_p' ref dst_p' ref src_anchor' ml' src_ref' dst_end) != 0) return 0;  						src_p = start3;  						src_ref = ref3;  						ml = ml3;    						start0 = start2;  						ref0 = ref2;  						ml0 = ml2;  						goto _Search2;  					}    					start2 = start3;  					ref2 = ref3;  					ml2 = ml3;  					goto _Search3;  				}    				// OK' now we have 3 ascending matches; let's write at least the first one  				// ip & ref are known; Now for ml  				if (start2 < src_p + ml)  				{  					if ((start2 - src_p) < ML_MASK)  					{  						if (ml > OPTIMAL_ML) ml = OPTIMAL_ML;  						if (src_p + ml > start2 + ml2 - MINMATCH) ml = (start2 - src_p) + ml2 - MINMATCH;  						var correction = ml - (start2 - src_p);  						if (correction > 0)  						{  							start2 += correction;  							ref2 += correction;  							ml2 -= correction;  						}  					}  					else  					{  						ml = (start2 - src_p);  					}  				}  				if (LZ4_encodeSequence_32(ctx' ref src_p' ref dst_p' ref src_anchor' ml' src_ref' dst_end) != 0) return 0;    				src_p = start2;  				src_ref = ref2;  				ml = ml2;    				start2 = start3;  				ref2 = ref3;  				ml2 = ml3;    				goto _Search3;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressHCCtx_32,The following statement contains a magic number: {  				var lastRun = (src_end - src_anchor);  				if ((dst_p - dst_0) + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > (uint)dst_len) return 0; // Check output limit  				if (lastRun >= RUN_MASK)  				{  					dst[dst_p++] = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) dst[dst_p++] = 255;  					dst[dst_p++] = (byte)lastRun;  				}  				else  				{  					dst[dst_p++] = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src' src_anchor' dst' dst_p' src_end - src_anchor);  				dst_p += src_end - src_anchor;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressHCCtx_32,The following statement contains a magic number: {  				var lastRun = (src_end - src_anchor);  				if ((dst_p - dst_0) + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > (uint)dst_len) return 0; // Check output limit  				if (lastRun >= RUN_MASK)  				{  					dst[dst_p++] = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) dst[dst_p++] = 255;  					dst[dst_p++] = (byte)lastRun;  				}  				else  				{  					dst[dst_p++] = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src' src_anchor' dst' dst_p' src_end - src_anchor);  				dst_p += src_end - src_anchor;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressHCCtx_32,The following statement contains a magic number: {  				var lastRun = (src_end - src_anchor);  				if ((dst_p - dst_0) + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > (uint)dst_len) return 0; // Check output limit  				if (lastRun >= RUN_MASK)  				{  					dst[dst_p++] = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) dst[dst_p++] = 255;  					dst[dst_p++] = (byte)lastRun;  				}  				else  				{  					dst[dst_p++] = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src' src_anchor' dst' dst_p' src_end - src_anchor);  				dst_p += src_end - src_anchor;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressHCCtx_32,The following statement contains a magic number: {  				var lastRun = (src_end - src_anchor);  				if ((dst_p - dst_0) + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > (uint)dst_len) return 0; // Check output limit  				if (lastRun >= RUN_MASK)  				{  					dst[dst_p++] = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) dst[dst_p++] = 255;  					dst[dst_p++] = (byte)lastRun;  				}  				else  				{  					dst[dst_p++] = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src' src_anchor' dst' dst_p' src_end - src_anchor);  				dst_p += src_end - src_anchor;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressHCCtx_32,The following statement contains a magic number: {  				var lastRun = (src_end - src_anchor);  				if ((dst_p - dst_0) + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > (uint)dst_len) return 0; // Check output limit  				if (lastRun >= RUN_MASK)  				{  					dst[dst_p++] = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) dst[dst_p++] = 255;  					dst[dst_p++] = (byte)lastRun;  				}  				else  				{  					dst[dst_p++] = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src' src_anchor' dst' dst_p' src_end - src_anchor);  				dst_p += src_end - src_anchor;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe64,The following statement contains a magic number: var src_LASTLITERALS_3 = src_LASTLITERALS - 3;
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe64,The following statement contains a magic number: var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (src_p - src_base);  				} while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src' src_ref' src_p)));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					var len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0)  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch already verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:  				// Encode MatchLength  				length = (src_p - src_anchor);    				if (dst_p + (length >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (length >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					length -= ML_MASK;  					for (; length > 509; length -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (length > 254)  					{  						length -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)length;  				}  				else  				{  					dst[dst_token] += (byte)length;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH_ADJUST)] = (src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (src_p - src_base);    				if ((src_ref > src_p - (MAX_DISTANCE + 1)) && (Equal4(src' src_ref' src_p)))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe64,The following statement contains a magic number: _last_literals:  			// Encode Last Literals  			{  				var lastRun = (src_end - src_anchor);    				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;    				if (lastRun >= RUN_MASK)  				{  					dst[dst_p++] = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) dst[dst_p++] = 255;  					dst[dst_p++] = (byte)lastRun;  				}  				else dst[dst_p++] = (byte)(lastRun << ML_BITS);  				BlockCopy(src' src_anchor' dst' dst_p' src_end - src_anchor);  				dst_p += src_end - src_anchor;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe64,The following statement contains a magic number: _last_literals:  			// Encode Last Literals  			{  				var lastRun = (src_end - src_anchor);    				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;    				if (lastRun >= RUN_MASK)  				{  					dst[dst_p++] = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) dst[dst_p++] = 255;  					dst[dst_p++] = (byte)lastRun;  				}  				else dst[dst_p++] = (byte)(lastRun << ML_BITS);  				BlockCopy(src' src_anchor' dst' dst_p' src_end - src_anchor);  				dst_p += src_end - src_anchor;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe64,The following statement contains a magic number: _last_literals:  			// Encode Last Literals  			{  				var lastRun = (src_end - src_anchor);    				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;    				if (lastRun >= RUN_MASK)  				{  					dst[dst_p++] = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) dst[dst_p++] = 255;  					dst[dst_p++] = (byte)lastRun;  				}  				else dst[dst_p++] = (byte)(lastRun << ML_BITS);  				BlockCopy(src' src_anchor' dst' dst_p' src_end - src_anchor);  				dst_p += src_end - src_anchor;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe64,The following statement contains a magic number: _last_literals:  			// Encode Last Literals  			{  				var lastRun = (src_end - src_anchor);    				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;    				if (lastRun >= RUN_MASK)  				{  					dst[dst_p++] = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) dst[dst_p++] = 255;  					dst[dst_p++] = (byte)lastRun;  				}  				else dst[dst_p++] = (byte)(lastRun << ML_BITS);  				BlockCopy(src' src_anchor' dst' dst_p' src_end - src_anchor);  				dst_p += src_end - src_anchor;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressCtx_safe64,The following statement contains a magic number: _last_literals:  			// Encode Last Literals  			{  				var lastRun = (src_end - src_anchor);    				if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end) return 0;    				if (lastRun >= RUN_MASK)  				{  					dst[dst_p++] = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) dst[dst_p++] = 255;  					dst[dst_p++] = (byte)lastRun;  				}  				else dst[dst_p++] = (byte)(lastRun << ML_BITS);  				BlockCopy(src' src_anchor' dst' dst_p' src_end - src_anchor);  				dst_p += src_end - src_anchor;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe64,The following statement contains a magic number: var src_LASTLITERALS_3 = src_LASTLITERALS - 3;
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe64,The following statement contains a magic number: var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0) /*?*/  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0) /*?*/  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0) /*?*/  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0) /*?*/  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0) /*?*/  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0) /*?*/  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0) /*?*/  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0) /*?*/  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0) /*?*/  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0) /*?*/  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0) /*?*/  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0) /*?*/  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0) /*?*/  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0) /*?*/  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0) /*?*/  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0) /*?*/  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0) /*?*/  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0) /*?*/  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0) /*?*/  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0) /*?*/  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0) /*?*/  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe64,The following statement contains a magic number: while (true)  			{  				var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  				var src_p_fwd = src_p;  				int src_ref;  				int dst_token;    				// Find a match  				do  				{  					h = h_fwd;  					var step = findMatchAttempts++ >> SKIPSTRENGTH;  					src_p = src_p_fwd;  					src_p_fwd = src_p + step;    					if (src_p_fwd > src_mflimit) goto _last_literals;    					h_fwd = (((Peek4(src' src_p_fwd)) * 2654435761u) >> HASH64K_ADJUST);  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  				} while (!Equal4(src' src_ref' src_p));    				// Catch up  				while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))  				{  					src_p--;  					src_ref--;  				}    				// Encode Literal length  				length = (src_p - src_anchor);  				dst_token = dst_p++;    				if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3) return 0; // Check output limit    				if (length >= RUN_MASK)  				{  					len = length - RUN_MASK;  					dst[dst_token] = (RUN_MASK << ML_BITS);  					if (len > 254)  					{  						do  						{  							dst[dst_p++] = 255;  							len -= 255;  						} while (len > 254);  						dst[dst_p++] = (byte)len;  						BlockCopy(src' src_anchor' dst' dst_p' length);  						dst_p += length;  						goto _next_match;  					}  					else  						dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] = (byte)(length << ML_BITS);  				}    				// Copy Literals  				if (length > 0) /*?*/  				{  					_i = dst_p + length;  					WildCopy(src' src_anchor' dst' dst_p' _i);  					dst_p = _i;  				}    			_next_match:  				// Encode Offset  				Poke2(dst' dst_p' (ushort)(src_p - src_ref));  				dst_p += 2;    				// Start Counting  				src_p += MINMATCH;  				src_ref += MINMATCH; // MinMatch verified  				src_anchor = src_p;    				while (src_p < src_LASTLITERALS_STEPSIZE_1)  				{  					var diff = (long)Xor8(src' src_ref' src_p);  					if (diff == 0)  					{  						src_p += STEPSIZE_64;  						src_ref += STEPSIZE_64;  						continue;  					}  					src_p += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  					goto _endCount;  				}    				if ((src_p < src_LASTLITERALS_3) && (Equal4(src' src_ref' src_p)))  				{  					src_p += 4;  					src_ref += 4;  				}  				if ((src_p < src_LASTLITERALS_1) && (Equal2(src' src_ref' src_p)))  				{  					src_p += 2;  					src_ref += 2;  				}  				if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p])) src_p++;    			_endCount:    				// Encode MatchLength  				len = (src_p - src_anchor);    				if (dst_p + (len >> 8) > dst_LASTLITERALS_1) return 0; // Check output limit    				if (len >= ML_MASK)  				{  					dst[dst_token] += ML_MASK;  					len -= ML_MASK;  					for (; len > 509; len -= 510)  					{  						dst[dst_p++] = 255;  						dst[dst_p++] = 255;  					}  					if (len > 254)  					{  						len -= 255;  						dst[dst_p++] = 255;  					}  					dst[dst_p++] = (byte)len;  				}  				else  				{  					dst[dst_token] += (byte)len;  				}    				// Test end of chunk  				if (src_p > src_mflimit)  				{  					src_anchor = src_p;  					break;  				}    				// Fill table  				hash_table[(((Peek4(src' src_p - 2)) * 2654435761u) >> HASH64K_ADJUST)] = (ushort)(src_p - 2 - src_base);    				// Test next position    				h = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  				src_ref = src_base + hash_table[h];  				hash_table[h] = (ushort)(src_p - src_base);    				if (Equal4(src' src_ref' src_p))  				{  					dst_token = dst_p++;  					dst[dst_token] = 0;  					goto _next_match;  				}    				// Prepare next loop  				src_anchor = src_p++;  				h_fwd = (((Peek4(src' src_p)) * 2654435761u) >> HASH64K_ADJUST);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe64,The following statement contains a magic number: _last_literals:  			// Encode Last Literals  			{  				var lastRun = (src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					dst[dst_p++] = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) dst[dst_p++] = 255;  					dst[dst_p++] = (byte)lastRun;  				}  				else dst[dst_p++] = (byte)(lastRun << ML_BITS);  				BlockCopy(src' src_anchor' dst' dst_p' src_end - src_anchor);  				dst_p += src_end - src_anchor;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe64,The following statement contains a magic number: _last_literals:  			// Encode Last Literals  			{  				var lastRun = (src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					dst[dst_p++] = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) dst[dst_p++] = 255;  					dst[dst_p++] = (byte)lastRun;  				}  				else dst[dst_p++] = (byte)(lastRun << ML_BITS);  				BlockCopy(src' src_anchor' dst' dst_p' src_end - src_anchor);  				dst_p += src_end - src_anchor;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe64,The following statement contains a magic number: _last_literals:  			// Encode Last Literals  			{  				var lastRun = (src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					dst[dst_p++] = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) dst[dst_p++] = 255;  					dst[dst_p++] = (byte)lastRun;  				}  				else dst[dst_p++] = (byte)(lastRun << ML_BITS);  				BlockCopy(src' src_anchor' dst' dst_p' src_end - src_anchor);  				dst_p += src_end - src_anchor;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe64,The following statement contains a magic number: _last_literals:  			// Encode Last Literals  			{  				var lastRun = (src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					dst[dst_p++] = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) dst[dst_p++] = 255;  					dst[dst_p++] = (byte)lastRun;  				}  				else dst[dst_p++] = (byte)(lastRun << ML_BITS);  				BlockCopy(src' src_anchor' dst' dst_p' src_end - src_anchor);  				dst_p += src_end - src_anchor;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compress64kCtx_safe64,The following statement contains a magic number: _last_literals:  			// Encode Last Literals  			{  				var lastRun = (src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					dst[dst_p++] = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) dst[dst_p++] = 255;  					dst[dst_p++] = (byte)lastRun;  				}  				else dst[dst_p++] = (byte)(lastRun << ML_BITS);  				BlockCopy(src' src_anchor' dst' dst_p' src_end - src_anchor);  				dst_p += src_end - src_anchor;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe64,The following statement contains a magic number: var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe64,The following statement contains a magic number: while (true)  			{  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (byte)(token >> ML_BITS)) == RUN_MASK)  				{  					int len;  					for (; (len = src[src_p++]) == 255; length += 255)  					{  						/* do nothing */  					}  					length += len;  				}    				// copy literals  				dst_cpy = dst_p + length;    				if (dst_cpy > dst_COPYLENGTH)  				{  					if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  					BlockCopy(src' src_p' dst' dst_p' length);  					src_p += length;  					break; // EOF  				}  				if (dst_p < dst_cpy) /*?*/  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside destination buffer    				// get matchlength  				if ((length = (byte)(token & ML_MASK)) == ML_MASK)  				{  					for (; src[src_p] == 255; length += 255) src_p++;  					length += src[src_p++];  				}    				// copy repeated sequence  				if ((dst_p - dst_ref) < STEPSIZE_64)  				{  					var dec64 = dec64table[dst_p - dst_ref];    					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_64 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy8(dst' dst_ref' dst_p);  					dst_p += 8;  					dst_ref += 8;  				}  				dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe64,The following statement contains a magic number: while (true)  			{  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (byte)(token >> ML_BITS)) == RUN_MASK)  				{  					int len;  					for (; (len = src[src_p++]) == 255; length += 255)  					{  						/* do nothing */  					}  					length += len;  				}    				// copy literals  				dst_cpy = dst_p + length;    				if (dst_cpy > dst_COPYLENGTH)  				{  					if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  					BlockCopy(src' src_p' dst' dst_p' length);  					src_p += length;  					break; // EOF  				}  				if (dst_p < dst_cpy) /*?*/  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside destination buffer    				// get matchlength  				if ((length = (byte)(token & ML_MASK)) == ML_MASK)  				{  					for (; src[src_p] == 255; length += 255) src_p++;  					length += src[src_p++];  				}    				// copy repeated sequence  				if ((dst_p - dst_ref) < STEPSIZE_64)  				{  					var dec64 = dec64table[dst_p - dst_ref];    					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_64 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy8(dst' dst_ref' dst_p);  					dst_p += 8;  					dst_ref += 8;  				}  				dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe64,The following statement contains a magic number: while (true)  			{  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (byte)(token >> ML_BITS)) == RUN_MASK)  				{  					int len;  					for (; (len = src[src_p++]) == 255; length += 255)  					{  						/* do nothing */  					}  					length += len;  				}    				// copy literals  				dst_cpy = dst_p + length;    				if (dst_cpy > dst_COPYLENGTH)  				{  					if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  					BlockCopy(src' src_p' dst' dst_p' length);  					src_p += length;  					break; // EOF  				}  				if (dst_p < dst_cpy) /*?*/  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside destination buffer    				// get matchlength  				if ((length = (byte)(token & ML_MASK)) == ML_MASK)  				{  					for (; src[src_p] == 255; length += 255) src_p++;  					length += src[src_p++];  				}    				// copy repeated sequence  				if ((dst_p - dst_ref) < STEPSIZE_64)  				{  					var dec64 = dec64table[dst_p - dst_ref];    					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_64 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy8(dst' dst_ref' dst_p);  					dst_p += 8;  					dst_ref += 8;  				}  				dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe64,The following statement contains a magic number: while (true)  			{  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (byte)(token >> ML_BITS)) == RUN_MASK)  				{  					int len;  					for (; (len = src[src_p++]) == 255; length += 255)  					{  						/* do nothing */  					}  					length += len;  				}    				// copy literals  				dst_cpy = dst_p + length;    				if (dst_cpy > dst_COPYLENGTH)  				{  					if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  					BlockCopy(src' src_p' dst' dst_p' length);  					src_p += length;  					break; // EOF  				}  				if (dst_p < dst_cpy) /*?*/  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside destination buffer    				// get matchlength  				if ((length = (byte)(token & ML_MASK)) == ML_MASK)  				{  					for (; src[src_p] == 255; length += 255) src_p++;  					length += src[src_p++];  				}    				// copy repeated sequence  				if ((dst_p - dst_ref) < STEPSIZE_64)  				{  					var dec64 = dec64table[dst_p - dst_ref];    					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_64 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy8(dst' dst_ref' dst_p);  					dst_p += 8;  					dst_ref += 8;  				}  				dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe64,The following statement contains a magic number: while (true)  			{  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (byte)(token >> ML_BITS)) == RUN_MASK)  				{  					int len;  					for (; (len = src[src_p++]) == 255; length += 255)  					{  						/* do nothing */  					}  					length += len;  				}    				// copy literals  				dst_cpy = dst_p + length;    				if (dst_cpy > dst_COPYLENGTH)  				{  					if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  					BlockCopy(src' src_p' dst' dst_p' length);  					src_p += length;  					break; // EOF  				}  				if (dst_p < dst_cpy) /*?*/  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside destination buffer    				// get matchlength  				if ((length = (byte)(token & ML_MASK)) == ML_MASK)  				{  					for (; src[src_p] == 255; length += 255) src_p++;  					length += src[src_p++];  				}    				// copy repeated sequence  				if ((dst_p - dst_ref) < STEPSIZE_64)  				{  					var dec64 = dec64table[dst_p - dst_ref];    					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_64 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy8(dst' dst_ref' dst_p);  					dst_p += 8;  					dst_ref += 8;  				}  				dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe64,The following statement contains a magic number: while (true)  			{  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (byte)(token >> ML_BITS)) == RUN_MASK)  				{  					int len;  					for (; (len = src[src_p++]) == 255; length += 255)  					{  						/* do nothing */  					}  					length += len;  				}    				// copy literals  				dst_cpy = dst_p + length;    				if (dst_cpy > dst_COPYLENGTH)  				{  					if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  					BlockCopy(src' src_p' dst' dst_p' length);  					src_p += length;  					break; // EOF  				}  				if (dst_p < dst_cpy) /*?*/  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside destination buffer    				// get matchlength  				if ((length = (byte)(token & ML_MASK)) == ML_MASK)  				{  					for (; src[src_p] == 255; length += 255) src_p++;  					length += src[src_p++];  				}    				// copy repeated sequence  				if ((dst_p - dst_ref) < STEPSIZE_64)  				{  					var dec64 = dec64table[dst_p - dst_ref];    					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_64 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy8(dst' dst_ref' dst_p);  					dst_p += 8;  					dst_ref += 8;  				}  				dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe64,The following statement contains a magic number: while (true)  			{  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (byte)(token >> ML_BITS)) == RUN_MASK)  				{  					int len;  					for (; (len = src[src_p++]) == 255; length += 255)  					{  						/* do nothing */  					}  					length += len;  				}    				// copy literals  				dst_cpy = dst_p + length;    				if (dst_cpy > dst_COPYLENGTH)  				{  					if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  					BlockCopy(src' src_p' dst' dst_p' length);  					src_p += length;  					break; // EOF  				}  				if (dst_p < dst_cpy) /*?*/  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside destination buffer    				// get matchlength  				if ((length = (byte)(token & ML_MASK)) == ML_MASK)  				{  					for (; src[src_p] == 255; length += 255) src_p++;  					length += src[src_p++];  				}    				// copy repeated sequence  				if ((dst_p - dst_ref) < STEPSIZE_64)  				{  					var dec64 = dec64table[dst_p - dst_ref];    					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_64 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy8(dst' dst_ref' dst_p);  					dst_p += 8;  					dst_ref += 8;  				}  				dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe64,The following statement contains a magic number: while (true)  			{  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (byte)(token >> ML_BITS)) == RUN_MASK)  				{  					int len;  					for (; (len = src[src_p++]) == 255; length += 255)  					{  						/* do nothing */  					}  					length += len;  				}    				// copy literals  				dst_cpy = dst_p + length;    				if (dst_cpy > dst_COPYLENGTH)  				{  					if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  					BlockCopy(src' src_p' dst' dst_p' length);  					src_p += length;  					break; // EOF  				}  				if (dst_p < dst_cpy) /*?*/  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside destination buffer    				// get matchlength  				if ((length = (byte)(token & ML_MASK)) == ML_MASK)  				{  					for (; src[src_p] == 255; length += 255) src_p++;  					length += src[src_p++];  				}    				// copy repeated sequence  				if ((dst_p - dst_ref) < STEPSIZE_64)  				{  					var dec64 = dec64table[dst_p - dst_ref];    					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_64 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy8(dst' dst_ref' dst_p);  					dst_p += 8;  					dst_ref += 8;  				}  				dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe64,The following statement contains a magic number: while (true)  			{  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (byte)(token >> ML_BITS)) == RUN_MASK)  				{  					int len;  					for (; (len = src[src_p++]) == 255; length += 255)  					{  						/* do nothing */  					}  					length += len;  				}    				// copy literals  				dst_cpy = dst_p + length;    				if (dst_cpy > dst_COPYLENGTH)  				{  					if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  					BlockCopy(src' src_p' dst' dst_p' length);  					src_p += length;  					break; // EOF  				}  				if (dst_p < dst_cpy) /*?*/  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside destination buffer    				// get matchlength  				if ((length = (byte)(token & ML_MASK)) == ML_MASK)  				{  					for (; src[src_p] == 255; length += 255) src_p++;  					length += src[src_p++];  				}    				// copy repeated sequence  				if ((dst_p - dst_ref) < STEPSIZE_64)  				{  					var dec64 = dec64table[dst_p - dst_ref];    					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_64 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy8(dst' dst_ref' dst_p);  					dst_p += 8;  					dst_ref += 8;  				}  				dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe64,The following statement contains a magic number: while (true)  			{  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (byte)(token >> ML_BITS)) == RUN_MASK)  				{  					int len;  					for (; (len = src[src_p++]) == 255; length += 255)  					{  						/* do nothing */  					}  					length += len;  				}    				// copy literals  				dst_cpy = dst_p + length;    				if (dst_cpy > dst_COPYLENGTH)  				{  					if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  					BlockCopy(src' src_p' dst' dst_p' length);  					src_p += length;  					break; // EOF  				}  				if (dst_p < dst_cpy) /*?*/  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside destination buffer    				// get matchlength  				if ((length = (byte)(token & ML_MASK)) == ML_MASK)  				{  					for (; src[src_p] == 255; length += 255) src_p++;  					length += src[src_p++];  				}    				// copy repeated sequence  				if ((dst_p - dst_ref) < STEPSIZE_64)  				{  					var dec64 = dec64table[dst_p - dst_ref];    					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_64 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy8(dst' dst_ref' dst_p);  					dst_p += 8;  					dst_ref += 8;  				}  				dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe64,The following statement contains a magic number: while (true)  			{  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (byte)(token >> ML_BITS)) == RUN_MASK)  				{  					int len;  					for (; (len = src[src_p++]) == 255; length += 255)  					{  						/* do nothing */  					}  					length += len;  				}    				// copy literals  				dst_cpy = dst_p + length;    				if (dst_cpy > dst_COPYLENGTH)  				{  					if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  					BlockCopy(src' src_p' dst' dst_p' length);  					src_p += length;  					break; // EOF  				}  				if (dst_p < dst_cpy) /*?*/  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside destination buffer    				// get matchlength  				if ((length = (byte)(token & ML_MASK)) == ML_MASK)  				{  					for (; src[src_p] == 255; length += 255) src_p++;  					length += src[src_p++];  				}    				// copy repeated sequence  				if ((dst_p - dst_ref) < STEPSIZE_64)  				{  					var dec64 = dec64table[dst_p - dst_ref];    					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_64 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy8(dst' dst_ref' dst_p);  					dst_p += 8;  					dst_ref += 8;  				}  				dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe64,The following statement contains a magic number: while (true)  			{  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (byte)(token >> ML_BITS)) == RUN_MASK)  				{  					int len;  					for (; (len = src[src_p++]) == 255; length += 255)  					{  						/* do nothing */  					}  					length += len;  				}    				// copy literals  				dst_cpy = dst_p + length;    				if (dst_cpy > dst_COPYLENGTH)  				{  					if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  					BlockCopy(src' src_p' dst' dst_p' length);  					src_p += length;  					break; // EOF  				}  				if (dst_p < dst_cpy) /*?*/  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside destination buffer    				// get matchlength  				if ((length = (byte)(token & ML_MASK)) == ML_MASK)  				{  					for (; src[src_p] == 255; length += 255) src_p++;  					length += src[src_p++];  				}    				// copy repeated sequence  				if ((dst_p - dst_ref) < STEPSIZE_64)  				{  					var dec64 = dec64table[dst_p - dst_ref];    					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_64 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy8(dst' dst_ref' dst_p);  					dst_p += 8;  					dst_ref += 8;  				}  				dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe64,The following statement contains a magic number: while (true)  			{  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (byte)(token >> ML_BITS)) == RUN_MASK)  				{  					int len;  					for (; (len = src[src_p++]) == 255; length += 255)  					{  						/* do nothing */  					}  					length += len;  				}    				// copy literals  				dst_cpy = dst_p + length;    				if (dst_cpy > dst_COPYLENGTH)  				{  					if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  					BlockCopy(src' src_p' dst' dst_p' length);  					src_p += length;  					break; // EOF  				}  				if (dst_p < dst_cpy) /*?*/  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside destination buffer    				// get matchlength  				if ((length = (byte)(token & ML_MASK)) == ML_MASK)  				{  					for (; src[src_p] == 255; length += 255) src_p++;  					length += src[src_p++];  				}    				// copy repeated sequence  				if ((dst_p - dst_ref) < STEPSIZE_64)  				{  					var dec64 = dec64table[dst_p - dst_ref];    					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_64 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy8(dst' dst_ref' dst_p);  					dst_p += 8;  					dst_ref += 8;  				}  				dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe64,The following statement contains a magic number: while (true)  			{  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (byte)(token >> ML_BITS)) == RUN_MASK)  				{  					int len;  					for (; (len = src[src_p++]) == 255; length += 255)  					{  						/* do nothing */  					}  					length += len;  				}    				// copy literals  				dst_cpy = dst_p + length;    				if (dst_cpy > dst_COPYLENGTH)  				{  					if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  					BlockCopy(src' src_p' dst' dst_p' length);  					src_p += length;  					break; // EOF  				}  				if (dst_p < dst_cpy) /*?*/  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside destination buffer    				// get matchlength  				if ((length = (byte)(token & ML_MASK)) == ML_MASK)  				{  					for (; src[src_p] == 255; length += 255) src_p++;  					length += src[src_p++];  				}    				// copy repeated sequence  				if ((dst_p - dst_ref) < STEPSIZE_64)  				{  					var dec64 = dec64table[dst_p - dst_ref];    					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_64 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy8(dst' dst_ref' dst_p);  					dst_p += 8;  					dst_ref += 8;  				}  				dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_safe64,The following statement contains a magic number: while (true)  			{  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (byte)(token >> ML_BITS)) == RUN_MASK)  				{  					int len;  					for (; (len = src[src_p++]) == 255; length += 255)  					{  						/* do nothing */  					}  					length += len;  				}    				// copy literals  				dst_cpy = dst_p + length;    				if (dst_cpy > dst_COPYLENGTH)  				{  					if (dst_cpy != dst_end) goto _output_error; // Error : not enough place for another match (min 4) + 5 literals  					BlockCopy(src' src_p' dst' dst_p' length);  					src_p += length;  					break; // EOF  				}  				if (dst_p < dst_cpy) /*?*/  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside destination buffer    				// get matchlength  				if ((length = (byte)(token & ML_MASK)) == ML_MASK)  				{  					for (; src[src_p] == 255; length += 255) src_p++;  					length += src[src_p++];  				}    				// copy repeated sequence  				if ((dst_p - dst_ref) < STEPSIZE_64)  				{  					var dec64 = dec64table[dst_p - dst_ref];    					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_64 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy8(dst' dst_ref' dst_p);  					dst_p += 8;  					dst_ref += 8;  				}  				dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}    					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe64,The following statement contains a magic number: var src_LASTLITERALS_3 = (src_end - (2 + 1 + LASTLITERALS));
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe64,The following statement contains a magic number: var dst_COPYLENGTH_STEPSIZE_4 = (dst_end - (COPYLENGTH + (STEPSIZE_64 - 4)));
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe64,The following statement contains a magic number: while (true)  			{  				byte token;  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					var s = 255;  					while ((src_p < src_end) && (s == 255)) length += (s = src[src_p++]);  				}    				// copy literals  				dst_cpy = dst_p + length;    				if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  				{  					if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  					if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  					BlockCopy(src' src_p' dst' dst_p' length);  					dst_p += length;  					break; // Necessarily EOF' due to parsing restrictions  				}  				if (dst_p < dst_cpy) /*?*/  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside of destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  					{  						int s = src[src_p++];  						length += s;  						if (s == 255) continue;  						break;  					}  				}    				// copy repeated sequence  				if (dst_p - dst_ref < STEPSIZE_64)  				{  					var dec64 = dec64table[dst_p - dst_ref];  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_64 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy8(dst' dst_ref' dst_p);  					dst_p += 8;  					dst_ref += 8;  				}  				dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}  					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe64,The following statement contains a magic number: while (true)  			{  				byte token;  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					var s = 255;  					while ((src_p < src_end) && (s == 255)) length += (s = src[src_p++]);  				}    				// copy literals  				dst_cpy = dst_p + length;    				if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  				{  					if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  					if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  					BlockCopy(src' src_p' dst' dst_p' length);  					dst_p += length;  					break; // Necessarily EOF' due to parsing restrictions  				}  				if (dst_p < dst_cpy) /*?*/  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside of destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  					{  						int s = src[src_p++];  						length += s;  						if (s == 255) continue;  						break;  					}  				}    				// copy repeated sequence  				if (dst_p - dst_ref < STEPSIZE_64)  				{  					var dec64 = dec64table[dst_p - dst_ref];  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_64 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy8(dst' dst_ref' dst_p);  					dst_p += 8;  					dst_ref += 8;  				}  				dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}  					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe64,The following statement contains a magic number: while (true)  			{  				byte token;  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					var s = 255;  					while ((src_p < src_end) && (s == 255)) length += (s = src[src_p++]);  				}    				// copy literals  				dst_cpy = dst_p + length;    				if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  				{  					if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  					if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  					BlockCopy(src' src_p' dst' dst_p' length);  					dst_p += length;  					break; // Necessarily EOF' due to parsing restrictions  				}  				if (dst_p < dst_cpy) /*?*/  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside of destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  					{  						int s = src[src_p++];  						length += s;  						if (s == 255) continue;  						break;  					}  				}    				// copy repeated sequence  				if (dst_p - dst_ref < STEPSIZE_64)  				{  					var dec64 = dec64table[dst_p - dst_ref];  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_64 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy8(dst' dst_ref' dst_p);  					dst_p += 8;  					dst_ref += 8;  				}  				dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}  					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe64,The following statement contains a magic number: while (true)  			{  				byte token;  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					var s = 255;  					while ((src_p < src_end) && (s == 255)) length += (s = src[src_p++]);  				}    				// copy literals  				dst_cpy = dst_p + length;    				if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  				{  					if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  					if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  					BlockCopy(src' src_p' dst' dst_p' length);  					dst_p += length;  					break; // Necessarily EOF' due to parsing restrictions  				}  				if (dst_p < dst_cpy) /*?*/  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside of destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  					{  						int s = src[src_p++];  						length += s;  						if (s == 255) continue;  						break;  					}  				}    				// copy repeated sequence  				if (dst_p - dst_ref < STEPSIZE_64)  				{  					var dec64 = dec64table[dst_p - dst_ref];  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_64 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy8(dst' dst_ref' dst_p);  					dst_p += 8;  					dst_ref += 8;  				}  				dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}  					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe64,The following statement contains a magic number: while (true)  			{  				byte token;  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					var s = 255;  					while ((src_p < src_end) && (s == 255)) length += (s = src[src_p++]);  				}    				// copy literals  				dst_cpy = dst_p + length;    				if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  				{  					if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  					if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  					BlockCopy(src' src_p' dst' dst_p' length);  					dst_p += length;  					break; // Necessarily EOF' due to parsing restrictions  				}  				if (dst_p < dst_cpy) /*?*/  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside of destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  					{  						int s = src[src_p++];  						length += s;  						if (s == 255) continue;  						break;  					}  				}    				// copy repeated sequence  				if (dst_p - dst_ref < STEPSIZE_64)  				{  					var dec64 = dec64table[dst_p - dst_ref];  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_64 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy8(dst' dst_ref' dst_p);  					dst_p += 8;  					dst_ref += 8;  				}  				dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}  					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe64,The following statement contains a magic number: while (true)  			{  				byte token;  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					var s = 255;  					while ((src_p < src_end) && (s == 255)) length += (s = src[src_p++]);  				}    				// copy literals  				dst_cpy = dst_p + length;    				if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  				{  					if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  					if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  					BlockCopy(src' src_p' dst' dst_p' length);  					dst_p += length;  					break; // Necessarily EOF' due to parsing restrictions  				}  				if (dst_p < dst_cpy) /*?*/  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside of destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  					{  						int s = src[src_p++];  						length += s;  						if (s == 255) continue;  						break;  					}  				}    				// copy repeated sequence  				if (dst_p - dst_ref < STEPSIZE_64)  				{  					var dec64 = dec64table[dst_p - dst_ref];  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_64 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy8(dst' dst_ref' dst_p);  					dst_p += 8;  					dst_ref += 8;  				}  				dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}  					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe64,The following statement contains a magic number: while (true)  			{  				byte token;  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					var s = 255;  					while ((src_p < src_end) && (s == 255)) length += (s = src[src_p++]);  				}    				// copy literals  				dst_cpy = dst_p + length;    				if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  				{  					if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  					if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  					BlockCopy(src' src_p' dst' dst_p' length);  					dst_p += length;  					break; // Necessarily EOF' due to parsing restrictions  				}  				if (dst_p < dst_cpy) /*?*/  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside of destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  					{  						int s = src[src_p++];  						length += s;  						if (s == 255) continue;  						break;  					}  				}    				// copy repeated sequence  				if (dst_p - dst_ref < STEPSIZE_64)  				{  					var dec64 = dec64table[dst_p - dst_ref];  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_64 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy8(dst' dst_ref' dst_p);  					dst_p += 8;  					dst_ref += 8;  				}  				dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}  					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe64,The following statement contains a magic number: while (true)  			{  				byte token;  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					var s = 255;  					while ((src_p < src_end) && (s == 255)) length += (s = src[src_p++]);  				}    				// copy literals  				dst_cpy = dst_p + length;    				if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  				{  					if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  					if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  					BlockCopy(src' src_p' dst' dst_p' length);  					dst_p += length;  					break; // Necessarily EOF' due to parsing restrictions  				}  				if (dst_p < dst_cpy) /*?*/  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside of destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  					{  						int s = src[src_p++];  						length += s;  						if (s == 255) continue;  						break;  					}  				}    				// copy repeated sequence  				if (dst_p - dst_ref < STEPSIZE_64)  				{  					var dec64 = dec64table[dst_p - dst_ref];  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_64 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy8(dst' dst_ref' dst_p);  					dst_p += 8;  					dst_ref += 8;  				}  				dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}  					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe64,The following statement contains a magic number: while (true)  			{  				byte token;  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					var s = 255;  					while ((src_p < src_end) && (s == 255)) length += (s = src[src_p++]);  				}    				// copy literals  				dst_cpy = dst_p + length;    				if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  				{  					if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  					if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  					BlockCopy(src' src_p' dst' dst_p' length);  					dst_p += length;  					break; // Necessarily EOF' due to parsing restrictions  				}  				if (dst_p < dst_cpy) /*?*/  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside of destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  					{  						int s = src[src_p++];  						length += s;  						if (s == 255) continue;  						break;  					}  				}    				// copy repeated sequence  				if (dst_p - dst_ref < STEPSIZE_64)  				{  					var dec64 = dec64table[dst_p - dst_ref];  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_64 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy8(dst' dst_ref' dst_p);  					dst_p += 8;  					dst_ref += 8;  				}  				dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}  					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe64,The following statement contains a magic number: while (true)  			{  				byte token;  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					var s = 255;  					while ((src_p < src_end) && (s == 255)) length += (s = src[src_p++]);  				}    				// copy literals  				dst_cpy = dst_p + length;    				if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  				{  					if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  					if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  					BlockCopy(src' src_p' dst' dst_p' length);  					dst_p += length;  					break; // Necessarily EOF' due to parsing restrictions  				}  				if (dst_p < dst_cpy) /*?*/  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside of destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  					{  						int s = src[src_p++];  						length += s;  						if (s == 255) continue;  						break;  					}  				}    				// copy repeated sequence  				if (dst_p - dst_ref < STEPSIZE_64)  				{  					var dec64 = dec64table[dst_p - dst_ref];  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_64 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy8(dst' dst_ref' dst_p);  					dst_p += 8;  					dst_ref += 8;  				}  				dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}  					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe64,The following statement contains a magic number: while (true)  			{  				byte token;  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					var s = 255;  					while ((src_p < src_end) && (s == 255)) length += (s = src[src_p++]);  				}    				// copy literals  				dst_cpy = dst_p + length;    				if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  				{  					if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  					if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  					BlockCopy(src' src_p' dst' dst_p' length);  					dst_p += length;  					break; // Necessarily EOF' due to parsing restrictions  				}  				if (dst_p < dst_cpy) /*?*/  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside of destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  					{  						int s = src[src_p++];  						length += s;  						if (s == 255) continue;  						break;  					}  				}    				// copy repeated sequence  				if (dst_p - dst_ref < STEPSIZE_64)  				{  					var dec64 = dec64table[dst_p - dst_ref];  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_64 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy8(dst' dst_ref' dst_p);  					dst_p += 8;  					dst_ref += 8;  				}  				dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}  					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe64,The following statement contains a magic number: while (true)  			{  				byte token;  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					var s = 255;  					while ((src_p < src_end) && (s == 255)) length += (s = src[src_p++]);  				}    				// copy literals  				dst_cpy = dst_p + length;    				if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  				{  					if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  					if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  					BlockCopy(src' src_p' dst' dst_p' length);  					dst_p += length;  					break; // Necessarily EOF' due to parsing restrictions  				}  				if (dst_p < dst_cpy) /*?*/  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside of destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  					{  						int s = src[src_p++];  						length += s;  						if (s == 255) continue;  						break;  					}  				}    				// copy repeated sequence  				if (dst_p - dst_ref < STEPSIZE_64)  				{  					var dec64 = dec64table[dst_p - dst_ref];  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_64 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy8(dst' dst_ref' dst_p);  					dst_p += 8;  					dst_ref += 8;  				}  				dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}  					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe64,The following statement contains a magic number: while (true)  			{  				byte token;  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					var s = 255;  					while ((src_p < src_end) && (s == 255)) length += (s = src[src_p++]);  				}    				// copy literals  				dst_cpy = dst_p + length;    				if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  				{  					if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  					if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  					BlockCopy(src' src_p' dst' dst_p' length);  					dst_p += length;  					break; // Necessarily EOF' due to parsing restrictions  				}  				if (dst_p < dst_cpy) /*?*/  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside of destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  					{  						int s = src[src_p++];  						length += s;  						if (s == 255) continue;  						break;  					}  				}    				// copy repeated sequence  				if (dst_p - dst_ref < STEPSIZE_64)  				{  					var dec64 = dec64table[dst_p - dst_ref];  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_64 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy8(dst' dst_ref' dst_p);  					dst_p += 8;  					dst_ref += 8;  				}  				dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}  					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_safe64,The following statement contains a magic number: while (true)  			{  				byte token;  				int length;    				// get runlength  				token = src[src_p++];  				if ((length = (token >> ML_BITS)) == RUN_MASK)  				{  					var s = 255;  					while ((src_p < src_end) && (s == 255)) length += (s = src[src_p++]);  				}    				// copy literals  				dst_cpy = dst_p + length;    				if ((dst_cpy > dst_MFLIMIT) || (src_p + length > src_LASTLITERALS_3))  				{  					if (dst_cpy > dst_end) goto _output_error; // Error : writes beyond output buffer  					if (src_p + length != src_end) goto _output_error; // Error : LZ4 format requires to consume all input at this stage (no match within the last 11 bytes' and at least 8 remaining input bytes for another match+literals)  					BlockCopy(src' src_p' dst' dst_p' length);  					dst_p += length;  					break; // Necessarily EOF' due to parsing restrictions  				}  				if (dst_p < dst_cpy) /*?*/  				{  					_i = WildCopy(src' src_p' dst' dst_p' dst_cpy);  					src_p += _i;  					dst_p += _i;  				}  				src_p -= (dst_p - dst_cpy);  				dst_p = dst_cpy;    				// get offset  				dst_ref = (dst_cpy) - Peek2(src' src_p);  				src_p += 2;  				if (dst_ref < dst_0) goto _output_error; // Error : offset outside of destination buffer    				// get matchlength  				if ((length = (token & ML_MASK)) == ML_MASK)  				{  					while (src_p < src_LASTLITERALS_1) // Error : a minimum input bytes must remain for LASTLITERALS + token  					{  						int s = src[src_p++];  						length += s;  						if (s == 255) continue;  						break;  					}  				}    				// copy repeated sequence  				if (dst_p - dst_ref < STEPSIZE_64)  				{  					var dec64 = dec64table[dst_p - dst_ref];  					dst[dst_p + 0] = dst[dst_ref + 0];  					dst[dst_p + 1] = dst[dst_ref + 1];  					dst[dst_p + 2] = dst[dst_ref + 2];  					dst[dst_p + 3] = dst[dst_ref + 3];  					dst_p += 4;  					dst_ref += 4;  					dst_ref -= dec32table[dst_p - dst_ref];  					Copy4(dst' dst_ref' dst_p);  					dst_p += STEPSIZE_64 - 4;  					dst_ref -= dec64;  				}  				else  				{  					Copy8(dst' dst_ref' dst_p);  					dst_p += 8;  					dst_ref += 8;  				}  				dst_cpy = dst_p + length - (STEPSIZE_64 - 4);    				if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)  				{  					if (dst_cpy > dst_LASTLITERALS) goto _output_error; // Error : last 5 bytes must be literals  					if (dst_p < dst_COPYLENGTH)  					{  						_i = SecureCopy(dst' dst_ref' dst_p' dst_COPYLENGTH);  						dst_ref += _i;  						dst_p += _i;  					}  					while (dst_p < dst_cpy) dst[dst_p++] = dst[dst_ref++];  					dst_p = dst_cpy;  					continue;  				}    				if (dst_p < dst_cpy)  				{  					SecureCopy(dst' dst_ref' dst_p' dst_cpy);  				}  				dst_p = dst_cpy; // correction  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4HC_CommonLength_64,The following statement contains a magic number: while (p1t < src_LASTLITERALS - (STEPSIZE_64 - 1))  			{  				var diff = (long)Xor8(src' p2' p1t);  				if (diff == 0)  				{  					p1t += STEPSIZE_64;  					p2 += STEPSIZE_64;  					continue;  				}  				p1t += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  				return (p1t - p1);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4HC_CommonLength_64,The following statement contains a magic number: if ((p1t < (src_LASTLITERALS - 3)) && (Equal4(src' p2' p1t)))  			{  				p1t += 4;  				p2 += 4;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4HC_CommonLength_64,The following statement contains a magic number: if ((p1t < (src_LASTLITERALS - 3)) && (Equal4(src' p2' p1t)))  			{  				p1t += 4;  				p2 += 4;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4HC_CommonLength_64,The following statement contains a magic number: if ((p1t < (src_LASTLITERALS - 3)) && (Equal4(src' p2' p1t)))  			{  				p1t += 4;  				p2 += 4;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4HC_CommonLength_64,The following statement contains a magic number: if ((p1t < (src_LASTLITERALS - 1)) && (Equal2(src' p2' p1t)))  			{  				p1t += 2;  				p2 += 2;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4HC_CommonLength_64,The following statement contains a magic number: if ((p1t < (src_LASTLITERALS - 1)) && (Equal2(src' p2' p1t)))  			{  				p1t += 2;  				p2 += 2;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4HC_InsertAndFindBestMatch_64,The following statement contains a magic number: if (src_ref >= src_p - 4) // potential repetition  			{  				if (Equal4(src' src_ref' src_p)) // confirmed  				{  					delta = (ushort)(src_p - src_ref);  					repl = ml = LZ4HC_CommonLength_64(ctx' src_p + MINMATCH' src_ref + MINMATCH) + MINMATCH;  					matchpos = src_ref;  				}  				src_ref = ((src_ref) - chainTable[(src_ref) & MAXD_MASK]);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4HC_InsertAndGetWiderMatch_64,The following statement contains a magic number: while ((src_ref >= src_p - MAX_DISTANCE) && (nbAttempts != 0))  			{  				nbAttempts--;  				if (src[startLimit + longest] == src[src_ref - delta + longest])  				{  					if (Equal4(src' src_ref' src_p))  					{  						var reft = src_ref + MINMATCH;  						var ipt = src_p + MINMATCH;  						var startt = src_p;    						while (ipt < src_LASTLITERALS - (STEPSIZE_64 - 1))  						{  							var diff = (long)Xor8(src' reft' ipt);  							if (diff == 0)  							{  								ipt += STEPSIZE_64;  								reft += STEPSIZE_64;  								continue;  							}  							ipt += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  							goto _endCount;  						}  						if ((ipt < (src_LASTLITERALS - 3)) && (Equal4(src' reft' ipt)))  						{  							ipt += 4;  							reft += 4;  						}  						if ((ipt < (src_LASTLITERALS - 1)) && (Equal2(src' reft' ipt)))  						{  							ipt += 2;  							reft += 2;  						}  						if ((ipt < src_LASTLITERALS) && (src[reft] == src[ipt])) ipt++;    					_endCount:  						reft = src_ref;    						while ((startt > startLimit) && (reft > src_base) && (src[startt - 1] == src[reft - 1]))  						{  							startt--;  							reft--;  						}    						if ((ipt - startt) > longest)  						{  							longest = (ipt - startt);  							matchpos = reft;  							startpos = startt;  						}  					}  				}  				src_ref = ((src_ref) - chainTable[(src_ref) & MAXD_MASK]);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4HC_InsertAndGetWiderMatch_64,The following statement contains a magic number: while ((src_ref >= src_p - MAX_DISTANCE) && (nbAttempts != 0))  			{  				nbAttempts--;  				if (src[startLimit + longest] == src[src_ref - delta + longest])  				{  					if (Equal4(src' src_ref' src_p))  					{  						var reft = src_ref + MINMATCH;  						var ipt = src_p + MINMATCH;  						var startt = src_p;    						while (ipt < src_LASTLITERALS - (STEPSIZE_64 - 1))  						{  							var diff = (long)Xor8(src' reft' ipt);  							if (diff == 0)  							{  								ipt += STEPSIZE_64;  								reft += STEPSIZE_64;  								continue;  							}  							ipt += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  							goto _endCount;  						}  						if ((ipt < (src_LASTLITERALS - 3)) && (Equal4(src' reft' ipt)))  						{  							ipt += 4;  							reft += 4;  						}  						if ((ipt < (src_LASTLITERALS - 1)) && (Equal2(src' reft' ipt)))  						{  							ipt += 2;  							reft += 2;  						}  						if ((ipt < src_LASTLITERALS) && (src[reft] == src[ipt])) ipt++;    					_endCount:  						reft = src_ref;    						while ((startt > startLimit) && (reft > src_base) && (src[startt - 1] == src[reft - 1]))  						{  							startt--;  							reft--;  						}    						if ((ipt - startt) > longest)  						{  							longest = (ipt - startt);  							matchpos = reft;  							startpos = startt;  						}  					}  				}  				src_ref = ((src_ref) - chainTable[(src_ref) & MAXD_MASK]);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4HC_InsertAndGetWiderMatch_64,The following statement contains a magic number: while ((src_ref >= src_p - MAX_DISTANCE) && (nbAttempts != 0))  			{  				nbAttempts--;  				if (src[startLimit + longest] == src[src_ref - delta + longest])  				{  					if (Equal4(src' src_ref' src_p))  					{  						var reft = src_ref + MINMATCH;  						var ipt = src_p + MINMATCH;  						var startt = src_p;    						while (ipt < src_LASTLITERALS - (STEPSIZE_64 - 1))  						{  							var diff = (long)Xor8(src' reft' ipt);  							if (diff == 0)  							{  								ipt += STEPSIZE_64;  								reft += STEPSIZE_64;  								continue;  							}  							ipt += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  							goto _endCount;  						}  						if ((ipt < (src_LASTLITERALS - 3)) && (Equal4(src' reft' ipt)))  						{  							ipt += 4;  							reft += 4;  						}  						if ((ipt < (src_LASTLITERALS - 1)) && (Equal2(src' reft' ipt)))  						{  							ipt += 2;  							reft += 2;  						}  						if ((ipt < src_LASTLITERALS) && (src[reft] == src[ipt])) ipt++;    					_endCount:  						reft = src_ref;    						while ((startt > startLimit) && (reft > src_base) && (src[startt - 1] == src[reft - 1]))  						{  							startt--;  							reft--;  						}    						if ((ipt - startt) > longest)  						{  							longest = (ipt - startt);  							matchpos = reft;  							startpos = startt;  						}  					}  				}  				src_ref = ((src_ref) - chainTable[(src_ref) & MAXD_MASK]);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4HC_InsertAndGetWiderMatch_64,The following statement contains a magic number: while ((src_ref >= src_p - MAX_DISTANCE) && (nbAttempts != 0))  			{  				nbAttempts--;  				if (src[startLimit + longest] == src[src_ref - delta + longest])  				{  					if (Equal4(src' src_ref' src_p))  					{  						var reft = src_ref + MINMATCH;  						var ipt = src_p + MINMATCH;  						var startt = src_p;    						while (ipt < src_LASTLITERALS - (STEPSIZE_64 - 1))  						{  							var diff = (long)Xor8(src' reft' ipt);  							if (diff == 0)  							{  								ipt += STEPSIZE_64;  								reft += STEPSIZE_64;  								continue;  							}  							ipt += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  							goto _endCount;  						}  						if ((ipt < (src_LASTLITERALS - 3)) && (Equal4(src' reft' ipt)))  						{  							ipt += 4;  							reft += 4;  						}  						if ((ipt < (src_LASTLITERALS - 1)) && (Equal2(src' reft' ipt)))  						{  							ipt += 2;  							reft += 2;  						}  						if ((ipt < src_LASTLITERALS) && (src[reft] == src[ipt])) ipt++;    					_endCount:  						reft = src_ref;    						while ((startt > startLimit) && (reft > src_base) && (src[startt - 1] == src[reft - 1]))  						{  							startt--;  							reft--;  						}    						if ((ipt - startt) > longest)  						{  							longest = (ipt - startt);  							matchpos = reft;  							startpos = startt;  						}  					}  				}  				src_ref = ((src_ref) - chainTable[(src_ref) & MAXD_MASK]);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4HC_InsertAndGetWiderMatch_64,The following statement contains a magic number: while ((src_ref >= src_p - MAX_DISTANCE) && (nbAttempts != 0))  			{  				nbAttempts--;  				if (src[startLimit + longest] == src[src_ref - delta + longest])  				{  					if (Equal4(src' src_ref' src_p))  					{  						var reft = src_ref + MINMATCH;  						var ipt = src_p + MINMATCH;  						var startt = src_p;    						while (ipt < src_LASTLITERALS - (STEPSIZE_64 - 1))  						{  							var diff = (long)Xor8(src' reft' ipt);  							if (diff == 0)  							{  								ipt += STEPSIZE_64;  								reft += STEPSIZE_64;  								continue;  							}  							ipt += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  							goto _endCount;  						}  						if ((ipt < (src_LASTLITERALS - 3)) && (Equal4(src' reft' ipt)))  						{  							ipt += 4;  							reft += 4;  						}  						if ((ipt < (src_LASTLITERALS - 1)) && (Equal2(src' reft' ipt)))  						{  							ipt += 2;  							reft += 2;  						}  						if ((ipt < src_LASTLITERALS) && (src[reft] == src[ipt])) ipt++;    					_endCount:  						reft = src_ref;    						while ((startt > startLimit) && (reft > src_base) && (src[startt - 1] == src[reft - 1]))  						{  							startt--;  							reft--;  						}    						if ((ipt - startt) > longest)  						{  							longest = (ipt - startt);  							matchpos = reft;  							startpos = startt;  						}  					}  				}  				src_ref = ((src_ref) - chainTable[(src_ref) & MAXD_MASK]);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4HC_InsertAndGetWiderMatch_64,The following statement contains a magic number: while ((src_ref >= src_p - MAX_DISTANCE) && (nbAttempts != 0))  			{  				nbAttempts--;  				if (src[startLimit + longest] == src[src_ref - delta + longest])  				{  					if (Equal4(src' src_ref' src_p))  					{  						var reft = src_ref + MINMATCH;  						var ipt = src_p + MINMATCH;  						var startt = src_p;    						while (ipt < src_LASTLITERALS - (STEPSIZE_64 - 1))  						{  							var diff = (long)Xor8(src' reft' ipt);  							if (diff == 0)  							{  								ipt += STEPSIZE_64;  								reft += STEPSIZE_64;  								continue;  							}  							ipt += debruijn64[((ulong)((diff) & -(diff)) * 0x0218A392CDABBD3FL) >> 58];  							goto _endCount;  						}  						if ((ipt < (src_LASTLITERALS - 3)) && (Equal4(src' reft' ipt)))  						{  							ipt += 4;  							reft += 4;  						}  						if ((ipt < (src_LASTLITERALS - 1)) && (Equal2(src' reft' ipt)))  						{  							ipt += 2;  							reft += 2;  						}  						if ((ipt < src_LASTLITERALS) && (src[reft] == src[ipt])) ipt++;    					_endCount:  						reft = src_ref;    						while ((startt > startLimit) && (reft > src_base) && (src[startt - 1] == src[reft - 1]))  						{  							startt--;  							reft--;  						}    						if ((ipt - startt) > longest)  						{  							longest = (ipt - startt);  							matchpos = reft;  							startpos = startt;  						}  					}  				}  				src_ref = ((src_ref) - chainTable[(src_ref) & MAXD_MASK]);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_encodeSequence_64,The following statement contains a magic number: if ((dst_p + length + (2 + 1 + LASTLITERALS) + (length >> 8)) > dst_end) return 1;
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_encodeSequence_64,The following statement contains a magic number: if ((dst_p + length + (2 + 1 + LASTLITERALS) + (length >> 8)) > dst_end) return 1;
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_encodeSequence_64,The following statement contains a magic number: if (length >= RUN_MASK)  			{  				dst[dst_token] = (RUN_MASK << ML_BITS);  				len = length - RUN_MASK;  				for (; len > 254; len -= 255) dst[dst_p++] = 255;  				dst[dst_p++] = (byte)len;  			}  			else  			{  				dst[dst_token] = (byte)(length << ML_BITS);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_encodeSequence_64,The following statement contains a magic number: if (length >= RUN_MASK)  			{  				dst[dst_token] = (RUN_MASK << ML_BITS);  				len = length - RUN_MASK;  				for (; len > 254; len -= 255) dst[dst_p++] = 255;  				dst[dst_p++] = (byte)len;  			}  			else  			{  				dst[dst_token] = (byte)(length << ML_BITS);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_encodeSequence_64,The following statement contains a magic number: if (length >= RUN_MASK)  			{  				dst[dst_token] = (RUN_MASK << ML_BITS);  				len = length - RUN_MASK;  				for (; len > 254; len -= 255) dst[dst_p++] = 255;  				dst[dst_p++] = (byte)len;  			}  			else  			{  				dst[dst_token] = (byte)(length << ML_BITS);  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_encodeSequence_64,The following statement contains a magic number: dst_p += 2;
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_encodeSequence_64,The following statement contains a magic number: if (dst_p + (1 + LASTLITERALS) + (length >> 8) > dst_end) return 1;
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_encodeSequence_64,The following statement contains a magic number: if (len >= ML_MASK)  			{  				dst[dst_token] += ML_MASK;  				len -= ML_MASK;  				for (; len > 509; len -= 510)  				{  					dst[dst_p++] = 255;  					dst[dst_p++] = 255;  				}  				if (len > 254)  				{  					len -= 255;  					dst[dst_p++] = 255;  				}  				dst[dst_p++] = (byte)len;  			}  			else  			{  				dst[dst_token] += (byte)len;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_encodeSequence_64,The following statement contains a magic number: if (len >= ML_MASK)  			{  				dst[dst_token] += ML_MASK;  				len -= ML_MASK;  				for (; len > 509; len -= 510)  				{  					dst[dst_p++] = 255;  					dst[dst_p++] = 255;  				}  				if (len > 254)  				{  					len -= 255;  					dst[dst_p++] = 255;  				}  				dst[dst_p++] = (byte)len;  			}  			else  			{  				dst[dst_token] += (byte)len;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_encodeSequence_64,The following statement contains a magic number: if (len >= ML_MASK)  			{  				dst[dst_token] += ML_MASK;  				len -= ML_MASK;  				for (; len > 509; len -= 510)  				{  					dst[dst_p++] = 255;  					dst[dst_p++] = 255;  				}  				if (len > 254)  				{  					len -= 255;  					dst[dst_p++] = 255;  				}  				dst[dst_p++] = (byte)len;  			}  			else  			{  				dst[dst_token] += (byte)len;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_encodeSequence_64,The following statement contains a magic number: if (len >= ML_MASK)  			{  				dst[dst_token] += ML_MASK;  				len -= ML_MASK;  				for (; len > 509; len -= 510)  				{  					dst[dst_p++] = 255;  					dst[dst_p++] = 255;  				}  				if (len > 254)  				{  					len -= 255;  					dst[dst_p++] = 255;  				}  				dst[dst_p++] = (byte)len;  			}  			else  			{  				dst[dst_token] += (byte)len;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_encodeSequence_64,The following statement contains a magic number: if (len >= ML_MASK)  			{  				dst[dst_token] += ML_MASK;  				len -= ML_MASK;  				for (; len > 509; len -= 510)  				{  					dst[dst_p++] = 255;  					dst[dst_p++] = 255;  				}  				if (len > 254)  				{  					len -= 255;  					dst[dst_p++] = 255;  				}  				dst[dst_p++] = (byte)len;  			}  			else  			{  				dst[dst_token] += (byte)len;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_encodeSequence_64,The following statement contains a magic number: if (len >= ML_MASK)  			{  				dst[dst_token] += ML_MASK;  				len -= ML_MASK;  				for (; len > 509; len -= 510)  				{  					dst[dst_p++] = 255;  					dst[dst_p++] = 255;  				}  				if (len > 254)  				{  					len -= 255;  					dst[dst_p++] = 255;  				}  				dst[dst_p++] = (byte)len;  			}  			else  			{  				dst[dst_token] += (byte)len;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_encodeSequence_64,The following statement contains a magic number: if (len >= ML_MASK)  			{  				dst[dst_token] += ML_MASK;  				len -= ML_MASK;  				for (; len > 509; len -= 510)  				{  					dst[dst_p++] = 255;  					dst[dst_p++] = 255;  				}  				if (len > 254)  				{  					len -= 255;  					dst[dst_p++] = 255;  				}  				dst[dst_p++] = (byte)len;  			}  			else  			{  				dst[dst_token] += (byte)len;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressHCCtx_64,The following statement contains a magic number: while (src_p < src_mflimit)  			{  				var ml = LZ4HC_InsertAndFindBestMatch_64(ctx' src_p' ref xxx_ref);  				if (ml == 0)  				{  					src_p++;  					continue;  				}    				// saved' in case we would skip too much  				var start0 = src_p;  				var ref0 = xxx_ref;  				var ml0 = ml;    			_Search2:  				var ml2 = src_p + ml < src_mflimit  					? LZ4HC_InsertAndGetWiderMatch_64(ctx' src_p + ml - 2' src_p + 1' ml' ref ref2' ref start2)  					: ml;    				if (ml2 == ml) // No better match  				{  					if (LZ4_encodeSequence_64(ctx' ref src_p' ref dst_p' ref src_anchor' ml' xxx_ref) != 0) return 0;  					continue;  				}    				if (start0 < src_p)  				{  					if (start2 < src_p + ml0) // empirical  					{  						src_p = start0;  						xxx_ref = ref0;  						ml = ml0;  					}  				}    				// Here' start0==ip  				if ((start2 - src_p) < 3) // First Match too small : removed  				{  					ml = ml2;  					src_p = start2;  					xxx_ref = ref2;  					goto _Search2;  				}    			_Search3:  				// Currently we have :  				// ml2 > ml1' and  				// ip1+3 <= ip2 (usually < ip1+ml1)  				if ((start2 - src_p) < OPTIMAL_ML)  				{  					var new_ml = ml;  					if (new_ml > OPTIMAL_ML) new_ml = OPTIMAL_ML;  					if (src_p + new_ml > start2 + ml2 - MINMATCH) new_ml = (start2 - src_p) + ml2 - MINMATCH;  					var correction = new_ml - (start2 - src_p);  					if (correction > 0)  					{  						start2 += correction;  						ref2 += correction;  						ml2 -= correction;  					}  				}  				// Now' we have start2 = ip+new_ml' with new_ml=min(ml' OPTIMAL_ML=18)    				var ml3 = start2 + ml2 < src_mflimit  					? LZ4HC_InsertAndGetWiderMatch_64(ctx' start2 + ml2 - 3' start2' ml2' ref ref3' ref start3)  					: ml2;    				if (ml3 == ml2) // No better match : 2 sequences to encode  				{  					// ip & ref are known; Now for ml  					if (start2 < src_p + ml) ml = (start2 - src_p);  					// Now' encode 2 sequences  					if (LZ4_encodeSequence_64(ctx' ref src_p' ref dst_p' ref src_anchor' ml' xxx_ref) != 0) return 0;  					src_p = start2;  					if (LZ4_encodeSequence_64(ctx' ref src_p' ref dst_p' ref src_anchor' ml2' ref2) != 0) return 0;  					continue;  				}    				if (start3 < src_p + ml + 3) // Not enough space for match 2 : remove it  				{  					if (start3 >= (src_p + ml)) // can write Seq1 immediately ==> Seq2 is removed' so Seq3 becomes Seq1  					{  						if (start2 < src_p + ml)  						{  							var correction = (src_p + ml - start2);  							start2 += correction;  							ref2 += correction;  							ml2 -= correction;  							if (ml2 < MINMATCH)  							{  								start2 = start3;  								ref2 = ref3;  								ml2 = ml3;  							}  						}    						if (LZ4_encodeSequence_64(ctx' ref src_p' ref dst_p' ref src_anchor' ml' xxx_ref) != 0) return 0;  						src_p = start3;  						xxx_ref = ref3;  						ml = ml3;    						start0 = start2;  						ref0 = ref2;  						ml0 = ml2;  						goto _Search2;  					}    					start2 = start3;  					ref2 = ref3;  					ml2 = ml3;  					goto _Search3;  				}    				// OK' now we have 3 ascending matches; let's write at least the first one  				// ip & ref are known; Now for ml  				if (start2 < src_p + ml)  				{  					if ((start2 - src_p) < ML_MASK)  					{  						if (ml > OPTIMAL_ML) ml = OPTIMAL_ML;  						if (src_p + ml > start2 + ml2 - MINMATCH) ml = (start2 - src_p) + ml2 - MINMATCH;  						var correction = ml - (start2 - src_p);  						if (correction > 0)  						{  							start2 += correction;  							ref2 += correction;  							ml2 -= correction;  						}  					}  					else  					{  						ml = (start2 - src_p);  					}  				}  				if (LZ4_encodeSequence_64(ctx' ref src_p' ref dst_p' ref src_anchor' ml' xxx_ref) != 0) return 0;    				src_p = start2;  				xxx_ref = ref2;  				ml = ml2;    				start2 = start3;  				ref2 = ref3;  				ml2 = ml3;    				goto _Search3;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressHCCtx_64,The following statement contains a magic number: while (src_p < src_mflimit)  			{  				var ml = LZ4HC_InsertAndFindBestMatch_64(ctx' src_p' ref xxx_ref);  				if (ml == 0)  				{  					src_p++;  					continue;  				}    				// saved' in case we would skip too much  				var start0 = src_p;  				var ref0 = xxx_ref;  				var ml0 = ml;    			_Search2:  				var ml2 = src_p + ml < src_mflimit  					? LZ4HC_InsertAndGetWiderMatch_64(ctx' src_p + ml - 2' src_p + 1' ml' ref ref2' ref start2)  					: ml;    				if (ml2 == ml) // No better match  				{  					if (LZ4_encodeSequence_64(ctx' ref src_p' ref dst_p' ref src_anchor' ml' xxx_ref) != 0) return 0;  					continue;  				}    				if (start0 < src_p)  				{  					if (start2 < src_p + ml0) // empirical  					{  						src_p = start0;  						xxx_ref = ref0;  						ml = ml0;  					}  				}    				// Here' start0==ip  				if ((start2 - src_p) < 3) // First Match too small : removed  				{  					ml = ml2;  					src_p = start2;  					xxx_ref = ref2;  					goto _Search2;  				}    			_Search3:  				// Currently we have :  				// ml2 > ml1' and  				// ip1+3 <= ip2 (usually < ip1+ml1)  				if ((start2 - src_p) < OPTIMAL_ML)  				{  					var new_ml = ml;  					if (new_ml > OPTIMAL_ML) new_ml = OPTIMAL_ML;  					if (src_p + new_ml > start2 + ml2 - MINMATCH) new_ml = (start2 - src_p) + ml2 - MINMATCH;  					var correction = new_ml - (start2 - src_p);  					if (correction > 0)  					{  						start2 += correction;  						ref2 += correction;  						ml2 -= correction;  					}  				}  				// Now' we have start2 = ip+new_ml' with new_ml=min(ml' OPTIMAL_ML=18)    				var ml3 = start2 + ml2 < src_mflimit  					? LZ4HC_InsertAndGetWiderMatch_64(ctx' start2 + ml2 - 3' start2' ml2' ref ref3' ref start3)  					: ml2;    				if (ml3 == ml2) // No better match : 2 sequences to encode  				{  					// ip & ref are known; Now for ml  					if (start2 < src_p + ml) ml = (start2 - src_p);  					// Now' encode 2 sequences  					if (LZ4_encodeSequence_64(ctx' ref src_p' ref dst_p' ref src_anchor' ml' xxx_ref) != 0) return 0;  					src_p = start2;  					if (LZ4_encodeSequence_64(ctx' ref src_p' ref dst_p' ref src_anchor' ml2' ref2) != 0) return 0;  					continue;  				}    				if (start3 < src_p + ml + 3) // Not enough space for match 2 : remove it  				{  					if (start3 >= (src_p + ml)) // can write Seq1 immediately ==> Seq2 is removed' so Seq3 becomes Seq1  					{  						if (start2 < src_p + ml)  						{  							var correction = (src_p + ml - start2);  							start2 += correction;  							ref2 += correction;  							ml2 -= correction;  							if (ml2 < MINMATCH)  							{  								start2 = start3;  								ref2 = ref3;  								ml2 = ml3;  							}  						}    						if (LZ4_encodeSequence_64(ctx' ref src_p' ref dst_p' ref src_anchor' ml' xxx_ref) != 0) return 0;  						src_p = start3;  						xxx_ref = ref3;  						ml = ml3;    						start0 = start2;  						ref0 = ref2;  						ml0 = ml2;  						goto _Search2;  					}    					start2 = start3;  					ref2 = ref3;  					ml2 = ml3;  					goto _Search3;  				}    				// OK' now we have 3 ascending matches; let's write at least the first one  				// ip & ref are known; Now for ml  				if (start2 < src_p + ml)  				{  					if ((start2 - src_p) < ML_MASK)  					{  						if (ml > OPTIMAL_ML) ml = OPTIMAL_ML;  						if (src_p + ml > start2 + ml2 - MINMATCH) ml = (start2 - src_p) + ml2 - MINMATCH;  						var correction = ml - (start2 - src_p);  						if (correction > 0)  						{  							start2 += correction;  							ref2 += correction;  							ml2 -= correction;  						}  					}  					else  					{  						ml = (start2 - src_p);  					}  				}  				if (LZ4_encodeSequence_64(ctx' ref src_p' ref dst_p' ref src_anchor' ml' xxx_ref) != 0) return 0;    				src_p = start2;  				xxx_ref = ref2;  				ml = ml2;    				start2 = start3;  				ref2 = ref3;  				ml2 = ml3;    				goto _Search3;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressHCCtx_64,The following statement contains a magic number: while (src_p < src_mflimit)  			{  				var ml = LZ4HC_InsertAndFindBestMatch_64(ctx' src_p' ref xxx_ref);  				if (ml == 0)  				{  					src_p++;  					continue;  				}    				// saved' in case we would skip too much  				var start0 = src_p;  				var ref0 = xxx_ref;  				var ml0 = ml;    			_Search2:  				var ml2 = src_p + ml < src_mflimit  					? LZ4HC_InsertAndGetWiderMatch_64(ctx' src_p + ml - 2' src_p + 1' ml' ref ref2' ref start2)  					: ml;    				if (ml2 == ml) // No better match  				{  					if (LZ4_encodeSequence_64(ctx' ref src_p' ref dst_p' ref src_anchor' ml' xxx_ref) != 0) return 0;  					continue;  				}    				if (start0 < src_p)  				{  					if (start2 < src_p + ml0) // empirical  					{  						src_p = start0;  						xxx_ref = ref0;  						ml = ml0;  					}  				}    				// Here' start0==ip  				if ((start2 - src_p) < 3) // First Match too small : removed  				{  					ml = ml2;  					src_p = start2;  					xxx_ref = ref2;  					goto _Search2;  				}    			_Search3:  				// Currently we have :  				// ml2 > ml1' and  				// ip1+3 <= ip2 (usually < ip1+ml1)  				if ((start2 - src_p) < OPTIMAL_ML)  				{  					var new_ml = ml;  					if (new_ml > OPTIMAL_ML) new_ml = OPTIMAL_ML;  					if (src_p + new_ml > start2 + ml2 - MINMATCH) new_ml = (start2 - src_p) + ml2 - MINMATCH;  					var correction = new_ml - (start2 - src_p);  					if (correction > 0)  					{  						start2 += correction;  						ref2 += correction;  						ml2 -= correction;  					}  				}  				// Now' we have start2 = ip+new_ml' with new_ml=min(ml' OPTIMAL_ML=18)    				var ml3 = start2 + ml2 < src_mflimit  					? LZ4HC_InsertAndGetWiderMatch_64(ctx' start2 + ml2 - 3' start2' ml2' ref ref3' ref start3)  					: ml2;    				if (ml3 == ml2) // No better match : 2 sequences to encode  				{  					// ip & ref are known; Now for ml  					if (start2 < src_p + ml) ml = (start2 - src_p);  					// Now' encode 2 sequences  					if (LZ4_encodeSequence_64(ctx' ref src_p' ref dst_p' ref src_anchor' ml' xxx_ref) != 0) return 0;  					src_p = start2;  					if (LZ4_encodeSequence_64(ctx' ref src_p' ref dst_p' ref src_anchor' ml2' ref2) != 0) return 0;  					continue;  				}    				if (start3 < src_p + ml + 3) // Not enough space for match 2 : remove it  				{  					if (start3 >= (src_p + ml)) // can write Seq1 immediately ==> Seq2 is removed' so Seq3 becomes Seq1  					{  						if (start2 < src_p + ml)  						{  							var correction = (src_p + ml - start2);  							start2 += correction;  							ref2 += correction;  							ml2 -= correction;  							if (ml2 < MINMATCH)  							{  								start2 = start3;  								ref2 = ref3;  								ml2 = ml3;  							}  						}    						if (LZ4_encodeSequence_64(ctx' ref src_p' ref dst_p' ref src_anchor' ml' xxx_ref) != 0) return 0;  						src_p = start3;  						xxx_ref = ref3;  						ml = ml3;    						start0 = start2;  						ref0 = ref2;  						ml0 = ml2;  						goto _Search2;  					}    					start2 = start3;  					ref2 = ref3;  					ml2 = ml3;  					goto _Search3;  				}    				// OK' now we have 3 ascending matches; let's write at least the first one  				// ip & ref are known; Now for ml  				if (start2 < src_p + ml)  				{  					if ((start2 - src_p) < ML_MASK)  					{  						if (ml > OPTIMAL_ML) ml = OPTIMAL_ML;  						if (src_p + ml > start2 + ml2 - MINMATCH) ml = (start2 - src_p) + ml2 - MINMATCH;  						var correction = ml - (start2 - src_p);  						if (correction > 0)  						{  							start2 += correction;  							ref2 += correction;  							ml2 -= correction;  						}  					}  					else  					{  						ml = (start2 - src_p);  					}  				}  				if (LZ4_encodeSequence_64(ctx' ref src_p' ref dst_p' ref src_anchor' ml' xxx_ref) != 0) return 0;    				src_p = start2;  				xxx_ref = ref2;  				ml = ml2;    				start2 = start3;  				ref2 = ref3;  				ml2 = ml3;    				goto _Search3;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressHCCtx_64,The following statement contains a magic number: while (src_p < src_mflimit)  			{  				var ml = LZ4HC_InsertAndFindBestMatch_64(ctx' src_p' ref xxx_ref);  				if (ml == 0)  				{  					src_p++;  					continue;  				}    				// saved' in case we would skip too much  				var start0 = src_p;  				var ref0 = xxx_ref;  				var ml0 = ml;    			_Search2:  				var ml2 = src_p + ml < src_mflimit  					? LZ4HC_InsertAndGetWiderMatch_64(ctx' src_p + ml - 2' src_p + 1' ml' ref ref2' ref start2)  					: ml;    				if (ml2 == ml) // No better match  				{  					if (LZ4_encodeSequence_64(ctx' ref src_p' ref dst_p' ref src_anchor' ml' xxx_ref) != 0) return 0;  					continue;  				}    				if (start0 < src_p)  				{  					if (start2 < src_p + ml0) // empirical  					{  						src_p = start0;  						xxx_ref = ref0;  						ml = ml0;  					}  				}    				// Here' start0==ip  				if ((start2 - src_p) < 3) // First Match too small : removed  				{  					ml = ml2;  					src_p = start2;  					xxx_ref = ref2;  					goto _Search2;  				}    			_Search3:  				// Currently we have :  				// ml2 > ml1' and  				// ip1+3 <= ip2 (usually < ip1+ml1)  				if ((start2 - src_p) < OPTIMAL_ML)  				{  					var new_ml = ml;  					if (new_ml > OPTIMAL_ML) new_ml = OPTIMAL_ML;  					if (src_p + new_ml > start2 + ml2 - MINMATCH) new_ml = (start2 - src_p) + ml2 - MINMATCH;  					var correction = new_ml - (start2 - src_p);  					if (correction > 0)  					{  						start2 += correction;  						ref2 += correction;  						ml2 -= correction;  					}  				}  				// Now' we have start2 = ip+new_ml' with new_ml=min(ml' OPTIMAL_ML=18)    				var ml3 = start2 + ml2 < src_mflimit  					? LZ4HC_InsertAndGetWiderMatch_64(ctx' start2 + ml2 - 3' start2' ml2' ref ref3' ref start3)  					: ml2;    				if (ml3 == ml2) // No better match : 2 sequences to encode  				{  					// ip & ref are known; Now for ml  					if (start2 < src_p + ml) ml = (start2 - src_p);  					// Now' encode 2 sequences  					if (LZ4_encodeSequence_64(ctx' ref src_p' ref dst_p' ref src_anchor' ml' xxx_ref) != 0) return 0;  					src_p = start2;  					if (LZ4_encodeSequence_64(ctx' ref src_p' ref dst_p' ref src_anchor' ml2' ref2) != 0) return 0;  					continue;  				}    				if (start3 < src_p + ml + 3) // Not enough space for match 2 : remove it  				{  					if (start3 >= (src_p + ml)) // can write Seq1 immediately ==> Seq2 is removed' so Seq3 becomes Seq1  					{  						if (start2 < src_p + ml)  						{  							var correction = (src_p + ml - start2);  							start2 += correction;  							ref2 += correction;  							ml2 -= correction;  							if (ml2 < MINMATCH)  							{  								start2 = start3;  								ref2 = ref3;  								ml2 = ml3;  							}  						}    						if (LZ4_encodeSequence_64(ctx' ref src_p' ref dst_p' ref src_anchor' ml' xxx_ref) != 0) return 0;  						src_p = start3;  						xxx_ref = ref3;  						ml = ml3;    						start0 = start2;  						ref0 = ref2;  						ml0 = ml2;  						goto _Search2;  					}    					start2 = start3;  					ref2 = ref3;  					ml2 = ml3;  					goto _Search3;  				}    				// OK' now we have 3 ascending matches; let's write at least the first one  				// ip & ref are known; Now for ml  				if (start2 < src_p + ml)  				{  					if ((start2 - src_p) < ML_MASK)  					{  						if (ml > OPTIMAL_ML) ml = OPTIMAL_ML;  						if (src_p + ml > start2 + ml2 - MINMATCH) ml = (start2 - src_p) + ml2 - MINMATCH;  						var correction = ml - (start2 - src_p);  						if (correction > 0)  						{  							start2 += correction;  							ref2 += correction;  							ml2 -= correction;  						}  					}  					else  					{  						ml = (start2 - src_p);  					}  				}  				if (LZ4_encodeSequence_64(ctx' ref src_p' ref dst_p' ref src_anchor' ml' xxx_ref) != 0) return 0;    				src_p = start2;  				xxx_ref = ref2;  				ml = ml2;    				start2 = start3;  				ref2 = ref3;  				ml2 = ml3;    				goto _Search3;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressHCCtx_64,The following statement contains a magic number: {  				var lastRun = (src_end - src_anchor);  				if ((dst_p - dst_0) + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > (uint)dst_len) return 0; // Check output limit  				if (lastRun >= RUN_MASK)  				{  					dst[dst_p++] = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) dst[dst_p++] = 255;  					dst[dst_p++] = (byte)lastRun;  				}  				else  				{  					dst[dst_p++] = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src' src_anchor' dst' dst_p' src_end - src_anchor);  				dst_p += src_end - src_anchor;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressHCCtx_64,The following statement contains a magic number: {  				var lastRun = (src_end - src_anchor);  				if ((dst_p - dst_0) + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > (uint)dst_len) return 0; // Check output limit  				if (lastRun >= RUN_MASK)  				{  					dst[dst_p++] = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) dst[dst_p++] = 255;  					dst[dst_p++] = (byte)lastRun;  				}  				else  				{  					dst[dst_p++] = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src' src_anchor' dst' dst_p' src_end - src_anchor);  				dst_p += src_end - src_anchor;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressHCCtx_64,The following statement contains a magic number: {  				var lastRun = (src_end - src_anchor);  				if ((dst_p - dst_0) + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > (uint)dst_len) return 0; // Check output limit  				if (lastRun >= RUN_MASK)  				{  					dst[dst_p++] = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) dst[dst_p++] = 255;  					dst[dst_p++] = (byte)lastRun;  				}  				else  				{  					dst[dst_p++] = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src' src_anchor' dst' dst_p' src_end - src_anchor);  				dst_p += src_end - src_anchor;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressHCCtx_64,The following statement contains a magic number: {  				var lastRun = (src_end - src_anchor);  				if ((dst_p - dst_0) + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > (uint)dst_len) return 0; // Check output limit  				if (lastRun >= RUN_MASK)  				{  					dst[dst_p++] = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) dst[dst_p++] = 255;  					dst[dst_p++] = (byte)lastRun;  				}  				else  				{  					dst[dst_p++] = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src' src_anchor' dst' dst_p' src_end - src_anchor);  				dst_p += src_end - src_anchor;  			}
Magic Number,LZ4ps,LZ4Codec,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\LZ4\LZ4Codec.cs,LZ4_compressHCCtx_64,The following statement contains a magic number: {  				var lastRun = (src_end - src_anchor);  				if ((dst_p - dst_0) + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > (uint)dst_len) return 0; // Check output limit  				if (lastRun >= RUN_MASK)  				{  					dst[dst_p++] = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) dst[dst_p++] = 255;  					dst[dst_p++] = (byte)lastRun;  				}  				else  				{  					dst[dst_p++] = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src' src_anchor' dst' dst_p' src_end - src_anchor);  				dst_p += src_end - src_anchor;  			}
Magic Number,Shoko.Server.Commands.MAL,CommandRequest_MALDownloadStatusFromMAL,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\MAL\CommandRequest_MALDownloadStatusFromMAL.cs,ProcessCommand,The following statement contains a magic number: try              {                  if (string.IsNullOrEmpty(ServerSettings.MAL_Username) ||                      string.IsNullOrEmpty(ServerSettings.MAL_Password))                      return;                    // find the latest eps to update                    myanimelist mal = MALHelper.GetMALAnimeList();                  if (mal == null || mal.anime == null) return;                      // find the anidb user                  List<SVR_JMMUser> aniDBUsers = RepoFactory.JMMUser.GetAniDBUsers();                  if (aniDBUsers.Count == 0) return;                    SVR_JMMUser user = aniDBUsers[0];                      foreach (myanimelistAnime malAnime in mal.anime)                  {                      // look up the anime                      CrossRef_AniDB_MAL xref = RepoFactory.CrossRef_AniDB_MAL.GetByMALID(malAnime.series_animedb_id);                      if (xref == null) continue;                        if (malAnime.series_animedb_id == 8107 || malAnime.series_animedb_id == 10737)                      {                          Console.Write("");                      }                        // check if this anime has any other links                      List<CrossRef_AniDB_MAL> allXrefs = RepoFactory.CrossRef_AniDB_MAL.GetByAnimeID(xref.AnimeID);                      if (allXrefs.Count == 0) continue;                        // find the range of watched episodes that this applies to                      int startEpNumber = xref.StartEpisodeNumber;                      int endEpNumber = GetUpperEpisodeLimit(allXrefs' xref);                        List<AniDB_Episode> aniEps = RepoFactory.AniDB_Episode.GetByAnimeID(xref.AnimeID);                      foreach (AniDB_Episode aniep in aniEps)                      {                          if (aniep.EpisodeType != xref.StartEpisodeType) continue;                            SVR_AnimeEpisode ep = RepoFactory.AnimeEpisode.GetByAniDBEpisodeID(aniep.EpisodeID);                          if (ep == null) continue;                            int adjustedWatchedEps = malAnime.my_watched_episodes + xref.StartEpisodeNumber - 1;                          int epNum = aniep.EpisodeNumber;                            if (epNum < startEpNumber || epNum > endEpNumber) continue;                            SVR_AnimeEpisode_User usrRec = ep.GetUserRecord(user.JMMUserID);                            if (epNum <= adjustedWatchedEps)                          {                              // update if the user doesn't have a record (means not watched)                              // or it is currently un-watched                              bool update = false;                              if (usrRec == null) update = true;                              else if (!usrRec.WatchedDate.HasValue) update = true;                                if (update) ep.ToggleWatchedStatus(true' true' DateTime.Now' user.JMMUserID' false);                          }                          else                          {                              if (usrRec != null && usrRec.WatchedDate.HasValue) ep.ToggleWatchedStatus(false' true' DateTime.Now' user.JMMUserID' false);                          }                      }                  }              }              catch (Exception ex)              {                  logger.Error("Error processing CommandRequest_MALDownloadStatusFromMAL: {0}"' ex);              }
Magic Number,Shoko.Server.Commands.MAL,CommandRequest_MALDownloadStatusFromMAL,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\MAL\CommandRequest_MALDownloadStatusFromMAL.cs,ProcessCommand,The following statement contains a magic number: try              {                  if (string.IsNullOrEmpty(ServerSettings.MAL_Username) ||                      string.IsNullOrEmpty(ServerSettings.MAL_Password))                      return;                    // find the latest eps to update                    myanimelist mal = MALHelper.GetMALAnimeList();                  if (mal == null || mal.anime == null) return;                      // find the anidb user                  List<SVR_JMMUser> aniDBUsers = RepoFactory.JMMUser.GetAniDBUsers();                  if (aniDBUsers.Count == 0) return;                    SVR_JMMUser user = aniDBUsers[0];                      foreach (myanimelistAnime malAnime in mal.anime)                  {                      // look up the anime                      CrossRef_AniDB_MAL xref = RepoFactory.CrossRef_AniDB_MAL.GetByMALID(malAnime.series_animedb_id);                      if (xref == null) continue;                        if (malAnime.series_animedb_id == 8107 || malAnime.series_animedb_id == 10737)                      {                          Console.Write("");                      }                        // check if this anime has any other links                      List<CrossRef_AniDB_MAL> allXrefs = RepoFactory.CrossRef_AniDB_MAL.GetByAnimeID(xref.AnimeID);                      if (allXrefs.Count == 0) continue;                        // find the range of watched episodes that this applies to                      int startEpNumber = xref.StartEpisodeNumber;                      int endEpNumber = GetUpperEpisodeLimit(allXrefs' xref);                        List<AniDB_Episode> aniEps = RepoFactory.AniDB_Episode.GetByAnimeID(xref.AnimeID);                      foreach (AniDB_Episode aniep in aniEps)                      {                          if (aniep.EpisodeType != xref.StartEpisodeType) continue;                            SVR_AnimeEpisode ep = RepoFactory.AnimeEpisode.GetByAniDBEpisodeID(aniep.EpisodeID);                          if (ep == null) continue;                            int adjustedWatchedEps = malAnime.my_watched_episodes + xref.StartEpisodeNumber - 1;                          int epNum = aniep.EpisodeNumber;                            if (epNum < startEpNumber || epNum > endEpNumber) continue;                            SVR_AnimeEpisode_User usrRec = ep.GetUserRecord(user.JMMUserID);                            if (epNum <= adjustedWatchedEps)                          {                              // update if the user doesn't have a record (means not watched)                              // or it is currently un-watched                              bool update = false;                              if (usrRec == null) update = true;                              else if (!usrRec.WatchedDate.HasValue) update = true;                                if (update) ep.ToggleWatchedStatus(true' true' DateTime.Now' user.JMMUserID' false);                          }                          else                          {                              if (usrRec != null && usrRec.WatchedDate.HasValue) ep.ToggleWatchedStatus(false' true' DateTime.Now' user.JMMUserID' false);                          }                      }                  }              }              catch (Exception ex)              {                  logger.Error("Error processing CommandRequest_MALDownloadStatusFromMAL: {0}"' ex);              }
Magic Number,UPnP,NAT,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utilities\UPnP.cs,Discover,The following statement contains a magic number: IPEndPoint ipe = new IPEndPoint(IPAddress.Broadcast' 1900);
Magic Number,UPnP,NAT,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utilities\UPnP.cs,Discover,The following statement contains a magic number: do              {                  s.SendTo(data' ipe);                  s.SendTo(data' ipe);                  s.SendTo(data' ipe);                    int length = 0;                  do                  {                      length = s.Receive(buffer);                        string resp = Encoding.ASCII.GetString(buffer' 0' length).ToLower();                      if (resp.Contains("upnp:rootdevice"))                      {                          resp = resp.Substring(resp.ToLower().IndexOf("location:") + 9);                          resp = resp.Substring(0' resp.IndexOf("\r")).Trim();                          if (!String.IsNullOrEmpty(_serviceUrl = GetServiceUrl(resp)))                          {                              _descUrl = resp;                              return true;                          }                      }                  } while (length > 0);              } while (start.Subtract(DateTime.Now) < _timeout);
Magic Number,UPnP,NAT,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utilities\UPnP.cs,CombineUrls,The following statement contains a magic number: n = resp.IndexOf('/'' n + 3);
Magic Number,UPnP,NAT,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utilities\UPnP.cs,GetExternalAddress,The following statement contains a magic number: try              {                  if (LastChange < DateTime.Now)                  {                      if (IPFirstTime)                      {                          IPFirstTime = false;                          CachedAddress = NAT.GetExternalIP();                      }                      else if (!IPThreadLock)                      {                          IPThreadLock = true;                          LastChange = DateTime.Now.AddMinutes(2);                          ThreadPool.QueueUserWorkItem((a) =>                          {                              CachedAddress = NAT.GetExternalIP();                              IPThreadLock = false;                          });                      }                  }              }              catch (Exception)              {                  return null;              }
Magic Number,Shoko.Server.ImageDownload,ImageUtils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ImageDownload\ImageUtils.cs,GetAniDBCharacterImagePath,The following statement contains a magic number: if (sid.Length == 1)                  subFolder = sid;              else                  subFolder = sid.Substring(0' 2);
Magic Number,Shoko.Server.ImageDownload,ImageUtils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ImageDownload\ImageUtils.cs,GetAniDBCreatorImagePath,The following statement contains a magic number: if (sid.Length == 1)                  subFolder = sid;              else                  subFolder = sid.Substring(0' 2);
Magic Number,Shoko.Server.ImageDownload,ImageUtils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ImageDownload\ImageUtils.cs,GetAniDBImagePath,The following statement contains a magic number: if (sid.Length == 1)                  subFolder = sid;              else                  subFolder = sid.Substring(0' 2);
Magic Number,Shoko.Server.Providers.Azure,AzureWebAPI,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\Azure\AzureWebAPI.cs,Get_AnimeXML,The following statement contains a magic number: try              {                  //if (!ServerSettings.WebCache_XRefFileEpisode_Send) return;                    string uri = $@"http://{azureHostBaseAddress}/api/animexml/{animeID}";                    DateTime start = DateTime.Now;                  string msg = $"Getting Anime XML Data From Cache: {animeID}";                  ShokoService.LogToSystem(Constants.DBLogType.APIAzureHTTP' msg);                    string xml = GetDataXML(uri);                    // remove the string container                  int iStart = xml.IndexOf("<?xml"' StringComparison.Ordinal);                  if (iStart > 0)                  {                      int iEnd = xml.IndexOf("</string>"' StringComparison.Ordinal);                      if (iEnd > 0) xml = xml.Substring(iStart' iEnd - iStart - 1);                  }                    TimeSpan ts = DateTime.Now - start;                  string content = xml;                  if (content.Length > 100) content = content.Substring(0' 100);                  msg = $"Got Anime XML Data From Cache: {animeID} - {ts.TotalMilliseconds} - {content}";                  ShokoService.LogToSystem(Constants.DBLogType.APIAzureHTTP' msg);                    return xml;              }              catch              {                  return null;              }
Magic Number,Shoko.Server.Providers.Azure,AzureWebAPI,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\Azure\AzureWebAPI.cs,Get_AnimeXML,The following statement contains a magic number: try              {                  //if (!ServerSettings.WebCache_XRefFileEpisode_Send) return;                    string uri = $@"http://{azureHostBaseAddress}/api/animexml/{animeID}";                    DateTime start = DateTime.Now;                  string msg = $"Getting Anime XML Data From Cache: {animeID}";                  ShokoService.LogToSystem(Constants.DBLogType.APIAzureHTTP' msg);                    string xml = GetDataXML(uri);                    // remove the string container                  int iStart = xml.IndexOf("<?xml"' StringComparison.Ordinal);                  if (iStart > 0)                  {                      int iEnd = xml.IndexOf("</string>"' StringComparison.Ordinal);                      if (iEnd > 0) xml = xml.Substring(iStart' iEnd - iStart - 1);                  }                    TimeSpan ts = DateTime.Now - start;                  string content = xml;                  if (content.Length > 100) content = content.Substring(0' 100);                  msg = $"Got Anime XML Data From Cache: {animeID} - {ts.TotalMilliseconds} - {content}";                  ShokoService.LogToSystem(Constants.DBLogType.APIAzureHTTP' msg);                    return xml;              }              catch              {                  return null;              }
Magic Number,Shoko.Server.Providers.Azure,AzureWebAPI,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\Azure\AzureWebAPI.cs,SendData,The following statement contains a magic number: try              {                  DateTime start = DateTime.Now;                    req = WebRequest.Create(uri);                  //req.Method = "POST";        // Post method                  req.Method = verb; // Post method' or PUT                  req.ContentType = "application/json; charset=UTF-8"; // content type                  req.Proxy = null;                    // Wrap the request stream with a text-based writer                  var encoding = Encoding.UTF8;                    StreamWriter writer = new StreamWriter(req.GetRequestStream()' encoding);                  // Write the XML text into the stream                  writer.WriteLine(json);                  writer.Close();                  // Send the data to the webserver                  rsp = req.GetResponse();                    TimeSpan ts = DateTime.Now - start;                  logger.Trace("Sent Web Cache Update in {0} ms: {1}"' ts.TotalMilliseconds' uri);              }              catch (WebException webEx)              {                  if (webEx.Status == WebExceptionStatus.ProtocolError)                  {                      var response = webEx.Response as HttpWebResponse;                      if (response != null)                      {                          if (!uri.Contains("Admin") || (int) response.StatusCode != 400)                              logger.Error("HTTP Status Code: " + (int) response.StatusCode);                          ret = response.StatusCode.ToString();                      }                  }                  if (!uri.Contains("Admin"))                      logger.Error("Error(1) in XMLServiceQueue.SendData: {0}"' webEx);              }              catch (Exception ex)              {                  logger.Error(ex' "Error(2) in XMLServiceQueue.SendData: {0}");              }              finally              {                  req?.GetRequestStream().Close();                  rsp?.GetResponseStream()?.Close();              }
Magic Number,Shoko.Server.Providers.Azure,AzureWebAPI,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\Azure\AzureWebAPI.cs,GetDataJson,The following statement contains a magic number: try              {                  HttpWebRequest webReq = (HttpWebRequest) WebRequest.Create(uri);                  webReq.Timeout = 30000; // 30 seconds                  webReq.Proxy = null;                  webReq.Method = "GET";                  webReq.Headers.Add(HttpRequestHeader.AcceptEncoding' "gzip'deflate");                  webReq.ContentType = "application/json; charset=UTF-8"; // content type                  webReq.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;                    using (HttpWebResponse webResponse = (HttpWebResponse) webReq.GetResponse())                  {                      using (Stream responseStream = webResponse.GetResponseStream())                      {                          if (responseStream == null) return string.Empty;                          Encoding encoding = Encoding.UTF8;                          StreamReader Reader = new StreamReader(responseStream' encoding);                            string output = Reader.ReadToEnd();                          output = HttpUtility.HtmlDecode(output);                            return output;                      }                  }              }              catch (WebException webEx)              {                  logger.Error("Error(1) in AzureWebAPI.GetData: {0}"' webEx);              }              catch (Exception ex)              {                  logger.Error(ex' "Error(2) in AzureWebAPI.GetData: {0}");              }
Magic Number,Shoko.Server.Providers.Azure,AzureWebAPI,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\Azure\AzureWebAPI.cs,DeleteDataJson,The following statement contains a magic number: try              {                  HttpWebRequest webReq = (HttpWebRequest) WebRequest.Create(uri);                  webReq.Timeout = 30000; // 30 seconds                  webReq.Proxy = null;                  webReq.Method = "DELETE";                  webReq.Headers.Add(HttpRequestHeader.AcceptEncoding' "gzip'deflate");                  webReq.ContentType = "application/json; charset=UTF-8"; // content type                  webReq.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;                    using (HttpWebResponse WebResponse = (HttpWebResponse) webReq.GetResponse())                  {                      using (Stream responseStream = WebResponse.GetResponseStream())                      {                          if (responseStream == null) return string.Empty;                          Encoding encoding = Encoding.UTF8;                          StreamReader Reader = new StreamReader(responseStream' encoding);                            string output = Reader.ReadToEnd();                          output = HttpUtility.HtmlDecode(output);                            return output;                      }                  }              }              catch (WebException webEx)              {                  logger.Error("Error(1) in AzureWebAPI.GetData: {0}"' webEx);              }              catch (Exception ex)              {                  logger.Error(ex' "Error(2) in AzureWebAPI.GetData: {0}");              }
Magic Number,Shoko.Server.Providers.Azure,AzureWebAPI,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\Azure\AzureWebAPI.cs,GetDataXML,The following statement contains a magic number: try              {                  HttpWebRequest webReq = (HttpWebRequest) WebRequest.Create(uri);                  webReq.Timeout = 30000; // 30 seconds                  webReq.Proxy = null;                  webReq.Method = "GET";                  webReq.Headers.Add(HttpRequestHeader.AcceptEncoding' "gzip'deflate");                  webReq.ContentType = "text/xml"; // content type                  webReq.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;                    using (var webResponse = (HttpWebResponse) webReq.GetResponse())                  {                      using (Stream responseStream = webResponse.GetResponseStream())                      {                          if (responseStream == null) return string.Empty;                          string enco = webResponse.CharacterSet;                          Encoding encoding = null;                          if (!string.IsNullOrEmpty(enco))                              encoding = Encoding.GetEncoding(enco);                          if (encoding == null)                              encoding = Encoding.Default;                          StreamReader Reader = new StreamReader(responseStream' encoding);                            string output = Reader.ReadToEnd();                          output = HttpUtility.HtmlDecode(output);                            return output;                      }                  }              }              catch (WebException webEx)              {                  // Azure is broken here' just suppress it                  // logger.Error("WebError in AzureWebAPI.GetData: {0}"' webEx);              }              catch (Exception ex)              {                  logger.Error($"Error in AzureWebAPI.GetData: {ex}");              }
Magic Number,Shoko.Server.Providers.Azure,AzureWebAPI,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\Azure\AzureWebAPI.cs,GetUserInfoData,The following statement contains a magic number: try              {                  if (string.IsNullOrEmpty(ServerSettings.AniDB_Username)) return null;                    Azure_UserInfo uinfo = new Azure_UserInfo                  {                      DateTimeUpdated = DateTime.Now'                      DateTimeUpdatedUTC = 0'                        // Optional JMM Desktop data                      DashboardType = null'                      VideoPlayer = vidPlayer                  };                  System.Reflection.Assembly a = System.Reflection.Assembly.GetEntryAssembly();                  try                  {                      if (a != null) uinfo.JMMServerVersion = Utils.GetApplicationVersion(a);                  }                  catch                  {                      // ignored                  }                    uinfo.UsernameHash = Utils.GetMd5Hash(ServerSettings.AniDB_Username);                  uinfo.DatabaseType = ServerSettings.DatabaseType;                  uinfo.WindowsVersion = Utils.GetOSInfo();                  uinfo.TraktEnabled = ServerSettings.Trakt_IsEnabled ? 1 : 0;                  uinfo.MALEnabled = string.IsNullOrEmpty(ServerSettings.MAL_Username) ? 0 : 1;                    uinfo.CountryLocation = string.Empty;                    // this field is not actually used                  uinfo.LastEpisodeWatchedAsDate = DateTime.Now.AddDays(-5);                    uinfo.LocalUserCount = (int) RepoFactory.JMMUser.GetTotalRecordCount();                    uinfo.FileCount = RepoFactory.VideoLocal.GetTotalRecordCount();                    SVR_AnimeEpisode_User rec = RepoFactory.AnimeEpisode_User.GetLastWatchedEpisode();                  uinfo.LastEpisodeWatched = 0;                  if (rec != null)                      uinfo.LastEpisodeWatched = AniDB.GetAniDBDateAsSeconds(rec.WatchedDate);                    return uinfo;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());                  return null;              }
Magic Number,Shoko.Server.Providers.Azure,AzureWebAPI,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\Azure\AzureWebAPI.cs,Send_FileHash,The following statement contains a magic number: foreach (SVR_AniDB_File aniFile in aniFiles)              {                  Azure_FileHash_Request input = aniFile.ToHashRequest();                  if (inputs.Count < 25)                      inputs.Add(input);                  else                  {                      string json = JSONHelper.Serialize(inputs);                      SendData(uri' json' "POST");                      inputs.Clear();                  }              }
Magic Number,Shoko.Server.Providers.Azure,AzureWebAPI,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\Azure\AzureWebAPI.cs,Send_FileHash,The following statement contains a magic number: foreach (SVR_VideoLocal v in locals)              {                  Azure_FileHash_Request input = v.ToHashRequest();                  if (inputs.Count < 25)                      inputs.Add(input);                  else                  {                      string json = JSONHelper.Serialize(inputs);                      SendData(uri' json' "POST");                      inputs.Clear();                  }              }
Magic Number,Shoko.Server.Providers.Azure,AzureWebAPI,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\Azure\AzureWebAPI.cs,Get_FileHashWithTaskAsync,The following statement contains a magic number: if (await Task.WhenAny(task' Task.Delay(30000)) == task) return await task;
Magic Number,Shoko.Server.Providers.Azure,AzureWebAPI,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\Azure\AzureWebAPI.cs,Send_Media,The following statement contains a magic number: foreach (SVR_VideoLocal v in locals.Where(a => a.MediaBlob != null && a.MediaBlob.Length > 0 &&                                                             a.MediaVersion == SVR_VideoLocal.MEDIA_VERSION &&                                                             !string.IsNullOrEmpty(a.ED2KHash)))              {                  Azure_Media_Request input = v.ToMediaRequest();                  if (inputs.Count < 25)                      inputs.Add(input);                  else                  {                      string json = JSONHelper.Serialize(inputs);                      //json = Newtonsoft.Json.JsonConvert.SerializeObject(inputs);                      SendData(uri' json' "POST");                      inputs.Clear();                  }              }
Magic Number,Shoko.Server.Providers.JMMAutoUpdates,JMMAutoUpdatesHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\JMMAutoUpdates\JMMAutoUpdatesHelper.cs,ConvertToAbsoluteVersion,The following statement contains a magic number: if (numbers.Length != 4) return 0;
Magic Number,Shoko.Server.Providers.JMMAutoUpdates,JMMAutoUpdatesHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\JMMAutoUpdates\JMMAutoUpdatesHelper.cs,ConvertToAbsoluteVersion,The following statement contains a magic number: return int.Parse(numbers[3]) * 100 +                     int.Parse(numbers[2]) * 100 * 100 +                     int.Parse(numbers[1]) * 100 * 100 * 100 +                     int.Parse(numbers[0]) * 100 * 100 * 100 * 100;
Magic Number,Shoko.Server.Providers.JMMAutoUpdates,JMMAutoUpdatesHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\JMMAutoUpdates\JMMAutoUpdatesHelper.cs,ConvertToAbsoluteVersion,The following statement contains a magic number: return int.Parse(numbers[3]) * 100 +                     int.Parse(numbers[2]) * 100 * 100 +                     int.Parse(numbers[1]) * 100 * 100 * 100 +                     int.Parse(numbers[0]) * 100 * 100 * 100 * 100;
Magic Number,Shoko.Server.Providers.JMMAutoUpdates,JMMAutoUpdatesHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\JMMAutoUpdates\JMMAutoUpdatesHelper.cs,ConvertToAbsoluteVersion,The following statement contains a magic number: return int.Parse(numbers[3]) * 100 +                     int.Parse(numbers[2]) * 100 * 100 +                     int.Parse(numbers[1]) * 100 * 100 * 100 +                     int.Parse(numbers[0]) * 100 * 100 * 100 * 100;
Magic Number,Shoko.Server.Providers.JMMAutoUpdates,JMMAutoUpdatesHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\JMMAutoUpdates\JMMAutoUpdatesHelper.cs,ConvertToAbsoluteVersion,The following statement contains a magic number: return int.Parse(numbers[3]) * 100 +                     int.Parse(numbers[2]) * 100 * 100 +                     int.Parse(numbers[1]) * 100 * 100 * 100 +                     int.Parse(numbers[0]) * 100 * 100 * 100 * 100;
Magic Number,Shoko.Server.Providers.JMMAutoUpdates,JMMAutoUpdatesHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\JMMAutoUpdates\JMMAutoUpdatesHelper.cs,ConvertToAbsoluteVersion,The following statement contains a magic number: return int.Parse(numbers[3]) * 100 +                     int.Parse(numbers[2]) * 100 * 100 +                     int.Parse(numbers[1]) * 100 * 100 * 100 +                     int.Parse(numbers[0]) * 100 * 100 * 100 * 100;
Magic Number,Shoko.Server.Providers.JMMAutoUpdates,JMMAutoUpdatesHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\JMMAutoUpdates\JMMAutoUpdatesHelper.cs,ConvertToAbsoluteVersion,The following statement contains a magic number: return int.Parse(numbers[3]) * 100 +                     int.Parse(numbers[2]) * 100 * 100 +                     int.Parse(numbers[1]) * 100 * 100 * 100 +                     int.Parse(numbers[0]) * 100 * 100 * 100 * 100;
Magic Number,Shoko.Server.Providers.JMMAutoUpdates,JMMAutoUpdatesHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\JMMAutoUpdates\JMMAutoUpdatesHelper.cs,ConvertToAbsoluteVersion,The following statement contains a magic number: return int.Parse(numbers[3]) * 100 +                     int.Parse(numbers[2]) * 100 * 100 +                     int.Parse(numbers[1]) * 100 * 100 * 100 +                     int.Parse(numbers[0]) * 100 * 100 * 100 * 100;
Magic Number,Shoko.Server.Providers.JMMAutoUpdates,JMMAutoUpdatesHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\JMMAutoUpdates\JMMAutoUpdatesHelper.cs,ConvertToAbsoluteVersion,The following statement contains a magic number: return int.Parse(numbers[3]) * 100 +                     int.Parse(numbers[2]) * 100 * 100 +                     int.Parse(numbers[1]) * 100 * 100 * 100 +                     int.Parse(numbers[0]) * 100 * 100 * 100 * 100;
Magic Number,Shoko.Server.Providers.JMMAutoUpdates,JMMAutoUpdatesHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\JMMAutoUpdates\JMMAutoUpdatesHelper.cs,ConvertToAbsoluteVersion,The following statement contains a magic number: return int.Parse(numbers[3]) * 100 +                     int.Parse(numbers[2]) * 100 * 100 +                     int.Parse(numbers[1]) * 100 * 100 * 100 +                     int.Parse(numbers[0]) * 100 * 100 * 100 * 100;
Magic Number,Shoko.Server.Providers.JMMAutoUpdates,JMMAutoUpdatesHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\JMMAutoUpdates\JMMAutoUpdatesHelper.cs,ConvertToAbsoluteVersion,The following statement contains a magic number: return int.Parse(numbers[3]) * 100 +                     int.Parse(numbers[2]) * 100 * 100 +                     int.Parse(numbers[1]) * 100 * 100 * 100 +                     int.Parse(numbers[0]) * 100 * 100 * 100 * 100;
Magic Number,Shoko.Server.Providers.JMMAutoUpdates,JMMAutoUpdatesHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\JMMAutoUpdates\JMMAutoUpdatesHelper.cs,ConvertToAbsoluteVersion,The following statement contains a magic number: return int.Parse(numbers[3]) * 100 +                     int.Parse(numbers[2]) * 100 * 100 +                     int.Parse(numbers[1]) * 100 * 100 * 100 +                     int.Parse(numbers[0]) * 100 * 100 * 100 * 100;
Magic Number,Shoko.Server.Providers.JMMAutoUpdates,JMMAutoUpdatesHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\JMMAutoUpdates\JMMAutoUpdatesHelper.cs,ConvertToAbsoluteVersion,The following statement contains a magic number: return int.Parse(numbers[3]) * 100 +                     int.Parse(numbers[2]) * 100 * 100 +                     int.Parse(numbers[1]) * 100 * 100 * 100 +                     int.Parse(numbers[0]) * 100 * 100 * 100 * 100;
Magic Number,Shoko.Server.Providers.MyAnimeList,MALHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\MyAnimeList\MALHelper.cs,SendMALAuthenticatedRequest,The following statement contains a magic number: webReq.Timeout = 30 * 1000;
Magic Number,Shoko.Server.Providers.MyAnimeList,MALHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\MyAnimeList\MALHelper.cs,SendMALAuthenticatedRequest,The following statement contains a magic number: webReq.Timeout = 30 * 1000;
Magic Number,Shoko.Server.Providers.MyAnimeList,MALHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\MyAnimeList\MALHelper.cs,VerifyCredentials,The following statement contains a magic number: try              {                  string username = ServerSettings.MAL_Username;                  string password = ServerSettings.MAL_Password;                    string url = "https://myanimelist.net/api/account/verify_credentials.xml";                  HttpWebRequest webReq = (HttpWebRequest) WebRequest.Create(url);                  webReq.Timeout = 30 * 1000;                  webReq.Credentials = new NetworkCredential(username' password);                  webReq.PreAuthenticate = true;                  webReq.UserAgent = "api-jmm-7EC61C5283B99DC1CFE9A3730BF507CE";                    HttpWebResponse WebResponse = (HttpWebResponse) webReq.GetResponse();                    Stream responseStream = WebResponse.GetResponseStream();                  String enco = WebResponse.CharacterSet;                  Encoding encoding = null;                  if (!String.IsNullOrEmpty(enco))                      encoding = Encoding.GetEncoding(WebResponse.CharacterSet);                  if (encoding == null)                      encoding = Encoding.Default;                  StreamReader Reader = new StreamReader(responseStream' encoding);                    string outputXML = Reader.ReadToEnd();                    WebResponse.Close();                  responseStream.Close();                    if (outputXML.Trim().Length == 0) return false;                    outputXML = ReplaceEntityNamesByCharacter(outputXML);                    XmlSerializer serializer = new XmlSerializer(typeof(user));                  XmlDocument docVerifyCredentials = new XmlDocument();                  docVerifyCredentials.LoadXml(outputXML);                    XmlNodeReader reader = new XmlNodeReader(docVerifyCredentials.DocumentElement);                  object obj = serializer.Deserialize(reader);                  user _user = (user) obj;                    if (_user.username.ToUpper() == username.ToUpper())                      return true;                    return false;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());                  return false;              }
Magic Number,Shoko.Server.Providers.MyAnimeList,MALHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\MyAnimeList\MALHelper.cs,VerifyCredentials,The following statement contains a magic number: try              {                  string username = ServerSettings.MAL_Username;                  string password = ServerSettings.MAL_Password;                    string url = "https://myanimelist.net/api/account/verify_credentials.xml";                  HttpWebRequest webReq = (HttpWebRequest) WebRequest.Create(url);                  webReq.Timeout = 30 * 1000;                  webReq.Credentials = new NetworkCredential(username' password);                  webReq.PreAuthenticate = true;                  webReq.UserAgent = "api-jmm-7EC61C5283B99DC1CFE9A3730BF507CE";                    HttpWebResponse WebResponse = (HttpWebResponse) webReq.GetResponse();                    Stream responseStream = WebResponse.GetResponseStream();                  String enco = WebResponse.CharacterSet;                  Encoding encoding = null;                  if (!String.IsNullOrEmpty(enco))                      encoding = Encoding.GetEncoding(WebResponse.CharacterSet);                  if (encoding == null)                      encoding = Encoding.Default;                  StreamReader Reader = new StreamReader(responseStream' encoding);                    string outputXML = Reader.ReadToEnd();                    WebResponse.Close();                  responseStream.Close();                    if (outputXML.Trim().Length == 0) return false;                    outputXML = ReplaceEntityNamesByCharacter(outputXML);                    XmlSerializer serializer = new XmlSerializer(typeof(user));                  XmlDocument docVerifyCredentials = new XmlDocument();                  docVerifyCredentials.LoadXml(outputXML);                    XmlNodeReader reader = new XmlNodeReader(docVerifyCredentials.DocumentElement);                  object obj = serializer.Deserialize(reader);                  user _user = (user) obj;                    if (_user.username.ToUpper() == username.ToUpper())                      return true;                    return false;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());                  return false;              }
Magic Number,Shoko.Server.Providers.MyAnimeList,MALHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\MyAnimeList\MALHelper.cs,UpdateMALSeries,The following statement contains a magic number: try              {                  if (string.IsNullOrEmpty(ServerSettings.MAL_Username) ||                      string.IsNullOrEmpty(ServerSettings.MAL_Password))                      return;                    // Populate MAL animelist hashtable if isNeverDecreaseWatched set                  Hashtable animeListHashtable = new Hashtable();                  myanimelist malAnimeList = GetMALAnimeList();                    if (ServerSettings.MAL_NeverDecreaseWatchedNums)                      //if set' check watched number before update: take some time' as user anime list must be loaded                  {                      if (malAnimeList != null && malAnimeList.anime != null)                      {                          for (int i = 0; i < malAnimeList.anime.Length; i++)                          {                              animeListHashtable.Add(malAnimeList.anime[i].series_animedb_id' malAnimeList.anime[i]);                          }                      }                  }                    // look for MAL Links                  List<CrossRef_AniDB_MAL> crossRefs = ser.GetAnime().GetCrossRefMAL();                  if (crossRefs == null || crossRefs.Count == 0)                  {                      logger.Warn("Could not find MAL link for : {0} ({1})"' ser.GetAnime().GetFormattedTitle()'                          ser.GetAnime().AnimeID);                      return;                  }                    List<SVR_AnimeEpisode> eps = ser.GetAnimeEpisodes();                    // find the anidb user                  List<SVR_JMMUser> aniDBUsers = RepoFactory.JMMUser.GetAniDBUsers();                  if (aniDBUsers.Count == 0) return;                    SVR_JMMUser user = aniDBUsers[0];                    int score = 0;                  if (ser.GetAnime().UserVote != null)                      score = ser.GetAnime().UserVote.VoteValue / 100;                    // e.g.                  // AniDB - Code Geass R2                  // MAL Equivalent = AniDB Normal Eps 1 - 25 / Code Geass: Hangyaku no Lelouch R2 / hxxp://myanimelist.net/anime/2904/Code_Geass:_Hangyaku_no_Lelouch_R2                  // MAL Equivalent = AniDB Special Eps 1 - 9 / Code Geass: Hangyaku no Lelouch R2 Picture Drama / hxxp://myanimelist.net/anime/5163/Code_Geass:_Hangyaku_no_Lelouch_R2_Picture_Drama                  // MAL Equivalent = AniDB Special Eps 9 - 18 / Code Geass: Hangyaku no Lelouch R2: Flash Specials / hxxp://myanimelist.net/anime/9591/Code_Geass:_Hangyaku_no_Lelouch_R2:_Flash_Specials                  // MAL Equivalent = AniDB Special Eps 20 / Code Geass: Hangyaku no Lelouch - Kiseki no Birthday Picture Drama / hxxp://myanimelist.net/anime/8728/Code_Geass:_Hangyaku_no_Lelouch_-_Kiseki_no_Birthday_Picture_Drama                    foreach (CrossRef_AniDB_MAL xref in crossRefs)                  {                      // look for the right MAL id                      int malID = -1;                      int epNumber = -1;                      int totalEpCount = -1;                        List<string> fanSubGroups = new List<string>();                        // for each cross ref (which is a series on MAL) we need to update the data                      // so find all the episodes which apply to this cross ref                      int lastWatchedEpNumber = 0;                      int downloadedEps = 0;                        foreach (SVR_AnimeEpisode ep in eps)                      {                          int epNum = ep.AniDB_Episode.EpisodeNumber;                          if (xref.StartEpisodeType == (int) ep.EpisodeTypeEnum && epNum >= xref.StartEpisodeNumber &&                              epNum <= GetUpperEpisodeLimit(crossRefs' xref))                          {                              malID = xref.MALID;                              epNumber = epNum - xref.StartEpisodeNumber + 1;                                // find the total episode count                              if (totalEpCount < 0)                              {                                  if (ep.EpisodeTypeEnum == EpisodeType.Episode)                                      totalEpCount = ser.GetAnime().EpisodeCountNormal;                                  if (ep.EpisodeTypeEnum == EpisodeType.Special)                                      totalEpCount = ser.GetAnime().EpisodeCountSpecial;                                  totalEpCount = totalEpCount - xref.StartEpisodeNumber + 1;                              }                                // any episodes here belong to the MAL series                              // find the latest watched episod enumber                              SVR_AnimeEpisode_User usrRecord = ep.GetUserRecord(user.JMMUserID);                              if (usrRecord?.WatchedDate != null && epNum > lastWatchedEpNumber)                              {                                  lastWatchedEpNumber = epNum;                              }                                List<CL_VideoDetailed> contracts = ep.GetVideoDetailedContracts(user.JMMUserID);                                // find the latest episode number in the collection                              if (contracts.Count > 0)                                  downloadedEps++;                                foreach (CL_VideoDetailed contract in contracts)                              {                                  if (!string.IsNullOrEmpty(contract.AniDB_Anime_GroupNameShort) &&                                      !fanSubGroups.Contains(contract.AniDB_Anime_GroupNameShort))                                      fanSubGroups.Add(contract.AniDB_Anime_GroupNameShort);                              }                          }                      }                        string fanSubs = string.Empty;                      foreach (string fgrp in fanSubGroups)                      {                          if (!string.IsNullOrEmpty(fanSubs)) fanSubs += "'";                          fanSubs += fgrp;                      }                        // determine status                      int status = 1; //watching                      int lastWatchedEpNumberMAL = 0;                      if (animeListHashtable.ContainsKey(malID))                      {                          myanimelistAnime animeInList = (myanimelistAnime) animeListHashtable[malID];                          status = animeInList.my_status;                          lastWatchedEpNumberMAL = animeInList.my_watched_episodes;                      }                        // over-ride is user has watched an episode                      // don't override on hold (3) or dropped (4) but do override plan to watch (6)                      if (status == 6 && lastWatchedEpNumber > 0) status = 1; //watching                      if (lastWatchedEpNumber == totalEpCount) status = 2; //completed                        if (lastWatchedEpNumber > totalEpCount)                      {                          logger.Error("updateMAL' episode number > matching anime episode total : {0} ({1}) / {2}"'                              ser.GetAnime().GetFormattedTitle()' ser.GetAnime().AnimeID' epNumber);                          continue;                      }                        if (malID <= 0 || totalEpCount <= 0)                      {                          logger.Warn("Could not find MAL link for : {0} ({1})"' ser.GetAnime().GetFormattedTitle()'                              ser.GetAnime().AnimeID);                          continue;                      }                        string confirmationMessage = string.Empty;                      if (animeListHashtable.ContainsKey(malID))                      {                          if ((ServerSettings.MAL_NeverDecreaseWatchedNums && lastWatchedEpNumberMAL > 0) && lastWatchedEpNumber <= lastWatchedEpNumberMAL)                          {                              continue;                          }                            ModifyAnime(malID' lastWatchedEpNumber' status' score' downloadedEps' fanSubs);                          confirmationMessage = string.Format(                              "MAL successfully updated (MAL MODIFY)' mal id: {0}' ep: {1}' score: {2}"' malID'                              lastWatchedEpNumber' score);                      }                      else                      {                          AddAnime(malID' lastWatchedEpNumber' status' score' downloadedEps' fanSubs);                          confirmationMessage = string.Format(                              "MAL successfully updated (MAL ADD)' mal id: {0}' ep: {1}' score: {2}"' malID'                              lastWatchedEpNumber' score);                      }                      logger.Trace(confirmationMessage);                  }              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server.Providers.MyAnimeList,MALHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\MyAnimeList\MALHelper.cs,UpdateMALSeries,The following statement contains a magic number: try              {                  if (string.IsNullOrEmpty(ServerSettings.MAL_Username) ||                      string.IsNullOrEmpty(ServerSettings.MAL_Password))                      return;                    // Populate MAL animelist hashtable if isNeverDecreaseWatched set                  Hashtable animeListHashtable = new Hashtable();                  myanimelist malAnimeList = GetMALAnimeList();                    if (ServerSettings.MAL_NeverDecreaseWatchedNums)                      //if set' check watched number before update: take some time' as user anime list must be loaded                  {                      if (malAnimeList != null && malAnimeList.anime != null)                      {                          for (int i = 0; i < malAnimeList.anime.Length; i++)                          {                              animeListHashtable.Add(malAnimeList.anime[i].series_animedb_id' malAnimeList.anime[i]);                          }                      }                  }                    // look for MAL Links                  List<CrossRef_AniDB_MAL> crossRefs = ser.GetAnime().GetCrossRefMAL();                  if (crossRefs == null || crossRefs.Count == 0)                  {                      logger.Warn("Could not find MAL link for : {0} ({1})"' ser.GetAnime().GetFormattedTitle()'                          ser.GetAnime().AnimeID);                      return;                  }                    List<SVR_AnimeEpisode> eps = ser.GetAnimeEpisodes();                    // find the anidb user                  List<SVR_JMMUser> aniDBUsers = RepoFactory.JMMUser.GetAniDBUsers();                  if (aniDBUsers.Count == 0) return;                    SVR_JMMUser user = aniDBUsers[0];                    int score = 0;                  if (ser.GetAnime().UserVote != null)                      score = ser.GetAnime().UserVote.VoteValue / 100;                    // e.g.                  // AniDB - Code Geass R2                  // MAL Equivalent = AniDB Normal Eps 1 - 25 / Code Geass: Hangyaku no Lelouch R2 / hxxp://myanimelist.net/anime/2904/Code_Geass:_Hangyaku_no_Lelouch_R2                  // MAL Equivalent = AniDB Special Eps 1 - 9 / Code Geass: Hangyaku no Lelouch R2 Picture Drama / hxxp://myanimelist.net/anime/5163/Code_Geass:_Hangyaku_no_Lelouch_R2_Picture_Drama                  // MAL Equivalent = AniDB Special Eps 9 - 18 / Code Geass: Hangyaku no Lelouch R2: Flash Specials / hxxp://myanimelist.net/anime/9591/Code_Geass:_Hangyaku_no_Lelouch_R2:_Flash_Specials                  // MAL Equivalent = AniDB Special Eps 20 / Code Geass: Hangyaku no Lelouch - Kiseki no Birthday Picture Drama / hxxp://myanimelist.net/anime/8728/Code_Geass:_Hangyaku_no_Lelouch_-_Kiseki_no_Birthday_Picture_Drama                    foreach (CrossRef_AniDB_MAL xref in crossRefs)                  {                      // look for the right MAL id                      int malID = -1;                      int epNumber = -1;                      int totalEpCount = -1;                        List<string> fanSubGroups = new List<string>();                        // for each cross ref (which is a series on MAL) we need to update the data                      // so find all the episodes which apply to this cross ref                      int lastWatchedEpNumber = 0;                      int downloadedEps = 0;                        foreach (SVR_AnimeEpisode ep in eps)                      {                          int epNum = ep.AniDB_Episode.EpisodeNumber;                          if (xref.StartEpisodeType == (int) ep.EpisodeTypeEnum && epNum >= xref.StartEpisodeNumber &&                              epNum <= GetUpperEpisodeLimit(crossRefs' xref))                          {                              malID = xref.MALID;                              epNumber = epNum - xref.StartEpisodeNumber + 1;                                // find the total episode count                              if (totalEpCount < 0)                              {                                  if (ep.EpisodeTypeEnum == EpisodeType.Episode)                                      totalEpCount = ser.GetAnime().EpisodeCountNormal;                                  if (ep.EpisodeTypeEnum == EpisodeType.Special)                                      totalEpCount = ser.GetAnime().EpisodeCountSpecial;                                  totalEpCount = totalEpCount - xref.StartEpisodeNumber + 1;                              }                                // any episodes here belong to the MAL series                              // find the latest watched episod enumber                              SVR_AnimeEpisode_User usrRecord = ep.GetUserRecord(user.JMMUserID);                              if (usrRecord?.WatchedDate != null && epNum > lastWatchedEpNumber)                              {                                  lastWatchedEpNumber = epNum;                              }                                List<CL_VideoDetailed> contracts = ep.GetVideoDetailedContracts(user.JMMUserID);                                // find the latest episode number in the collection                              if (contracts.Count > 0)                                  downloadedEps++;                                foreach (CL_VideoDetailed contract in contracts)                              {                                  if (!string.IsNullOrEmpty(contract.AniDB_Anime_GroupNameShort) &&                                      !fanSubGroups.Contains(contract.AniDB_Anime_GroupNameShort))                                      fanSubGroups.Add(contract.AniDB_Anime_GroupNameShort);                              }                          }                      }                        string fanSubs = string.Empty;                      foreach (string fgrp in fanSubGroups)                      {                          if (!string.IsNullOrEmpty(fanSubs)) fanSubs += "'";                          fanSubs += fgrp;                      }                        // determine status                      int status = 1; //watching                      int lastWatchedEpNumberMAL = 0;                      if (animeListHashtable.ContainsKey(malID))                      {                          myanimelistAnime animeInList = (myanimelistAnime) animeListHashtable[malID];                          status = animeInList.my_status;                          lastWatchedEpNumberMAL = animeInList.my_watched_episodes;                      }                        // over-ride is user has watched an episode                      // don't override on hold (3) or dropped (4) but do override plan to watch (6)                      if (status == 6 && lastWatchedEpNumber > 0) status = 1; //watching                      if (lastWatchedEpNumber == totalEpCount) status = 2; //completed                        if (lastWatchedEpNumber > totalEpCount)                      {                          logger.Error("updateMAL' episode number > matching anime episode total : {0} ({1}) / {2}"'                              ser.GetAnime().GetFormattedTitle()' ser.GetAnime().AnimeID' epNumber);                          continue;                      }                        if (malID <= 0 || totalEpCount <= 0)                      {                          logger.Warn("Could not find MAL link for : {0} ({1})"' ser.GetAnime().GetFormattedTitle()'                              ser.GetAnime().AnimeID);                          continue;                      }                        string confirmationMessage = string.Empty;                      if (animeListHashtable.ContainsKey(malID))                      {                          if ((ServerSettings.MAL_NeverDecreaseWatchedNums && lastWatchedEpNumberMAL > 0) && lastWatchedEpNumber <= lastWatchedEpNumberMAL)                          {                              continue;                          }                            ModifyAnime(malID' lastWatchedEpNumber' status' score' downloadedEps' fanSubs);                          confirmationMessage = string.Format(                              "MAL successfully updated (MAL MODIFY)' mal id: {0}' ep: {1}' score: {2}"' malID'                              lastWatchedEpNumber' score);                      }                      else                      {                          AddAnime(malID' lastWatchedEpNumber' status' score' downloadedEps' fanSubs);                          confirmationMessage = string.Format(                              "MAL successfully updated (MAL ADD)' mal id: {0}' ep: {1}' score: {2}"' malID'                              lastWatchedEpNumber' score);                      }                      logger.Trace(confirmationMessage);                  }              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server.Providers.MyAnimeList,MALHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\MyAnimeList\MALHelper.cs,UpdateMALSeries,The following statement contains a magic number: try              {                  if (string.IsNullOrEmpty(ServerSettings.MAL_Username) ||                      string.IsNullOrEmpty(ServerSettings.MAL_Password))                      return;                    // Populate MAL animelist hashtable if isNeverDecreaseWatched set                  Hashtable animeListHashtable = new Hashtable();                  myanimelist malAnimeList = GetMALAnimeList();                    if (ServerSettings.MAL_NeverDecreaseWatchedNums)                      //if set' check watched number before update: take some time' as user anime list must be loaded                  {                      if (malAnimeList != null && malAnimeList.anime != null)                      {                          for (int i = 0; i < malAnimeList.anime.Length; i++)                          {                              animeListHashtable.Add(malAnimeList.anime[i].series_animedb_id' malAnimeList.anime[i]);                          }                      }                  }                    // look for MAL Links                  List<CrossRef_AniDB_MAL> crossRefs = ser.GetAnime().GetCrossRefMAL();                  if (crossRefs == null || crossRefs.Count == 0)                  {                      logger.Warn("Could not find MAL link for : {0} ({1})"' ser.GetAnime().GetFormattedTitle()'                          ser.GetAnime().AnimeID);                      return;                  }                    List<SVR_AnimeEpisode> eps = ser.GetAnimeEpisodes();                    // find the anidb user                  List<SVR_JMMUser> aniDBUsers = RepoFactory.JMMUser.GetAniDBUsers();                  if (aniDBUsers.Count == 0) return;                    SVR_JMMUser user = aniDBUsers[0];                    int score = 0;                  if (ser.GetAnime().UserVote != null)                      score = ser.GetAnime().UserVote.VoteValue / 100;                    // e.g.                  // AniDB - Code Geass R2                  // MAL Equivalent = AniDB Normal Eps 1 - 25 / Code Geass: Hangyaku no Lelouch R2 / hxxp://myanimelist.net/anime/2904/Code_Geass:_Hangyaku_no_Lelouch_R2                  // MAL Equivalent = AniDB Special Eps 1 - 9 / Code Geass: Hangyaku no Lelouch R2 Picture Drama / hxxp://myanimelist.net/anime/5163/Code_Geass:_Hangyaku_no_Lelouch_R2_Picture_Drama                  // MAL Equivalent = AniDB Special Eps 9 - 18 / Code Geass: Hangyaku no Lelouch R2: Flash Specials / hxxp://myanimelist.net/anime/9591/Code_Geass:_Hangyaku_no_Lelouch_R2:_Flash_Specials                  // MAL Equivalent = AniDB Special Eps 20 / Code Geass: Hangyaku no Lelouch - Kiseki no Birthday Picture Drama / hxxp://myanimelist.net/anime/8728/Code_Geass:_Hangyaku_no_Lelouch_-_Kiseki_no_Birthday_Picture_Drama                    foreach (CrossRef_AniDB_MAL xref in crossRefs)                  {                      // look for the right MAL id                      int malID = -1;                      int epNumber = -1;                      int totalEpCount = -1;                        List<string> fanSubGroups = new List<string>();                        // for each cross ref (which is a series on MAL) we need to update the data                      // so find all the episodes which apply to this cross ref                      int lastWatchedEpNumber = 0;                      int downloadedEps = 0;                        foreach (SVR_AnimeEpisode ep in eps)                      {                          int epNum = ep.AniDB_Episode.EpisodeNumber;                          if (xref.StartEpisodeType == (int) ep.EpisodeTypeEnum && epNum >= xref.StartEpisodeNumber &&                              epNum <= GetUpperEpisodeLimit(crossRefs' xref))                          {                              malID = xref.MALID;                              epNumber = epNum - xref.StartEpisodeNumber + 1;                                // find the total episode count                              if (totalEpCount < 0)                              {                                  if (ep.EpisodeTypeEnum == EpisodeType.Episode)                                      totalEpCount = ser.GetAnime().EpisodeCountNormal;                                  if (ep.EpisodeTypeEnum == EpisodeType.Special)                                      totalEpCount = ser.GetAnime().EpisodeCountSpecial;                                  totalEpCount = totalEpCount - xref.StartEpisodeNumber + 1;                              }                                // any episodes here belong to the MAL series                              // find the latest watched episod enumber                              SVR_AnimeEpisode_User usrRecord = ep.GetUserRecord(user.JMMUserID);                              if (usrRecord?.WatchedDate != null && epNum > lastWatchedEpNumber)                              {                                  lastWatchedEpNumber = epNum;                              }                                List<CL_VideoDetailed> contracts = ep.GetVideoDetailedContracts(user.JMMUserID);                                // find the latest episode number in the collection                              if (contracts.Count > 0)                                  downloadedEps++;                                foreach (CL_VideoDetailed contract in contracts)                              {                                  if (!string.IsNullOrEmpty(contract.AniDB_Anime_GroupNameShort) &&                                      !fanSubGroups.Contains(contract.AniDB_Anime_GroupNameShort))                                      fanSubGroups.Add(contract.AniDB_Anime_GroupNameShort);                              }                          }                      }                        string fanSubs = string.Empty;                      foreach (string fgrp in fanSubGroups)                      {                          if (!string.IsNullOrEmpty(fanSubs)) fanSubs += "'";                          fanSubs += fgrp;                      }                        // determine status                      int status = 1; //watching                      int lastWatchedEpNumberMAL = 0;                      if (animeListHashtable.ContainsKey(malID))                      {                          myanimelistAnime animeInList = (myanimelistAnime) animeListHashtable[malID];                          status = animeInList.my_status;                          lastWatchedEpNumberMAL = animeInList.my_watched_episodes;                      }                        // over-ride is user has watched an episode                      // don't override on hold (3) or dropped (4) but do override plan to watch (6)                      if (status == 6 && lastWatchedEpNumber > 0) status = 1; //watching                      if (lastWatchedEpNumber == totalEpCount) status = 2; //completed                        if (lastWatchedEpNumber > totalEpCount)                      {                          logger.Error("updateMAL' episode number > matching anime episode total : {0} ({1}) / {2}"'                              ser.GetAnime().GetFormattedTitle()' ser.GetAnime().AnimeID' epNumber);                          continue;                      }                        if (malID <= 0 || totalEpCount <= 0)                      {                          logger.Warn("Could not find MAL link for : {0} ({1})"' ser.GetAnime().GetFormattedTitle()'                              ser.GetAnime().AnimeID);                          continue;                      }                        string confirmationMessage = string.Empty;                      if (animeListHashtable.ContainsKey(malID))                      {                          if ((ServerSettings.MAL_NeverDecreaseWatchedNums && lastWatchedEpNumberMAL > 0) && lastWatchedEpNumber <= lastWatchedEpNumberMAL)                          {                              continue;                          }                            ModifyAnime(malID' lastWatchedEpNumber' status' score' downloadedEps' fanSubs);                          confirmationMessage = string.Format(                              "MAL successfully updated (MAL MODIFY)' mal id: {0}' ep: {1}' score: {2}"' malID'                              lastWatchedEpNumber' score);                      }                      else                      {                          AddAnime(malID' lastWatchedEpNumber' status' score' downloadedEps' fanSubs);                          confirmationMessage = string.Format(                              "MAL successfully updated (MAL ADD)' mal id: {0}' ep: {1}' score: {2}"' malID'                              lastWatchedEpNumber' score);                      }                      logger.Trace(confirmationMessage);                  }              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());              }
Magic Number,Shoko.Server.Providers.MyAnimeList,HtmlEntities,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\MyAnimeList\MALHelper.cs,Lookup,The following statement contains a magic number: if (_entitiesLookupTable == null)              {                  lock (_lookupLockObject)                  {                      if (_entitiesLookupTable == null)                      {                          Hashtable hashtable = new Hashtable();                          foreach (string str in _entitiesList)                          {                              hashtable[str.Substring(2)] = str[0];                          }                          _entitiesLookupTable = hashtable;                      }                  }              }
Magic Number,Shoko.Server.Providers.MyAnimeList,HttpUtilityV2,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\MyAnimeList\MALHelper.cs,HtmlDecode,The following statement contains a magic number: if (s != null)              {                  if (s.IndexOf('&') < 0)                  {                      output.Write(s);                  }                  else                  {                      int length = s.Length;                      for (int i = 0; i < length; i++)                      {                          char ch = s[i];                          if (ch == '&')                          {                              int num3 = s.IndexOfAny(s_entityEndingChars' i + 1);                              if ((num3 > 0) && (s[num3] == ';'))                              {                                  string entity = s.Substring(i + 1' num3 - i - 1);                                  if ((entity.Length > 1) && (entity[0] == '#'))                                  {                                      try                                      {                                          if ((entity[1] == 'x') || (entity[1] == 'X'))                                          {                                              ch = (char) int.Parse(entity.Substring(2)' NumberStyles.AllowHexSpecifier);                                          }                                          else                                          {                                              ch = (char) int.Parse(entity.Substring(1));                                          }                                          i = num3;                                      }                                      catch (FormatException)                                      {                                          i++;                                      }                                      catch (ArgumentException)                                      {                                          i++;                                      }                                  }                                  else                                  {                                      i = num3;                                      char ch2 = HtmlEntities.Lookup(entity);                                      if (ch2 != '\0')                                      {                                          ch = ch2;                                      }                                      else                                      {                                          output.Write('&');                                          output.Write(entity);                                          output.Write(';');                                          goto Label_0103;                                      }                                  }                              }                          }                          output.Write(ch);                          Label_0103:                          ;                      }                  }              }
Magic Number,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,SendData,The following statement contains a magic number: int ret = 400;
Magic Number,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,SendData,The following statement contains a magic number: try              {                  byte[] data = new UTF8Encoding().GetBytes(json);                    string msg = "Trakt SEND Data" + Environment.NewLine +                               "Verb: " + verb + Environment.NewLine +                               "uri: " + uri + Environment.NewLine +                               "json: " + json + Environment.NewLine;                  logger.Trace(msg);                    var request = (HttpWebRequest) WebRequest.Create(uri);                  request.KeepAlive = true;                    request.Method = verb;                  request.ContentLength = data.Length;                  request.Timeout = 120000;                  request.ContentType = "application/json";                  request.UserAgent = "JMM";                  foreach (var header in headers)                  {                      request.Headers.Add(header.Key' header.Value);                  }                    // post to trakt                  Stream postStream = request.GetRequestStream();                  postStream.Write(data' 0' data.Length);                    // get the response                  var response = (HttpWebResponse) request.GetResponse();                    Stream responseStream = response.GetResponseStream();                  if (responseStream == null) return ret;                    StreamReader reader = new StreamReader(responseStream);                  string strResponse = reader.ReadToEnd();                    int statusCode = (int) response.StatusCode;                    // cleanup                  postStream.Close();                  responseStream.Close();                  reader.Close();                  response.Close();                    webResponse = strResponse;                    msg = "Trakt SEND Data - Response" + Environment.NewLine +                        "Status Code: " + statusCode + Environment.NewLine +                        "Response: " + strResponse + Environment.NewLine;                  logger.Trace(msg);                    return statusCode;              }              catch (WebException webEx)              {                  if (webEx.Status == WebExceptionStatus.ProtocolError)                  {                      if (webEx.Response is HttpWebResponse response)                      {                          logger.Error($"Error in SendData: {(int) response.StatusCode} - {webEx}");                          ret = (int) response.StatusCode;                            try                          {                              Stream responseStream2 = response.GetResponseStream();                              if (responseStream2 == null) return ret;                              StreamReader reader2 = new StreamReader(responseStream2);                              webResponse = reader2.ReadToEnd();                              logger.Error($"Error in SendData: {webResponse}");                          }                          catch                          {                              // ignore                          }                      }                  }                  Console.Write(webEx.ToString());              }              catch (Exception ex)              {                  logger.Error($"Error in SendData: {ex}");              }
Magic Number,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,GetFromTrakt,The following statement contains a magic number: int retCode = 400;
Magic Number,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,GetFromTrakt,The following statement contains a magic number: request.Timeout = 120000;
Magic Number,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,GetTraktEpisodeIdV2,The following statement contains a magic number: try              {                  if (traktSummary == null) return null;                  int? traktEpId = null;                    #region normal episodes                    // now do stuff to improve performance                  if (ep.GetEpisodeTypeEnum() == EpisodeType.Episode)                  {                      if (traktSummary.CrossRefTraktV2 != null &&                          traktSummary.CrossRefTraktV2.Count > 0)                      {                          // find the xref that is right                          // relies on the xref's being sorted by season number and then episode number (desc)                          List<CrossRef_AniDB_TraktV2> traktCrossRef =                              traktSummary.CrossRefTraktV2.OrderByDescending(a => a.AniDBStartEpisodeNumber).ToList();                            bool foundStartingPoint = false;                          CrossRef_AniDB_TraktV2 xrefBase = null;                          foreach (CrossRef_AniDB_TraktV2 xrefTrakt in traktCrossRef)                          {                              if (xrefTrakt.AniDBStartEpisodeType != (int) EpisodeType.Episode) continue;                              if (ep.EpisodeNumber >= xrefTrakt.AniDBStartEpisodeNumber)                              {                                  foundStartingPoint = true;                                  xrefBase = xrefTrakt;                                  break;                              }                          }                            // we have found the starting epiosde numbder from AniDB                          // now let's check that the Trakt Season and Episode Number exist                          if (foundStartingPoint)                          {                              Dictionary<int' int> dictTraktSeasons = null;                              Dictionary<int' Trakt_Episode> dictTraktEpisodes = null;                              foreach (TraktDetailsContainer det in traktSummary.TraktDetails.Values)                              {                                  if (det.TraktID == xrefBase.TraktID)                                  {                                      dictTraktSeasons = det.DictTraktSeasons;                                      dictTraktEpisodes = det.DictTraktEpisodes;                                      break;                                  }                              }                                if (dictTraktSeasons != null && dictTraktSeasons.ContainsKey(xrefBase.TraktSeasonNumber))                              {                                  int episodeNumber = dictTraktSeasons[xrefBase.TraktSeasonNumber] +                                                      (ep.EpisodeNumber + xrefBase.TraktStartEpisodeNumber - 2) -                                                      (xrefBase.AniDBStartEpisodeNumber - 1);                                  if (dictTraktEpisodes.ContainsKey(episodeNumber))                                  {                                      Trakt_Episode traktep = dictTraktEpisodes[episodeNumber];                                      traktID = xrefBase.TraktID;                                      season = traktep.Season;                                      epNumber = traktep.EpisodeNumber;                                      traktEpId = traktep.TraktID;                                  }                              }                          }                      }                  }                    #endregion                    #region special episodes                    if (ep.GetEpisodeTypeEnum() == EpisodeType.Special)                  {                      // find the xref that is right                      // relies on the xref's being sorted by season number and then episode number (desc)                      List<CrossRef_AniDB_TraktV2> traktCrossRef =                          traktSummary.CrossRefTraktV2?.OrderByDescending(a => a.AniDBStartEpisodeNumber).ToList();                        if (traktCrossRef == null) return null;                      bool foundStartingPoint = false;                      CrossRef_AniDB_TraktV2 xrefBase = null;                      foreach (CrossRef_AniDB_TraktV2 xrefTrakt in traktCrossRef)                      {                          if (xrefTrakt.AniDBStartEpisodeType != (int) EpisodeType.Special) continue;                          if (ep.EpisodeNumber >= xrefTrakt.AniDBStartEpisodeNumber)                          {                              foundStartingPoint = true;                              xrefBase = xrefTrakt;                              break;                          }                      }                        // we have found the starting epiosde numbder from AniDB                      // now let's check that the Trakt Season and Episode Number exist                      if (foundStartingPoint)                      {                          Dictionary<int' int> dictTraktSeasons = null;                          Dictionary<int' Trakt_Episode> dictTraktEpisodes = null;                          foreach (TraktDetailsContainer det in traktSummary.TraktDetails.Values)                          {                              if (det.TraktID == xrefBase.TraktID)                              {                                  dictTraktSeasons = det.DictTraktSeasons;                                  dictTraktEpisodes = det.DictTraktEpisodes;                                  break;                              }                          }                            if (dictTraktSeasons != null && dictTraktSeasons.ContainsKey(xrefBase.TraktSeasonNumber))                          {                              int episodeNumber = dictTraktSeasons[xrefBase.TraktSeasonNumber] +                                                  (ep.EpisodeNumber + xrefBase.TraktStartEpisodeNumber - 2) -                                                  (xrefBase.AniDBStartEpisodeNumber - 1);                              if (dictTraktEpisodes != null && dictTraktEpisodes.ContainsKey(episodeNumber))                              {                                  Trakt_Episode traktep = dictTraktEpisodes[episodeNumber];                                  traktID = xrefBase.TraktID;                                  season = traktep.Season;                                  epNumber = traktep.EpisodeNumber;                                  traktEpId = traktep.TraktID;                              }                          }                      }                  }                    #endregion                    return traktEpId;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());                  return null;              }
Magic Number,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,GetTraktEpisodeIdV2,The following statement contains a magic number: try              {                  if (traktSummary == null) return null;                  int? traktEpId = null;                    #region normal episodes                    // now do stuff to improve performance                  if (ep.GetEpisodeTypeEnum() == EpisodeType.Episode)                  {                      if (traktSummary.CrossRefTraktV2 != null &&                          traktSummary.CrossRefTraktV2.Count > 0)                      {                          // find the xref that is right                          // relies on the xref's being sorted by season number and then episode number (desc)                          List<CrossRef_AniDB_TraktV2> traktCrossRef =                              traktSummary.CrossRefTraktV2.OrderByDescending(a => a.AniDBStartEpisodeNumber).ToList();                            bool foundStartingPoint = false;                          CrossRef_AniDB_TraktV2 xrefBase = null;                          foreach (CrossRef_AniDB_TraktV2 xrefTrakt in traktCrossRef)                          {                              if (xrefTrakt.AniDBStartEpisodeType != (int) EpisodeType.Episode) continue;                              if (ep.EpisodeNumber >= xrefTrakt.AniDBStartEpisodeNumber)                              {                                  foundStartingPoint = true;                                  xrefBase = xrefTrakt;                                  break;                              }                          }                            // we have found the starting epiosde numbder from AniDB                          // now let's check that the Trakt Season and Episode Number exist                          if (foundStartingPoint)                          {                              Dictionary<int' int> dictTraktSeasons = null;                              Dictionary<int' Trakt_Episode> dictTraktEpisodes = null;                              foreach (TraktDetailsContainer det in traktSummary.TraktDetails.Values)                              {                                  if (det.TraktID == xrefBase.TraktID)                                  {                                      dictTraktSeasons = det.DictTraktSeasons;                                      dictTraktEpisodes = det.DictTraktEpisodes;                                      break;                                  }                              }                                if (dictTraktSeasons != null && dictTraktSeasons.ContainsKey(xrefBase.TraktSeasonNumber))                              {                                  int episodeNumber = dictTraktSeasons[xrefBase.TraktSeasonNumber] +                                                      (ep.EpisodeNumber + xrefBase.TraktStartEpisodeNumber - 2) -                                                      (xrefBase.AniDBStartEpisodeNumber - 1);                                  if (dictTraktEpisodes.ContainsKey(episodeNumber))                                  {                                      Trakt_Episode traktep = dictTraktEpisodes[episodeNumber];                                      traktID = xrefBase.TraktID;                                      season = traktep.Season;                                      epNumber = traktep.EpisodeNumber;                                      traktEpId = traktep.TraktID;                                  }                              }                          }                      }                  }                    #endregion                    #region special episodes                    if (ep.GetEpisodeTypeEnum() == EpisodeType.Special)                  {                      // find the xref that is right                      // relies on the xref's being sorted by season number and then episode number (desc)                      List<CrossRef_AniDB_TraktV2> traktCrossRef =                          traktSummary.CrossRefTraktV2?.OrderByDescending(a => a.AniDBStartEpisodeNumber).ToList();                        if (traktCrossRef == null) return null;                      bool foundStartingPoint = false;                      CrossRef_AniDB_TraktV2 xrefBase = null;                      foreach (CrossRef_AniDB_TraktV2 xrefTrakt in traktCrossRef)                      {                          if (xrefTrakt.AniDBStartEpisodeType != (int) EpisodeType.Special) continue;                          if (ep.EpisodeNumber >= xrefTrakt.AniDBStartEpisodeNumber)                          {                              foundStartingPoint = true;                              xrefBase = xrefTrakt;                              break;                          }                      }                        // we have found the starting epiosde numbder from AniDB                      // now let's check that the Trakt Season and Episode Number exist                      if (foundStartingPoint)                      {                          Dictionary<int' int> dictTraktSeasons = null;                          Dictionary<int' Trakt_Episode> dictTraktEpisodes = null;                          foreach (TraktDetailsContainer det in traktSummary.TraktDetails.Values)                          {                              if (det.TraktID == xrefBase.TraktID)                              {                                  dictTraktSeasons = det.DictTraktSeasons;                                  dictTraktEpisodes = det.DictTraktEpisodes;                                  break;                              }                          }                            if (dictTraktSeasons != null && dictTraktSeasons.ContainsKey(xrefBase.TraktSeasonNumber))                          {                              int episodeNumber = dictTraktSeasons[xrefBase.TraktSeasonNumber] +                                                  (ep.EpisodeNumber + xrefBase.TraktStartEpisodeNumber - 2) -                                                  (xrefBase.AniDBStartEpisodeNumber - 1);                              if (dictTraktEpisodes != null && dictTraktEpisodes.ContainsKey(episodeNumber))                              {                                  Trakt_Episode traktep = dictTraktEpisodes[episodeNumber];                                  traktID = xrefBase.TraktID;                                  season = traktep.Season;                                  epNumber = traktep.EpisodeNumber;                                  traktEpId = traktep.TraktID;                              }                          }                      }                  }                    #endregion                    return traktEpId;              }              catch (Exception ex)              {                  logger.Error(ex' ex.ToString());                  return null;              }
Magic Number,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,Scrobble,The following statement contains a magic number: try              {                  if (!ServerSettings.Trakt_IsEnabled || string.IsNullOrEmpty(ServerSettings.Trakt_AuthToken))                      return 401;                    string json = string.Empty;                    string url;                  switch (scrobbleStatus)                  {                      case ScrobblePlayingStatus.Start:                          url = TraktURIs.SetScrobbleStart;                          break;                      case ScrobblePlayingStatus.Pause:                          url = TraktURIs.SetScrobblePause;                          break;                      case ScrobblePlayingStatus.Stop:                          url = TraktURIs.SetScrobbleStop;                          break;                      default:                          return 400;                  }                    //1.get traktid and slugid from episode id                  if (!int.TryParse(AnimeEpisodeID' out int aep)) return 400;                  SVR_AnimeEpisode ep = RepoFactory.AnimeEpisode.GetByID(aep);                  string slugID = string.Empty;                  int season = 0;                  int epNumber = 0;                  int? traktID = GetTraktEpisodeIdV2(ep' ref slugID' ref season' ref epNumber);                    //2.generate json                  if (traktID != null && traktID > 0)                  {                      switch (scrobbleType)                      {                          case ScrobblePlayingType.episode:                              TraktV2ScrobbleEpisode showE = new TraktV2ScrobbleEpisode();                              showE.Init(progress' traktID' slugID' season' epNumber);                              json = JSONHelper.Serialize(showE);                              break;                            //do we have any movies that work?                          case ScrobblePlayingType.movie:                              TraktV2ScrobbleMovie showM = new TraktV2ScrobbleMovie();                              json = JSONHelper.Serialize(showM);                              showM.Init(progress' slugID' traktID.ToString());                              break;                      }                      //3. send Json                      string retData = string.Empty;                      SendData(url' json' "POST"' BuildRequestHeaders()' ref retData);                  }                  else                  {                      //3. nothing to send log error                      logger.Warn("TraktTVHelper.Scrobble: No TraktID found for: " + "AnimeEpisodeID: " + aep +                                  " AnimeRomajiName: " + ep.AniDB_Episode.RomajiName);                      return 404;                  }                  return 200;              }              catch (Exception ex)              {                  logger.Error(ex' "Error in TraktTVHelper.Scrobble: " + ex);                  return 500;              }
Magic Number,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,Scrobble,The following statement contains a magic number: try              {                  if (!ServerSettings.Trakt_IsEnabled || string.IsNullOrEmpty(ServerSettings.Trakt_AuthToken))                      return 401;                    string json = string.Empty;                    string url;                  switch (scrobbleStatus)                  {                      case ScrobblePlayingStatus.Start:                          url = TraktURIs.SetScrobbleStart;                          break;                      case ScrobblePlayingStatus.Pause:                          url = TraktURIs.SetScrobblePause;                          break;                      case ScrobblePlayingStatus.Stop:                          url = TraktURIs.SetScrobbleStop;                          break;                      default:                          return 400;                  }                    //1.get traktid and slugid from episode id                  if (!int.TryParse(AnimeEpisodeID' out int aep)) return 400;                  SVR_AnimeEpisode ep = RepoFactory.AnimeEpisode.GetByID(aep);                  string slugID = string.Empty;                  int season = 0;                  int epNumber = 0;                  int? traktID = GetTraktEpisodeIdV2(ep' ref slugID' ref season' ref epNumber);                    //2.generate json                  if (traktID != null && traktID > 0)                  {                      switch (scrobbleType)                      {                          case ScrobblePlayingType.episode:                              TraktV2ScrobbleEpisode showE = new TraktV2ScrobbleEpisode();                              showE.Init(progress' traktID' slugID' season' epNumber);                              json = JSONHelper.Serialize(showE);                              break;                            //do we have any movies that work?                          case ScrobblePlayingType.movie:                              TraktV2ScrobbleMovie showM = new TraktV2ScrobbleMovie();                              json = JSONHelper.Serialize(showM);                              showM.Init(progress' slugID' traktID.ToString());                              break;                      }                      //3. send Json                      string retData = string.Empty;                      SendData(url' json' "POST"' BuildRequestHeaders()' ref retData);                  }                  else                  {                      //3. nothing to send log error                      logger.Warn("TraktTVHelper.Scrobble: No TraktID found for: " + "AnimeEpisodeID: " + aep +                                  " AnimeRomajiName: " + ep.AniDB_Episode.RomajiName);                      return 404;                  }                  return 200;              }              catch (Exception ex)              {                  logger.Error(ex' "Error in TraktTVHelper.Scrobble: " + ex);                  return 500;              }
Magic Number,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,Scrobble,The following statement contains a magic number: try              {                  if (!ServerSettings.Trakt_IsEnabled || string.IsNullOrEmpty(ServerSettings.Trakt_AuthToken))                      return 401;                    string json = string.Empty;                    string url;                  switch (scrobbleStatus)                  {                      case ScrobblePlayingStatus.Start:                          url = TraktURIs.SetScrobbleStart;                          break;                      case ScrobblePlayingStatus.Pause:                          url = TraktURIs.SetScrobblePause;                          break;                      case ScrobblePlayingStatus.Stop:                          url = TraktURIs.SetScrobbleStop;                          break;                      default:                          return 400;                  }                    //1.get traktid and slugid from episode id                  if (!int.TryParse(AnimeEpisodeID' out int aep)) return 400;                  SVR_AnimeEpisode ep = RepoFactory.AnimeEpisode.GetByID(aep);                  string slugID = string.Empty;                  int season = 0;                  int epNumber = 0;                  int? traktID = GetTraktEpisodeIdV2(ep' ref slugID' ref season' ref epNumber);                    //2.generate json                  if (traktID != null && traktID > 0)                  {                      switch (scrobbleType)                      {                          case ScrobblePlayingType.episode:                              TraktV2ScrobbleEpisode showE = new TraktV2ScrobbleEpisode();                              showE.Init(progress' traktID' slugID' season' epNumber);                              json = JSONHelper.Serialize(showE);                              break;                            //do we have any movies that work?                          case ScrobblePlayingType.movie:                              TraktV2ScrobbleMovie showM = new TraktV2ScrobbleMovie();                              json = JSONHelper.Serialize(showM);                              showM.Init(progress' slugID' traktID.ToString());                              break;                      }                      //3. send Json                      string retData = string.Empty;                      SendData(url' json' "POST"' BuildRequestHeaders()' ref retData);                  }                  else                  {                      //3. nothing to send log error                      logger.Warn("TraktTVHelper.Scrobble: No TraktID found for: " + "AnimeEpisodeID: " + aep +                                  " AnimeRomajiName: " + ep.AniDB_Episode.RomajiName);                      return 404;                  }                  return 200;              }              catch (Exception ex)              {                  logger.Error(ex' "Error in TraktTVHelper.Scrobble: " + ex);                  return 500;              }
Magic Number,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,Scrobble,The following statement contains a magic number: try              {                  if (!ServerSettings.Trakt_IsEnabled || string.IsNullOrEmpty(ServerSettings.Trakt_AuthToken))                      return 401;                    string json = string.Empty;                    string url;                  switch (scrobbleStatus)                  {                      case ScrobblePlayingStatus.Start:                          url = TraktURIs.SetScrobbleStart;                          break;                      case ScrobblePlayingStatus.Pause:                          url = TraktURIs.SetScrobblePause;                          break;                      case ScrobblePlayingStatus.Stop:                          url = TraktURIs.SetScrobbleStop;                          break;                      default:                          return 400;                  }                    //1.get traktid and slugid from episode id                  if (!int.TryParse(AnimeEpisodeID' out int aep)) return 400;                  SVR_AnimeEpisode ep = RepoFactory.AnimeEpisode.GetByID(aep);                  string slugID = string.Empty;                  int season = 0;                  int epNumber = 0;                  int? traktID = GetTraktEpisodeIdV2(ep' ref slugID' ref season' ref epNumber);                    //2.generate json                  if (traktID != null && traktID > 0)                  {                      switch (scrobbleType)                      {                          case ScrobblePlayingType.episode:                              TraktV2ScrobbleEpisode showE = new TraktV2ScrobbleEpisode();                              showE.Init(progress' traktID' slugID' season' epNumber);                              json = JSONHelper.Serialize(showE);                              break;                            //do we have any movies that work?                          case ScrobblePlayingType.movie:                              TraktV2ScrobbleMovie showM = new TraktV2ScrobbleMovie();                              json = JSONHelper.Serialize(showM);                              showM.Init(progress' slugID' traktID.ToString());                              break;                      }                      //3. send Json                      string retData = string.Empty;                      SendData(url' json' "POST"' BuildRequestHeaders()' ref retData);                  }                  else                  {                      //3. nothing to send log error                      logger.Warn("TraktTVHelper.Scrobble: No TraktID found for: " + "AnimeEpisodeID: " + aep +                                  " AnimeRomajiName: " + ep.AniDB_Episode.RomajiName);                      return 404;                  }                  return 200;              }              catch (Exception ex)              {                  logger.Error(ex' "Error in TraktTVHelper.Scrobble: " + ex);                  return 500;              }
Magic Number,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,Scrobble,The following statement contains a magic number: try              {                  if (!ServerSettings.Trakt_IsEnabled || string.IsNullOrEmpty(ServerSettings.Trakt_AuthToken))                      return 401;                    string json = string.Empty;                    string url;                  switch (scrobbleStatus)                  {                      case ScrobblePlayingStatus.Start:                          url = TraktURIs.SetScrobbleStart;                          break;                      case ScrobblePlayingStatus.Pause:                          url = TraktURIs.SetScrobblePause;                          break;                      case ScrobblePlayingStatus.Stop:                          url = TraktURIs.SetScrobbleStop;                          break;                      default:                          return 400;                  }                    //1.get traktid and slugid from episode id                  if (!int.TryParse(AnimeEpisodeID' out int aep)) return 400;                  SVR_AnimeEpisode ep = RepoFactory.AnimeEpisode.GetByID(aep);                  string slugID = string.Empty;                  int season = 0;                  int epNumber = 0;                  int? traktID = GetTraktEpisodeIdV2(ep' ref slugID' ref season' ref epNumber);                    //2.generate json                  if (traktID != null && traktID > 0)                  {                      switch (scrobbleType)                      {                          case ScrobblePlayingType.episode:                              TraktV2ScrobbleEpisode showE = new TraktV2ScrobbleEpisode();                              showE.Init(progress' traktID' slugID' season' epNumber);                              json = JSONHelper.Serialize(showE);                              break;                            //do we have any movies that work?                          case ScrobblePlayingType.movie:                              TraktV2ScrobbleMovie showM = new TraktV2ScrobbleMovie();                              json = JSONHelper.Serialize(showM);                              showM.Init(progress' slugID' traktID.ToString());                              break;                      }                      //3. send Json                      string retData = string.Empty;                      SendData(url' json' "POST"' BuildRequestHeaders()' ref retData);                  }                  else                  {                      //3. nothing to send log error                      logger.Warn("TraktTVHelper.Scrobble: No TraktID found for: " + "AnimeEpisodeID: " + aep +                                  " AnimeRomajiName: " + ep.AniDB_Episode.RomajiName);                      return 404;                  }                  return 200;              }              catch (Exception ex)              {                  logger.Error(ex' "Error in TraktTVHelper.Scrobble: " + ex);                  return 500;              }
Magic Number,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,Scrobble,The following statement contains a magic number: try              {                  if (!ServerSettings.Trakt_IsEnabled || string.IsNullOrEmpty(ServerSettings.Trakt_AuthToken))                      return 401;                    string json = string.Empty;                    string url;                  switch (scrobbleStatus)                  {                      case ScrobblePlayingStatus.Start:                          url = TraktURIs.SetScrobbleStart;                          break;                      case ScrobblePlayingStatus.Pause:                          url = TraktURIs.SetScrobblePause;                          break;                      case ScrobblePlayingStatus.Stop:                          url = TraktURIs.SetScrobbleStop;                          break;                      default:                          return 400;                  }                    //1.get traktid and slugid from episode id                  if (!int.TryParse(AnimeEpisodeID' out int aep)) return 400;                  SVR_AnimeEpisode ep = RepoFactory.AnimeEpisode.GetByID(aep);                  string slugID = string.Empty;                  int season = 0;                  int epNumber = 0;                  int? traktID = GetTraktEpisodeIdV2(ep' ref slugID' ref season' ref epNumber);                    //2.generate json                  if (traktID != null && traktID > 0)                  {                      switch (scrobbleType)                      {                          case ScrobblePlayingType.episode:                              TraktV2ScrobbleEpisode showE = new TraktV2ScrobbleEpisode();                              showE.Init(progress' traktID' slugID' season' epNumber);                              json = JSONHelper.Serialize(showE);                              break;                            //do we have any movies that work?                          case ScrobblePlayingType.movie:                              TraktV2ScrobbleMovie showM = new TraktV2ScrobbleMovie();                              json = JSONHelper.Serialize(showM);                              showM.Init(progress' slugID' traktID.ToString());                              break;                      }                      //3. send Json                      string retData = string.Empty;                      SendData(url' json' "POST"' BuildRequestHeaders()' ref retData);                  }                  else                  {                      //3. nothing to send log error                      logger.Warn("TraktTVHelper.Scrobble: No TraktID found for: " + "AnimeEpisodeID: " + aep +                                  " AnimeRomajiName: " + ep.AniDB_Episode.RomajiName);                      return 404;                  }                  return 200;              }              catch (Exception ex)              {                  logger.Error(ex' "Error in TraktTVHelper.Scrobble: " + ex);                  return 500;              }
Magic Number,Shoko.Server.Security,CRC32,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Security\CRC32.cs,Reflect,The following statement contains a magic number: for (int i = 0; i < 32; i++)              {                  oval = (oval << 1) + (val & 1);                  val >>= 1;              }
Magic Number,Shoko.Server.Security,CRC32,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Security\CRC32.cs,BuildCRC32Table,The following statement contains a magic number: uint[] table = new uint[256];
Magic Number,Shoko.Server.Security,CRC32,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Security\CRC32.cs,BuildCRC32Table,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  dwCrc = (uint) i;                  for (int j = 8; j > 0; j--)                  {                      if ((dwCrc & 1) == 1)                          dwCrc = (dwCrc >> 1) ^ ulPolynomial;                      else                          dwCrc >>= 1;                  }                  table[i] = dwCrc;              }
Magic Number,Shoko.Server.Security,CRC32,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Security\CRC32.cs,BuildCRC32Table,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  dwCrc = (uint) i;                  for (int j = 8; j > 0; j--)                  {                      if ((dwCrc & 1) == 1)                          dwCrc = (dwCrc >> 1) ^ ulPolynomial;                      else                          dwCrc >>= 1;                  }                  table[i] = dwCrc;              }
Magic Number,Shoko.Server.Security,CRC32,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Security\CRC32.cs,CRC32,The following statement contains a magic number: this.HashSizeValue = 32;
Magic Number,Shoko.Server.Security,CRC32,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Security\CRC32.cs,HashCore,The following statement contains a magic number: for (int i = offset; i < offset + count; i++)              {                  ulong tabPtr = (m_crc & 0xFF) ^ buffer[i];                  m_crc >>= 8;                  m_crc ^= crc32Table[tabPtr];              }
Magic Number,Shoko.Server.Security,CRC32,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Security\CRC32.cs,HashFinal,The following statement contains a magic number: byte[] finalHash = new byte[4];
Magic Number,Shoko.Server.Security,CRC32,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Security\CRC32.cs,HashFinal,The following statement contains a magic number: finalHash[0] = (byte) ((finalCRC >> 24) & 0xFF);
Magic Number,Shoko.Server.Security,CRC32,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Security\CRC32.cs,HashFinal,The following statement contains a magic number: finalHash[1] = (byte) ((finalCRC >> 16) & 0xFF);
Magic Number,Shoko.Server.Security,CRC32,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Security\CRC32.cs,HashFinal,The following statement contains a magic number: finalHash[2] = (byte) ((finalCRC >> 8) & 0xFF);
Magic Number,Shoko.Server.Security,CRC32,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Security\CRC32.cs,HashFinal,The following statement contains a magic number: finalHash[2] = (byte) ((finalCRC >> 8) & 0xFF);
Magic Number,Shoko.Server.Security,CRC32,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Security\CRC32.cs,HashFinal,The following statement contains a magic number: finalHash[3] = (byte) ((finalCRC >> 0) & 0xFF);
Magic Number,LeanWork.IO.FileSystem,RecoveringFileSystemWatcher,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utilities\LeanWork\IO\FileSystem\RecoveringFileSystemWatcher.cs,BufferingFileSystemWatcher_Error,The following statement contains a magic number: var NetworkNameNoLongerAvailable = -2147467259;
Magic Number,LeanWork.IO.FileSystem,RecoveringFileSystemWatcher,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utilities\LeanWork\IO\FileSystem\RecoveringFileSystemWatcher.cs,BufferingFileSystemWatcher_Error,The following statement contains a magic number: var AccessIsDenied = -2147467259;
Duplicate Code,Shoko.Server,ShokoServiceImplementationMetro,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementationMetro.cs,SetTvDBInfo,The method contains a code clone-set at the following line numbers (starting from the method definition): ((65' 88)' (143' 166))
Duplicate Code,Shoko.Server,ShokoServiceImplementationMetro,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementationMetro.cs,SetTvDBInfo,The method contains a code clone-set at the following line numbers (starting from the method definition): ((92' 115)' (167' 190))
Duplicate Code,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,GetTraktEpisodeIdV2,The method contains a code clone-set at the following line numbers (starting from the method definition): ((25' 53)' (84' 112))
Duplicate Code,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,SyncCollectionToTrakt,The method contains a code clone-set at the following line numbers (starting from the method definition): ((103' 156)' (178' 231))
Missing Default,Shoko.Server,AniDBHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDBHelper.cs,GetMyListFileStatus,The following switch statement is missing a default case: switch (ev)                  {                          case enHelperActivityType.Banned_555:                              logger.Error("Recieved ban on trying to get MyList stats for file");                              return;                          // Ignore no info in MyList for file                          case enHelperActivityType.NoSuchMyListFile: return;                          case enHelperActivityType.LoginRequired:                              logger.Error("Not logged in to AniDB");                              return;                  }
Missing Default,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,IncrementEpisodeStats,The following switch statement is missing a default case: switch ((StatCountType) statCountType)                  {                      case StatCountType.Played:                          epUserRecord.PlayedCount++;                          break;                      case StatCountType.Stopped:                          epUserRecord.StoppedCount++;                          break;                      case StatCountType.Watched:                          epUserRecord.WatchedCount++;                          break;                  }
Missing Default,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,IncrementEpisodeStats,The following switch statement is missing a default case: switch ((StatCountType) statCountType)                  {                      case StatCountType.Played:                          userRecord.PlayedCount++;                          break;                      case StatCountType.Stopped:                          userRecord.StoppedCount++;                          break;                      case StatCountType.Watched:                          userRecord.WatchedCount++;                          break;                  }
Missing Default,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,EnableDisableImage,The following switch statement is missing a default case: switch (imgType)                  {                      case ImageEntityType.AniDB_Cover:                          SVR_AniDB_Anime anime = RepoFactory.AniDB_Anime.GetByAnimeID(imageID);                          if (anime == null) return "Could not find anime";                          anime.ImageEnabled = enabled ? 1 : 0;                          RepoFactory.AniDB_Anime.Save(anime);                          break;                        case ImageEntityType.TvDB_Banner:                          TvDB_ImageWideBanner banner = RepoFactory.TvDB_ImageWideBanner.GetByID(imageID);                          if (banner == null) return "Could not find image";                          banner.Enabled = enabled ? 1 : 0;                          RepoFactory.TvDB_ImageWideBanner.Save(banner);                          break;                        case ImageEntityType.TvDB_Cover:                          TvDB_ImagePoster poster = RepoFactory.TvDB_ImagePoster.GetByID(imageID);                          if (poster == null) return "Could not find image";                          poster.Enabled = enabled ? 1 : 0;                          RepoFactory.TvDB_ImagePoster.Save(poster);                          break;                        case ImageEntityType.TvDB_FanArt:                          TvDB_ImageFanart fanart = RepoFactory.TvDB_ImageFanart.GetByID(imageID);                          if (fanart == null) return "Could not find image";                          fanart.Enabled = enabled ? 1 : 0;                          RepoFactory.TvDB_ImageFanart.Save(fanart);                          break;                        case ImageEntityType.MovieDB_Poster:                          MovieDB_Poster moviePoster = RepoFactory.MovieDB_Poster.GetByID(imageID);                          if (moviePoster == null) return "Could not find image";                          moviePoster.Enabled = enabled ? 1 : 0;                          RepoFactory.MovieDB_Poster.Save(moviePoster);                          break;                        case ImageEntityType.MovieDB_FanArt:                          MovieDB_Fanart movieFanart = RepoFactory.MovieDB_Fanart.GetByID(imageID);                          if (movieFanart == null) return "Could not find image";                          movieFanart.Enabled = enabled ? 1 : 0;                          RepoFactory.MovieDB_Fanart.Save(movieFanart);                          break;                  }
Missing Default,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,SetDefaultImage,The following switch statement is missing a default case: switch (imgType)                  {                      case ImageEntityType.AniDB_Cover:                      case ImageEntityType.TvDB_Cover:                      case ImageEntityType.MovieDB_Poster:                          sizeType = ImageSizeType.Poster;                          break;                        case ImageEntityType.TvDB_Banner:                          sizeType = ImageSizeType.WideBanner;                          break;                        case ImageEntityType.TvDB_FanArt:                      case ImageEntityType.MovieDB_FanArt:                          sizeType = ImageSizeType.Fanart;                          break;                  }
Missing Default,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetRecommendations,The following switch statement is missing a default case: switch (recommendationType)                  {                      case 1:                          ignoreType = 1;                          break;                      case 2:                          ignoreType = 2;                          break;                  }
Missing Default,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,Admin_GetRandomLinkForApproval,The following switch statement is missing a default case: switch (lType)                  {                      case AzureLinkType.TvDB:                          link = AzureWebAPI.Admin_GetRandomTvDBLinkForApproval();                          break;                      case AzureLinkType.Trakt:                          link = AzureWebAPI.Admin_GetRandomTraktLinkForApproval();                          break;                  }
Missing Default,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,TraktScrobble,The following switch statement is missing a default case: switch (status)                  {                      case (int)Providers.TraktTV.ScrobblePlayingStatus.Start:                          statusTraktV2 = Providers.TraktTV.ScrobblePlayingStatus.Start;                          break;                      case (int)Providers.TraktTV.ScrobblePlayingStatus.Pause:                          statusTraktV2 = Providers.TraktTV.ScrobblePlayingStatus.Pause;                          break;                      case (int)Providers.TraktTV.ScrobblePlayingStatus.Stop:                          statusTraktV2 = Providers.TraktTV.ScrobblePlayingStatus.Stop;                          break;                  }
Missing Default,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,LinkAniDBOther,The following switch statement is missing a default case: switch (xrefType)                  {                      case CrossRefType.MovieDB:                          MovieDBHelper.LinkAniDBMovieDB(animeID' movieID' false);                          break;                  }
Missing Default,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,RemoveLinkAniDBOther,The following switch statement is missing a default case: switch (xrefType)                  {                      case CrossRefType.MovieDB:                            // check if there are default images used associated                          List<AniDB_Anime_DefaultImage> images =                              RepoFactory.AniDB_Anime_DefaultImage.GetByAnimeID(animeID);                          foreach (AniDB_Anime_DefaultImage image in images)                          {                              if (image.ImageParentType == (int) ImageEntityType.MovieDB_FanArt ||                                  image.ImageParentType == (int) ImageEntityType.MovieDB_Poster)                              {                                  RepoFactory.AniDB_Anime_DefaultImage.Delete(image.AniDB_Anime_DefaultImageID);                              }                          }                          MovieDBHelper.RemoveLinkAniDBMovieDB(animeID);                          break;                  }
Missing Default,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,SearchForFiles,The following switch statement is missing a default case: switch (sType)                  {                      case FileSearchCriteria.Name:                          List<SVR_VideoLocal> results1 = RepoFactory.VideoLocal.GetByName(searchCriteria.Trim());                          foreach (SVR_VideoLocal vid in results1)                              vids.Add(vid.ToClient(userID));                          break;                        case FileSearchCriteria.ED2KHash:                          SVR_VideoLocal vidl = RepoFactory.VideoLocal.GetByHash(searchCriteria.Trim());                          if (vidl != null)                              vids.Add(vidl.ToClient(userID));                          break;                        case FileSearchCriteria.Size:                          break;                        case FileSearchCriteria.LastOneHundred:                          int number = 100;                          if (!string.IsNullOrEmpty(searchCriteria))                          {                              if (int.TryParse(searchCriteria' out int temp)) number = temp;                          }                          List<SVR_VideoLocal> results2 = RepoFactory.VideoLocal.GetMostRecentlyAdded(number);                          foreach (SVR_VideoLocal vid in results2)                              vids.Add(vid.ToClient(userID));                          break;                  }
Missing Default,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetGroupFileSummary,The following switch statement is missing a default case: switch (animeEp.EpisodeTypeEnum)                                      {                                          case EpisodeType.Episode:                                              contract.FileCountNormal++;                                              break;                                          case EpisodeType.Special:                                              contract.FileCountSpecials++;                                              break;                                      }
Missing Default,Shoko.Server,ShokoServiceImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementation\ShokoServiceImplementation_Entities.cs,GetGroupFileSummary,The following switch statement is missing a default case: switch (animeEp.EpisodeTypeEnum)                                  {                                      case EpisodeType.Episode:                                          cl.FileCountNormal++;                                          break;                                      case EpisodeType.Special:                                          cl.FileCountSpecials++;                                          break;                                  }
Missing Default,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,CheckFileKeep,The following switch statement is missing a default case: switch (type)                  {                      case FileQualityFilterType.AUDIOCODEC:                          result &= CheckAudioCodec(file);                          break;                      case FileQualityFilterType.AUDIOSTREAMCOUNT:                          result &= CheckAudioStreamCount(file);                          break;                      case FileQualityFilterType.CHAPTER:                          if (aniFile == null) return false;                          result &= CheckChaptered(file);                          break;                      case FileQualityFilterType.RESOLUTION:                          result &= CheckResolution(file' aniFile);                          break;                      case FileQualityFilterType.SOURCE:                          if (aniFile == null) return false;                          result &= CheckSource(aniFile);                          break;                      case FileQualityFilterType.SUBGROUP:                          if (aniFile == null) return false;                          result &= CheckSubGroup(aniFile);                          break;                      case FileQualityFilterType.SUBSTREAMCOUNT:                          result &= CheckSubStreamCount(file);                          break;                      case FileQualityFilterType.VERSION:                          if (aniFile == null) return false;                          result &= CheckDeprecated(aniFile);                          break;                      case FileQualityFilterType.VIDEOCODEC:                          if (aniFile == null) return false;                          result &= CheckVideoCodec(file);                          break;                  }
Missing Default,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,CheckAudioCodec,The following switch statement is missing a default case: switch (operationType)              {                  case FileQualityFilterOperationType.IN:                      return codecs.FindInEnumerable(Settings._requiredaudiocodecs.Item1);                  case FileQualityFilterOperationType.NOTIN:                      return !codecs.FindInEnumerable(Settings._requiredaudiocodecs.Item1);              }
Missing Default,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,CheckAudioStreamCount,The following switch statement is missing a default case: switch (operationType)              {                  case FileQualityFilterOperationType.EQUALS:                      return streamCount == Settings.RequiredAudioStreamCount;                  case FileQualityFilterOperationType.GREATER_EQ:                      return streamCount >= Settings.RequiredAudioStreamCount;                  case FileQualityFilterOperationType.LESS_EQ:                      return streamCount <= Settings.RequiredAudioStreamCount;              }
Missing Default,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,CheckResolution,The following switch statement is missing a default case: switch (operationType)              {                  case FileQualityFilterOperationType.EQUALS:                      return res.Equals(Settings.RequiredResolutions.FirstOrDefault());                  case FileQualityFilterOperationType.GREATER_EQ:                      List<int> keysGT = ResolutionArea.Keys.Where(a => resArea >= a).ToList();                      keysGT.AddRange(ResolutionAreaOld.Keys.Where(a => resArea >= a));                      List<string> valuesGT = new List<string>();                      foreach (int key in keysGT)                      {                          if (ResolutionArea.ContainsKey(key)) valuesGT.Add(ResolutionArea[key]);                          if (ResolutionAreaOld.ContainsKey(key)) valuesGT.Add(ResolutionAreaOld[key]);                      }                      if (valuesGT.FindInEnumerable(Settings.RequiredResolutions)) return true;                      break;                  case FileQualityFilterOperationType.LESS_EQ:                      List<int> keysLT = ResolutionArea.Keys.Where(a => resArea <= a).ToList();                      keysLT.AddRange(ResolutionAreaOld.Keys.Where(a => resArea <= a));                      List<string> valuesLT = new List<string>();                      foreach (int key in keysLT)                      {                          if (ResolutionArea.ContainsKey(key)) valuesLT.Add(ResolutionArea[key]);                          if (ResolutionAreaOld.ContainsKey(key)) valuesLT.Add(ResolutionAreaOld[key]);                      }                      if (valuesLT.FindInEnumerable(Settings.RequiredResolutions)) return true;                      break;                  case FileQualityFilterOperationType.IN:                      return Settings.RequiredResolutions.Contains(res);                  case FileQualityFilterOperationType.NOTIN:                      return !Settings.RequiredResolutions.Contains(res);              }
Missing Default,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,CheckSource,The following switch statement is missing a default case: switch (operationType)              {                  case FileQualityFilterOperationType.IN:                      return Settings._requiredsources.Item1.Contains(aniFile.File_Source.ToLowerInvariant());                  case FileQualityFilterOperationType.NOTIN:                      return !Settings._requiredsources.Item1.Contains(aniFile.File_Source.ToLowerInvariant());              }
Missing Default,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,CheckSubGroup,The following switch statement is missing a default case: switch (operationType)              {                  case FileQualityFilterOperationType.IN:                      return Settings._requiredsubgroups.Item1.Contains(aniFile.Anime_GroupName.ToLowerInvariant()) ||                             Settings._requiredsubgroups.Item1.Contains(aniFile.Anime_GroupNameShort.ToLowerInvariant());                  case FileQualityFilterOperationType.NOTIN:                      return !Settings._requiredsubgroups.Item1.Contains(aniFile.Anime_GroupName.ToLowerInvariant()) &&                             !Settings._requiredsubgroups.Item1.Contains(aniFile.Anime_GroupNameShort.ToLowerInvariant());              }
Missing Default,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,CheckSubStreamCount,The following switch statement is missing a default case: switch (operationType)              {                  case FileQualityFilterOperationType.EQUALS:                      return streamCount == Settings.RequiredSubStreamCount;                  case FileQualityFilterOperationType.GREATER_EQ:                      return streamCount >= Settings.RequiredSubStreamCount;                  case FileQualityFilterOperationType.LESS_EQ:                      return streamCount <= Settings.RequiredSubStreamCount;              }
Missing Default,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,CheckVideoCodec,The following switch statement is missing a default case: switch (operationType)              {                  case FileQualityFilterOperationType.IN:                      return Settings._requiredvideocodecs.Item1.FindInEnumerable(codecs);                  case FileQualityFilterOperationType.NOTIN:                      return !Settings._requiredvideocodecs.Item1.FindInEnumerable(codecs);              }
Missing Default,Shoko.Server,FileQualityFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Import\FileQualityFilter.cs,CompareTo,The following switch statement is missing a default case: switch (type)                  {                      case FileQualityFilterType.AUDIOCODEC:                          result = CompareAudioCodecTo(newFile' oldFile);                          break;                        case FileQualityFilterType.AUDIOSTREAMCOUNT:                          result = CompareAudioStreamCountTo(newFile' oldFile);                          break;                        case FileQualityFilterType.CHAPTER:                          result = CompareChapterTo(newFile' newEp' oldFile' oldEp);                          break;                        case FileQualityFilterType.RESOLUTION:                          result = CompareResolutionTo(newFile' oldFile' newEp' oldEp);                          break;                        case FileQualityFilterType.SOURCE:                          if (newEp == null) return 1;                          if (oldEp == null) return -1;                          result = CompareSourceTo(newEp' oldEp);                          break;                        case FileQualityFilterType.SUBGROUP:                          if (newEp == null) return 1;                          if (oldEp == null) return -1;                          result = CompareSubGroupTo(newEp' oldEp);                          break;                        case FileQualityFilterType.SUBSTREAMCOUNT:                          result = CompareSubStreamCountTo(newFile' oldFile);                          break;                        case FileQualityFilterType.VERSION:                          if (newEp == null) return 1;                          if (oldEp == null) return -1;                          result = CompareVersionTo(newFile' oldFile);                          break;                        case FileQualityFilterType.VIDEOCODEC:                          result = CompareVideoCodecTo(newFile' oldFile);                          break;                  }
Missing Default,Shoko.Server,ShokoServiceImplementationMetro,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v1\Implementations\ShokoServiceImplementationMetro.cs,GetAniDBRecommendationsForAnime,The following switch statement is missing a default case: switch (recType)                          {                              case AniDBRecommendationType.ForFans:                                  shout.CommentType = (int) WhatPeopleAreSayingType.AniDBForFans;                                  break;                              case AniDBRecommendationType.MustSee:                                  shout.CommentType = (int) WhatPeopleAreSayingType.AniDBMustSee;                                  break;                              case AniDBRecommendationType.Recommended:                                  shout.CommentType = (int) WhatPeopleAreSayingType.AniDBRecommendation;                                  break;                          }
Missing Default,Shoko.Server,ServerSettings,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\ServerSettings.cs,LoadSettingsFromFile,The following switch statement is missing a default case: switch (res)                      {                          case true:                              // gonna try grant access again in advance                              try                              {                                  //TODO add MessageBox If Failed                                  if (!Utils.GrantAccess(ApplicationPath))                                  {                                      logger.Error("Unable to gain permissions for program data. Try running as admin.");                                  }                              }                              catch (Exception)                              {                                  // ignored                              }                              Utils.RestartAsAdmin();                              break;                          case false:                              ServerShutdown?.Invoke(null' new ReasonedEventArgs { Reason="Failed to set folder permissions" } );                              Environment.Exit(0);                              break;                      }
Missing Default,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,GetOSInfo,The following switch statement is missing a default case: switch (vs.Minor)                  {                      case 0:                          operatingSystem = "95";                          break;                      case 10:                          if (vs.Revision.ToString() == "2222A")                              operatingSystem = "98SE";                          else                              operatingSystem = "98";                          break;                      case 90:                          operatingSystem = "Me";                          break;                  }
Missing Default,Shoko.Server,Utils,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utils.cs,GetScheduledHours,The following switch statement is missing a default case: switch (freq)              {                  case ScheduledUpdateFrequency.Daily:                      return 24;                  case ScheduledUpdateFrequency.HoursSix:                      return 6;                  case ScheduledUpdateFrequency.HoursTwelve:                      return 12;                  case ScheduledUpdateFrequency.WeekOne:                      return 24 * 7;                  case ScheduledUpdateFrequency.MonthOne:                      return 24 * 30;                  case ScheduledUpdateFrequency.Never:                      return int.MaxValue;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_AddFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_AddFile.cs,Process,The following switch statement is missing a default case: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_AddFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_AddFile.cs,Process,The following switch statement is missing a default case: switch (sMsgType)              {                  case "210": return enHelperActivityType.FileAdded;                  case "310":                  {                      //file already exists: read 'watched' status                      string[] arrResult = socketResponse.Split('\n');                      if (arrResult.Length >= 2)                      {                          string[] arrStatus = arrResult[1].Split('|');                          int state = int.Parse(arrStatus[6]);                          State = (AniDBFile_State) state;                            int viewdate = int.Parse(arrStatus[7]);                          ReturnIsWatched = viewdate > 0;                            if (ReturnIsWatched)                          {                              DateTime utcDate = new DateTime(1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);                              utcDate = utcDate.AddSeconds(viewdate);                                WatchedDate = utcDate.ToLocalTime();                          }                          else                          {                              WatchedDate = null;                          }                      }                  }                      return enHelperActivityType.FileAlreadyExists;                  case "311": return enHelperActivityType.UpdatingFile;                  case "320": return enHelperActivityType.NoSuchFile;                  case "411": return enHelperActivityType.NoSuchFile;                  case "502": return enHelperActivityType.LoginFailed;                  case "501": return enHelperActivityType.LoginRequired;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_DeleteFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_DeleteFile.cs,Process,The following switch statement is missing a default case: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_DeleteFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_DeleteFile.cs,Process,The following switch statement is missing a default case: switch (sMsgType)              {                  case "211": return enHelperActivityType.FileDeleted;                  case "411": return enHelperActivityType.NoSuchFile;                  case "502": return enHelperActivityType.LoginFailed;                  case "501": return enHelperActivityType.LoginRequired;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_GetAnimeDescription,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetAnimeDescription.cs,Process,The following switch statement is missing a default case: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_GetAnimeDescription,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetAnimeDescription.cs,Process,The following switch statement is missing a default case: switch (sMsgType)              {                  case "233":                  {                      // 233 ANIMEDESC                      // the first 11 characters should be "240 EPISODE"                      // the rest of the information should be the data list                        animeDesc = new Raw_AniDB_AnimeDesc(socketResponse);                      return enHelperActivityType.GotAnimeDesc;                  }                  case "330": return enHelperActivityType.NoSuchAnime;                  case "333": // no such description                      return enHelperActivityType.NoSuchAnime;                  case "501": return enHelperActivityType.LoginRequired;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_GetAnimeInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetAnimeInfo.cs,Process,The following switch statement is missing a default case: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_GetAnimeInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetAnimeInfo.cs,Process,The following switch statement is missing a default case: switch (sMsgType)              {                  case "230":                  {                      // 230 FILE INFO                      // the first 9 characters should be "230 ANIME "                      // the rest of the information should be the data list                      animeInfo = new Raw_AniDB_Anime(socketResponse);                      return enHelperActivityType.GotAnimeInfo;                  }                  case "330": return enHelperActivityType.NoSuchAnime;                  case "501": return enHelperActivityType.LoginRequired;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_GetCalendar,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetCalendar.cs,Process,The following switch statement is missing a default case: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_GetCalendar,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetCalendar.cs,Process,The following switch statement is missing a default case: switch (sMsgType)              {                  case "297":                  {                      calendars = new CalendarCollection(socketResponse);                      return enHelperActivityType.GotCalendar;                  }                  case "397": return enHelperActivityType.CalendarEmpty;                  case "501": return enHelperActivityType.LoginRequired;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_GetCharacterInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetCharacterInfo.cs,Process,The following switch statement is missing a default case: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_GetCharacterInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetCharacterInfo.cs,Process,The following switch statement is missing a default case: switch (sMsgType)              {                  case "235":                  {                      // 235 CHARACTER INFO                      // the first 11 characters should be "235 CHARACTER"                      // the rest of the information should be the data list                        charInfo = new Raw_AniDB_Character(socketResponse);                      return enHelperActivityType.GotCharInfo;                          // Response: 235 CHARACTER 99297|6267|25|539|5|01|The Girl Returns|Shoujo Kikan|????|1238976000                  }                  case "335": return enHelperActivityType.NoSuchChar;                  case "501": return enHelperActivityType.LoginRequired;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_GetCreatorInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetCreatorInfo.cs,Process,The following switch statement is missing a default case: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_GetCreatorInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetCreatorInfo.cs,Process,The following switch statement is missing a default case: switch (sMsgType)              {                  case "245":                  {                      // 245 CREATOR                      // the first 11 characters should be "245 CREATOR"                      // the rest of the information should be the data list                        creatorInfo = new Raw_AniDB_Creator(socketResponse);                      return enHelperActivityType.GotCreatorInfo;                          // 245 CREATOR 200|?????|Suwabe Jun`ichi|1|17015.jpg||http://www.haikyo.or.jp/PROFILE/man/11470.html|Junichi_Suwabe|%E8%AB%8F%E8%A8%AA%E9%83%A8%E9%A0%86%E4%B8%80|1236300570                  }                  case "345": return enHelperActivityType.NoSuchCreator;                  case "501": return enHelperActivityType.LoginRequired;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_GetEpisodeInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetEpisodeInfo.cs,Process,The following switch statement is missing a default case: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_GetEpisodeInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetEpisodeInfo.cs,Process,The following switch statement is missing a default case: switch (sMsgType)              {                  case "240":                  {                      // 240 EPISODE INFO                      // the first 11 characters should be "240 EPISODE"                      // the rest of the information should be the data list                        episodeInfo = new Raw_AniDB_Episode(socketResponse' EpisodeSourceType.Episode);                      if (!episodeInfo.IsValid) return enHelperActivityType.NoSuchEpisode;                      return enHelperActivityType.GotEpisodeInfo;                          // Response: 240 EPISODE 99297|6267|25|539|5|01|The Girl Returns|Shoujo Kikan|????|1238976000                  }                  case "340": return enHelperActivityType.NoSuchEpisode;                  case "501": return enHelperActivityType.LoginRequired;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_GetEpisodeInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetEpisodeInfo.cs,Init,The following switch statement is missing a default case: switch (epType)              {                  case EpisodeType.Credits:                      epNumberFormatted = "C" + episodeNumber.ToString();                      break;                  case EpisodeType.Special:                      epNumberFormatted = "S" + episodeNumber.ToString();                      break;                  case EpisodeType.Other:                      epNumberFormatted = "0" + episodeNumber.ToString();                      break;                  case EpisodeType.Trailer:                      epNumberFormatted = "T" + episodeNumber.ToString();                      break;                  case EpisodeType.Parody:                      epNumberFormatted = "P" + episodeNumber.ToString();                      break;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_GetFileInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetFileInfo.cs,Process,The following switch statement is missing a default case: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_GetFileInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetFileInfo.cs,Process,The following switch statement is missing a default case: switch (sMsgType)              {                  case "220":                  {                      // 220 FILE INFO                      // the first 9 characters should be "220 FILE "                      // the rest of the information should be the data list                        fileInfo = new Raw_AniDB_File(socketResponse);                      //episodeInfo = new Raw_AniDB_Episode(socketResponse' enEpisodeSourceType.File);                      return enHelperActivityType.GotFileInfo;                  }                  case "320": return enHelperActivityType.FileDoesNotExist;                  case "501": return enHelperActivityType.LoginRequired;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_GetGroupStatus,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetGroupStatus.cs,Process,The following switch statement is missing a default case: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_GetGroupStatus,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetGroupStatus.cs,Process,The following switch statement is missing a default case: switch (sMsgType)              {                  case "225":                  {                      // 225 GROUPSTATUS                        grpStatus = new GroupStatusCollection(animeID' socketResponse);                      return enHelperActivityType.GotGroupStatus;                  }                  case "330": return enHelperActivityType.NoSuchAnime;                  case "325": // no such description                      return enHelperActivityType.NoGroupsFound;                  case "501": return enHelperActivityType.LoginRequired;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_GetMyListFileInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetMyListFileInfo.cs,Process,The following switch statement is missing a default case: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_GetMyListFileInfo,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetMyListFileInfo.cs,Process,The following switch statement is missing a default case: switch (sMsgType)              {                  case "221":                  {                      myListFile = new Raw_AniDB_MyListFile(socketResponse);                      //BaseConfig.MyAnimeLog.Write(myListFile.ToString());                      return enHelperActivityType.GotMyListFileInfo;                  }                  case "321": return enHelperActivityType.NoSuchMyListFile;                  case "501": return enHelperActivityType.LoginRequired;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_GetMyListStats,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetMyListStats.cs,Process,The following switch statement is missing a default case: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_GetMyListStats,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetMyListStats.cs,Process,The following switch statement is missing a default case: switch (sMsgType)              {                  case "222":                  {                      myListStats = new Raw_AniDB_MyListStats(socketResponse);                      return enHelperActivityType.GotMyListStats;                  }                  case "501": return enHelperActivityType.LoginRequired;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_GetReview,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetReview.cs,Process,The following switch statement is missing a default case: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_GetReview,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetReview.cs,Process,The following switch statement is missing a default case: switch (sMsgType)              {                  case "234":                  {                      // 234 REVIEW                       // the first 10 characters should be "240 REVIEW"                      // the rest of the information should be the data list                        ReviewInfo = new Raw_AniDB_Review(socketResponse);                      return enHelperActivityType.GotReview;                  }                  case "334": return enHelperActivityType.NoSuchReview;                  case "501": return enHelperActivityType.LoginRequired;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_GetUpdated,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetUpdated.cs,Process,The following switch statement is missing a default case: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_GetUpdated,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetUpdated.cs,Process,The following switch statement is missing a default case: switch (sMsgType)              {                  case "243":                  {                      // remove the header info                      string[] sDetails = socketResponse.Substring(0).Split('\n');                        if (sDetails.Length > 1)                      {                          // first item will be the status command so ignore                          // only concerned with the second line                            string[] flds = sDetails[1].Substring(0).Split('|');                          AniDBEntity = int.Parse(flds[0]);                          RecordCount = int.Parse(flds[1]);                          StartTime = flds[2];                          AnimeIDListRaw = flds[3].Trim();                          string[] aids = AnimeIDListRaw.Split(''');                          foreach (string sid in aids)                          {                              AnimeIDList.Add(int.Parse(sid));                          }                      }                        return enHelperActivityType.GotUpdated;                  }                  case "343": return enHelperActivityType.NoUpdates;                  case "501": return enHelperActivityType.LoginRequired;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_Login,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_Login.cs,Process,The following switch statement is missing a default case: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_MarkFileAsDeleted,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_MarkFileAsDeleted.cs,Process,The following switch statement is missing a default case: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_MarkFileAsDeleted,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_MarkFileAsDeleted.cs,Process,The following switch statement is missing a default case: switch (sMsgType)              {                  case "210": return enHelperActivityType.FileMarkedAsDeleted;                  case "310": return enHelperActivityType.FileMarkedAsDeleted;                  case "311": return enHelperActivityType.FileMarkedAsDeleted;                  case "320": return enHelperActivityType.NoSuchFile;                  case "411": return enHelperActivityType.NoSuchFile;                    case "502": return enHelperActivityType.LoginFailed;                  case "501": return enHelperActivityType.LoginRequired;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_MarkFileAsExternal,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_MarkFileAsExternal.cs,Process,The following switch statement is missing a default case: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_MarkFileAsExternal,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_MarkFileAsExternal.cs,Process,The following switch statement is missing a default case: switch (sMsgType)              {                  case "210": return enHelperActivityType.FileMarkedAsDeleted;                  case "310": return enHelperActivityType.FileMarkedAsDeleted;                  case "311": return enHelperActivityType.FileMarkedAsDeleted;                  case "320": return enHelperActivityType.NoSuchFile;                  case "411": return enHelperActivityType.NoSuchFile;                    case "502": return enHelperActivityType.LoginFailed;                  case "501": return enHelperActivityType.LoginRequired;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_MarkFileAsUnknown,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_MarkFileAsUnknown.cs,Process,The following switch statement is missing a default case: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_MarkFileAsUnknown,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_MarkFileAsUnknown.cs,Process,The following switch statement is missing a default case: switch (sMsgType)              {                  case "210": return enHelperActivityType.FileMarkedAsDeleted;                  case "310": return enHelperActivityType.FileMarkedAsDeleted;                  case "311": return enHelperActivityType.FileMarkedAsDeleted;                  case "320": return enHelperActivityType.NoSuchFile;                  case "411": return enHelperActivityType.NoSuchFile;                    case "502": return enHelperActivityType.LoginFailed;                  case "501": return enHelperActivityType.LoginRequired;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_NotifyGet,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_NotifyGet.cs,Process,The following switch statement is missing a default case: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_NotifyGet,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_NotifyGet.cs,Process,The following switch statement is missing a default case: switch (sMsgType)              {                  case "292":                  {                      NotifyMessage = new Raw_AniDB_NotifyMessage(socketResponse);                      return enHelperActivityType.GotNotifyGet;                  }                    case "293":                  {                      NotifyAlert = new Raw_AniDB_NotifyAlert(socketResponse);                      return enHelperActivityType.GotNotifyGet;                  }                  case "392":                  case "393":                  {                      return enHelperActivityType.NoSuchNotify;                  }                  case "501":                  {                      return enHelperActivityType.LoginRequired;                  }              }
Missing Default,AniDBAPI.Commands,AniDBCommand_NotifyList,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_NotifyList.cs,Process,The following switch statement is missing a default case: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_NotifyList,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_NotifyList.cs,Process,The following switch statement is missing a default case: switch (sMsgType)              {                  case "291":                  {                      notifyListCollection = new Raw_AniDB_NotifyList(socketResponse);                      return enHelperActivityType.GotNotifyList;                  }                  case "501": return enHelperActivityType.LoginRequired;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_Ping,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_Ping.cs,Process,The following switch statement is missing a default case: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_UpdateFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_UpdateFile.cs,Process,The following switch statement is missing a default case: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_UpdateFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_UpdateFile.cs,Process,The following switch statement is missing a default case: switch (sMsgType)              {                  case "210": return enHelperActivityType.FileAdded;                  case "310": return enHelperActivityType.FileAlreadyExists;                  case "311": return enHelperActivityType.UpdatingFile;                  case "320": return enHelperActivityType.NoSuchFile;                  case "411": return enHelperActivityType.NoSuchMyListFile;                    case "502": return enHelperActivityType.LoginFailed;                  case "501": return enHelperActivityType.LoginRequired;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_Vote,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_Vote.cs,Process,The following switch statement is missing a default case: switch (ResponseCode)              {                  case 598: return enHelperActivityType.UnknownCommand_598;                  case 555: return enHelperActivityType.Banned_555;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_Vote,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_Vote.cs,Process,The following switch statement is missing a default case: switch (sMsgType)              {                  case "260": return enHelperActivityType.Voted;                  case "261":                        // this means we were trying to retrieve the vote                      if (voteType == AniDBVoteType.Anime || voteType == AniDBVoteType.AnimeTemp)                      {                          // 261 VOTE FOUNDCode Geass Hangyaku no Lelouch|900|1|4521                          Raw_AniDB_Vote vote = new Raw_AniDB_Vote();                          vote.ProcessVoteFoundAnime(socketResponse' this.entityID' this.voteType);                          this.voteValue = vote.VoteValue;                      }                      if (voteType == AniDBVoteType.Episode)                      {                          //261 VOTE FOUNDThe Day a New Demon Was Born|700|1|63091                          Raw_AniDB_Vote vote = new Raw_AniDB_Vote();                          vote.ProcessVoteFoundEpisode(socketResponse' this.entityID' this.episodeNumber'                              this.episodeType);                          this.voteValue = vote.VoteValue;                      }                      return enHelperActivityType.VoteFound;                  case "262": return enHelperActivityType.VoteUpdated;                  case "263": return enHelperActivityType.VoteRevoked;                                        case "360": return enHelperActivityType.NoSuchVote;                  case "361": return enHelperActivityType.InvalidVoteType;                  case "362": return enHelperActivityType.InvalidVoteValue;                  case "363": return enHelperActivityType.PermVoteNotAllowed;                  case "364": return enHelperActivityType.PermVoteAlready;                    case "501": return enHelperActivityType.LoginRequired;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_Vote,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_Vote.cs,Init,The following switch statement is missing a default case: switch (voteType)              {                  case AniDBVoteType.Anime:                      iVoteType = 1;                      break;                  case AniDBVoteType.AnimeTemp:                      iVoteType = 2;                      break;                  case AniDBVoteType.Group:                      iVoteType = 3;                      break;                  case AniDBVoteType.Episode:                      iVoteType = 1;                      break;              }
Missing Default,AniDBAPI.Commands,AniDBCommand_Vote,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_Vote.cs,InitEpisode,The following switch statement is missing a default case: switch (epType)              {                  case EpisodeType.Credits:                      epNumberFormatted = "C" + epno.ToString();                      break;                  case EpisodeType.Special:                      epNumberFormatted = "S" + epno.ToString();                      break;                  case EpisodeType.Other:                      epNumberFormatted = "0" + epno.ToString();                      break;                  case EpisodeType.Trailer:                      epNumberFormatted = "T" + epno.ToString();                      break;                  case EpisodeType.Parody:                      epNumberFormatted = "P" + epno.ToString();                      break;              }
Missing Default,AniDBAPI.Commands,AniDBUDPCommand,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBUDPCommand.cs,ProcessCommand,The following switch statement is missing a default case: switch (ResponseCode)                  {                      case 600:                          errormsg = "600 INTERNAL SERVER ERROR";                          break;                      case 601:                          errormsg = "601 ANIDB OUT OF SERVICE - TRY AGAIN LATER";                          break;                      case 602:                          errormsg = "602 SERVER BUSY - TRY AGAIN LATER";                          break;                      case 604:                          errormsg = "TIMEOUT - DELAY AND RESUBMIT";                          break;                  }
Missing Default,Shoko.Server.Commands,AniDBCommand_GetGroup,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\AniDB_API\Commands\AniDBCommand_GetGroup.cs,Process,The following switch statement is missing a default case: switch (sMsgType)              {                  case "250":                  {                      // 250 GROUP                      //3938|704|1900|53|1126|Ayako-Fansubs|Ayako|#Ayako|irc.rizon.net|http://ayakofansubs.info/|1669.png                      Group = new Raw_AniDB_Group(socketResponse);                      return enHelperActivityType.GotGroup;                  }                  case "350": return enHelperActivityType.NoSuchGroup;                  case "501": return enHelperActivityType.LoginRequired;              }
Missing Default,Shoko.Server.Commands,CommandRequest_DownloadImage,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_DownloadImage.cs,ProcessCommand,The following switch statement is missing a default case: switch (EntityTypeEnum)                  {                      case ImageEntityType.TvDB_Episode:                          TvDB_Episode ep = RepoFactory.TvDB_Episode.GetByID(EntityID);                          if (string.IsNullOrEmpty(ep?.Filename))                          {                              logger.Warn($"TvDB Episode image failed to download: Can't get episode with ID: {EntityID}");                              return;                          }                          req = new ImageDownloadRequest(EntityTypeEnum' ep' ForceDownload);                          break;                        case ImageEntityType.TvDB_FanArt:                          TvDB_ImageFanart fanart = RepoFactory.TvDB_ImageFanart.GetByID(EntityID);                          if (string.IsNullOrEmpty(fanart?.BannerPath))                          {                              logger.Warn($"TvDB Fanart image failed to download: Can't find valid fanart with ID: {EntityID}");                              RemoveImageRecord();                              return;                          }                          req = new ImageDownloadRequest(EntityTypeEnum' fanart' ForceDownload);                          break;                        case ImageEntityType.TvDB_Cover:                          TvDB_ImagePoster poster = RepoFactory.TvDB_ImagePoster.GetByID(EntityID);                          if (string.IsNullOrEmpty(poster?.BannerPath))                          {                              logger.Warn($"TvDB Poster image failed to download: Can't find valid poster with ID: {EntityID}");                              RemoveImageRecord();                              return;                          }                          req = new ImageDownloadRequest(EntityTypeEnum' poster' ForceDownload);                          break;                        case ImageEntityType.TvDB_Banner:                          TvDB_ImageWideBanner wideBanner = RepoFactory.TvDB_ImageWideBanner.GetByID(EntityID);                          if (string.IsNullOrEmpty(wideBanner?.BannerPath))                          {                              logger.Warn($"TvDB Banner image failed to download: Can't find valid banner with ID: {EntityID}");                              RemoveImageRecord();                              return;                          }                          req = new ImageDownloadRequest(EntityTypeEnum' wideBanner' ForceDownload);                          break;                        case ImageEntityType.MovieDB_Poster:                          MovieDB_Poster moviePoster = RepoFactory.MovieDB_Poster.GetByID(EntityID);                          if (string.IsNullOrEmpty(moviePoster?.URL))                          {                              logger.Warn($"MovieDB Poster image failed to download: Can't find valid poster with ID: {EntityID}");                              RemoveImageRecord();                              return;                          }                          req = new ImageDownloadRequest(EntityTypeEnum' moviePoster' ForceDownload);                          break;                        case ImageEntityType.MovieDB_FanArt:                          MovieDB_Fanart movieFanart = RepoFactory.MovieDB_Fanart.GetByID(EntityID);                          if (string.IsNullOrEmpty(movieFanart?.URL))                          {                              logger.Warn($"MovieDB Fanart image failed to download: Can't find valid fanart with ID: {EntityID}");                              return;                          }                          req = new ImageDownloadRequest(EntityTypeEnum' movieFanart' ForceDownload);                          break;                        case ImageEntityType.AniDB_Cover:                          SVR_AniDB_Anime anime = RepoFactory.AniDB_Anime.GetByAnimeID(EntityID);                          if (anime == null)                          {                              logger.Warn($"AniDB poster image failed to download: Can't find AniDB_Anime with ID: {EntityID}");                              return;                          }                          AniDbImageRateLimiter.Instance.EnsureRate();                          req = new ImageDownloadRequest(EntityTypeEnum' anime' ForceDownload);                          break;                        case ImageEntityType.AniDB_Character:                          AniDB_Character chr = RepoFactory.AniDB_Character.GetByCharID(EntityID);                          if (chr == null)                          {                              logger.Warn($"AniDB Character image failed to download: Can't find AniDB Character with ID: {EntityID}");                              return;                          }                          AniDbImageRateLimiter.Instance.EnsureRate();                          req = new ImageDownloadRequest(EntityTypeEnum' chr' ForceDownload);                          break;                        case ImageEntityType.AniDB_Creator:                          AniDB_Seiyuu creator = RepoFactory.AniDB_Seiyuu.GetBySeiyuuID(EntityID);                          if (creator == null)                          {                              logger.Warn($"AniDB Seiyuu image failed to download: Can't find Seiyuu with ID: {EntityID}");                              return;                          }                          AniDbImageRateLimiter.Instance.EnsureRate();                          req = new ImageDownloadRequest(EntityTypeEnum' creator' ForceDownload);                          break;                  }
Missing Default,Shoko.Server.Commands,CommandRequest_DownloadImage,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\Import\CommandRequest_DownloadImage.cs,RemoveImageRecord,The following switch statement is missing a default case: switch (EntityTypeEnum)                  {                      case ImageEntityType.TvDB_FanArt:                          TvDB_ImageFanart fanart = RepoFactory.TvDB_ImageFanart.GetByID(EntityID);                          if (fanart == null) return;                          RepoFactory.TvDB_ImageFanart.Delete(fanart);                          break;                        case ImageEntityType.TvDB_Cover:                          TvDB_ImagePoster poster = RepoFactory.TvDB_ImagePoster.GetByID(EntityID);                          if (poster == null) return;                          RepoFactory.TvDB_ImagePoster.Delete(poster);                          break;                        case ImageEntityType.TvDB_Banner:                          TvDB_ImageWideBanner wideBanner = RepoFactory.TvDB_ImageWideBanner.GetByID(EntityID);                          if (wideBanner == null) return;                          RepoFactory.TvDB_ImageWideBanner.Delete(wideBanner);                          break;                        case ImageEntityType.MovieDB_Poster:                          MovieDB_Poster moviePoster = RepoFactory.MovieDB_Poster.GetByID(EntityID);                          if (moviePoster == null) return;                          RepoFactory.MovieDB_Poster.Delete(moviePoster);                          break;                        case ImageEntityType.MovieDB_FanArt:                          MovieDB_Fanart movieFanart = RepoFactory.MovieDB_Fanart.GetByID(EntityID);                          if (movieFanart == null) return;                          RepoFactory.MovieDB_Fanart.Delete(movieFanart);                          break;                  }
Missing Default,Shoko.Server.Commands,CommandRequestImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\CommandRequestImplementation.cs,Save,The following switch statement is missing a default case: switch (CommandRequestRepository.GetQueueIndex(cri))              {                  case 0:                      ShokoService.CmdProcessorGeneral.NotifyOfNewCommand();                      break;                  case 1:                      ShokoService.CmdProcessorHasher.NotifyOfNewCommand();                      break;                  case 2:                      ShokoService.CmdProcessorImages.NotifyOfNewCommand();                      break;              }
Missing Default,Shoko.Server.Commands,CommandRequestImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Commands\CommandRequestImplementation.cs,Save,The following switch statement is missing a default case: switch (CommandRequestRepository.GetQueueIndex(cri))              {                  case 0:                      ShokoService.CmdProcessorGeneral.NotifyOfNewCommand();                      break;                  case 1:                      ShokoService.CmdProcessorHasher.NotifyOfNewCommand();                      break;                  case 2:                      ShokoService.CmdProcessorImages.NotifyOfNewCommand();                      break;              }
Missing Default,Shoko.Server.API.v2.Models.common,Group,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Models\common\Group.cs,GenerateSizes,The following switch statement is missing a default case: switch (ep.EpisodeTypeEnum)                  {                      case EpisodeType.Episode:                      {                          eps++;                          if (local) local_eps++;                          if ((ep.GetUserRecord(uid)?.WatchedCount ?? 0) > 0) watched_eps++;                          break;                      }                      case EpisodeType.Credits:                      {                          credits++;                          if (local) local_credits++;                          if ((ep.GetUserRecord(uid)?.WatchedCount ?? 0) > 0) watched_credits++;                          break;                      }                      case EpisodeType.Special:                      {                          specials++;                          if (local) local_specials++;                          if ((ep.GetUserRecord(uid)?.WatchedCount ?? 0) > 0) watched_specials++;                          break;                      }                      case EpisodeType.Trailer:                      {                          trailers++;                          if (local) local_trailers++;                          if ((ep.GetUserRecord(uid)?.WatchedCount ?? 0) > 0) watched_trailers++;                          break;                      }                      case EpisodeType.Parody:                      {                          parodies++;                          if (local) local_parodies++;                          if ((ep.GetUserRecord(uid)?.WatchedCount ?? 0) > 0) watched_parodies++;                          break;                      }                      case EpisodeType.Other:                      {                          others++;                          if (local) local_others++;                          if ((ep.GetUserRecord(uid)?.WatchedCount ?? 0) > 0) watched_others++;                          break;                      }                  }
Missing Default,Shoko.Server.API.v2.Models.common,RawFile,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Models\common\RawFile.cs,RawFile,The following switch statement is missing a default case: switch (p.StreamType)                              {                                  //video                                  case "1":                                      new_media.AddVideo(p);                                      break;                                  //audio                                  case "2":                                      new_media.AddAudio(p);                                      break;                                  //subtitle                                  case "3":                                      new_media.AddSubtitle(p);                                      break;                                  //menu                                  case "4":                                      Dictionary<string' string> mdict = new Dictionary<string' string>();                                      //TODO APIv2: menu object could be usefull for external players                                      new_media.AddMenu(mdict);                                      break;                              }
Missing Default,Shoko.Server.API.v2.Models.common,Serie,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Models\common\Serie.cs,GenerateSizes,The following switch statement is missing a default case: switch (ep.EpisodeTypeEnum)                  {                      case EpisodeType.Episode:                      {                          eps++;                          if (local) local_eps++;                          if ((ep.GetUserRecord(uid)?.WatchedCount ?? 0) > 0) watched_eps++;                          break;                      }                      case EpisodeType.Credits:                      {                          credits++;                          if (local) local_credits++;                          if ((ep.GetUserRecord(uid)?.WatchedCount ?? 0) > 0) watched_credits++;                          break;                      }                      case EpisodeType.Special:                      {                          specials++;                          if (local) local_specials++;                          if ((ep.GetUserRecord(uid)?.WatchedCount ?? 0) > 0) watched_specials++;                          break;                      }                      case EpisodeType.Trailer:                      {                          trailers++;                          if (local) local_trailers++;                          if ((ep.GetUserRecord(uid)?.WatchedCount ?? 0) > 0) watched_trailers++;                          break;                      }                      case EpisodeType.Parody:                      {                          parodies++;                          if (local) local_parodies++;                          if ((ep.GetUserRecord(uid)?.WatchedCount ?? 0) > 0) watched_parodies++;                          break;                      }                      case EpisodeType.Other:                      {                          others++;                          if (local) local_others++;                          if ((ep.GetUserRecord(uid)?.WatchedCount ?? 0) > 0) watched_others++;                          break;                      }                  }
Missing Default,Shoko.Server.API.v2.Modules,PlexWebhook,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\API\v2\Modules\PlexWebhook.cs,WebhookPost,The following switch statement is missing a default case: switch (eventData.Event)              {                  case "media.scrobble":                      Scrobble(eventData);                      break;                  case "media.resume":                  case "media.play":                      TraktScrobble(eventData' ScrobblePlayingStatus.Start);                      break;                  case "media.pause":                      TraktScrobble(eventData' ScrobblePlayingStatus.Pause);                      break;                  case "media.stop":                      TraktScrobble(eventData' ScrobblePlayingStatus.Stop);                      break;              }
Missing Default,Shoko.Server.Extensions,ModelClients,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Extensions\ModelClients.cs,ToClient,The following switch statement is missing a default case: switch (imgType)              {                  case ImageEntityType.TvDB_Banner:                      parentImage = RepoFactory.TvDB_ImageWideBanner.GetByID(session' defaultImage.ImageParentID);                      break;                  case ImageEntityType.TvDB_Cover:                      parentImage = RepoFactory.TvDB_ImagePoster.GetByID(session' defaultImage.ImageParentID);                      break;                  case ImageEntityType.TvDB_FanArt:                      parentImage = RepoFactory.TvDB_ImageFanart.GetByID(session' defaultImage.ImageParentID);                      break;                  case ImageEntityType.MovieDB_Poster:                      parentImage = RepoFactory.MovieDB_Poster.GetByID(session' defaultImage.ImageParentID);                      break;                  case ImageEntityType.MovieDB_FanArt:                      parentImage = RepoFactory.MovieDB_Fanart.GetByID(session' defaultImage.ImageParentID);                      break;              }
Missing Default,Shoko.Server.Extensions,ModelClients,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Extensions\ModelClients.cs,ToClient,The following switch statement is missing a default case: switch (imgType)              {                  case ImageEntityType.TvDB_Banner:                      contract.TVWideBanner = (parentImage as TvDB_ImageWideBanner);                      break;                  case ImageEntityType.TvDB_Cover:                      contract.TVPoster = (parentImage as TvDB_ImagePoster);                      break;                  case ImageEntityType.TvDB_FanArt:                      contract.TVFanart = (parentImage as TvDB_ImageFanart);                      break;                  case ImageEntityType.MovieDB_Poster:                      contract.MoviePoster = (parentImage as MovieDB_Poster);                      break;                  case ImageEntityType.MovieDB_FanArt:                      contract.MovieFanart = (parentImage as MovieDB_Fanart);                      break;              }
Missing Default,Shoko.Server.Models,SVR_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AniDB_Anime.cs,GetDefaultPosterPathNoBlanks,The following switch statement is missing a default case: switch (imageType)              {                  case ImageEntityType.AniDB_Cover:                      return PosterPath;                    case ImageEntityType.TvDB_Cover:                      TvDB_ImagePoster tvPoster =                          RepoFactory.TvDB_ImagePoster.GetByID(session' defaultPoster.ImageParentID);                      if (tvPoster != null)                          return tvPoster.GetFullImagePath();                      else                          return PosterPath;                    case ImageEntityType.MovieDB_Poster:                      MovieDB_Poster moviePoster =                          RepoFactory.MovieDB_Poster.GetByID(session' defaultPoster.ImageParentID);                      if (moviePoster != null)                          return moviePoster.GetFullImagePath();                      else                          return PosterPath;              }
Missing Default,Shoko.Server.Models,SVR_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AniDB_Anime.cs,GetDefaultPosterDetailsNoBlanks,The following switch statement is missing a default case: switch (imageType)              {                  case ImageEntityType.AniDB_Cover:                      return details;                    case ImageEntityType.TvDB_Cover:                      TvDB_ImagePoster tvPoster =                          RepoFactory.TvDB_ImagePoster.GetByID(session' defaultPoster.ImageParentID);                      if (tvPoster != null)                          details = new ImageDetails                          {                              ImageType = ImageEntityType.TvDB_Cover'                              ImageID = tvPoster.TvDB_ImagePosterID                          };                      return details;                    case ImageEntityType.MovieDB_Poster:                      MovieDB_Poster moviePoster =                          RepoFactory.MovieDB_Poster.GetByID(session' defaultPoster.ImageParentID);                      if (moviePoster != null)                          details = new ImageDetails                          {                              ImageType = ImageEntityType.MovieDB_Poster'                              ImageID = moviePoster.MovieDB_PosterID                          };                      return details;              }
Missing Default,Shoko.Server.Models,SVR_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AniDB_Anime.cs,GetDefaultFanartDetailsNoBlanks,The following switch statement is missing a default case: switch (imageType)              {                  case ImageEntityType.TvDB_FanArt:                      TvDB_ImageFanart tvFanart = RepoFactory.TvDB_ImageFanart.GetByID(session' fanart.ImageParentID);                      if (tvFanart != null)                          details = new ImageDetails                          {                              ImageType = ImageEntityType.TvDB_FanArt'                              ImageID = tvFanart.TvDB_ImageFanartID                          };                      return details;                    case ImageEntityType.MovieDB_FanArt:                      MovieDB_Fanart movieFanart = RepoFactory.MovieDB_Fanart.GetByID(session' fanart.ImageParentID);                      if (movieFanart != null)                          details = new ImageDetails                          {                              ImageType = ImageEntityType.MovieDB_FanArt'                              ImageID = movieFanart.MovieDB_FanartID                          };                      return details;              }
Missing Default,Shoko.Server.Models,SVR_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AniDB_Anime.cs,GetDefaultFanartOnlineURL,The following switch statement is missing a default case: switch (imageType)              {                  case ImageEntityType.TvDB_FanArt:                      TvDB_ImageFanart tvFanart =                          RepoFactory.TvDB_ImageFanart.GetByID(GetDefaultFanart(session).ImageParentID);                      if (tvFanart != null)                          return string.Format(Constants.URLS.TvDB_Images' tvFanart.BannerPath);                      break;                    case ImageEntityType.MovieDB_FanArt:                      MovieDB_Fanart movieFanart =                          RepoFactory.MovieDB_Fanart.GetByID(GetDefaultFanart(session).ImageParentID);                      if (movieFanart != null)                          return movieFanart.URL;                      break;              }
Missing Default,Shoko.Server.Models,SVR_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AniDB_Anime.cs,GetDefaultWideBannerDetailsNoBlanks,The following switch statement is missing a default case: switch (imageType)              {                  case ImageEntityType.TvDB_Banner:                      details = new ImageDetails                      {                          ImageType = ImageEntityType.TvDB_Banner'                          ImageID = banner.ToClient(session).TVWideBanner.TvDB_ImageWideBannerID                      };                      return details;              }
Missing Default,Shoko.Server.Models,SVR_AniDB_Anime,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AniDB_Anime.cs,ToAzure,The following switch statement is missing a default case: switch (recType)                  {                      case AniDBRecommendationType.ForFans:                          comment.CommentType = (int) WhatPeopleAreSayingType.AniDBForFans;                          break;                      case AniDBRecommendationType.MustSee:                          comment.CommentType = (int) WhatPeopleAreSayingType.AniDBMustSee;                          break;                      case AniDBRecommendationType.Recommended:                          comment.CommentType = (int) WhatPeopleAreSayingType.AniDBRecommendation;                          break;                  }
Missing Default,Shoko.Server.Models,SVR_AnimeGroup,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_AnimeGroup.cs,BatchGetVotes,The following switch statement is missing a default case: switch (vote.VoteType)                          {                              case (int)AniDBVoteType.Anime:                                  permVoteCount++;                                  permVoteTotal += vote.VoteValue;                                  break;                              case (int)AniDBVoteType.AnimeTemp:                                  tempVoteCount++;                                  tempVoteTotal += vote.VoteValue;                                  break;                          }
Missing Default,Shoko.Server.Models,SVR_GroupFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_GroupFilter.cs,EvaluateConditions,The following switch statement is missing a default case: switch (gfc.GetConditionTypeEnum())              {                  case GroupFilterConditionType.Favourite:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include && contractGroup.IsFave == 0)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude && contractGroup.IsFave == 1)                          return false;                      break;                    case GroupFilterConditionType.MissingEpisodes:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include &&                          (contractGroup.MissingEpisodeCount > 0 || contractGroup.MissingEpisodeCountGroups > 0) ==                          false) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude &&                          (contractGroup.MissingEpisodeCount > 0 || contractGroup.MissingEpisodeCountGroups > 0)) return false;                      break;                    case GroupFilterConditionType.MissingEpisodesCollecting:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include &&                          contractGroup.MissingEpisodeCountGroups > 0 == false) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude &&                          contractGroup.MissingEpisodeCountGroups > 0) return false;                      break;                  case GroupFilterConditionType.Tag:                      List<string> tags =                          gfc.ConditionParameter.Trim()                              .Split(new[] {'''}' StringSplitOptions.RemoveEmptyEntries)                              .Select(a => a.ToLowerInvariant().Trim())                              .Where(a => !string.IsNullOrWhiteSpace(a))                              .ToList();                      bool tagsFound =                          tags.Any(                              a => contractGroup.Stat_AllTags.Contains(a' StringComparer.InvariantCultureIgnoreCase));                      if ((gfc.GetConditionOperatorEnum() == GroupFilterOperator.In ||                           gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include) && !tagsFound) return false;                      if ((gfc.GetConditionOperatorEnum() == GroupFilterOperator.NotIn ||                           gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude) && tagsFound) return false;                      break;                  case GroupFilterConditionType.Year:                      HashSet<int> years = new HashSet<int>();                      string[] parameterStrings = gfc.ConditionParameter.Trim()                          .Split(new[] {'''}' StringSplitOptions.RemoveEmptyEntries);                      foreach (string yearString in parameterStrings)                      {                          if (int.TryParse(yearString.Trim()' out int year))                              years.Add(year);                      }                      if (years.Count <= 0) return false;                      if ((gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include || gfc.GetConditionOperatorEnum() == GroupFilterOperator.In) &&                          !contractGroup.Stat_AllYears.FindInEnumerable(years))                          return false;                      if ((gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude || gfc.GetConditionOperatorEnum() == GroupFilterOperator.NotIn) &&                          contractGroup.Stat_AllYears.FindInEnumerable(years))                          return false;                      break;                  case GroupFilterConditionType.Season:                      string[] paramStrings = gfc.ConditionParameter.Trim().Split(''');                        switch (gfc.GetConditionOperatorEnum())                      {                          case GroupFilterOperator.Include:                          case GroupFilterOperator.In:                              return paramStrings.FindInEnumerable(contractGroup.Stat_AllSeasons);                          case GroupFilterOperator.Exclude:                          case GroupFilterOperator.NotIn:                              return !paramStrings.FindInEnumerable(contractGroup.Stat_AllSeasons);                      }                      break;                  case GroupFilterConditionType.HasWatchedEpisodes:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include &&                          contractGroup.WatchedEpisodeCount > 0 == false)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude &&                          contractGroup.WatchedEpisodeCount > 0)                          return false;                      break;                    case GroupFilterConditionType.HasUnwatchedEpisodes:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include &&                          contractGroup.UnwatchedEpisodeCount > 0 == false)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude &&                          contractGroup.UnwatchedEpisodeCount > 0)                          return false;                      break;                    case GroupFilterConditionType.AssignedTvDBInfo:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include &&                          contractGroup.Stat_HasTvDBLink == false)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude &&                          contractGroup.Stat_HasTvDBLink)                          return false;                      break;                    case GroupFilterConditionType.AssignedMALInfo:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include &&                          contractGroup.Stat_HasMALLink == false)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude &&                          contractGroup.Stat_HasMALLink)                          return false;                      break;                    case GroupFilterConditionType.AssignedMovieDBInfo:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include &&                          contractGroup.Stat_HasMovieDBLink == false)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude &&                          contractGroup.Stat_HasMovieDBLink)                          return false;                      break;                    case GroupFilterConditionType.AssignedTvDBOrMovieDBInfo:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include &&                          !contractGroup.Stat_HasMovieDBOrTvDBLink)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude &&                          contractGroup.Stat_HasMovieDBOrTvDBLink)                          return false;                      break;                    case GroupFilterConditionType.CompletedSeries:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include &&                          contractGroup.Stat_IsComplete == false)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude &&                          contractGroup.Stat_IsComplete)                          return false;                      break;                    case GroupFilterConditionType.FinishedAiring:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include &&                          contractGroup.Stat_HasFinishedAiring == false)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude &&                          contractGroup.Stat_HasFinishedAiring)                          return false;                      break;                    case GroupFilterConditionType.UserVoted:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include &&                          contractGroup.Stat_UserVotePermanent.HasValue == false) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude &&                          contractGroup.Stat_UserVotePermanent.HasValue) return false;                      break;                    case GroupFilterConditionType.UserVotedAny:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include &&                          contractGroup.Stat_UserVoteOverall.HasValue == false) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude &&                          contractGroup.Stat_UserVoteOverall.HasValue) return false;                      break;                    case GroupFilterConditionType.AirDate:                      DateTime filterDate;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          int.TryParse(gfc.ConditionParameter' out int days);                          filterDate = DateTime.Today.AddDays(0 - days);                      }                      else                          filterDate = GetDateFromString(gfc.ConditionParameter);                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.GreaterThan ||                          gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          if (!contractGroup.Stat_AirDate_Min.HasValue || !contractGroup.Stat_AirDate_Max.HasValue)                              return false;                          if (contractGroup.Stat_AirDate_Max.Value < filterDate) return false;                      }                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LessThan)                      {                          if (!contractGroup.Stat_AirDate_Min.HasValue || !contractGroup.Stat_AirDate_Max.HasValue)                              return false;                          if (contractGroup.Stat_AirDate_Min.Value > filterDate) return false;                      }                      break;                  case GroupFilterConditionType.LatestEpisodeAirDate:                      DateTime filterDateEpisodeLastAired;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          int.TryParse(gfc.ConditionParameter' out int days);                          filterDateEpisodeLastAired = DateTime.Today.AddDays(0 - days);                      }                      else                          filterDateEpisodeLastAired = GetDateFromString(gfc.ConditionParameter);                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.GreaterThan ||                          gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          if (!contractGroup.LatestEpisodeAirDate.HasValue) return false;                          if (contractGroup.LatestEpisodeAirDate.Value < filterDateEpisodeLastAired) return false;                      }                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LessThan)                      {                          if (!contractGroup.LatestEpisodeAirDate.HasValue) return false;                          if (contractGroup.LatestEpisodeAirDate.Value > filterDateEpisodeLastAired) return false;                      }                      break;                  case GroupFilterConditionType.SeriesCreatedDate:                      DateTime filterDateSeries;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          int.TryParse(gfc.ConditionParameter' out int days);                          filterDateSeries = DateTime.Today.AddDays(0 - days);                      }                      else                          filterDateSeries = GetDateFromString(gfc.ConditionParameter);                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.GreaterThan ||                          gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          if (!contractGroup.Stat_SeriesCreatedDate.HasValue) return false;                          if (contractGroup.Stat_SeriesCreatedDate.Value < filterDateSeries) return false;                      }                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LessThan)                      {                          if (!contractGroup.Stat_SeriesCreatedDate.HasValue) return false;                          if (contractGroup.Stat_SeriesCreatedDate.Value > filterDateSeries) return false;                      }                      break;                    case GroupFilterConditionType.EpisodeWatchedDate:                      DateTime filterDateEpsiodeWatched;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          int.TryParse(gfc.ConditionParameter' out int days);                          filterDateEpsiodeWatched = DateTime.Today.AddDays(0 - days);                      }                      else                          filterDateEpsiodeWatched = GetDateFromString(gfc.ConditionParameter);                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.GreaterThan ||                          gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          if (!contractGroup.WatchedDate.HasValue) return false;                          if (contractGroup.WatchedDate.Value < filterDateEpsiodeWatched) return false;                      }                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LessThan)                      {                          if (contractGroup?.WatchedDate == null) return false;                          if (contractGroup.WatchedDate.Value > filterDateEpsiodeWatched) return false;                      }                      break;                    case GroupFilterConditionType.EpisodeAddedDate:                      DateTime filterDateEpisodeAdded;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          int.TryParse(gfc.ConditionParameter' out int days);                          filterDateEpisodeAdded = DateTime.Today.AddDays(0 - days);                      }                      else                          filterDateEpisodeAdded = GetDateFromString(gfc.ConditionParameter);                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.GreaterThan ||                          gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          if (!contractGroup.EpisodeAddedDate.HasValue) return false;                          if (contractGroup.EpisodeAddedDate.Value < filterDateEpisodeAdded) return false;                      }                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LessThan)                      {                          if (!contractGroup.EpisodeAddedDate.HasValue) return false;                          if (contractGroup.EpisodeAddedDate.Value > filterDateEpisodeAdded) return false;                      }                      break;                    case GroupFilterConditionType.EpisodeCount:                      int.TryParse(gfc.ConditionParameter' out var epCount);                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.GreaterThan &&                          contractGroup.Stat_EpisodeCount < epCount)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LessThan &&                          contractGroup.Stat_EpisodeCount > epCount)                          return false;                      break;                    case GroupFilterConditionType.AniDBRating:                      decimal.TryParse(gfc.ConditionParameter' style' culture' out var dRating);                      decimal thisRating = contractGroup.Stat_AniDBRating / 100;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.GreaterThan && thisRating < dRating)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LessThan && thisRating > dRating)                          return false;                      break;                    case GroupFilterConditionType.UserRating:                      if (!contractGroup.Stat_UserVoteOverall.HasValue) return false;                      decimal.TryParse(gfc.ConditionParameter' style' culture' out var dUserRating);                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.GreaterThan &&                          contractGroup.Stat_UserVoteOverall.Value < dUserRating) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LessThan &&                          contractGroup.Stat_UserVoteOverall.Value > dUserRating) return false;                      break;                    case GroupFilterConditionType.CustomTags:                      List<string> ctags =                          gfc.ConditionParameter.Trim()                              .Split(new[] {'''}' StringSplitOptions.RemoveEmptyEntries)                              .Select(a => a.ToLowerInvariant().Trim())                              .ToList();                      bool foundTag = ctags.FindInEnumerable(contractGroup.Stat_AllCustomTags);                      if ((gfc.GetConditionOperatorEnum() == GroupFilterOperator.In) && !foundTag) return false;                      if ((gfc.GetConditionOperatorEnum() == GroupFilterOperator.NotIn) && foundTag) return false;                      break;                    case GroupFilterConditionType.AnimeType:                      List<string> ctypes =                          gfc.ConditionParameter                              .Split(new[] {'''}' StringSplitOptions.RemoveEmptyEntries)                              .Select(a => ((int) Commons.Extensions.Models.RawToType(a)).ToString())                              .ToList();                      bool foundAnimeType = ctypes.FindInEnumerable(contractGroup.Stat_AnimeTypes);                      if ((gfc.GetConditionOperatorEnum() == GroupFilterOperator.In) && !foundAnimeType) return false;                      if ((gfc.GetConditionOperatorEnum() == GroupFilterOperator.NotIn) && foundAnimeType)                          return false;                      break;                    case GroupFilterConditionType.VideoQuality:                      List<string> vqs =                          gfc.ConditionParameter                              .Split(new[] {'''}' StringSplitOptions.RemoveEmptyEntries)                              .Select(a => a.ToLowerInvariant().Trim())                              .ToList();                      bool foundVid = vqs.FindInEnumerable(contractGroup.Stat_AllVideoQuality);                      bool foundVidAllEps = vqs.FindInEnumerable(contractGroup.Stat_AllVideoQuality_Episodes);                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.In && !foundVid) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.NotIn && foundVid) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.InAllEpisodes && !foundVidAllEps)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.NotInAllEpisodes && foundVidAllEps)                          return false;                      break;                    case GroupFilterConditionType.AudioLanguage:                      List<string> als =                          gfc.ConditionParameter.Trim()                              .Split(new[] {'''}' StringSplitOptions.RemoveEmptyEntries)                              .Select(a => a.ToLowerInvariant().Trim())                              .ToList();                      bool foundLang = als.FindInEnumerable(contractGroup.Stat_AudioLanguages);                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.In && !foundLang) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.NotIn && foundLang) return false;                      break;                    case GroupFilterConditionType.SubtitleLanguage:                      List<string> ass =                          gfc.ConditionParameter                              .Split(new[] {'''}' StringSplitOptions.RemoveEmptyEntries)                              .Select(a => a.ToLowerInvariant().Trim())                              .ToList();                      bool foundSub = ass.FindInEnumerable(contractGroup.Stat_SubtitleLanguages);                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.In && !foundSub) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.NotIn && foundSub) return false;                      break;              }
Missing Default,Shoko.Server.Models,SVR_GroupFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_GroupFilter.cs,EvaluateConditions,The following switch statement is missing a default case: switch (gfc.GetConditionOperatorEnum())                      {                          case GroupFilterOperator.Include:                          case GroupFilterOperator.In:                              return paramStrings.FindInEnumerable(contractGroup.Stat_AllSeasons);                          case GroupFilterOperator.Exclude:                          case GroupFilterOperator.NotIn:                              return !paramStrings.FindInEnumerable(contractGroup.Stat_AllSeasons);                      }
Missing Default,Shoko.Server.Models,SVR_GroupFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_GroupFilter.cs,EvaluateConditions,The following switch statement is missing a default case: switch (gfc.GetConditionTypeEnum())              {                  case GroupFilterConditionType.MissingEpisodes:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include &&                          (contractSerie.MissingEpisodeCount > 0 || contractSerie.MissingEpisodeCountGroups > 0) ==                          false) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude &&                          (contractSerie.MissingEpisodeCount > 0 || contractSerie.MissingEpisodeCountGroups > 0))                          return false;                      break;                    case GroupFilterConditionType.MissingEpisodesCollecting:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include &&                          contractSerie.MissingEpisodeCountGroups > 0 == false) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude &&                          contractSerie.MissingEpisodeCountGroups > 0) return false;                      break;                  case GroupFilterConditionType.Tag:                      List<string> tags =                          gfc.ConditionParameter.Trim()                              .Split(new[] {'''}' StringSplitOptions.RemoveEmptyEntries)                              .Select(a => a.ToLowerInvariant().Trim())                              .Where(a => !string.IsNullOrWhiteSpace(a))                              .ToList();                      bool tagsFound =                          tags.Any(a => contractSerie.AniDBAnime.AniDBAnime.GetAllTags()                              .Contains(a'                                  StringComparer.InvariantCultureIgnoreCase));                      if ((gfc.GetConditionOperatorEnum() == GroupFilterOperator.In ||                           gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include) && !tagsFound) return false;                      if ((gfc.GetConditionOperatorEnum() == GroupFilterOperator.NotIn ||                           gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude) && tagsFound) return false;                      break;                  case GroupFilterConditionType.Year:                      int BeginYear = contractSerie.AniDBAnime.AniDBAnime.BeginYear;                      int EndYear = contractSerie.AniDBAnime.AniDBAnime.EndYear;                      if (BeginYear == 0) return false;                      if (EndYear == 0) EndYear = int.MaxValue;                      HashSet<int> years = new HashSet<int>();                      string[] parameterStrings = gfc.ConditionParameter.Trim().Split(''');                      foreach (string yearString in parameterStrings)                      {                          if (int.TryParse(yearString.Trim()' out int paramYear))                              years.Add(paramYear);                      }                        if (years.Count <= 0) return false;                      switch (gfc.GetConditionOperatorEnum())                      {                          case GroupFilterOperator.Include:                          case GroupFilterOperator.In:                              if (years.Any(year => year >= BeginYear && year <= EndYear))                                  return true;                              return false;                          case GroupFilterOperator.Exclude:                          case GroupFilterOperator.NotIn:                              if (years.Any(year => year >= BeginYear && year <= EndYear))                                  return false;                              return true;                      }                        break;                  case GroupFilterConditionType.Season:                      Tuple<AnimeSeason' int>[] paramStrings = gfc.ConditionParameter.Trim().Split(''').Select(a =>                      {                          var b = a.Trim().Split(' ');                          if (!Enum.TryParse(b[0]' out AnimeSeason season)) return null;                          if (!int.TryParse(b[1]' out int year)) return null;                          return Tuple.Create(season' year);                      }).Where(a => a != null).ToArray();                        switch (gfc.GetConditionOperatorEnum())                      {                          case GroupFilterOperator.Include:                          case GroupFilterOperator.In:                              return paramStrings.Any(a => contractSerie?.AniDBAnime?.IsInSeason(a.Item1' a.Item2) ?? false);                          case GroupFilterOperator.Exclude:                          case GroupFilterOperator.NotIn:                              return !paramStrings.Any(a => contractSerie?.AniDBAnime?.IsInSeason(a.Item1' a.Item2) ?? false);                      }                        break;                  case GroupFilterConditionType.HasWatchedEpisodes:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include &&                          contractSerie.WatchedEpisodeCount > 0 == false)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude &&                          contractSerie.WatchedEpisodeCount > 0)                          return false;                      break;                    case GroupFilterConditionType.HasUnwatchedEpisodes:                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include &&                          contractSerie.UnwatchedEpisodeCount > 0 == false)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude &&                          contractSerie.UnwatchedEpisodeCount > 0)                          return false;                      break;                    case GroupFilterConditionType.AssignedTvDBInfo:                      bool tvDBInfoMissing = contractSerie.CrossRefAniDBTvDBV2 == null ||                                             contractSerie.CrossRefAniDBTvDBV2.Count == 0;                      bool supposedToHaveTvDBLink = contractSerie.AniDBAnime.AniDBAnime.AnimeType !=                                                    (int) AnimeType.Movie &&                                                    !(contractSerie.AniDBAnime.AniDBAnime.Restricted > 0);                      tvDBInfoMissing &= supposedToHaveTvDBLink;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include && tvDBInfoMissing)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude && !tvDBInfoMissing)                          return false;                      break;                    case GroupFilterConditionType.AssignedMALInfo:                      bool malMissing = contractSerie.CrossRefAniDBMAL == null ||                                        contractSerie.CrossRefAniDBMAL.Count == 0;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include && malMissing) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude && !malMissing) return false;                      break;                    case GroupFilterConditionType.AssignedMovieDBInfo:                      bool movieMissing = contractSerie.CrossRefAniDBMovieDB == null;                      bool supposedToHaveMovieLink = contractSerie.AniDBAnime.AniDBAnime.AnimeType ==                                                     (int) AnimeType.Movie &&                                                     !(contractSerie.AniDBAnime.AniDBAnime.Restricted > 0);                      movieMissing &= supposedToHaveMovieLink;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include && movieMissing) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude && !movieMissing)                          return false;                      break;                    case GroupFilterConditionType.AssignedTvDBOrMovieDBInfo:                      bool restricted = (contractSerie.AniDBAnime.AniDBAnime.Restricted > 0);                      bool movieLinkMissing = contractSerie.CrossRefAniDBMovieDB == null && !restricted;                      bool tvlinkMissing = (contractSerie.CrossRefAniDBTvDBV2 == null ||                                            contractSerie.CrossRefAniDBTvDBV2.Count == 0) && !restricted;                      bool bothMissing = movieLinkMissing && tvlinkMissing;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include && bothMissing) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude && !bothMissing) return false;                      break;                    case GroupFilterConditionType.CompletedSeries:                      bool completed = contractSerie.AniDBAnime.AniDBAnime.EndDate.HasValue &&                                       contractSerie.AniDBAnime.AniDBAnime.EndDate.Value < DateTime.Now &&                                       !(contractSerie.MissingEpisodeCount > 0 ||                                         contractSerie.MissingEpisodeCountGroups > 0);                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include && !completed) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude && completed) return false;                      break;                    case GroupFilterConditionType.FinishedAiring:                      bool finished = contractSerie.AniDBAnime.AniDBAnime.EndDate.HasValue &&                                      contractSerie.AniDBAnime.AniDBAnime.EndDate.Value < DateTime.Now;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include && !finished) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude && finished) return false;                      break;                    case GroupFilterConditionType.UserVoted:                      bool voted = (contractSerie.AniDBAnime.UserVote != null) &&                                   (contractSerie.AniDBAnime.UserVote.VoteType == (int) AniDBVoteType.Anime);                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include && !voted) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude && voted) return false;                      break;                    case GroupFilterConditionType.UserVotedAny:                      bool votedany = contractSerie.AniDBAnime.UserVote != null;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Include && !votedany) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.Exclude && votedany) return false;                      break;                    case GroupFilterConditionType.AirDate:                      DateTime filterDate;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          int.TryParse(gfc.ConditionParameter' out int days);                          filterDate = DateTime.Today.AddDays(0 - days);                      }                      else                          filterDate = GroupFilterHelper.GetDateFromString(gfc.ConditionParameter);                        if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.GreaterThan ||                          gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                          if (!contractSerie.AniDBAnime.AniDBAnime.AirDate.HasValue ||                              contractSerie.AniDBAnime.AniDBAnime.AirDate.Value < filterDate)                              return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LessThan)                          if (!contractSerie.AniDBAnime.AniDBAnime.AirDate.HasValue ||                              contractSerie.AniDBAnime.AniDBAnime.AirDate.Value > filterDate)                              return false;                      break;                  case GroupFilterConditionType.LatestEpisodeAirDate:                      DateTime filterDateEpisodeLastAired;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          int.TryParse(gfc.ConditionParameter' out int days);                          filterDateEpisodeLastAired = DateTime.Today.AddDays(0 - days);                      }                      else                          filterDateEpisodeLastAired = GetDateFromString(gfc.ConditionParameter);                        if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.GreaterThan ||                          gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          if (!contractSerie.LatestEpisodeAirDate.HasValue) return false;                          if (contractSerie.LatestEpisodeAirDate.Value < filterDateEpisodeLastAired) return false;                      }                        if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LessThan)                      {                          if (!contractSerie.LatestEpisodeAirDate.HasValue) return false;                          if (contractSerie.LatestEpisodeAirDate.Value > filterDateEpisodeLastAired) return false;                      }                        break;                  case GroupFilterConditionType.SeriesCreatedDate:                      DateTime filterDateSeries;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          int.TryParse(gfc.ConditionParameter' out int days);                          filterDateSeries = DateTime.Today.AddDays(0 - days);                      }                      else                          filterDateSeries = GetDateFromString(gfc.ConditionParameter);                        if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.GreaterThan ||                          gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          if (contractSerie.DateTimeCreated < filterDateSeries) return false;                      }                        if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LessThan)                      {                          if (contractSerie.DateTimeCreated > filterDateSeries) return false;                      }                        break;                    case GroupFilterConditionType.EpisodeWatchedDate:                      DateTime filterDateEpsiodeWatched;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          int.TryParse(gfc.ConditionParameter' out int days);                          filterDateEpsiodeWatched = DateTime.Today.AddDays(0 - days);                      }                      else                          filterDateEpsiodeWatched = GetDateFromString(gfc.ConditionParameter);                        if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.GreaterThan ||                          gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          if (!contractSerie.WatchedDate.HasValue) return false;                          if (contractSerie.WatchedDate.Value < filterDateEpsiodeWatched) return false;                      }                        if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LessThan)                      {                          if (contractSerie?.WatchedDate == null) return false;                          if (contractSerie.WatchedDate.Value > filterDateEpsiodeWatched) return false;                      }                        break;                    case GroupFilterConditionType.EpisodeAddedDate:                      DateTime filterDateEpisodeAdded;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          int.TryParse(gfc.ConditionParameter' out int days);                          filterDateEpisodeAdded = DateTime.Today.AddDays(0 - days);                      }                      else                          filterDateEpisodeAdded = GetDateFromString(gfc.ConditionParameter);                        if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.GreaterThan ||                          gfc.GetConditionOperatorEnum() == GroupFilterOperator.LastXDays)                      {                          if (!contractSerie.EpisodeAddedDate.HasValue) return false;                          if (contractSerie.EpisodeAddedDate.Value < filterDateEpisodeAdded) return false;                      }                        if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LessThan)                      {                          if (!contractSerie.EpisodeAddedDate.HasValue) return false;                          if (contractSerie.EpisodeAddedDate.Value > filterDateEpisodeAdded) return false;                      }                        break;                    case GroupFilterConditionType.EpisodeCount:                      int.TryParse(gfc.ConditionParameter' out var epCount);                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.GreaterThan &&                          contractSerie.AniDBAnime.AniDBAnime.EpisodeCount < epCount) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LessThan &&                          contractSerie.AniDBAnime.AniDBAnime.EpisodeCount > epCount) return false;                      break;                    case GroupFilterConditionType.AniDBRating:                      decimal.TryParse(gfc.ConditionParameter' style' culture' out var dRating);                      int totalVotes = contractSerie.AniDBAnime.AniDBAnime.VoteCount +                                       contractSerie.AniDBAnime.AniDBAnime.TempVoteCount;                      decimal totalRating = contractSerie.AniDBAnime.AniDBAnime.Rating *                                            contractSerie.AniDBAnime.AniDBAnime.VoteCount +                                            contractSerie.AniDBAnime.AniDBAnime.TempRating *                                            contractSerie.AniDBAnime.AniDBAnime.TempVoteCount;                      decimal thisRating = totalVotes == 0 ? 0 : totalRating / totalVotes / 100;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.GreaterThan && thisRating < dRating)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LessThan && thisRating > dRating)                          return false;                      break;                    case GroupFilterConditionType.UserRating:                      decimal.TryParse(gfc.ConditionParameter' style' culture' out var dUserRating);                      decimal val = contractSerie.AniDBAnime.UserVote?.VoteValue ?? 0;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.GreaterThan && val < dUserRating)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.LessThan && val > dUserRating)                          return false;                      break;                      case GroupFilterConditionType.CustomTags:                      List<string> ctags =                          gfc.ConditionParameter.Trim()                              .Split(new[] {'''}' StringSplitOptions.RemoveEmptyEntries)                              .Select(a => a.ToLowerInvariant().Trim())                              .ToList();                      bool foundTag =                          ctags.FindInEnumerable(contractSerie.AniDBAnime.CustomTags.Select(a => a.TagName));                      if ((gfc.GetConditionOperatorEnum() == GroupFilterOperator.In) && !foundTag) return false;                      if ((gfc.GetConditionOperatorEnum() == GroupFilterOperator.NotIn) && foundTag) return false;                      break;                    case GroupFilterConditionType.AnimeType:                      List<string> ctypes =                          gfc.ConditionParameter.Trim()                              .Split(new[] {'''}' StringSplitOptions.RemoveEmptyEntries)                              .Select(                                  a => ((int) Commons.Extensions.Models.RawToType(a.ToLowerInvariant())).ToString())                              .ToList();                      bool foundAnimeType = ctypes.Contains(contractSerie.AniDBAnime.AniDBAnime.AnimeType.ToString());                      if ((gfc.GetConditionOperatorEnum() == GroupFilterOperator.In) && !foundAnimeType) return false;                      if ((gfc.GetConditionOperatorEnum() == GroupFilterOperator.NotIn) && foundAnimeType)                          return false;                      break;                    case GroupFilterConditionType.VideoQuality:                      List<string> vqs =                          gfc.ConditionParameter.Trim()                              .Split(new[] {'''}' StringSplitOptions.RemoveEmptyEntries)                              .Select(a => a.ToLowerInvariant().Trim())                              .ToList();                      bool foundVid = vqs.FindInEnumerable(contractSerie.AniDBAnime.Stat_AllVideoQuality);                      bool foundVidAllEps =                          vqs.FindInEnumerable(contractSerie.AniDBAnime.Stat_AllVideoQuality_Episodes);                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.In && !foundVid) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.NotIn && foundVid) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.InAllEpisodes && !foundVidAllEps)                          return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.NotInAllEpisodes && foundVidAllEps)                          return false;                      break;                    case GroupFilterConditionType.AudioLanguage:                      List<string> als =                          gfc.ConditionParameter.Trim()                              .Split(new[] {'''}' StringSplitOptions.RemoveEmptyEntries)                              .Select(a => a.ToLowerInvariant().Trim())                              .ToList();                      bool foundLang = als.FindInEnumerable(contractSerie.AniDBAnime.Stat_AudioLanguages);                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.In && !foundLang) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.NotIn && foundLang) return false;                      break;                    case GroupFilterConditionType.SubtitleLanguage:                      List<string> ass =                          gfc.ConditionParameter.Trim()                              .Split(new[] {'''}' StringSplitOptions.RemoveEmptyEntries)                              .Select(a => a.ToLowerInvariant().Trim())                              .ToList();                      bool foundSub = ass.FindInEnumerable(contractSerie.AniDBAnime.Stat_AudioLanguages);                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.In && !foundSub) return false;                      if (gfc.GetConditionOperatorEnum() == GroupFilterOperator.NotIn && foundSub) return false;                      break;              }
Missing Default,Shoko.Server.Models,SVR_GroupFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_GroupFilter.cs,EvaluateConditions,The following switch statement is missing a default case: switch (gfc.GetConditionOperatorEnum())                      {                          case GroupFilterOperator.Include:                          case GroupFilterOperator.In:                              if (years.Any(year => year >= BeginYear && year <= EndYear))                                  return true;                              return false;                          case GroupFilterOperator.Exclude:                          case GroupFilterOperator.NotIn:                              if (years.Any(year => year >= BeginYear && year <= EndYear))                                  return false;                              return true;                      }
Missing Default,Shoko.Server.Models,SVR_GroupFilter,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Models\SVR_GroupFilter.cs,EvaluateConditions,The following switch statement is missing a default case: switch (gfc.GetConditionOperatorEnum())                      {                          case GroupFilterOperator.Include:                          case GroupFilterOperator.In:                              return paramStrings.Any(a => contractSerie?.AniDBAnime?.IsInSeason(a.Item1' a.Item2) ?? false);                          case GroupFilterOperator.Exclude:                          case GroupFilterOperator.NotIn:                              return !paramStrings.Any(a => contractSerie?.AniDBAnime?.IsInSeason(a.Item1' a.Item2) ?? false);                      }
Missing Default,Shoko.Server.Renamer,LegacyRenamer,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Renamer\LegacyRenamer.cs,EvaluateTestH,The following switch statement is missing a default case: switch (episodes[0].GetEpisodeTypeEnum())                  {                      case EpisodeType.Episode:                          epType = "E";                          break;                      case EpisodeType.Credits:                          epType = "C";                          break;                      case EpisodeType.Other:                          epType = "O";                          break;                      case EpisodeType.Parody:                          epType = "P";                          break;                      case EpisodeType.Special:                          epType = "S";                          break;                      case EpisodeType.Trailer:                          epType = "T";                          break;                  }
Missing Default,Shoko.Server.Repositories.Cached,AniDB_VoteRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\AniDB_VoteRepository.cs,AniDB_VoteRepository,The following switch statement is missing a default case: switch (cr.VoteType)                  {                      case (int) AniDBVoteType.Anime:                      case (int) AniDBVoteType.AnimeTemp:                          SVR_AniDB_Anime.UpdateStatsByAnimeID(cr.EntityID);                          break;                      case (int) AniDBVoteType.Episode:                          SVR_AnimeEpisode ep = RepoFactory.AnimeEpisode.GetByID(cr.EntityID);                          RepoFactory.AnimeEpisode.Save(ep);                          break;                  }
Missing Default,Shoko.Server.Repositories.Cached,AniDB_VoteRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\AniDB_VoteRepository.cs,AniDB_VoteRepository,The following switch statement is missing a default case: switch (cr.VoteType)                  {                      case (int) AniDBVoteType.Anime:                      case (int) AniDBVoteType.AnimeTemp:                          SVR_AniDB_Anime.UpdateStatsByAnimeID(cr.EntityID);                          break;                      case (int) AniDBVoteType.Episode:                          SVR_AnimeEpisode ep = RepoFactory.AnimeEpisode.GetByID(cr.EntityID);                          RepoFactory.AnimeEpisode.Save(ep);                          break;                  }
Missing Default,Shoko.Server.Repositories,AniDB_AnimeRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\AniDB_AnimeRepository.cs,GetDefaultImagesByAnime,The following switch statement is missing a default case: switch ((ImageEntityType) aniDbDefImage.ImageParentType)                      {                          case ImageEntityType.TvDB_Banner:                              parentImage = (IImageEntity) result[1];                              break;                          case ImageEntityType.TvDB_Cover:                              parentImage = (IImageEntity) result[2];                              break;                          case ImageEntityType.TvDB_FanArt:                              parentImage = (IImageEntity) result[3];                              break;                          case ImageEntityType.MovieDB_Poster:                              parentImage = (IImageEntity) result[4];                              break;                          case ImageEntityType.MovieDB_FanArt:                              parentImage = (IImageEntity) result[5];                              break;                      }
Missing Default,Shoko.Server.Repositories,AniDB_AnimeRepository,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Repositories\Cached\AniDB_AnimeRepository.cs,GetDefaultImagesByAnime,The following switch statement is missing a default case: switch (defImage.AniDBImageSizeType)                      {                          case ImageSizeType.Poster:                              defImages.Poster = defImage;                              break;                          case ImageSizeType.WideBanner:                              defImages.WideBanner = defImage;                              break;                          case ImageSizeType.Fanart:                              defImages.Fanart = defImage;                              break;                      }
Missing Default,Shoko.Server.PlexAndKodi,CommonImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\CommonImplementation.cs,GetMetadata,The following switch statement is missing a default case: switch ((JMMType) type)                  {                      case JMMType.Group:                          return GetItemsFromGroup(prov' user.JMMUserID' Id' his' nocast' filter);                      case JMMType.GroupFilter:                          return GetGroupsOrSubFiltersFromFilter(prov' user.JMMUserID' Id' his' nocast);                      case JMMType.GroupUnsort:                          return GetUnsort(prov' user.JMMUserID' his);                      case JMMType.Serie:                          return GetItemsFromSerie(prov' user.JMMUserID' Id' his' nocast);                      case JMMType.Episode:                          return GetFromEpisode(prov' user.JMMUserID' Id' his);                      case JMMType.File:                          return GetFromFile(prov' user.JMMUserID' Id' his);                      case JMMType.Playlist:                          return GetItemsFromPlaylist(prov' user.JMMUserID' Id' his);                      case JMMType.FakeIosThumb:                          return FakeParentForIOSThumbnail(prov' Id);                  }
Missing Default,Shoko.Server.PlexAndKodi,CommonImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\CommonImplementation.cs,Search,The following switch statement is missing a default case: switch (ser.Contract.AniDBAnime.AniDBAnime.AnimeType)                      {                          case (int) AnimeType.Movie:                              v.SourceTitle = "Anime Movies";                              break;                          case (int) AnimeType.OVA:                              v.SourceTitle = "Anime Ovas";                              break;                          case (int) AnimeType.Other:                              v.SourceTitle = "Anime Others";                              break;                          case (int) AnimeType.TVSeries:                              v.SourceTitle = "Anime Series";                              break;                          case (int) AnimeType.TVSpecial:                              v.SourceTitle = "Anime Specials";                              break;                          case (int) AnimeType.Web:                              v.SourceTitle = "Anime Web Clips";                              break;                      }
Missing Default,Shoko.Server.PlexAndKodi,CommonImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\CommonImplementation.cs,TraktScrobble,The following switch statement is missing a default case: switch (status)                  {                      case (int) Providers.TraktTV.ScrobblePlayingStatus.Start:                          statusTraktV2 = Providers.TraktTV.ScrobblePlayingStatus.Start;                          break;                      case (int) Providers.TraktTV.ScrobblePlayingStatus.Pause:                          statusTraktV2 = Providers.TraktTV.ScrobblePlayingStatus.Pause;                          break;                      case (int) Providers.TraktTV.ScrobblePlayingStatus.Stop:                          statusTraktV2 = Providers.TraktTV.ScrobblePlayingStatus.Stop;                          break;                  }
Missing Default,Shoko.Server.PlexAndKodi,CommonImplementation,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\CommonImplementation.cs,TraktScrobble,The following switch statement is missing a default case: switch (typeTrakt)                  {                      // Movie                      case (int) Providers.TraktTV.ScrobblePlayingType.movie:                          rsp.Code = Providers.TraktTV.TraktTVHelper.Scrobble(                                  Providers.TraktTV.ScrobblePlayingType.movie' animeId'                                  statusTraktV2' progressTrakt)                              .ToString();                          rsp.Message = "Movie Scrobbled";                          break;                      // TV episode                      case (int) Providers.TraktTV.ScrobblePlayingType.episode:                          rsp.Code =                              Providers.TraktTV.TraktTVHelper.Scrobble(Providers.TraktTV.ScrobblePlayingType.episode'                                      animeId'                                      statusTraktV2' progressTrakt)                                  .ToString();                          rsp.Message = "Episode Scrobbled";                          break;                      //error                  }
Missing Default,Shoko.Server.PlexAndKodi,PlexEpisodeType,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\EpisodeType.cs,EpisodeTypeTranslated,The following switch statement is missing a default case: switch (an)                      {                          case AnimeType.Movie:                              tp.Name = plural ? "Movies" : "Movie";                              tp.Image = "plex_movies.png";                              return;                          case AnimeType.OVA:                              tp.Name = plural ? "Ovas" : "Ova";                              tp.Image = "plex_ovas.png";                              return;                          case AnimeType.Other:                              tp.Name = plural ? "Others" : "Other";                              tp.Image = "plex_others.png";                              return;                          case AnimeType.TVSeries:                              tp.Name = plural ? "Episodes" : "Episode";                              tp.Image = "plex_episodes.png";                              return;                          case AnimeType.TVSpecial:                              tp.Name = plural ? "TV Episodes" : "TV Episode";                              tp.Image = "plex_tvepisodes.png";                              return;                          case AnimeType.Web:                              tp.Name = plural ? "Web Clips" : "Web Clip";                              tp.Image = "plex_webclips.png";                              return;                      }
Missing Default,Shoko.Server.PlexAndKodi,Extensions,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Extensions.cs,GenerateKey,The following switch statement is missing a default case: switch ((Shoko.Models.PlexAndKodi.AnimeTypes) Enum.Parse(typeof(Shoko.Models.PlexAndKodi.AnimeTypes)'                  v.AnimeType' true))              {                  case Shoko.Models.PlexAndKodi.AnimeTypes.AnimeGroup:                      v.Key = prov.ConstructGroupIdUrl(userid' v.Id);                      break;                  case Shoko.Models.PlexAndKodi.AnimeTypes.AnimeSerie:                      v.Key = prov.ConstructSerieIdUrl(userid' v.Id);                      break;                  case Shoko.Models.PlexAndKodi.AnimeTypes.AnimeEpisode:                  case Shoko.Models.PlexAndKodi.AnimeTypes.AnimeFile:                      Helper.AddLinksToAnimeEpisodeVideo(prov' v' userid);                      AddResumePosition(v' prov' userid);                      break;              }
Missing Default,Shoko.Server.PlexAndKodi,Extensions,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Extensions.cs,AddResumePosition,The following switch statement is missing a default case: switch (                  (Shoko.Models.PlexAndKodi.AnimeTypes)                  Enum.Parse(typeof(Shoko.Models.PlexAndKodi.AnimeTypes)' v.AnimeType' true))              {                  case Shoko.Models.PlexAndKodi.AnimeTypes.AnimeEpisode:                      if (v.Medias != null)                      {                          VideoLocal_User vl = v.Medias.Select(a => RepoFactory.VideoLocal.GetByID(int.Parse(a.Id)))                              .Where(a => a != null)                              .Select(a => a.GetUserRecord(userid))                              .Where(a => a != null)                              .OrderByDescending(a => a.ResumePosition)                              .FirstOrDefault();                          if (vl != null && vl.ResumePosition > 0)                          {                              v.ViewOffset = vl.ResumePosition.ToString();                              if (vl.WatchedDate.HasValue)                                  v.LastViewedAt = vl.WatchedDate.Value.ToUnixTime();                          }                      }                      break;                  case Shoko.Models.PlexAndKodi.AnimeTypes.AnimeFile:                      int vid = int.Parse(v.Id); //This suxx' but adding regeneration at videolocal_user is worst.                      VideoLocal_User vl2 = RepoFactory.VideoLocal.GetByID(vid)?.GetUserRecord(userid);                      if (vl2 != null && vl2.ResumePosition > 0)                      {                          v.ViewOffset = vl2.ResumePosition.ToString();                          if (vl2.WatchedDate.HasValue)                              v.LastViewedAt = vl2.WatchedDate.Value.ToUnixTime();                      }                      break;              }
Missing Default,Shoko.Server.PlexAndKodi,Helper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Helper.cs,AddInformationFromMasterSeries,The following switch statement is missing a default case: switch (cserie.AniDBAnime.AniDBAnime.AnimeType)              {                  case (int) AnimeType.Movie:                      v.Type = "movie";                      if (v.Title.StartsWith("Complete Movie"))                      {                          v.Title = nv.Title;                          v.Summary = nv.Summary;                          v.Index = null;                          ret = true;                      }                      else if (v.Title.StartsWith("Part "))                      {                          v.Title = nv.Title + " - " + v.Title;                          v.Summary = nv.Summary;                      }                      v.Thumb = nv.Thumb;                      break;                  case (int) AnimeType.OVA:                      if (v.Title == "OVA")                      {                          v.Title = nv.Title;                          v.Type = "movie";                          v.Thumb = nv.Thumb;                          v.Summary = nv.Summary;                          v.Index = null;                          ret = true;                      }                      break;              }
Missing Default,Shoko.Server.PlexAndKodi.Plex,PlexProvider,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\PlexAndKodi\Plex\PlexProvider.cs,NewMediaContainer,The following switch statement is missing a default case: switch (type)              {                  case MediaContainerTypes.Show:                      m.ViewGroup = "show";                      m.ViewMode = "65592";                      break;                  case MediaContainerTypes.Episode:                      m.ViewGroup = "episode";                      m.ViewMode = "65592";                      break;                  case MediaContainerTypes.Video:                      m.ViewMode = "65586";                      m.ViewGroup = "video";                      break;                  case MediaContainerTypes.Season:                      m.ViewMode = "131132";                      m.ViewGroup = "season";                      break;                  case MediaContainerTypes.Movie:                      m.ViewGroup = "movie";                      m.ViewMode = "65592";                      break;                  case MediaContainerTypes.File:                      break;              }
Missing Default,Shoko.Server.Tasks,AutoAnimeGroupCalculator,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Tasks\AutoAnimeGroupCalculator.cs,AutoAnimeGroupCalculator,The following switch statement is missing a default case: switch (mainAnimeSelectionStrategy)              {                  case MainAnimeSelectionStrategy.MinAirDate:                      _mainAnimeSelector = FindSuitableAnimeByMinAirDate;                      break;                  case MainAnimeSelectionStrategy.Weighted:                      _mainAnimeSelector = FindSuitableAnimeByWeighting;                      break;              }
Missing Default,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,SyncEpisodeToTrakt,The following switch statement is missing a default case: switch (syncType)                  {                      case TraktSyncType.CollectionAdd:                          url = TraktURIs.SyncCollectionAdd;                          break;                      case TraktSyncType.CollectionRemove:                          url = TraktURIs.SyncCollectionRemove;                          break;                      case TraktSyncType.HistoryAdd:                          url = TraktURIs.SyncHistoryAdd;                          break;                      case TraktSyncType.HistoryRemove:                          url = TraktURIs.SyncHistoryRemove;                          break;                  }
Missing Default,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,Scrobble,The following switch statement is missing a default case: switch (scrobbleType)                      {                          case ScrobblePlayingType.episode:                              TraktV2ScrobbleEpisode showE = new TraktV2ScrobbleEpisode();                              showE.Init(progress' traktID' slugID' season' epNumber);                              json = JSONHelper.Serialize(showE);                              break;                            //do we have any movies that work?                          case ScrobblePlayingType.movie:                              TraktV2ScrobbleMovie showM = new TraktV2ScrobbleMovie();                              json = JSONHelper.Serialize(showM);                              showM.Init(progress' slugID' traktID.ToString());                              break;                      }
Missing Default,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,SyncCollectionToTrakt,The following switch statement is missing a default case: switch (epsync.SyncType)                                  {                                      case TraktSyncType.CollectionAdd:                                          syncCollectionAdd.AddEpisode(epsync.Slug' epsync.Season' epsync.EpNumber'                                              epsync.EpDate);                                          break;                                      case TraktSyncType.CollectionRemove:                                          syncCollectionRemove.AddEpisode(epsync.Slug' epsync.Season' epsync.EpNumber'                                              epsync.EpDate);                                          break;                                      case TraktSyncType.HistoryAdd:                                          syncHistoryAdd.AddEpisode(epsync.Slug' epsync.Season' epsync.EpNumber'                                              epsync.EpDate);                                          break;                                      case TraktSyncType.HistoryRemove:                                          syncHistoryRemove.AddEpisode(epsync.Slug' epsync.Season' epsync.EpNumber'                                              epsync.EpDate);                                          break;                                  }
Missing Default,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,SyncCollectionToTrakt,The following switch statement is missing a default case: switch (epsync.SyncType)                                          {                                              case TraktSyncType.CollectionAdd:                                                  syncCollectionAdd.AddEpisode(epsync.Slug' epsync.Season'                                                      epsync.EpNumber'                                                      epsync.EpDate);                                                  break;                                              case TraktSyncType.CollectionRemove:                                                  syncCollectionRemove.AddEpisode(epsync.Slug' epsync.Season'                                                      epsync.EpNumber' epsync.EpDate);                                                  break;                                              case TraktSyncType.HistoryAdd:                                                  syncHistoryAdd.AddEpisode(epsync.Slug' epsync.Season' epsync.EpNumber'                                                      epsync.EpDate);                                                  break;                                              case TraktSyncType.HistoryRemove:                                                  syncHistoryRemove.AddEpisode(epsync.Slug' epsync.Season'                                                      epsync.EpNumber'                                                      epsync.EpDate);                                                  break;                                          }
Missing Default,Shoko.Server.Providers.TraktTV,TraktTVHelper,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Providers\TraktTV\TraktTVHelper.cs,SyncCollectionToTrakt,The following switch statement is missing a default case: switch (epsync.SyncType)                                          {                                              case TraktSyncType.CollectionAdd:                                                  syncCollectionAdd.AddEpisode(epsync.Slug' epsync.Season'                                                      epsync.EpNumber'                                                      epsync.EpDate);                                                  break;                                              case TraktSyncType.CollectionRemove:                                                  syncCollectionRemove.AddEpisode(epsync.Slug' epsync.Season'                                                      epsync.EpNumber' epsync.EpDate);                                                  break;                                              case TraktSyncType.HistoryAdd:                                                  syncHistoryAdd.AddEpisode(epsync.Slug' epsync.Season' epsync.EpNumber'                                                      epsync.EpDate);                                                  break;                                              case TraktSyncType.HistoryRemove:                                                  syncHistoryRemove.AddEpisode(epsync.Slug' epsync.Season'                                                      epsync.EpNumber'                                                      epsync.EpDate);                                                  break;                                          }
Missing Default,LeanWork.IO.FileSystem,BufferingFileSystemWatcher,C:\repos\japanesemediamanager_jmmserver\Shoko.Server\Utilities\LeanWork\IO\FileSystem\BufferingFileSystemWatcher.cs,RaiseBufferedEventsUntilCancelled,The following switch statement is missing a default case: switch (e.ChangeType)                              {                                  case WatcherChangeTypes.Created:                                      InvokeHandler(_onCreatedHandler' e);                                      break;                                  case WatcherChangeTypes.Changed:                                      InvokeHandler(_onChangedHandler' e);                                      break;                                  case WatcherChangeTypes.Deleted:                                      InvokeHandler(_onDeletedHandler' e);                                      break;                                  case WatcherChangeTypes.Renamed:                                      InvokeHandler(_onRenamedHandler' e as RenamedEventArgs);                                      break;                              }
