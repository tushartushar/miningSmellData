Implementation smell,Namespace,Class,File,Method,Description
Long Method,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The method has 307 lines of code.
Complex Method,IIS.SLSharp.Bindings.OpenTK,SLSharpBinding,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Bindings.cs,Compile,Cyclomatic complexity of the method is 10
Complex Method,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,Cyclomatic complexity of the method is 94
Long Parameter List,IIS.SLSharp.Bindings.OpenTK.Textures,RenderToTexture,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\RenderToTexture.cs,RenderToTexture,The method has 6 parameters.
Long Parameter List,IIS.SLSharp.Bindings.OpenTK.Textures,RenderToTexture,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\RenderToTexture.cs,RenderToTexture,The method has 5 parameters.
Long Parameter List,IIS.SLSharp.Bindings.OpenTK.Textures,RenderToTexture,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\RenderToTexture.cs,RenderToTexture,The method has 5 parameters.
Long Parameter List,IIS.SLSharp.Bindings.OpenTK.Textures,Texture2D,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Texture2D.cs,Texture2D,The method has 5 parameters.
Long Statement,IIS.SLSharp.Bindings.OpenTK,Program,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Program.cs,Validate,The length of the statement  "	var log = "=== Compilation log ===" + Environment.NewLine + logCompile + Environment.NewLine + "=== Validation log ===" + Environment.NewLine + logValidate; " is 156.
Long Statement,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The length of the statement  "		// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool ..... " is 121.
Long Statement,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The length of the statement  "			throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time."); " is 141.
Long Statement,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The length of the statement  "									GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2))); " is 125.
Long Statement,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The length of the statement  "									GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5))); " is 125.
Long Statement,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The length of the statement  "									throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier."); " is 139.
Long Statement,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The length of the statement  "						GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface); " is 164.
Long Statement,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The length of the statement  "						GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface); " is 187.
Long Statement,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The length of the statement  "						GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width); " is 125.
Long Statement,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The length of the statement  "						GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height); " is 127.
Long Statement,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The length of the statement  "						GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat); " is 143.
Long Statement,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The length of the statement  "						GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed); " is 135.
Long Statement,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The length of the statement  "						Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height); " is 201.
Long Statement,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The length of the statement  "						throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ()); " is 129.
Long Statement,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The length of the statement  "				Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)")); " is 172.
Long Statement,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The length of the statement  "		throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename)); " is 152.
Long Statement,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,GetString,The length of the statement  "	return string.Empty + (char)input [offset + 0] + (char)input [offset + 1] + (char)input [offset + 2] + (char)input [offset + 3]; " is 128.
Long Statement,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,GetDescriptionFromFile,The length of the statement  "	return "\n--> Header of " + filename + "\nID: " + idString + "\nSize: " + dwSize + "\nFlags: " + dwFlags + " (" + (eDDSD)dwFlags + ")" + "\nHeight: " + dwHeight + "\nWidth: " + dwWidth + "\nPitch: " + dwPitchOrLinearSize + "\nDepth: " + dwDepth + "\nMipMaps: " + dwMipMapCount + "\n\n---PixelFormat---" + filename + "\nSize: " + pfSize + "\nFlags: " + pfFlags + " (" + (eDDPF)pfFlags + ")" + "\nFourCC: " + pfFourCC + " (" + (eFOURCC)pfFourCC + ")" +  " is 450.
Long Statement,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,GetDescriptionFromFile,The length of the statement  "	"\n\n---Capabilities---" + filename + "\nCaps1: " + dwCaps1 + " (" + (eDDSCAPS)dwCaps1 + ")" + "\nCaps2: " + dwCaps2 + " (" + (eDDSCAPS2)dwCaps2 + ")"; " is 151.
Long Statement,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,GetDescriptionFromMemory,The length of the statement  "	return "\nFile: " + filename + "\nDimension: " + Dimension + "\nSize: " + _Width + " * " + _Height + " * " + _Depth + "\nCompressed: " + _IsCompressed + "\nBytes for Main Image: " + _BytesForMainSurface + "\nMipMaps: " + _MipMapCount; " is 234.
Long Statement,IIS.SLSharp.Bindings.OpenTK.Textures,FramebufferObject,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\FramebufferObject.cs,SetTexture,The length of the statement  "	GL.FramebufferTexture2D (FramebufferTarget.Framebuffer' FramebufferAttachment.ColorAttachment0 + index' texture.Target' texture.Name' 0); " is 137.
Long Statement,IIS.SLSharp.Bindings.OpenTK.Textures,RenderbufferObject,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\RenderbufferObject.cs,SetSize,The length of the statement  "	GL.FramebufferRenderbuffer (FramebufferTarget.Framebuffer' FramebufferAttachment.DepthAttachment' RenderbufferTarget.Renderbuffer' _rbo); " is 137.
Long Statement,IIS.SLSharp.Bindings.OpenTK.Textures,Texture2D,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Texture2D.cs,GenerateMipMaps,The length of the statement  "		throw new NotImplementedException ("You currently GL_EXT_framebuffer_object; we need need testing here as the" + " fallback version doesn't seem to work."); " is 156.
Long Statement,IIS.SLSharp.Bindings.OpenTK.Textures,Texture2D,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Texture2D.cs,FromBitmap,The length of the statement  "	var bits = bmp.LockBits (new Rectangle (0' 0' bmp.Width' bmp.Height)' ImageLockMode.ReadOnly' System.Drawing.Imaging.PixelFormat.Format32bppArgb); " is 146.
Complex Conditional,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The conditional expression  "idString != "DDS " || // magic key  dwSize != 124 || // constant size of struct' never reused  pfSize != 32 || // constant size of struct' never reused  !CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  !CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  !CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)"  is complex.
Complex Conditional,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The conditional expression  "TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes"  is complex.
Complex Conditional,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The conditional expression  "GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0"  is complex.
Magic Number,IIS.SLSharp.Bindings.OpenTK,Quad,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Quad.cs,Render,The following statement contains a magic number: GL.VertexAttribPointer (posLocation' 2' VertexAttribPointerType.Float' false' 0' 0);  
Magic Number,IIS.SLSharp.Bindings.OpenTK,Quad,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Quad.cs,Render,The following statement contains a magic number: GL.DrawArrays (BeginMode.Quads' positive ? 4 : 0' 4);  
Magic Number,IIS.SLSharp.Bindings.OpenTK,Quad,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Quad.cs,Render,The following statement contains a magic number: GL.DrawArrays (BeginMode.Quads' positive ? 4 : 0' 4);  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try// Exceptions will be thrown if any Problem occurs while working on the file.    {  	_RawDataFromFile = File.ReadAllBytes (@filename);  	#region Translate Header to less cryptic representation  	ConvertDX9Header (ref _RawDataFromFile);  	// The first 128 Bytes of the file is non-image data  	// start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....  	if (idString != "DDS " || // magic key  	dwSize != 124 || // constant size of struct' never reused  	pfSize != 32 || // constant size of struct' never reused  	!CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  	!CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  	!CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  	)  		throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  	#region Examine Flags  	if (CheckFlag (dwFlags' (uint)eDDSD.WIDTH))  		_Width = (int)dwWidth;  	else  		throw new ArgumentException ("ERROR: Flag for Width not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.HEIGHT))  		_Height = (int)dwHeight;  	else  		throw new ArgumentException ("ERROR: Flag for Height not set.");  	if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  		dimension = TextureTarget.Texture3D;  		// image is 3D Volume  		_Depth = (int)dwDepth;  		throw Unfinished;  	} else {  		// image is 2D or Cube  		if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  			dimension = TextureTarget.TextureCubeMap;  			_Depth = 6;  		} else {  			dimension = TextureTarget.Texture2D;  			_Depth = 1;  		}  	}  	// these flags must be set for mipmaps to be included  	if (CheckFlag (dwCaps1' (uint)eDDSCAPS.MIPMAP) && CheckFlag (dwFlags' (uint)eDDSD.MIPMAPCOUNT))  		_MipMapCount = (int)dwMipMapCount;  	// image contains MipMaps  	else  		_MipMapCount = 1;  	// only 1 main image  	// Should never happen  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH) && CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE))  		throw new ArgumentException ("INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time.");  	// This flag is set if format is uncompressed RGB RGBA etc.  	if (CheckFlag (dwFlags' (uint)eDDSD.PITCH)) {  		// _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed  		_IsCompressed = false;  		throw Unfinished;  	}  	// This flag is set if format is compressed DXTn.  	if (CheckFlag (dwFlags' (uint)eDDSD.LINEARSIZE)) {  		_BytesForMainSurface = (int)dwPitchOrLinearSize;  		_IsCompressed = true;  	}  	#endregion Examine Flags  	#region Examine Pixel Format' anything but DXTn will fail atm.  	if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  		switch ((eFOURCC)pfFourCC) {  		case eFOURCC.DXT1:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  			_BytesPerBlock = 8;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT2:  		case eFOURCC.DXT3:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		//case eFOURCC.DXT4:  		case eFOURCC.DXT5:  			_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  			_BytesPerBlock = 16;  			_IsCompressed = true;  			break;  		default:  			throw Unfinished;  		// handle uncompressed formats   		}  	else  		throw Unfinished;  	// pf*Bitmasks should be examined here  	#endregion  	// Works' but commented out because some texture authoring tools don't set this flag.  	/* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                 if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                 {                     if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                         Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                 }*/if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("\n" + GetDescriptionFromMemory (filename' dimension));  	#endregion Translate Header to less cryptic representation  	#region send the Texture to GL  	#region Generate and Bind Handle  	GL.GenTextures (1' out texturehandle);  	GL.BindTexture (dimension' texturehandle);  	#endregion Generate and Bind Handle  	int Cursor = HeaderSizeInBytes;  	// foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D  	for (int Slices = 0; Slices < _Depth; Slices++) {  		int trueMipMapCount = _MipMapCount - 1;  		// TODO: triplecheck correctness  		int Width = _Width;  		int Height = _Height;  		for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  		 {  			#region determine Dimensions  			int BlocksPerRow = (Width + 3) >> 2;  			int BlocksPerColumn = (Height + 3) >> 2;  			int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  			//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  			int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  			// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  			if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  				Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  			#endregion determine Dimensions  			// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  			if (Width > 2 && Height > 2) {  				// Note: there could be a potential problem with non-power-of-two cube maps  				#region Prepare Array for TexImage  				byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  				if (!TextureLoaderParameters.FlipImages) {  					// no changes to the image' copy as is  					Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  				} else {  					// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  					for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  						int targetColumn = BlocksPerColumn - sourceColumn - 1;  						for (int row = 0; row < BlocksPerRow; row++) {  							int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  							int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  							#region Swap Bytes  							switch (_PixelInternalFormat) {  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  								// Color only  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  								// Alpha  								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  								RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  								RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  								RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  								RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  								RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  								// Alpha' the first 2 bytes remain   								RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  								RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  								// extract 3 bits each and flip them  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  								GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  								// Color  								RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  								RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  								RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  								RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  								RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  								RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  								RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  								RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  								break;  							default:  								throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  							}  							#endregion Swap Bytes  						}  					}  				}  				#endregion Prepare Array for TexImage  				#region Create TexImage  				switch (dimension) {  				case TextureTarget.Texture2D:  					GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.TextureCubeMap:  					GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  					break;  				case TextureTarget.Texture1D:  				// Untested  				case TextureTarget.Texture3D:  				// Untested  				default:  					throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  				}  				GL.Finish ();  				#endregion Create TexImage  				#region Query Success  				int width' height' internalformat' compressed;  				switch (dimension) {  				case TextureTarget.Texture1D:  				case TextureTarget.Texture2D:  				case TextureTarget.Texture3D:  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				case TextureTarget.TextureCubeMap:  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  					GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  					break;  				default:  					throw Unfinished;  				}  				GLError = GL.GetError ();  				if (TextureLoaderParameters.Verbose)  					Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  				if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  					GL.DeleteTextures (1' ref texturehandle);  					throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  				}  				#endregion Query Success  			} else {  				if (trueMipMapCount > Level)  					trueMipMapCount = Level - 1;  				// The current Level is invalid  			}  			#region Prepare the next MipMap level  			Width /= 2;  			if (Width < 1)  				Width = 1;  			Height /= 2;  			if (Height < 1)  				Height = 1;  			Cursor += SurfaceSizeInBytes;  			#endregion Prepare the next MipMap level  		}  		#region Set States properly  		GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  		GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  		int TexMaxLevel;  		GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  		#endregion Set States properly  	}  	#region Set Texture Parameters  	GL.TexParameter (dimension' TextureParameterName.TextureMinFilter' (int)TextureLoaderParameters.MinificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureMagFilter' (int)TextureLoaderParameters.MagnificationFilter);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapS' (int)TextureLoaderParameters.WrapModeS);  	GL.TexParameter (dimension' TextureParameterName.TextureWrapT' (int)TextureLoaderParameters.WrapModeT);  	GL.TexEnv (TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int)TextureLoaderParameters.EnvMode);  	GLError = GL.GetError ();  	if (GLError != ErrorCode.NoError) {  		throw new ArgumentException ("Error setting Texture Parameters. GL Error: " + GLError);  	}  	#endregion Set Texture Parameters  	// If it made it here without throwing any Exception the result is a valid Texture.  	return;  	// success  	#endregion send the Texture to GL  } catch (Exception e) {  	dimension = (TextureTarget)0;  	texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;  	throw new ArgumentException ("ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile (filename));  	// return; // failure  } finally {  	_RawDataFromFile = null;  	// clarity' not really needed  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (idString != "DDS " || // magic key  dwSize != 124 || // constant size of struct' never reused  pfSize != 32 || // constant size of struct' never reused  !CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  !CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  !CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  )  	throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (idString != "DDS " || // magic key  dwSize != 124 || // constant size of struct' never reused  pfSize != 32 || // constant size of struct' never reused  !CheckFlag (dwFlags' (uint)eDDSD.CAPS) || // must know it's caps  !CheckFlag (dwFlags' (uint)eDDSD.PIXELFORMAT) || // must know it's format  !CheckFlag (dwCaps1' (uint)eDDSCAPS.TEXTURE)// must be a Texture  )  	throw new ArgumentException ("ERROR: File has invalid signature or missing Flags.");  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (CheckFlag (dwFlags' (uint)eDDSD.DEPTH) && CheckFlag (dwCaps2' (uint)eDDSCAPS2.VOLUME)) {  	dimension = TextureTarget.Texture3D;  	// image is 3D Volume  	_Depth = (int)dwDepth;  	throw Unfinished;  } else {  	// image is 2D or Cube  	if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  		dimension = TextureTarget.TextureCubeMap;  		_Depth = 6;  	} else {  		dimension = TextureTarget.Texture2D;  		_Depth = 1;  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (CheckFlag (dwCaps2' (uint)eDDSCAPS2.CUBEMAP)) {  	dimension = TextureTarget.TextureCubeMap;  	_Depth = 6;  } else {  	dimension = TextureTarget.Texture2D;  	_Depth = 1;  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: _Depth = 6;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  	switch ((eFOURCC)pfFourCC) {  	case eFOURCC.DXT1:  		_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  		_BytesPerBlock = 8;  		_IsCompressed = true;  		break;  	//case eFOURCC.DXT2:  	case eFOURCC.DXT3:  		_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  		_BytesPerBlock = 16;  		_IsCompressed = true;  		break;  	//case eFOURCC.DXT4:  	case eFOURCC.DXT5:  		_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  		_BytesPerBlock = 16;  		_IsCompressed = true;  		break;  	default:  		throw Unfinished;  	// handle uncompressed formats   	}  else  	throw Unfinished;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  	switch ((eFOURCC)pfFourCC) {  	case eFOURCC.DXT1:  		_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  		_BytesPerBlock = 8;  		_IsCompressed = true;  		break;  	//case eFOURCC.DXT2:  	case eFOURCC.DXT3:  		_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  		_BytesPerBlock = 16;  		_IsCompressed = true;  		break;  	//case eFOURCC.DXT4:  	case eFOURCC.DXT5:  		_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  		_BytesPerBlock = 16;  		_IsCompressed = true;  		break;  	default:  		throw Unfinished;  	// handle uncompressed formats   	}  else  	throw Unfinished;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (CheckFlag (pfFlags' (uint)eDDPF.FOURCC))  	switch ((eFOURCC)pfFourCC) {  	case eFOURCC.DXT1:  		_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  		_BytesPerBlock = 8;  		_IsCompressed = true;  		break;  	//case eFOURCC.DXT2:  	case eFOURCC.DXT3:  		_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  		_BytesPerBlock = 16;  		_IsCompressed = true;  		break;  	//case eFOURCC.DXT4:  	case eFOURCC.DXT5:  		_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  		_BytesPerBlock = 16;  		_IsCompressed = true;  		break;  	default:  		throw Unfinished;  	// handle uncompressed formats   	}  else  	throw Unfinished;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch ((eFOURCC)pfFourCC) {  case eFOURCC.DXT1:  	_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  	_BytesPerBlock = 8;  	_IsCompressed = true;  	break;  //case eFOURCC.DXT2:  case eFOURCC.DXT3:  	_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  	_BytesPerBlock = 16;  	_IsCompressed = true;  	break;  //case eFOURCC.DXT4:  case eFOURCC.DXT5:  	_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  	_BytesPerBlock = 16;  	_IsCompressed = true;  	break;  default:  	throw Unfinished;  // handle uncompressed formats   }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch ((eFOURCC)pfFourCC) {  case eFOURCC.DXT1:  	_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  	_BytesPerBlock = 8;  	_IsCompressed = true;  	break;  //case eFOURCC.DXT2:  case eFOURCC.DXT3:  	_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  	_BytesPerBlock = 16;  	_IsCompressed = true;  	break;  //case eFOURCC.DXT4:  case eFOURCC.DXT5:  	_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  	_BytesPerBlock = 16;  	_IsCompressed = true;  	break;  default:  	throw Unfinished;  // handle uncompressed formats   }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch ((eFOURCC)pfFourCC) {  case eFOURCC.DXT1:  	_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;  	_BytesPerBlock = 8;  	_IsCompressed = true;  	break;  //case eFOURCC.DXT2:  case eFOURCC.DXT3:  	_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;  	_BytesPerBlock = 16;  	_IsCompressed = true;  	break;  //case eFOURCC.DXT4:  case eFOURCC.DXT5:  	_PixelInternalFormat = (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;  	_BytesPerBlock = 16;  	_IsCompressed = true;  	break;  default:  	throw Unfinished;  // handle uncompressed formats   }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: _BytesPerBlock = 8;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: _BytesPerBlock = 16;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: _BytesPerBlock = 16;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Slices = 0; Slices < _Depth; Slices++) {  	int trueMipMapCount = _MipMapCount - 1;  	// TODO: triplecheck correctness  	int Width = _Width;  	int Height = _Height;  	for (int Level = 0; Level < _MipMapCount; Level++)// start at base image  	 {  		#region determine Dimensions  		int BlocksPerRow = (Width + 3) >> 2;  		int BlocksPerColumn = (Height + 3) >> 2;  		int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  		//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  		int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  		// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  		if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  			Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  		#endregion determine Dimensions  		// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  		if (Width > 2 && Height > 2) {  			// Note: there could be a potential problem with non-power-of-two cube maps  			#region Prepare Array for TexImage  			byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  			if (!TextureLoaderParameters.FlipImages) {  				// no changes to the image' copy as is  				Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  			} else {  				// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  				for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  					int targetColumn = BlocksPerColumn - sourceColumn - 1;  					for (int row = 0; row < BlocksPerRow; row++) {  						int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  						int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  						#region Swap Bytes  						switch (_PixelInternalFormat) {  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  							// Color only  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  							// Alpha  							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  							RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  							RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  							RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  							RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  							RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  							// Alpha' the first 2 bytes remain   							RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  							RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  							// extract 3 bits each and flip them  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  							GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  							// Color  							RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  							RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  							RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  							RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  							RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  							RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  							RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  							RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  							break;  						default:  							throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  						}  						#endregion Swap Bytes  					}  				}  			}  			#endregion Prepare Array for TexImage  			#region Create TexImage  			switch (dimension) {  			case TextureTarget.Texture2D:  				GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.TextureCubeMap:  				GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  				break;  			case TextureTarget.Texture1D:  			// Untested  			case TextureTarget.Texture3D:  			// Untested  			default:  				throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  			}  			GL.Finish ();  			#endregion Create TexImage  			#region Query Success  			int width' height' internalformat' compressed;  			switch (dimension) {  			case TextureTarget.Texture1D:  			case TextureTarget.Texture2D:  			case TextureTarget.Texture3D:  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			case TextureTarget.TextureCubeMap:  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  				GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  				break;  			default:  				throw Unfinished;  			}  			GLError = GL.GetError ();  			if (TextureLoaderParameters.Verbose)  				Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  			if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  				GL.DeleteTextures (1' ref texturehandle);  				throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  			}  			#endregion Query Success  		} else {  			if (trueMipMapCount > Level)  				trueMipMapCount = Level - 1;  			// The current Level is invalid  		}  		#region Prepare the next MipMap level  		Width /= 2;  		if (Width < 1)  			Width = 1;  		Height /= 2;  		if (Height < 1)  			Height = 1;  		Cursor += SurfaceSizeInBytes;  		#endregion Prepare the next MipMap level  	}  	#region Set States properly  	GL.TexParameter (dimension' (TextureParameterName)All.TextureBaseLevel' 0);  	GL.TexParameter (dimension' (TextureParameterName)All.TextureMaxLevel' trueMipMapCount);  	int TexMaxLevel;  	GL.GetTexParameter (dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel);  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("Verification: GL: " + GL.GetError ().ToString () + " TextureMaxLevel: " + TexMaxLevel + ((TexMaxLevel == trueMipMapCount) ? " (Correct.)" : " (Wrong!)"));  	#endregion Set States properly  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int Level = 0; Level < _MipMapCount; Level++)// start at base image   {  	#region determine Dimensions  	int BlocksPerRow = (Width + 3) >> 2;  	int BlocksPerColumn = (Height + 3) >> 2;  	int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn;  	//   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5  	int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;  	// this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.  	if (TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes)  		Trace.WriteLine ("Warning: Calculated byte-count of main image differs from what was read from file.");  	#endregion determine Dimensions  	// skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.  	if (Width > 2 && Height > 2) {  		// Note: there could be a potential problem with non-power-of-two cube maps  		#region Prepare Array for TexImage  		byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  		if (!TextureLoaderParameters.FlipImages) {  			// no changes to the image' copy as is  			Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  		} else {  			// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  			for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  				int targetColumn = BlocksPerColumn - sourceColumn - 1;  				for (int row = 0; row < BlocksPerRow; row++) {  					int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  					int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  					#region Swap Bytes  					switch (_PixelInternalFormat) {  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  						// Color only  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  						// Alpha  						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  						RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  						RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  						RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  						RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  						RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  						// Alpha' the first 2 bytes remain   						RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  						RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  						// extract 3 bits each and flip them  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  						GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  						// Color  						RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  						RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  						RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  						RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  						RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  						RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  						RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  						RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  						break;  					default:  						throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  					}  					#endregion Swap Bytes  				}  			}  		}  		#endregion Prepare Array for TexImage  		#region Create TexImage  		switch (dimension) {  		case TextureTarget.Texture2D:  			GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.TextureCubeMap:  			GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  			break;  		case TextureTarget.Texture1D:  		// Untested  		case TextureTarget.Texture3D:  		// Untested  		default:  			throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  		}  		GL.Finish ();  		#endregion Create TexImage  		#region Query Success  		int width' height' internalformat' compressed;  		switch (dimension) {  		case TextureTarget.Texture1D:  		case TextureTarget.Texture2D:  		case TextureTarget.Texture3D:  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		case TextureTarget.TextureCubeMap:  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  			GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  			break;  		default:  			throw Unfinished;  		}  		GLError = GL.GetError ();  		if (TextureLoaderParameters.Verbose)  			Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  		if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  			GL.DeleteTextures (1' ref texturehandle);  			throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  		}  		#endregion Query Success  	} else {  		if (trueMipMapCount > Level)  			trueMipMapCount = Level - 1;  		// The current Level is invalid  	}  	#region Prepare the next MipMap level  	Width /= 2;  	if (Width < 1)  		Width = 1;  	Height /= 2;  	if (Height < 1)  		Height = 1;  	Cursor += SurfaceSizeInBytes;  	#endregion Prepare the next MipMap level  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (Width > 2 && Height > 2) {  	// Note: there could be a potential problem with non-power-of-two cube maps  	#region Prepare Array for TexImage  	byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];  	if (!TextureLoaderParameters.FlipImages) {  		// no changes to the image' copy as is  		Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  	} else {  		// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  		for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  			int targetColumn = BlocksPerColumn - sourceColumn - 1;  			for (int row = 0; row < BlocksPerRow; row++) {  				int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  				int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  				#region Swap Bytes  				switch (_PixelInternalFormat) {  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  					// Color only  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  					// Alpha  					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  					RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  					RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  					RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  					RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  					RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  					// Alpha' the first 2 bytes remain   					RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  					RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  					// extract 3 bits each and flip them  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  					GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  					// Color  					RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  					RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  					RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  					RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  					RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  					RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  					RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  					RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  					break;  				default:  					throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  				}  				#endregion Swap Bytes  			}  		}  	}  	#endregion Prepare Array for TexImage  	#region Create TexImage  	switch (dimension) {  	case TextureTarget.Texture2D:  		GL.CompressedTexImage2D (TextureTarget.Texture2D' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.TextureCubeMap:  		GL.CompressedTexImage2D (TextureTarget.TextureCubeMapPositiveX + Slices' Level' _PixelInternalFormat' Width' Height' TextureLoaderParameters.Border' SurfaceSizeInBytes' RawDataOfSurface);  		break;  	case TextureTarget.Texture1D:  	// Untested  	case TextureTarget.Texture3D:  	// Untested  	default:  		throw new ArgumentException ("ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension);  	}  	GL.Finish ();  	#endregion Create TexImage  	#region Query Success  	int width' height' internalformat' compressed;  	switch (dimension) {  	case TextureTarget.Texture1D:  	case TextureTarget.Texture2D:  	case TextureTarget.Texture3D:  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (dimension' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	case TextureTarget.TextureCubeMap:  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat);  		GL.GetTexLevelParameter (TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed);  		break;  	default:  		throw Unfinished;  	}  	GLError = GL.GetError ();  	if (TextureLoaderParameters.Verbose)  		Trace.WriteLine ("GL: " + GLError.ToString () + " Level: " + Level + " DXTn: " + ((compressed == 1) ? "Yes" : "No") + " Frmt:" + (ExtTextureCompressionS3tc)internalformat + " " + width + "*" + height);  	if (GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0) {  		GL.DeleteTextures (1' ref texturehandle);  		throw new ArgumentException ("ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString ());  	}  	#endregion Query Success  } else {  	if (trueMipMapCount > Level)  		trueMipMapCount = Level - 1;  	// The current Level is invalid  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: if (!TextureLoaderParameters.FlipImages) {  	// no changes to the image' copy as is  	Array.Copy (_RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes);  } else {  	// Turn the blocks upside down and the rows aswell' done in a single pass through all blocks  	for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  		int targetColumn = BlocksPerColumn - sourceColumn - 1;  		for (int row = 0; row < BlocksPerRow; row++) {  			int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  			int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  			#region Swap Bytes  			switch (_PixelInternalFormat) {  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  				// Color only  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  				// Alpha  				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  				RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  				RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  				RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  				RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  				RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  				// Alpha' the first 2 bytes remain   				RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  				RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  				// extract 3 bits each and flip them  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  				GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  				// Color  				RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  				RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  				RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  				RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  				RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  				RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  				RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  				RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  				break;  			default:  				throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  			}  			#endregion Swap Bytes  		}  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int sourceColumn = 0; sourceColumn < BlocksPerColumn; sourceColumn++) {  	int targetColumn = BlocksPerColumn - sourceColumn - 1;  	for (int row = 0; row < BlocksPerRow; row++) {  		int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  		int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  		#region Swap Bytes  		switch (_PixelInternalFormat) {  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  			// Color only  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  			// Alpha  			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  			RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  			RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  			RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  			RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  			RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  			// Alpha' the first 2 bytes remain   			RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  			RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  			// extract 3 bits each and flip them  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  			GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  			// Color  			RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  			RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  			RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  			RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  			RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  			RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  			RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  			RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  			break;  		default:  			throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  		}  		#endregion Swap Bytes  	}  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: for (int row = 0; row < BlocksPerRow; row++) {  	int target = (targetColumn * BlocksPerRow + row) * _BytesPerBlock;  	int source = (sourceColumn * BlocksPerRow + row) * _BytesPerBlock + Cursor;  	#region Swap Bytes  	switch (_PixelInternalFormat) {  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  		// Color only  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  		// Alpha  		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  		RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  		RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  		RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  		RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  		RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  		// Alpha' the first 2 bytes remain   		RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  		RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  		// extract 3 bits each and flip them  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  		GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  		// Color  		RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  		RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  		RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  		RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  		RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  		RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  		RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  		RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  		break;  	default:  		throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  	}  	#endregion Swap Bytes  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: switch (_PixelInternalFormat) {  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:  	// Color only  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:  	// Alpha  	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  	RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  	RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  	RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  	RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  	RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  case (PixelInternalFormat)ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:  	// Alpha' the first 2 bytes remain   	RawDataOfSurface [target + 0] = _RawDataFromFile [source + 0];  	RawDataOfSurface [target + 1] = _RawDataFromFile [source + 1];  	// extract 3 bits each and flip them  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  	GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  	// Color  	RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  	RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  	RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  	RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  	RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  	RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  	RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  	RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  	break;  default:  	throw new ArgumentException ("ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 2] = _RawDataFromFile [source + 2];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 3] = _RawDataFromFile [source + 3];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 4] = _RawDataFromFile [source + 7];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 5] = _RawDataFromFile [source + 6];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 6] = _RawDataFromFile [source + 5];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 7] = _RawDataFromFile [source + 4];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 0] = _RawDataFromFile [source + 6];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 1] = _RawDataFromFile [source + 7];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 2] = _RawDataFromFile [source + 4];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 3] = _RawDataFromFile [source + 5];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 4] = _RawDataFromFile [source + 2];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 5] = _RawDataFromFile [source + 3];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 6] = _RawDataFromFile [source + 0];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 7] = _RawDataFromFile [source + 1];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 5' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 2)));  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: GetBytesFromUInt24 (ref RawDataOfSurface' (uint)target + 2' FlipUInt24 (GetUInt24 (ref _RawDataFromFile' (uint)source + 5)));  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 8] = _RawDataFromFile [source + 8];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 9] = _RawDataFromFile [source + 9];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 10] = _RawDataFromFile [source + 10];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 11] = _RawDataFromFile [source + 11];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 12] = _RawDataFromFile [source + 15];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 13] = _RawDataFromFile [source + 14];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 14] = _RawDataFromFile [source + 13];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: RawDataOfSurface [target + 15] = _RawDataFromFile [source + 12];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: Width /= 2;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: Height /= 2;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4 * 11;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4 * 11;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 20;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4 * 3;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4 * 3;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,GetString,The following statement contains a magic number: return string.Empty + (char)input [offset + 0] + (char)input [offset + 1] + (char)input [offset + 2] + (char)input [offset + 3];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,GetString,The following statement contains a magic number: return string.Empty + (char)input [offset + 0] + (char)input [offset + 1] + (char)input [offset + 2] + (char)input [offset + 3];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,GetUInt32,The following statement contains a magic number: return (uint)(((input [offset + 3] * 256 + input [offset + 2]) * 256 + input [offset + 1]) * 256 + input [offset + 0]);  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,GetUInt32,The following statement contains a magic number: return (uint)(((input [offset + 3] * 256 + input [offset + 2]) * 256 + input [offset + 1]) * 256 + input [offset + 0]);  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,GetUInt32,The following statement contains a magic number: return (uint)(((input [offset + 3] * 256 + input [offset + 2]) * 256 + input [offset + 1]) * 256 + input [offset + 0]);  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,GetUInt32,The following statement contains a magic number: return (uint)(((input [offset + 3] * 256 + input [offset + 2]) * 256 + input [offset + 1]) * 256 + input [offset + 0]);  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,GetUInt32,The following statement contains a magic number: return (uint)(((input [offset + 3] * 256 + input [offset + 2]) * 256 + input [offset + 1]) * 256 + input [offset + 0]);  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,GetUInt24,The following statement contains a magic number: return (uint)((input [offset + 2] * 256 + input [offset + 1]) * 256 + input [offset + 0]);  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,GetUInt24,The following statement contains a magic number: return (uint)((input [offset + 2] * 256 + input [offset + 1]) * 256 + input [offset + 0]);  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,GetUInt24,The following statement contains a magic number: return (uint)((input [offset + 2] * 256 + input [offset + 1]) * 256 + input [offset + 0]);  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,GetBytesFromUInt24,The following statement contains a magic number: input [offset + 1] = (byte)((splitme & 0x0000ff00) >> 8);  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,GetBytesFromUInt24,The following statement contains a magic number: input [offset + 2] = (byte)((splitme & 0x00ff0000) >> 16);  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,GetBytesFromUInt24,The following statement contains a magic number: input [offset + 2] = (byte)((splitme & 0x00ff0000) >> 16);  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: for (int i = 0; i < 2; i++)  	ThreeBits [i] = new byte[4];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: for (int i = 0; i < 2; i++)  	ThreeBits [i] = new byte[4];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: ThreeBits [i] = new byte[4];  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: ThreeBits [0] [2] = (byte)(inputUInt24 & BitMask);  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: ThreeBits [0] [3] = (byte)(inputUInt24 & BitMask);  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: ThreeBits [1] [2] = (byte)(inputUInt24 & BitMask);  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: ThreeBits [1] [3] = (byte)(inputUInt24 & BitMask);  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint)(ThreeBits [1] [1] << 3);  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint)(ThreeBits [1] [2] << 6);  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint)(ThreeBits [1] [2] << 6);  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint)(ThreeBits [1] [3] << 9);  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint)(ThreeBits [1] [3] << 9);  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint)(ThreeBits [0] [0] << 12);  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint)(ThreeBits [0] [1] << 15);  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint)(ThreeBits [0] [2] << 18);  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint)(ThreeBits [0] [2] << 18);  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint)(ThreeBits [0] [3] << 21);  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures.Externals,ImageDDS,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Externals\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint)(ThreeBits [0] [3] << 21);  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures,Texture2D,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Texture2D.cs,GenerateMipMaps,The following statement contains a magic number: if (Utilities.IsVersion (3) || Utilities.HasExtension ("GL_EXT_framebuffer_object"))  	GL.GenerateMipmap (GenerateMipmapTarget.Texture2D);  else {  	GL.TexParameter (Target' TextureParameterName.GenerateMipmap' 1);  	throw new NotImplementedException ("You currently GL_EXT_framebuffer_object; we need need testing here as the" + " fallback version doesn't seem to work.");  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures,Texture2D,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\Texture2D.cs,Resize,The following statement contains a magic number: if (keepContent) {  	var tmpWidth = Width < width ? Width : width;  	var tmpHeight = Height < height ? Height : height;  	var tmp = new float[tmpWidth * tmpHeight * 4];  	GL.ReadPixels (0' 0' tmpWidth' tmpHeight' PixelFormat.Rgba' PixelType.Float' tmp);  	Width = width;  	Height = height;  	GL.TexImage2D (Target' 0' _internalFormat' Width' Height' 0' PixelFormat.Rgba' PixelType.UnsignedByte' IntPtr.Zero);  	GL.TexSubImage2D (Target' 0' 0' 0' tmpWidth' tmpHeight' PixelFormat.Rgba' PixelType.Float' tmp);  } else {  	Width = width;  	Height = height;  	GL.TexImage2D (Target' 0' _internalFormat' Width' Height' 0' PixelFormat.Rgba' PixelType.UnsignedByte' IntPtr.Zero);  }  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures,TextureBase,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\TextureBase.cs,EnlargeToPow2,The following statement contains a magic number: v |= v >> 2;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures,TextureBase,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\TextureBase.cs,EnlargeToPow2,The following statement contains a magic number: v |= v >> 4;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures,TextureBase,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\TextureBase.cs,EnlargeToPow2,The following statement contains a magic number: v |= v >> 8;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures,TextureBase,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\TextureBase.cs,EnlargeToPow2,The following statement contains a magic number: v |= v >> 16;  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures,TextureBase,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\TextureBase.cs,GetFormat,The following statement contains a magic number: if (components < 1 || components > 4)  	throw new ArgumentOutOfRangeException ("components"' components' "Components must be between 1 and 4.");  
Magic Number,IIS.SLSharp.Bindings.OpenTK.Textures,TextureCube,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Textures\TextureCube.cs,TextureCube,The following statement contains a magic number: for (var i = 0; i < 6; i++)  	GL.TexImage2D (TextureTarget.TextureCubeMapPositiveX + i' 0' internalformat' Width' Height' 0' format' PixelType.UnsignedByte' IntPtr.Zero);  
Magic Number,IIS.SLSharp,Utilities,F:\newReposMay17\IgniteInteractiveStudio_SLSharp\IIS.SLSharp.Bindings.OpenTK\Utilities.cs,HasExtension,The following statement contains a magic number: if (IsVersion (3' 1)) {  	int numExt;  	GL.GetInteger (GetPName.NumExtensions' out numExt);  	for (var i = 0; i < numExt; i++)  		if (GL.GetString (StringName.Extensions' 1) == name)  			return true;  	return false;  }  
