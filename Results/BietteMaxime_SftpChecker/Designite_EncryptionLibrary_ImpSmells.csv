Implementation smell,Namespace,Class,File,Method,Description
Complex Method,EncryptionLibrary.Helpers,AesThenHmac,C:\repos\BietteMaxime_SftpChecker\EncryptionLibrary\Helpers\AesThenHmac.cs,SimpleEncrypt,Cyclomatic complexity of the method is 17
Complex Method,EncryptionLibrary.Helpers,AesThenHmac,C:\repos\BietteMaxime_SftpChecker\EncryptionLibrary\Helpers\AesThenHmac.cs,SimpleDecrypt,Cyclomatic complexity of the method is 16
Long Statement,EncryptionLibrary.Helpers,AesThenHmac,C:\repos\BietteMaxime_SftpChecker\EncryptionLibrary\Helpers\AesThenHmac.cs,SimpleDecrypt,The length of the statement  "							binaryWriter.Write (encryptedMessage' nonSecretPayloadLength + iv.Length' encryptedMessage.Length - nonSecretPayloadLength - iv.Length - sentTag.Length); " is 153.
Magic Number,EncryptionLibrary.Helpers,AesThenHmac,C:\repos\BietteMaxime_SftpChecker\EncryptionLibrary\Helpers\AesThenHmac.cs,SimpleEncrypt,The following statement contains a magic number: if (cryptKey == null || cryptKey.Length != KeyBitSize / 8)  	throw new ArgumentException (String.Format ("Key needs to be {0} bit!"' KeyBitSize)' "cryptKey");  
Magic Number,EncryptionLibrary.Helpers,AesThenHmac,C:\repos\BietteMaxime_SftpChecker\EncryptionLibrary\Helpers\AesThenHmac.cs,SimpleEncrypt,The following statement contains a magic number: if (authKey == null || authKey.Length != KeyBitSize / 8)  	throw new ArgumentException (String.Format ("Key needs to be {0} bit!"' KeyBitSize)' "authKey");  
Magic Number,EncryptionLibrary.Helpers,AesThenHmac,C:\repos\BietteMaxime_SftpChecker\EncryptionLibrary\Helpers\AesThenHmac.cs,SimpleDecrypt,The following statement contains a magic number: if (cryptKey == null || cryptKey.Length != KeyBitSize / 8)  	throw new ArgumentException (String.Format ("CryptKey needs to be {0} bit!"' KeyBitSize)' "cryptKey");  
Magic Number,EncryptionLibrary.Helpers,AesThenHmac,C:\repos\BietteMaxime_SftpChecker\EncryptionLibrary\Helpers\AesThenHmac.cs,SimpleDecrypt,The following statement contains a magic number: if (authKey == null || authKey.Length != KeyBitSize / 8)  	throw new ArgumentException (String.Format ("AuthKey needs to be {0} bit!"' KeyBitSize)' "authKey");  
Magic Number,EncryptionLibrary.Helpers,AesThenHmac,C:\repos\BietteMaxime_SftpChecker\EncryptionLibrary\Helpers\AesThenHmac.cs,SimpleDecrypt,The following statement contains a magic number: using (var hmac = new HMACSHA256 (authKey)) {  	var sentTag = new byte[hmac.HashSize / 8];  	//Calculate Tag  	var calcTag = hmac.ComputeHash (encryptedMessage' 0' encryptedMessage.Length - sentTag.Length);  	var ivLength = (BlockBitSize / 8);  	//if message length is to small just return null  	if (encryptedMessage.Length < sentTag.Length + nonSecretPayloadLength + ivLength)  		return null;  	//Grab Sent Tag  	Array.Copy (encryptedMessage' encryptedMessage.Length - sentTag.Length' sentTag' 0' sentTag.Length);  	//Compare Tag with constant time comparison  	var compare = 0;  	for (var i = 0; i < sentTag.Length; i++)  		compare |= sentTag [i] ^ calcTag [i];  	//if message doesn't authenticate return null  	if (compare != 0)  		return null;  	using (var aes = new AesManaged {  		KeySize = KeyBitSize'  		BlockSize = BlockBitSize'  		Mode = CipherMode.CBC'  		Padding = PaddingMode.PKCS7  	}) {  		//Grab IV from message  		var iv = new byte[ivLength];  		Array.Copy (encryptedMessage' nonSecretPayloadLength' iv' 0' iv.Length);  		using (var decrypter = aes.CreateDecryptor (cryptKey' iv))  			using (var plainTextStream = new MemoryStream ()) {  				using (var decrypterStream = new CryptoStream (plainTextStream' decrypter' CryptoStreamMode.Write))  					using (var binaryWriter = new BinaryWriter (decrypterStream)) {  						//Decrypt Cipher Text from Message  						binaryWriter.Write (encryptedMessage' nonSecretPayloadLength + iv.Length' encryptedMessage.Length - nonSecretPayloadLength - iv.Length - sentTag.Length);  					}  				//Return Plain Text  				return plainTextStream.ToArray ();  			}  	}  }  
Magic Number,EncryptionLibrary.Helpers,AesThenHmac,C:\repos\BietteMaxime_SftpChecker\EncryptionLibrary\Helpers\AesThenHmac.cs,SimpleDecrypt,The following statement contains a magic number: using (var hmac = new HMACSHA256 (authKey)) {  	var sentTag = new byte[hmac.HashSize / 8];  	//Calculate Tag  	var calcTag = hmac.ComputeHash (encryptedMessage' 0' encryptedMessage.Length - sentTag.Length);  	var ivLength = (BlockBitSize / 8);  	//if message length is to small just return null  	if (encryptedMessage.Length < sentTag.Length + nonSecretPayloadLength + ivLength)  		return null;  	//Grab Sent Tag  	Array.Copy (encryptedMessage' encryptedMessage.Length - sentTag.Length' sentTag' 0' sentTag.Length);  	//Compare Tag with constant time comparison  	var compare = 0;  	for (var i = 0; i < sentTag.Length; i++)  		compare |= sentTag [i] ^ calcTag [i];  	//if message doesn't authenticate return null  	if (compare != 0)  		return null;  	using (var aes = new AesManaged {  		KeySize = KeyBitSize'  		BlockSize = BlockBitSize'  		Mode = CipherMode.CBC'  		Padding = PaddingMode.PKCS7  	}) {  		//Grab IV from message  		var iv = new byte[ivLength];  		Array.Copy (encryptedMessage' nonSecretPayloadLength' iv' 0' iv.Length);  		using (var decrypter = aes.CreateDecryptor (cryptKey' iv))  			using (var plainTextStream = new MemoryStream ()) {  				using (var decrypterStream = new CryptoStream (plainTextStream' decrypter' CryptoStreamMode.Write))  					using (var binaryWriter = new BinaryWriter (decrypterStream)) {  						//Decrypt Cipher Text from Message  						binaryWriter.Write (encryptedMessage' nonSecretPayloadLength + iv.Length' encryptedMessage.Length - nonSecretPayloadLength - iv.Length - sentTag.Length);  					}  				//Return Plain Text  				return plainTextStream.ToArray ();  			}  	}  }  
