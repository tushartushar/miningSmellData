Implementation smell,Namespace,Class,File,Method,Description
Long Method,ChatSharp.Handlers,CapabilityHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\CapabilityHandlers.cs,HandleCapability,The method has 107 lines of code.
Long Method,ChatSharp.Handlers,MessageHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\MessageHandlers.cs,HandleMode,The method has 109 lines of code.
Long Method,ChatSharp.Handlers,UserHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\UserHandlers.cs,HandleWhox,The method has 111 lines of code.
Complex Method,ChatSharp,IrcMessage,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\IrcMessage.cs,IrcMessage,Cyclomatic complexity of the method is 11
Complex Method,ChatSharp,IrcUser,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\IrcUser.cs,Match,Cyclomatic complexity of the method is 9
Complex Method,ChatSharp,WhoxEnumExtensions,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\WhoX.cs,AsString,Cyclomatic complexity of the method is 12
Complex Method,ChatSharp,WhoxEnumExtensions,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\WhoX.cs,AsString,Cyclomatic complexity of the method is 15
Complex Method,ChatSharp.Handlers,CapabilityHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\CapabilityHandlers.cs,HandleCapability,Cyclomatic complexity of the method is 17
Complex Method,ChatSharp.Handlers,ChannelHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\ChannelHandlers.cs,HandleUserListPart,Cyclomatic complexity of the method is 13
Complex Method,ChatSharp.Handlers,MessageHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\MessageHandlers.cs,HandleMode,Cyclomatic complexity of the method is 22
Complex Method,ChatSharp.Handlers,ServerHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\ServerHandlers.cs,HandleISupport,Cyclomatic complexity of the method is 20
Long Statement,ChatSharp,IrcClient,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\IrcClient.Commands.cs,SendMessage,The length of the statement  "            if (destinations == null || !destinations.Any()) throw new InvalidOperationException("Message must have at least one target.");" is 127.
Long Statement,ChatSharp,IrcClient,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\IrcClient.Commands.cs,SendMessage,The length of the statement  "            if (illegalCharacters.Any(message.Contains)) throw new ArgumentException("Illegal characters are present in message."' "message");" is 130.
Long Statement,ChatSharp,IrcClient,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\IrcClient.Commands.cs,SendAction,The length of the statement  "            if (destinations == null || !destinations.Any()) throw new InvalidOperationException("Message must have at least one target.");" is 127.
Long Statement,ChatSharp,IrcClient,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\IrcClient.Commands.cs,SendAction,The length of the statement  "            if (illegalCharacters.Any(message.Contains)) throw new ArgumentException("Illegal characters are present in message."' "message");" is 130.
Long Statement,ChatSharp,IrcClient,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\IrcClient.Commands.cs,SendNotice,The length of the statement  "            if (destinations == null || !destinations.Any()) throw new InvalidOperationException("Message must have at least one target.");" is 127.
Long Statement,ChatSharp,IrcClient,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\IrcClient.Commands.cs,SendNotice,The length of the statement  "            if (illegalCharacters.Any(message.Contains)) throw new ArgumentException("Illegal characters are present in message."' "message");" is 130.
Long Statement,ChatSharp.Handlers,CapabilityHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\CapabilityHandlers.cs,HandleCapability,The length of the statement  "                    if (client.IsNegotiatingCapabilities && client.Capabilities.Enabled.Count() == acceptedCaps.Count() && !client.IsAuthenticatingSasl)" is 132.
Long Statement,ChatSharp.Handlers,MessageHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\MessageHandlers.cs,RegisterDefaultHandlers,The length of the statement  "            client.SetHandler("405"' ErrorHandlers.HandleError);//ERR_TOOMANYCHANNELS "<channel name> :You have joined too many \ channels"" is 127.
Long Statement,ChatSharp.Handlers,UserHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\UserHandlers.cs,HandleWhoEnd,The length of the statement  "                var query = client.RequestManager.PendingOperations.Where(kvp => kvp.Key.StartsWith("WHO " + message.Parameters[1])).FirstOrDefault();" is 134.
Long Statement,ChatSharp.Handlers,UserHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\UserHandlers.cs,HandleWhoEnd,The length of the statement  "                var query = client.RequestManager.PendingOperations.Where(kvp => kvp.Key == "WHO " + message.Parameters[1]).FirstOrDefault();" is 125.
Empty Catch Block,ChatSharp.Handlers,ChannelHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\ChannelHandlers.cs,HandleUserListEnd,The method has an empty catch block.
Empty Catch Block,ChatSharp.Handlers,MessageHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\MessageHandlers.cs,HandleMode,The method has an empty catch block.
Magic Number,ChatSharp,IrcClient,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\IrcClient.Commands.cs,Who,The following statement contains a magic number: int queryType = RandomNumber.Next(0' 999);
Magic Number,ChatSharp,IrcClient,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\IrcClient.Commands.cs,DateTimeFromIrcTime,The following statement contains a magic number: return new DateTime(1970' 1' 1).AddSeconds(time);
Magic Number,ChatSharp,IrcClient,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\IrcClient.Commands.cs,ConnectAsync,The following statement contains a magic number: PingTimer = new Timer(30000);
Magic Number,ChatSharp,IrcClient,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\IrcClient.Commands.cs,ConnectAsync,The following statement contains a magic number: var checkQueue = new Timer(1000);
Magic Number,ChatSharp,IrcClient,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\IrcClient.Commands.cs,DataRecieved,The following statement contains a magic number: var message = Encoding.GetString(ReadBuffer' 0' messageLength - 2);
Magic Number,ChatSharp,IrcUser,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\IrcUser.cs,Match,The following statement contains a magic number: Match(parts[0]' Nick) && Match(parts[1]' User) && Match(parts[2]' Hostname)
Magic Number,ChatSharp,Timestamp,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Timestamp.cs,Timestamp,The following statement contains a magic number: UnixTimestamp = Date.Subtract(new DateTime(1970' 1' 1' 0' 0' 0)).TotalSeconds;
Magic Number,ChatSharp.Events,ErronousNickEventArgs,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Events\ErronousNickEventArgs.cs,GenerateRandomNick,The following statement contains a magic number: var nick = new char[8];
Magic Number,ChatSharp.Events,IrcNoticeEventArgs,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Events\IrcNoticeEventArgs.cs,IrcNoticeEventArgs,The following statement contains a magic number: message.Parameters.Length != 2
Magic Number,ChatSharp.Handlers,CapabilityHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\CapabilityHandlers.cs,HandleCapability,The following statement contains a magic number: switch (message.Parameters[1])             {                 case "LS":                     client.IsNegotiatingCapabilities = true;                     // Parse server capabilities                     var serverCapsString = (message.Parameters[2] == "*" ? message.Parameters[3] : message.Parameters[2]);                     serverCaps.AddRange(serverCapsString.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries));                      // CAP 3.2 multiline support. Send CAP requests on the last CAP LS line.                     // The last CAP LS line doesn't have * set as Parameters[2]                     if (message.Parameters[2] != "*")                     {                         // Check which capabilities we support that the server supports                         requestedCaps.AddRange(supportedCaps.Select(cap => cap.Name).Intersect(serverCaps));                          // Check if we have to request any capability to be enabled.                         // If not' end the capability negotiation.                         if (requestedCaps.Count > 0)                             client.SendRawMessage("CAP REQ :{0}"' string.Join(" "' requestedCaps));                         else                         {                             client.SendRawMessage("CAP END");                             client.IsNegotiatingCapabilities = false;                         }                     }                     break;                 case "ACK":                     // Get the accepted capabilities                     var acceptedCaps = message.Parameters[2].Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                     foreach (string acceptedCap in acceptedCaps)                     {                         client.Capabilities.Enable(acceptedCap);                         // Begin SASL authentication                         if (acceptedCap == "sasl")                         {                             client.SendRawMessage("AUTHENTICATE PLAIN");                             client.IsAuthenticatingSasl = true;                         }                     }                      // Check if the enabled capabilities count is the same as the ones                     // acknowledged by the server.                     if (client.IsNegotiatingCapabilities && client.Capabilities.Enabled.Count() == acceptedCaps.Count() && !client.IsAuthenticatingSasl)                     {                         client.SendRawMessage("CAP END");                         client.IsNegotiatingCapabilities = false;                     }                      break;                 case "NAK":                     // Get the rejected capabilities                     var rejectedCaps = message.Parameters[2].Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                     foreach (string acceptedCap in rejectedCaps)                         client.Capabilities.Disable(acceptedCap);                      // Check if the disabled capabilities count is the same as the ones                     // rejected by the server.                     if (client.IsNegotiatingCapabilities && client.Capabilities.Disabled.Count() == rejectedCaps.Count())                     {                         client.SendRawMessage("CAP END");                         client.IsNegotiatingCapabilities = false;                     }                      break;                 case "LIST":                     var activeCapsString = (message.Parameters[2] == "*" ? message.Parameters[3] : message.Parameters[2]);                     var activeCaps = activeCapsString.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                      // Check which cap we have that isn't active but the server lists                     // as active.                     foreach (string cap in activeCaps)                     {                         if (client.Capabilities.Contains(cap))                             if (!client.Capabilities[cap].IsEnabled)                                 client.Capabilities.Enable(cap);                     }                      break;                 case "NEW":                     var newCaps = message.Parameters[2].Split(new[] { " " }' StringSplitOptions.RemoveEmptyEntries);                     var wantCaps = new List<string>();                      // Check which new capabilities we support and send a REQ for them                     wantCaps.AddRange(newCaps.Where(cap => client.Capabilities.Contains(cap) && !client.Capabilities[cap].IsEnabled));                      client.SendRawMessage(string.Format("CAP REQ :{0}"' string.Join(" "' wantCaps)));                     break;                 case "DEL":                     var disabledCaps = message.Parameters[2].Split(new[] { " " }' StringSplitOptions.RemoveEmptyEntries).ToList();                      // Disable each recently server-disabled capability                     disabledCaps.ForEach(                         cap => {                             if (client.Capabilities.Contains(cap) && client.Capabilities[cap].IsEnabled)                                 client.Capabilities.Disable(cap);                         }                     );                     break;                 default:                     break;             }
Magic Number,ChatSharp.Handlers,CapabilityHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\CapabilityHandlers.cs,HandleCapability,The following statement contains a magic number: switch (message.Parameters[1])             {                 case "LS":                     client.IsNegotiatingCapabilities = true;                     // Parse server capabilities                     var serverCapsString = (message.Parameters[2] == "*" ? message.Parameters[3] : message.Parameters[2]);                     serverCaps.AddRange(serverCapsString.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries));                      // CAP 3.2 multiline support. Send CAP requests on the last CAP LS line.                     // The last CAP LS line doesn't have * set as Parameters[2]                     if (message.Parameters[2] != "*")                     {                         // Check which capabilities we support that the server supports                         requestedCaps.AddRange(supportedCaps.Select(cap => cap.Name).Intersect(serverCaps));                          // Check if we have to request any capability to be enabled.                         // If not' end the capability negotiation.                         if (requestedCaps.Count > 0)                             client.SendRawMessage("CAP REQ :{0}"' string.Join(" "' requestedCaps));                         else                         {                             client.SendRawMessage("CAP END");                             client.IsNegotiatingCapabilities = false;                         }                     }                     break;                 case "ACK":                     // Get the accepted capabilities                     var acceptedCaps = message.Parameters[2].Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                     foreach (string acceptedCap in acceptedCaps)                     {                         client.Capabilities.Enable(acceptedCap);                         // Begin SASL authentication                         if (acceptedCap == "sasl")                         {                             client.SendRawMessage("AUTHENTICATE PLAIN");                             client.IsAuthenticatingSasl = true;                         }                     }                      // Check if the enabled capabilities count is the same as the ones                     // acknowledged by the server.                     if (client.IsNegotiatingCapabilities && client.Capabilities.Enabled.Count() == acceptedCaps.Count() && !client.IsAuthenticatingSasl)                     {                         client.SendRawMessage("CAP END");                         client.IsNegotiatingCapabilities = false;                     }                      break;                 case "NAK":                     // Get the rejected capabilities                     var rejectedCaps = message.Parameters[2].Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                     foreach (string acceptedCap in rejectedCaps)                         client.Capabilities.Disable(acceptedCap);                      // Check if the disabled capabilities count is the same as the ones                     // rejected by the server.                     if (client.IsNegotiatingCapabilities && client.Capabilities.Disabled.Count() == rejectedCaps.Count())                     {                         client.SendRawMessage("CAP END");                         client.IsNegotiatingCapabilities = false;                     }                      break;                 case "LIST":                     var activeCapsString = (message.Parameters[2] == "*" ? message.Parameters[3] : message.Parameters[2]);                     var activeCaps = activeCapsString.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                      // Check which cap we have that isn't active but the server lists                     // as active.                     foreach (string cap in activeCaps)                     {                         if (client.Capabilities.Contains(cap))                             if (!client.Capabilities[cap].IsEnabled)                                 client.Capabilities.Enable(cap);                     }                      break;                 case "NEW":                     var newCaps = message.Parameters[2].Split(new[] { " " }' StringSplitOptions.RemoveEmptyEntries);                     var wantCaps = new List<string>();                      // Check which new capabilities we support and send a REQ for them                     wantCaps.AddRange(newCaps.Where(cap => client.Capabilities.Contains(cap) && !client.Capabilities[cap].IsEnabled));                      client.SendRawMessage(string.Format("CAP REQ :{0}"' string.Join(" "' wantCaps)));                     break;                 case "DEL":                     var disabledCaps = message.Parameters[2].Split(new[] { " " }' StringSplitOptions.RemoveEmptyEntries).ToList();                      // Disable each recently server-disabled capability                     disabledCaps.ForEach(                         cap => {                             if (client.Capabilities.Contains(cap) && client.Capabilities[cap].IsEnabled)                                 client.Capabilities.Disable(cap);                         }                     );                     break;                 default:                     break;             }
Magic Number,ChatSharp.Handlers,CapabilityHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\CapabilityHandlers.cs,HandleCapability,The following statement contains a magic number: switch (message.Parameters[1])             {                 case "LS":                     client.IsNegotiatingCapabilities = true;                     // Parse server capabilities                     var serverCapsString = (message.Parameters[2] == "*" ? message.Parameters[3] : message.Parameters[2]);                     serverCaps.AddRange(serverCapsString.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries));                      // CAP 3.2 multiline support. Send CAP requests on the last CAP LS line.                     // The last CAP LS line doesn't have * set as Parameters[2]                     if (message.Parameters[2] != "*")                     {                         // Check which capabilities we support that the server supports                         requestedCaps.AddRange(supportedCaps.Select(cap => cap.Name).Intersect(serverCaps));                          // Check if we have to request any capability to be enabled.                         // If not' end the capability negotiation.                         if (requestedCaps.Count > 0)                             client.SendRawMessage("CAP REQ :{0}"' string.Join(" "' requestedCaps));                         else                         {                             client.SendRawMessage("CAP END");                             client.IsNegotiatingCapabilities = false;                         }                     }                     break;                 case "ACK":                     // Get the accepted capabilities                     var acceptedCaps = message.Parameters[2].Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                     foreach (string acceptedCap in acceptedCaps)                     {                         client.Capabilities.Enable(acceptedCap);                         // Begin SASL authentication                         if (acceptedCap == "sasl")                         {                             client.SendRawMessage("AUTHENTICATE PLAIN");                             client.IsAuthenticatingSasl = true;                         }                     }                      // Check if the enabled capabilities count is the same as the ones                     // acknowledged by the server.                     if (client.IsNegotiatingCapabilities && client.Capabilities.Enabled.Count() == acceptedCaps.Count() && !client.IsAuthenticatingSasl)                     {                         client.SendRawMessage("CAP END");                         client.IsNegotiatingCapabilities = false;                     }                      break;                 case "NAK":                     // Get the rejected capabilities                     var rejectedCaps = message.Parameters[2].Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                     foreach (string acceptedCap in rejectedCaps)                         client.Capabilities.Disable(acceptedCap);                      // Check if the disabled capabilities count is the same as the ones                     // rejected by the server.                     if (client.IsNegotiatingCapabilities && client.Capabilities.Disabled.Count() == rejectedCaps.Count())                     {                         client.SendRawMessage("CAP END");                         client.IsNegotiatingCapabilities = false;                     }                      break;                 case "LIST":                     var activeCapsString = (message.Parameters[2] == "*" ? message.Parameters[3] : message.Parameters[2]);                     var activeCaps = activeCapsString.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                      // Check which cap we have that isn't active but the server lists                     // as active.                     foreach (string cap in activeCaps)                     {                         if (client.Capabilities.Contains(cap))                             if (!client.Capabilities[cap].IsEnabled)                                 client.Capabilities.Enable(cap);                     }                      break;                 case "NEW":                     var newCaps = message.Parameters[2].Split(new[] { " " }' StringSplitOptions.RemoveEmptyEntries);                     var wantCaps = new List<string>();                      // Check which new capabilities we support and send a REQ for them                     wantCaps.AddRange(newCaps.Where(cap => client.Capabilities.Contains(cap) && !client.Capabilities[cap].IsEnabled));                      client.SendRawMessage(string.Format("CAP REQ :{0}"' string.Join(" "' wantCaps)));                     break;                 case "DEL":                     var disabledCaps = message.Parameters[2].Split(new[] { " " }' StringSplitOptions.RemoveEmptyEntries).ToList();                      // Disable each recently server-disabled capability                     disabledCaps.ForEach(                         cap => {                             if (client.Capabilities.Contains(cap) && client.Capabilities[cap].IsEnabled)                                 client.Capabilities.Disable(cap);                         }                     );                     break;                 default:                     break;             }
Magic Number,ChatSharp.Handlers,CapabilityHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\CapabilityHandlers.cs,HandleCapability,The following statement contains a magic number: switch (message.Parameters[1])             {                 case "LS":                     client.IsNegotiatingCapabilities = true;                     // Parse server capabilities                     var serverCapsString = (message.Parameters[2] == "*" ? message.Parameters[3] : message.Parameters[2]);                     serverCaps.AddRange(serverCapsString.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries));                      // CAP 3.2 multiline support. Send CAP requests on the last CAP LS line.                     // The last CAP LS line doesn't have * set as Parameters[2]                     if (message.Parameters[2] != "*")                     {                         // Check which capabilities we support that the server supports                         requestedCaps.AddRange(supportedCaps.Select(cap => cap.Name).Intersect(serverCaps));                          // Check if we have to request any capability to be enabled.                         // If not' end the capability negotiation.                         if (requestedCaps.Count > 0)                             client.SendRawMessage("CAP REQ :{0}"' string.Join(" "' requestedCaps));                         else                         {                             client.SendRawMessage("CAP END");                             client.IsNegotiatingCapabilities = false;                         }                     }                     break;                 case "ACK":                     // Get the accepted capabilities                     var acceptedCaps = message.Parameters[2].Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                     foreach (string acceptedCap in acceptedCaps)                     {                         client.Capabilities.Enable(acceptedCap);                         // Begin SASL authentication                         if (acceptedCap == "sasl")                         {                             client.SendRawMessage("AUTHENTICATE PLAIN");                             client.IsAuthenticatingSasl = true;                         }                     }                      // Check if the enabled capabilities count is the same as the ones                     // acknowledged by the server.                     if (client.IsNegotiatingCapabilities && client.Capabilities.Enabled.Count() == acceptedCaps.Count() && !client.IsAuthenticatingSasl)                     {                         client.SendRawMessage("CAP END");                         client.IsNegotiatingCapabilities = false;                     }                      break;                 case "NAK":                     // Get the rejected capabilities                     var rejectedCaps = message.Parameters[2].Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                     foreach (string acceptedCap in rejectedCaps)                         client.Capabilities.Disable(acceptedCap);                      // Check if the disabled capabilities count is the same as the ones                     // rejected by the server.                     if (client.IsNegotiatingCapabilities && client.Capabilities.Disabled.Count() == rejectedCaps.Count())                     {                         client.SendRawMessage("CAP END");                         client.IsNegotiatingCapabilities = false;                     }                      break;                 case "LIST":                     var activeCapsString = (message.Parameters[2] == "*" ? message.Parameters[3] : message.Parameters[2]);                     var activeCaps = activeCapsString.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                      // Check which cap we have that isn't active but the server lists                     // as active.                     foreach (string cap in activeCaps)                     {                         if (client.Capabilities.Contains(cap))                             if (!client.Capabilities[cap].IsEnabled)                                 client.Capabilities.Enable(cap);                     }                      break;                 case "NEW":                     var newCaps = message.Parameters[2].Split(new[] { " " }' StringSplitOptions.RemoveEmptyEntries);                     var wantCaps = new List<string>();                      // Check which new capabilities we support and send a REQ for them                     wantCaps.AddRange(newCaps.Where(cap => client.Capabilities.Contains(cap) && !client.Capabilities[cap].IsEnabled));                      client.SendRawMessage(string.Format("CAP REQ :{0}"' string.Join(" "' wantCaps)));                     break;                 case "DEL":                     var disabledCaps = message.Parameters[2].Split(new[] { " " }' StringSplitOptions.RemoveEmptyEntries).ToList();                      // Disable each recently server-disabled capability                     disabledCaps.ForEach(                         cap => {                             if (client.Capabilities.Contains(cap) && client.Capabilities[cap].IsEnabled)                                 client.Capabilities.Disable(cap);                         }                     );                     break;                 default:                     break;             }
Magic Number,ChatSharp.Handlers,CapabilityHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\CapabilityHandlers.cs,HandleCapability,The following statement contains a magic number: switch (message.Parameters[1])             {                 case "LS":                     client.IsNegotiatingCapabilities = true;                     // Parse server capabilities                     var serverCapsString = (message.Parameters[2] == "*" ? message.Parameters[3] : message.Parameters[2]);                     serverCaps.AddRange(serverCapsString.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries));                      // CAP 3.2 multiline support. Send CAP requests on the last CAP LS line.                     // The last CAP LS line doesn't have * set as Parameters[2]                     if (message.Parameters[2] != "*")                     {                         // Check which capabilities we support that the server supports                         requestedCaps.AddRange(supportedCaps.Select(cap => cap.Name).Intersect(serverCaps));                          // Check if we have to request any capability to be enabled.                         // If not' end the capability negotiation.                         if (requestedCaps.Count > 0)                             client.SendRawMessage("CAP REQ :{0}"' string.Join(" "' requestedCaps));                         else                         {                             client.SendRawMessage("CAP END");                             client.IsNegotiatingCapabilities = false;                         }                     }                     break;                 case "ACK":                     // Get the accepted capabilities                     var acceptedCaps = message.Parameters[2].Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                     foreach (string acceptedCap in acceptedCaps)                     {                         client.Capabilities.Enable(acceptedCap);                         // Begin SASL authentication                         if (acceptedCap == "sasl")                         {                             client.SendRawMessage("AUTHENTICATE PLAIN");                             client.IsAuthenticatingSasl = true;                         }                     }                      // Check if the enabled capabilities count is the same as the ones                     // acknowledged by the server.                     if (client.IsNegotiatingCapabilities && client.Capabilities.Enabled.Count() == acceptedCaps.Count() && !client.IsAuthenticatingSasl)                     {                         client.SendRawMessage("CAP END");                         client.IsNegotiatingCapabilities = false;                     }                      break;                 case "NAK":                     // Get the rejected capabilities                     var rejectedCaps = message.Parameters[2].Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                     foreach (string acceptedCap in rejectedCaps)                         client.Capabilities.Disable(acceptedCap);                      // Check if the disabled capabilities count is the same as the ones                     // rejected by the server.                     if (client.IsNegotiatingCapabilities && client.Capabilities.Disabled.Count() == rejectedCaps.Count())                     {                         client.SendRawMessage("CAP END");                         client.IsNegotiatingCapabilities = false;                     }                      break;                 case "LIST":                     var activeCapsString = (message.Parameters[2] == "*" ? message.Parameters[3] : message.Parameters[2]);                     var activeCaps = activeCapsString.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                      // Check which cap we have that isn't active but the server lists                     // as active.                     foreach (string cap in activeCaps)                     {                         if (client.Capabilities.Contains(cap))                             if (!client.Capabilities[cap].IsEnabled)                                 client.Capabilities.Enable(cap);                     }                      break;                 case "NEW":                     var newCaps = message.Parameters[2].Split(new[] { " " }' StringSplitOptions.RemoveEmptyEntries);                     var wantCaps = new List<string>();                      // Check which new capabilities we support and send a REQ for them                     wantCaps.AddRange(newCaps.Where(cap => client.Capabilities.Contains(cap) && !client.Capabilities[cap].IsEnabled));                      client.SendRawMessage(string.Format("CAP REQ :{0}"' string.Join(" "' wantCaps)));                     break;                 case "DEL":                     var disabledCaps = message.Parameters[2].Split(new[] { " " }' StringSplitOptions.RemoveEmptyEntries).ToList();                      // Disable each recently server-disabled capability                     disabledCaps.ForEach(                         cap => {                             if (client.Capabilities.Contains(cap) && client.Capabilities[cap].IsEnabled)                                 client.Capabilities.Disable(cap);                         }                     );                     break;                 default:                     break;             }
Magic Number,ChatSharp.Handlers,CapabilityHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\CapabilityHandlers.cs,HandleCapability,The following statement contains a magic number: switch (message.Parameters[1])             {                 case "LS":                     client.IsNegotiatingCapabilities = true;                     // Parse server capabilities                     var serverCapsString = (message.Parameters[2] == "*" ? message.Parameters[3] : message.Parameters[2]);                     serverCaps.AddRange(serverCapsString.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries));                      // CAP 3.2 multiline support. Send CAP requests on the last CAP LS line.                     // The last CAP LS line doesn't have * set as Parameters[2]                     if (message.Parameters[2] != "*")                     {                         // Check which capabilities we support that the server supports                         requestedCaps.AddRange(supportedCaps.Select(cap => cap.Name).Intersect(serverCaps));                          // Check if we have to request any capability to be enabled.                         // If not' end the capability negotiation.                         if (requestedCaps.Count > 0)                             client.SendRawMessage("CAP REQ :{0}"' string.Join(" "' requestedCaps));                         else                         {                             client.SendRawMessage("CAP END");                             client.IsNegotiatingCapabilities = false;                         }                     }                     break;                 case "ACK":                     // Get the accepted capabilities                     var acceptedCaps = message.Parameters[2].Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                     foreach (string acceptedCap in acceptedCaps)                     {                         client.Capabilities.Enable(acceptedCap);                         // Begin SASL authentication                         if (acceptedCap == "sasl")                         {                             client.SendRawMessage("AUTHENTICATE PLAIN");                             client.IsAuthenticatingSasl = true;                         }                     }                      // Check if the enabled capabilities count is the same as the ones                     // acknowledged by the server.                     if (client.IsNegotiatingCapabilities && client.Capabilities.Enabled.Count() == acceptedCaps.Count() && !client.IsAuthenticatingSasl)                     {                         client.SendRawMessage("CAP END");                         client.IsNegotiatingCapabilities = false;                     }                      break;                 case "NAK":                     // Get the rejected capabilities                     var rejectedCaps = message.Parameters[2].Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                     foreach (string acceptedCap in rejectedCaps)                         client.Capabilities.Disable(acceptedCap);                      // Check if the disabled capabilities count is the same as the ones                     // rejected by the server.                     if (client.IsNegotiatingCapabilities && client.Capabilities.Disabled.Count() == rejectedCaps.Count())                     {                         client.SendRawMessage("CAP END");                         client.IsNegotiatingCapabilities = false;                     }                      break;                 case "LIST":                     var activeCapsString = (message.Parameters[2] == "*" ? message.Parameters[3] : message.Parameters[2]);                     var activeCaps = activeCapsString.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                      // Check which cap we have that isn't active but the server lists                     // as active.                     foreach (string cap in activeCaps)                     {                         if (client.Capabilities.Contains(cap))                             if (!client.Capabilities[cap].IsEnabled)                                 client.Capabilities.Enable(cap);                     }                      break;                 case "NEW":                     var newCaps = message.Parameters[2].Split(new[] { " " }' StringSplitOptions.RemoveEmptyEntries);                     var wantCaps = new List<string>();                      // Check which new capabilities we support and send a REQ for them                     wantCaps.AddRange(newCaps.Where(cap => client.Capabilities.Contains(cap) && !client.Capabilities[cap].IsEnabled));                      client.SendRawMessage(string.Format("CAP REQ :{0}"' string.Join(" "' wantCaps)));                     break;                 case "DEL":                     var disabledCaps = message.Parameters[2].Split(new[] { " " }' StringSplitOptions.RemoveEmptyEntries).ToList();                      // Disable each recently server-disabled capability                     disabledCaps.ForEach(                         cap => {                             if (client.Capabilities.Contains(cap) && client.Capabilities[cap].IsEnabled)                                 client.Capabilities.Disable(cap);                         }                     );                     break;                 default:                     break;             }
Magic Number,ChatSharp.Handlers,CapabilityHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\CapabilityHandlers.cs,HandleCapability,The following statement contains a magic number: switch (message.Parameters[1])             {                 case "LS":                     client.IsNegotiatingCapabilities = true;                     // Parse server capabilities                     var serverCapsString = (message.Parameters[2] == "*" ? message.Parameters[3] : message.Parameters[2]);                     serverCaps.AddRange(serverCapsString.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries));                      // CAP 3.2 multiline support. Send CAP requests on the last CAP LS line.                     // The last CAP LS line doesn't have * set as Parameters[2]                     if (message.Parameters[2] != "*")                     {                         // Check which capabilities we support that the server supports                         requestedCaps.AddRange(supportedCaps.Select(cap => cap.Name).Intersect(serverCaps));                          // Check if we have to request any capability to be enabled.                         // If not' end the capability negotiation.                         if (requestedCaps.Count > 0)                             client.SendRawMessage("CAP REQ :{0}"' string.Join(" "' requestedCaps));                         else                         {                             client.SendRawMessage("CAP END");                             client.IsNegotiatingCapabilities = false;                         }                     }                     break;                 case "ACK":                     // Get the accepted capabilities                     var acceptedCaps = message.Parameters[2].Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                     foreach (string acceptedCap in acceptedCaps)                     {                         client.Capabilities.Enable(acceptedCap);                         // Begin SASL authentication                         if (acceptedCap == "sasl")                         {                             client.SendRawMessage("AUTHENTICATE PLAIN");                             client.IsAuthenticatingSasl = true;                         }                     }                      // Check if the enabled capabilities count is the same as the ones                     // acknowledged by the server.                     if (client.IsNegotiatingCapabilities && client.Capabilities.Enabled.Count() == acceptedCaps.Count() && !client.IsAuthenticatingSasl)                     {                         client.SendRawMessage("CAP END");                         client.IsNegotiatingCapabilities = false;                     }                      break;                 case "NAK":                     // Get the rejected capabilities                     var rejectedCaps = message.Parameters[2].Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                     foreach (string acceptedCap in rejectedCaps)                         client.Capabilities.Disable(acceptedCap);                      // Check if the disabled capabilities count is the same as the ones                     // rejected by the server.                     if (client.IsNegotiatingCapabilities && client.Capabilities.Disabled.Count() == rejectedCaps.Count())                     {                         client.SendRawMessage("CAP END");                         client.IsNegotiatingCapabilities = false;                     }                      break;                 case "LIST":                     var activeCapsString = (message.Parameters[2] == "*" ? message.Parameters[3] : message.Parameters[2]);                     var activeCaps = activeCapsString.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                      // Check which cap we have that isn't active but the server lists                     // as active.                     foreach (string cap in activeCaps)                     {                         if (client.Capabilities.Contains(cap))                             if (!client.Capabilities[cap].IsEnabled)                                 client.Capabilities.Enable(cap);                     }                      break;                 case "NEW":                     var newCaps = message.Parameters[2].Split(new[] { " " }' StringSplitOptions.RemoveEmptyEntries);                     var wantCaps = new List<string>();                      // Check which new capabilities we support and send a REQ for them                     wantCaps.AddRange(newCaps.Where(cap => client.Capabilities.Contains(cap) && !client.Capabilities[cap].IsEnabled));                      client.SendRawMessage(string.Format("CAP REQ :{0}"' string.Join(" "' wantCaps)));                     break;                 case "DEL":                     var disabledCaps = message.Parameters[2].Split(new[] { " " }' StringSplitOptions.RemoveEmptyEntries).ToList();                      // Disable each recently server-disabled capability                     disabledCaps.ForEach(                         cap => {                             if (client.Capabilities.Contains(cap) && client.Capabilities[cap].IsEnabled)                                 client.Capabilities.Disable(cap);                         }                     );                     break;                 default:                     break;             }
Magic Number,ChatSharp.Handlers,CapabilityHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\CapabilityHandlers.cs,HandleCapability,The following statement contains a magic number: switch (message.Parameters[1])             {                 case "LS":                     client.IsNegotiatingCapabilities = true;                     // Parse server capabilities                     var serverCapsString = (message.Parameters[2] == "*" ? message.Parameters[3] : message.Parameters[2]);                     serverCaps.AddRange(serverCapsString.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries));                      // CAP 3.2 multiline support. Send CAP requests on the last CAP LS line.                     // The last CAP LS line doesn't have * set as Parameters[2]                     if (message.Parameters[2] != "*")                     {                         // Check which capabilities we support that the server supports                         requestedCaps.AddRange(supportedCaps.Select(cap => cap.Name).Intersect(serverCaps));                          // Check if we have to request any capability to be enabled.                         // If not' end the capability negotiation.                         if (requestedCaps.Count > 0)                             client.SendRawMessage("CAP REQ :{0}"' string.Join(" "' requestedCaps));                         else                         {                             client.SendRawMessage("CAP END");                             client.IsNegotiatingCapabilities = false;                         }                     }                     break;                 case "ACK":                     // Get the accepted capabilities                     var acceptedCaps = message.Parameters[2].Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                     foreach (string acceptedCap in acceptedCaps)                     {                         client.Capabilities.Enable(acceptedCap);                         // Begin SASL authentication                         if (acceptedCap == "sasl")                         {                             client.SendRawMessage("AUTHENTICATE PLAIN");                             client.IsAuthenticatingSasl = true;                         }                     }                      // Check if the enabled capabilities count is the same as the ones                     // acknowledged by the server.                     if (client.IsNegotiatingCapabilities && client.Capabilities.Enabled.Count() == acceptedCaps.Count() && !client.IsAuthenticatingSasl)                     {                         client.SendRawMessage("CAP END");                         client.IsNegotiatingCapabilities = false;                     }                      break;                 case "NAK":                     // Get the rejected capabilities                     var rejectedCaps = message.Parameters[2].Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                     foreach (string acceptedCap in rejectedCaps)                         client.Capabilities.Disable(acceptedCap);                      // Check if the disabled capabilities count is the same as the ones                     // rejected by the server.                     if (client.IsNegotiatingCapabilities && client.Capabilities.Disabled.Count() == rejectedCaps.Count())                     {                         client.SendRawMessage("CAP END");                         client.IsNegotiatingCapabilities = false;                     }                      break;                 case "LIST":                     var activeCapsString = (message.Parameters[2] == "*" ? message.Parameters[3] : message.Parameters[2]);                     var activeCaps = activeCapsString.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                      // Check which cap we have that isn't active but the server lists                     // as active.                     foreach (string cap in activeCaps)                     {                         if (client.Capabilities.Contains(cap))                             if (!client.Capabilities[cap].IsEnabled)                                 client.Capabilities.Enable(cap);                     }                      break;                 case "NEW":                     var newCaps = message.Parameters[2].Split(new[] { " " }' StringSplitOptions.RemoveEmptyEntries);                     var wantCaps = new List<string>();                      // Check which new capabilities we support and send a REQ for them                     wantCaps.AddRange(newCaps.Where(cap => client.Capabilities.Contains(cap) && !client.Capabilities[cap].IsEnabled));                      client.SendRawMessage(string.Format("CAP REQ :{0}"' string.Join(" "' wantCaps)));                     break;                 case "DEL":                     var disabledCaps = message.Parameters[2].Split(new[] { " " }' StringSplitOptions.RemoveEmptyEntries).ToList();                      // Disable each recently server-disabled capability                     disabledCaps.ForEach(                         cap => {                             if (client.Capabilities.Contains(cap) && client.Capabilities[cap].IsEnabled)                                 client.Capabilities.Disable(cap);                         }                     );                     break;                 default:                     break;             }
Magic Number,ChatSharp.Handlers,CapabilityHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\CapabilityHandlers.cs,HandleCapability,The following statement contains a magic number: switch (message.Parameters[1])             {                 case "LS":                     client.IsNegotiatingCapabilities = true;                     // Parse server capabilities                     var serverCapsString = (message.Parameters[2] == "*" ? message.Parameters[3] : message.Parameters[2]);                     serverCaps.AddRange(serverCapsString.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries));                      // CAP 3.2 multiline support. Send CAP requests on the last CAP LS line.                     // The last CAP LS line doesn't have * set as Parameters[2]                     if (message.Parameters[2] != "*")                     {                         // Check which capabilities we support that the server supports                         requestedCaps.AddRange(supportedCaps.Select(cap => cap.Name).Intersect(serverCaps));                          // Check if we have to request any capability to be enabled.                         // If not' end the capability negotiation.                         if (requestedCaps.Count > 0)                             client.SendRawMessage("CAP REQ :{0}"' string.Join(" "' requestedCaps));                         else                         {                             client.SendRawMessage("CAP END");                             client.IsNegotiatingCapabilities = false;                         }                     }                     break;                 case "ACK":                     // Get the accepted capabilities                     var acceptedCaps = message.Parameters[2].Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                     foreach (string acceptedCap in acceptedCaps)                     {                         client.Capabilities.Enable(acceptedCap);                         // Begin SASL authentication                         if (acceptedCap == "sasl")                         {                             client.SendRawMessage("AUTHENTICATE PLAIN");                             client.IsAuthenticatingSasl = true;                         }                     }                      // Check if the enabled capabilities count is the same as the ones                     // acknowledged by the server.                     if (client.IsNegotiatingCapabilities && client.Capabilities.Enabled.Count() == acceptedCaps.Count() && !client.IsAuthenticatingSasl)                     {                         client.SendRawMessage("CAP END");                         client.IsNegotiatingCapabilities = false;                     }                      break;                 case "NAK":                     // Get the rejected capabilities                     var rejectedCaps = message.Parameters[2].Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                     foreach (string acceptedCap in rejectedCaps)                         client.Capabilities.Disable(acceptedCap);                      // Check if the disabled capabilities count is the same as the ones                     // rejected by the server.                     if (client.IsNegotiatingCapabilities && client.Capabilities.Disabled.Count() == rejectedCaps.Count())                     {                         client.SendRawMessage("CAP END");                         client.IsNegotiatingCapabilities = false;                     }                      break;                 case "LIST":                     var activeCapsString = (message.Parameters[2] == "*" ? message.Parameters[3] : message.Parameters[2]);                     var activeCaps = activeCapsString.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                      // Check which cap we have that isn't active but the server lists                     // as active.                     foreach (string cap in activeCaps)                     {                         if (client.Capabilities.Contains(cap))                             if (!client.Capabilities[cap].IsEnabled)                                 client.Capabilities.Enable(cap);                     }                      break;                 case "NEW":                     var newCaps = message.Parameters[2].Split(new[] { " " }' StringSplitOptions.RemoveEmptyEntries);                     var wantCaps = new List<string>();                      // Check which new capabilities we support and send a REQ for them                     wantCaps.AddRange(newCaps.Where(cap => client.Capabilities.Contains(cap) && !client.Capabilities[cap].IsEnabled));                      client.SendRawMessage(string.Format("CAP REQ :{0}"' string.Join(" "' wantCaps)));                     break;                 case "DEL":                     var disabledCaps = message.Parameters[2].Split(new[] { " " }' StringSplitOptions.RemoveEmptyEntries).ToList();                      // Disable each recently server-disabled capability                     disabledCaps.ForEach(                         cap => {                             if (client.Capabilities.Contains(cap) && client.Capabilities[cap].IsEnabled)                                 client.Capabilities.Disable(cap);                         }                     );                     break;                 default:                     break;             }
Magic Number,ChatSharp.Handlers,CapabilityHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\CapabilityHandlers.cs,HandleCapability,The following statement contains a magic number: switch (message.Parameters[1])             {                 case "LS":                     client.IsNegotiatingCapabilities = true;                     // Parse server capabilities                     var serverCapsString = (message.Parameters[2] == "*" ? message.Parameters[3] : message.Parameters[2]);                     serverCaps.AddRange(serverCapsString.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries));                      // CAP 3.2 multiline support. Send CAP requests on the last CAP LS line.                     // The last CAP LS line doesn't have * set as Parameters[2]                     if (message.Parameters[2] != "*")                     {                         // Check which capabilities we support that the server supports                         requestedCaps.AddRange(supportedCaps.Select(cap => cap.Name).Intersect(serverCaps));                          // Check if we have to request any capability to be enabled.                         // If not' end the capability negotiation.                         if (requestedCaps.Count > 0)                             client.SendRawMessage("CAP REQ :{0}"' string.Join(" "' requestedCaps));                         else                         {                             client.SendRawMessage("CAP END");                             client.IsNegotiatingCapabilities = false;                         }                     }                     break;                 case "ACK":                     // Get the accepted capabilities                     var acceptedCaps = message.Parameters[2].Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                     foreach (string acceptedCap in acceptedCaps)                     {                         client.Capabilities.Enable(acceptedCap);                         // Begin SASL authentication                         if (acceptedCap == "sasl")                         {                             client.SendRawMessage("AUTHENTICATE PLAIN");                             client.IsAuthenticatingSasl = true;                         }                     }                      // Check if the enabled capabilities count is the same as the ones                     // acknowledged by the server.                     if (client.IsNegotiatingCapabilities && client.Capabilities.Enabled.Count() == acceptedCaps.Count() && !client.IsAuthenticatingSasl)                     {                         client.SendRawMessage("CAP END");                         client.IsNegotiatingCapabilities = false;                     }                      break;                 case "NAK":                     // Get the rejected capabilities                     var rejectedCaps = message.Parameters[2].Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                     foreach (string acceptedCap in rejectedCaps)                         client.Capabilities.Disable(acceptedCap);                      // Check if the disabled capabilities count is the same as the ones                     // rejected by the server.                     if (client.IsNegotiatingCapabilities && client.Capabilities.Disabled.Count() == rejectedCaps.Count())                     {                         client.SendRawMessage("CAP END");                         client.IsNegotiatingCapabilities = false;                     }                      break;                 case "LIST":                     var activeCapsString = (message.Parameters[2] == "*" ? message.Parameters[3] : message.Parameters[2]);                     var activeCaps = activeCapsString.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                      // Check which cap we have that isn't active but the server lists                     // as active.                     foreach (string cap in activeCaps)                     {                         if (client.Capabilities.Contains(cap))                             if (!client.Capabilities[cap].IsEnabled)                                 client.Capabilities.Enable(cap);                     }                      break;                 case "NEW":                     var newCaps = message.Parameters[2].Split(new[] { " " }' StringSplitOptions.RemoveEmptyEntries);                     var wantCaps = new List<string>();                      // Check which new capabilities we support and send a REQ for them                     wantCaps.AddRange(newCaps.Where(cap => client.Capabilities.Contains(cap) && !client.Capabilities[cap].IsEnabled));                      client.SendRawMessage(string.Format("CAP REQ :{0}"' string.Join(" "' wantCaps)));                     break;                 case "DEL":                     var disabledCaps = message.Parameters[2].Split(new[] { " " }' StringSplitOptions.RemoveEmptyEntries).ToList();                      // Disable each recently server-disabled capability                     disabledCaps.ForEach(                         cap => {                             if (client.Capabilities.Contains(cap) && client.Capabilities[cap].IsEnabled)                                 client.Capabilities.Disable(cap);                         }                     );                     break;                 default:                     break;             }
Magic Number,ChatSharp.Handlers,CapabilityHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\CapabilityHandlers.cs,HandleCapability,The following statement contains a magic number: switch (message.Parameters[1])             {                 case "LS":                     client.IsNegotiatingCapabilities = true;                     // Parse server capabilities                     var serverCapsString = (message.Parameters[2] == "*" ? message.Parameters[3] : message.Parameters[2]);                     serverCaps.AddRange(serverCapsString.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries));                      // CAP 3.2 multiline support. Send CAP requests on the last CAP LS line.                     // The last CAP LS line doesn't have * set as Parameters[2]                     if (message.Parameters[2] != "*")                     {                         // Check which capabilities we support that the server supports                         requestedCaps.AddRange(supportedCaps.Select(cap => cap.Name).Intersect(serverCaps));                          // Check if we have to request any capability to be enabled.                         // If not' end the capability negotiation.                         if (requestedCaps.Count > 0)                             client.SendRawMessage("CAP REQ :{0}"' string.Join(" "' requestedCaps));                         else                         {                             client.SendRawMessage("CAP END");                             client.IsNegotiatingCapabilities = false;                         }                     }                     break;                 case "ACK":                     // Get the accepted capabilities                     var acceptedCaps = message.Parameters[2].Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                     foreach (string acceptedCap in acceptedCaps)                     {                         client.Capabilities.Enable(acceptedCap);                         // Begin SASL authentication                         if (acceptedCap == "sasl")                         {                             client.SendRawMessage("AUTHENTICATE PLAIN");                             client.IsAuthenticatingSasl = true;                         }                     }                      // Check if the enabled capabilities count is the same as the ones                     // acknowledged by the server.                     if (client.IsNegotiatingCapabilities && client.Capabilities.Enabled.Count() == acceptedCaps.Count() && !client.IsAuthenticatingSasl)                     {                         client.SendRawMessage("CAP END");                         client.IsNegotiatingCapabilities = false;                     }                      break;                 case "NAK":                     // Get the rejected capabilities                     var rejectedCaps = message.Parameters[2].Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                     foreach (string acceptedCap in rejectedCaps)                         client.Capabilities.Disable(acceptedCap);                      // Check if the disabled capabilities count is the same as the ones                     // rejected by the server.                     if (client.IsNegotiatingCapabilities && client.Capabilities.Disabled.Count() == rejectedCaps.Count())                     {                         client.SendRawMessage("CAP END");                         client.IsNegotiatingCapabilities = false;                     }                      break;                 case "LIST":                     var activeCapsString = (message.Parameters[2] == "*" ? message.Parameters[3] : message.Parameters[2]);                     var activeCaps = activeCapsString.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                      // Check which cap we have that isn't active but the server lists                     // as active.                     foreach (string cap in activeCaps)                     {                         if (client.Capabilities.Contains(cap))                             if (!client.Capabilities[cap].IsEnabled)                                 client.Capabilities.Enable(cap);                     }                      break;                 case "NEW":                     var newCaps = message.Parameters[2].Split(new[] { " " }' StringSplitOptions.RemoveEmptyEntries);                     var wantCaps = new List<string>();                      // Check which new capabilities we support and send a REQ for them                     wantCaps.AddRange(newCaps.Where(cap => client.Capabilities.Contains(cap) && !client.Capabilities[cap].IsEnabled));                      client.SendRawMessage(string.Format("CAP REQ :{0}"' string.Join(" "' wantCaps)));                     break;                 case "DEL":                     var disabledCaps = message.Parameters[2].Split(new[] { " " }' StringSplitOptions.RemoveEmptyEntries).ToList();                      // Disable each recently server-disabled capability                     disabledCaps.ForEach(                         cap => {                             if (client.Capabilities.Contains(cap) && client.Capabilities[cap].IsEnabled)                                 client.Capabilities.Disable(cap);                         }                     );                     break;                 default:                     break;             }
Magic Number,ChatSharp.Handlers,ChannelHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\ChannelHandlers.cs,HandleGetTopic,The following statement contains a magic number: channel._Topic = message.Parameters[2];
Magic Number,ChatSharp.Handlers,ChannelHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\ChannelHandlers.cs,HandleGetEmptyTopic,The following statement contains a magic number: channel._Topic = message.Parameters[2];
Magic Number,ChatSharp.Handlers,ChannelHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\ChannelHandlers.cs,HandleUserListPart,The following statement contains a magic number: var channel = client.Channels[message.Parameters[2]];
Magic Number,ChatSharp.Handlers,ChannelHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\ChannelHandlers.cs,HandleUserListPart,The following statement contains a magic number: var users = message.Parameters[3].Split(new[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);
Magic Number,ChatSharp.Handlers,ChannelHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\ChannelHandlers.cs,WhoIsChannel,The following statement contains a magic number: Thread.Sleep(client.Settings.JoinWhoIsDelay * 1000);
Magic Number,ChatSharp.Handlers,ChannelHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\ChannelHandlers.cs,HandleKick,The following statement contains a magic number: client.OnUserKicked(new KickEventArgs(channel' new IrcUser(message.Prefix)'                 kicked' message.Parameters[2]));
Magic Number,ChatSharp.Handlers,ListingHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\ListingHandlers.cs,HandleBanListPart,The following statement contains a magic number: list.Add(new Mask(parameters[2]' client.Users.GetOrAdd(parameters[3])'                 IrcClient.DateTimeFromIrcTime(int.Parse(parameters[4]))));
Magic Number,ChatSharp.Handlers,ListingHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\ListingHandlers.cs,HandleBanListPart,The following statement contains a magic number: list.Add(new Mask(parameters[2]' client.Users.GetOrAdd(parameters[3])'                 IrcClient.DateTimeFromIrcTime(int.Parse(parameters[4]))));
Magic Number,ChatSharp.Handlers,ListingHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\ListingHandlers.cs,HandleBanListPart,The following statement contains a magic number: list.Add(new Mask(parameters[2]' client.Users.GetOrAdd(parameters[3])'                 IrcClient.DateTimeFromIrcTime(int.Parse(parameters[4]))));
Magic Number,ChatSharp.Handlers,ListingHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\ListingHandlers.cs,HandleExceptionListPart,The following statement contains a magic number: list.Add(new Mask(parameters[2]' client.Users.GetOrAdd(parameters[3])'                 IrcClient.DateTimeFromIrcTime(int.Parse(parameters[4]))));
Magic Number,ChatSharp.Handlers,ListingHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\ListingHandlers.cs,HandleExceptionListPart,The following statement contains a magic number: list.Add(new Mask(parameters[2]' client.Users.GetOrAdd(parameters[3])'                 IrcClient.DateTimeFromIrcTime(int.Parse(parameters[4]))));
Magic Number,ChatSharp.Handlers,ListingHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\ListingHandlers.cs,HandleExceptionListPart,The following statement contains a magic number: list.Add(new Mask(parameters[2]' client.Users.GetOrAdd(parameters[3])'                 IrcClient.DateTimeFromIrcTime(int.Parse(parameters[4]))));
Magic Number,ChatSharp.Handlers,ListingHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\ListingHandlers.cs,HandleInviteListPart,The following statement contains a magic number: list.Add(new Mask(parameters[2]' client.Users.GetOrAdd(parameters[3])'                 IrcClient.DateTimeFromIrcTime(int.Parse(parameters[4]))));
Magic Number,ChatSharp.Handlers,ListingHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\ListingHandlers.cs,HandleInviteListPart,The following statement contains a magic number: list.Add(new Mask(parameters[2]' client.Users.GetOrAdd(parameters[3])'                 IrcClient.DateTimeFromIrcTime(int.Parse(parameters[4]))));
Magic Number,ChatSharp.Handlers,ListingHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\ListingHandlers.cs,HandleInviteListPart,The following statement contains a magic number: list.Add(new Mask(parameters[2]' client.Users.GetOrAdd(parameters[3])'                 IrcClient.DateTimeFromIrcTime(int.Parse(parameters[4]))));
Magic Number,ChatSharp.Handlers,ListingHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\ListingHandlers.cs,HandleQuietListPart,The following statement contains a magic number: list.Add(new Mask(parameters[2]' client.Users.GetOrAdd(parameters[3])'                 IrcClient.DateTimeFromIrcTime(int.Parse(parameters[4]))));
Magic Number,ChatSharp.Handlers,ListingHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\ListingHandlers.cs,HandleQuietListPart,The following statement contains a magic number: list.Add(new Mask(parameters[2]' client.Users.GetOrAdd(parameters[3])'                 IrcClient.DateTimeFromIrcTime(int.Parse(parameters[4]))));
Magic Number,ChatSharp.Handlers,ListingHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\ListingHandlers.cs,HandleQuietListPart,The following statement contains a magic number: list.Add(new Mask(parameters[2]' client.Users.GetOrAdd(parameters[3])'                 IrcClient.DateTimeFromIrcTime(int.Parse(parameters[4]))));
Magic Number,ChatSharp.Handlers,MessageHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\MessageHandlers.cs,HandleMode,The following statement contains a magic number: int i = 2;
Magic Number,ChatSharp.Handlers,MOTDHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\MOTDHandlers.cs,HandleMOTD,The following statement contains a magic number: message.Parameters.Length != 2
Magic Number,ChatSharp.Handlers,MOTDHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\MOTDHandlers.cs,HandleMOTD,The following statement contains a magic number: var part = message.Parameters[1].Substring(2);
Magic Number,ChatSharp.Handlers,SaslHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\SaslHandlers.cs,HandleAuthentication,The following statement contains a magic number: var chunk = b64Bytes.Take(400).ToArray();
Magic Number,ChatSharp.Handlers,SaslHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\SaslHandlers.cs,HandleAuthentication,The following statement contains a magic number: b64Bytes = b64Bytes.Skip(400).ToArray();
Magic Number,ChatSharp.Handlers,SaslHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\SaslHandlers.cs,HandleAuthentication,The following statement contains a magic number: b64Bytes.Length >= 400
Magic Number,ChatSharp.Handlers,ServerHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\ServerHandlers.cs,HandleISupport,The following statement contains a magic number: switch (key.ToUpper())                     {                         case "PREFIX":                             var modes = value.Substring(1' value.IndexOf(')') - 1);                             var prefixes = value.Substring(value.IndexOf(')') + 1);                             client.ServerInfo.Prefixes = new[] {modes' prefixes};                             break;                         case "CHANTYPES":                             client.ServerInfo.ChannelTypes = value.ToCharArray();                             break;                         case "CHANMODES":                             var chanModeGroups = value.Split(''');                             client.ServerInfo.SupportedChannelModes.ChannelLists = chanModeGroups[0];                             client.ServerInfo.SupportedChannelModes.ParameterizedSettings = chanModeGroups[1];                             client.ServerInfo.SupportedChannelModes.OptionallyParameterizedSettings = chanModeGroups[2];                             client.ServerInfo.SupportedChannelModes.Settings = chanModeGroups[3];                             break;                         case "MODES":                             client.ServerInfo.MaxModesPerCommand = int.Parse(value);                             break;                         case "MAXCHANNELS": // TODO: CHANLIMIT                             client.ServerInfo.MaxChannelsPerUser = int.Parse(value);                             break;                         case "NICKLEN":                             client.ServerInfo.MaxNickLength = int.Parse(value);                             break;                         case "MAXLIST":                             var limits = value.Split(''');                             client.ServerInfo.ModeListLimits = new ServerInfo.ModeListLimit[limits.Length];                             for (int i = 0; i < limits.Length; i++)                             {                                 var limitedModes = limits[i].Remove(limits[i].IndexOf(':'));                                 var limit = int.Parse(limits[i].Substring(limits[i].IndexOf(':') + 1));                                 foreach (var mode in limitedModes)                                     client.ServerInfo.ModeListLimits[i] = new ServerInfo.ModeListLimit(mode' limit);                             }                             break;                         case "NETWORK":                             client.ServerInfo.NetworkName = value;                             break;                         case "EXCEPTS":                             client.ServerInfo.SupportsBanExceptions = value[0];                             break;                         case "INVEX":                             client.ServerInfo.SupportsInviteExceptions = value[0];                             break;                         case "TOPICLEN":                             client.ServerInfo.MaxTopicLength = int.Parse(value);                             break;                         case "KICKLEN":                             client.ServerInfo.MaxKickCommentLength = int.Parse(value);                             break;                         case "CHANNELLEN":                             client.ServerInfo.MaxChannelNameLength = int.Parse(value);                             break;                         case "AWAYLEN":                             client.ServerInfo.MaxAwayLength = int.Parse(value);                             break;                     }
Magic Number,ChatSharp.Handlers,ServerHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\ServerHandlers.cs,HandleISupport,The following statement contains a magic number: switch (key.ToUpper())                     {                         case "PREFIX":                             var modes = value.Substring(1' value.IndexOf(')') - 1);                             var prefixes = value.Substring(value.IndexOf(')') + 1);                             client.ServerInfo.Prefixes = new[] {modes' prefixes};                             break;                         case "CHANTYPES":                             client.ServerInfo.ChannelTypes = value.ToCharArray();                             break;                         case "CHANMODES":                             var chanModeGroups = value.Split(''');                             client.ServerInfo.SupportedChannelModes.ChannelLists = chanModeGroups[0];                             client.ServerInfo.SupportedChannelModes.ParameterizedSettings = chanModeGroups[1];                             client.ServerInfo.SupportedChannelModes.OptionallyParameterizedSettings = chanModeGroups[2];                             client.ServerInfo.SupportedChannelModes.Settings = chanModeGroups[3];                             break;                         case "MODES":                             client.ServerInfo.MaxModesPerCommand = int.Parse(value);                             break;                         case "MAXCHANNELS": // TODO: CHANLIMIT                             client.ServerInfo.MaxChannelsPerUser = int.Parse(value);                             break;                         case "NICKLEN":                             client.ServerInfo.MaxNickLength = int.Parse(value);                             break;                         case "MAXLIST":                             var limits = value.Split(''');                             client.ServerInfo.ModeListLimits = new ServerInfo.ModeListLimit[limits.Length];                             for (int i = 0; i < limits.Length; i++)                             {                                 var limitedModes = limits[i].Remove(limits[i].IndexOf(':'));                                 var limit = int.Parse(limits[i].Substring(limits[i].IndexOf(':') + 1));                                 foreach (var mode in limitedModes)                                     client.ServerInfo.ModeListLimits[i] = new ServerInfo.ModeListLimit(mode' limit);                             }                             break;                         case "NETWORK":                             client.ServerInfo.NetworkName = value;                             break;                         case "EXCEPTS":                             client.ServerInfo.SupportsBanExceptions = value[0];                             break;                         case "INVEX":                             client.ServerInfo.SupportsInviteExceptions = value[0];                             break;                         case "TOPICLEN":                             client.ServerInfo.MaxTopicLength = int.Parse(value);                             break;                         case "KICKLEN":                             client.ServerInfo.MaxKickCommentLength = int.Parse(value);                             break;                         case "CHANNELLEN":                             client.ServerInfo.MaxChannelNameLength = int.Parse(value);                             break;                         case "AWAYLEN":                             client.ServerInfo.MaxAwayLength = int.Parse(value);                             break;                     }
Magic Number,ChatSharp.Handlers,ServerHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\ServerHandlers.cs,HandleMyInfo,The following statement contains a magic number: message.Parameters[4]
Magic Number,ChatSharp.Handlers,ServerHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\ServerHandlers.cs,HandleMyInfo,The following statement contains a magic number: message.Parameters.Length >= 5
Magic Number,ChatSharp.Handlers,UserHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\UserHandlers.cs,HandleWhoIsUser,The following statement contains a magic number: whois.User.User = message.Parameters[2];
Magic Number,ChatSharp.Handlers,UserHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\UserHandlers.cs,HandleWhoIsUser,The following statement contains a magic number: whois.User.Hostname = message.Parameters[3];
Magic Number,ChatSharp.Handlers,UserHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\UserHandlers.cs,HandleWhoIsUser,The following statement contains a magic number: whois.User.RealName = message.Parameters[5];
Magic Number,ChatSharp.Handlers,UserHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\UserHandlers.cs,HandleWhoIsUser,The following statement contains a magic number: message.Parameters != null && message.Parameters.Length >= 6
Magic Number,ChatSharp.Handlers,UserHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\UserHandlers.cs,HandleWhoIsLoggedInAs,The following statement contains a magic number: whois.LoggedInAs = message.Parameters[2];
Magic Number,ChatSharp.Handlers,UserHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\UserHandlers.cs,HandleWhoIsServer,The following statement contains a magic number: whois.Server = message.Parameters[2];
Magic Number,ChatSharp.Handlers,UserHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\UserHandlers.cs,HandleWhoIsServer,The following statement contains a magic number: whois.ServerInfo = message.Parameters[3];
Magic Number,ChatSharp.Handlers,UserHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\UserHandlers.cs,HandleWhoIsIdle,The following statement contains a magic number: whois.SecondsIdle = int.Parse(message.Parameters[2]);
Magic Number,ChatSharp.Handlers,UserHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\UserHandlers.cs,HandleWhoIsChannels,The following statement contains a magic number: var channels = message.Parameters[2].Split(new[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);
Magic Number,ChatSharp.Handlers,UserHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\UserHandlers.cs,HandleWho,The following statement contains a magic number: who.User.User = message.Parameters[2];
Magic Number,ChatSharp.Handlers,UserHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\UserHandlers.cs,HandleWho,The following statement contains a magic number: who.IP = message.Parameters[3];
Magic Number,ChatSharp.Handlers,UserHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\UserHandlers.cs,HandleWho,The following statement contains a magic number: who.Server = message.Parameters[4];
Magic Number,ChatSharp.Handlers,UserHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\UserHandlers.cs,HandleWho,The following statement contains a magic number: who.User.Nick = message.Parameters[5];
Magic Number,ChatSharp.Handlers,UserHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\UserHandlers.cs,HandleWho,The following statement contains a magic number: who.Flags = message.Parameters[6];
Magic Number,ChatSharp.Handlers,UserHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\UserHandlers.cs,HandleWho,The following statement contains a magic number: var supposedRealName = message.Parameters[7];
Magic Number,ChatSharp.Handlers,UserHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\UserHandlers.cs,HandleWhox,The following statement contains a magic number: int queryType = int.Parse(queryParts[2]);
Magic Number,ChatSharp.Handlers,UserHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\UserHandlers.cs,HandleWhox,The following statement contains a magic number: WhoxField fields = (WhoxField)int.Parse(queryParts[3]);
Magic Number,ChatSharp.Handlers,UserHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\UserHandlers.cs,HandleLoggedIn,The following statement contains a magic number: client.User.Account = message.Parameters[2];
Missing Default,ChatSharp.Handlers,ServerHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\ServerHandlers.cs,HandleISupport,The following switch statement is missing a default case: switch (key.ToUpper())                     {                         case "PREFIX":                             var modes = value.Substring(1' value.IndexOf(')') - 1);                             var prefixes = value.Substring(value.IndexOf(')') + 1);                             client.ServerInfo.Prefixes = new[] {modes' prefixes};                             break;                         case "CHANTYPES":                             client.ServerInfo.ChannelTypes = value.ToCharArray();                             break;                         case "CHANMODES":                             var chanModeGroups = value.Split(''');                             client.ServerInfo.SupportedChannelModes.ChannelLists = chanModeGroups[0];                             client.ServerInfo.SupportedChannelModes.ParameterizedSettings = chanModeGroups[1];                             client.ServerInfo.SupportedChannelModes.OptionallyParameterizedSettings = chanModeGroups[2];                             client.ServerInfo.SupportedChannelModes.Settings = chanModeGroups[3];                             break;                         case "MODES":                             client.ServerInfo.MaxModesPerCommand = int.Parse(value);                             break;                         case "MAXCHANNELS": // TODO: CHANLIMIT                             client.ServerInfo.MaxChannelsPerUser = int.Parse(value);                             break;                         case "NICKLEN":                             client.ServerInfo.MaxNickLength = int.Parse(value);                             break;                         case "MAXLIST":                             var limits = value.Split(''');                             client.ServerInfo.ModeListLimits = new ServerInfo.ModeListLimit[limits.Length];                             for (int i = 0; i < limits.Length; i++)                             {                                 var limitedModes = limits[i].Remove(limits[i].IndexOf(':'));                                 var limit = int.Parse(limits[i].Substring(limits[i].IndexOf(':') + 1));                                 foreach (var mode in limitedModes)                                     client.ServerInfo.ModeListLimits[i] = new ServerInfo.ModeListLimit(mode' limit);                             }                             break;                         case "NETWORK":                             client.ServerInfo.NetworkName = value;                             break;                         case "EXCEPTS":                             client.ServerInfo.SupportsBanExceptions = value[0];                             break;                         case "INVEX":                             client.ServerInfo.SupportsInviteExceptions = value[0];                             break;                         case "TOPICLEN":                             client.ServerInfo.MaxTopicLength = int.Parse(value);                             break;                         case "KICKLEN":                             client.ServerInfo.MaxKickCommentLength = int.Parse(value);                             break;                         case "CHANNELLEN":                             client.ServerInfo.MaxChannelNameLength = int.Parse(value);                             break;                         case "AWAYLEN":                             client.ServerInfo.MaxAwayLength = int.Parse(value);                             break;                     }
Missing Default,ChatSharp.Handlers,ServerHandlers,D:\research\architectureSmells\repos1\SirCmpwn_ChatSharp\ChatSharp\Handlers\ServerHandlers.cs,HandleISupport,The following switch statement is missing a default case: switch (key.ToUpper())                     {                         case "WHOX":                             client.ServerInfo.ExtendedWho = true;                             break;                     }
