Implementation smell,Namespace,Class,File,Method,Description
Long Method,Squared.Task.Http,HttpServer,C:\repos\sq_Fracture\Squared\TaskLib\Http\Request.cs,RequestTask,The method has 120 lines of code.
Complex Method,Squared.Task,TaskScheduler,C:\repos\sq_Fracture\Squared\TaskLib\TaskScheduler.cs,SleepWorkerThreadFunc,Cyclomatic complexity of the method is 10
Complex Method,Squared.Task,WindowsMessageJobQueue,C:\repos\sq_Fracture\Squared\TaskLib\Win32.cs,InternalStep,Cyclomatic complexity of the method is 9
Complex Method,Squared.Task.IO,DiskMonitor,C:\repos\sq_Fracture\Squared\TaskLib\DiskMonitor.cs,GetChangedFiles,Cyclomatic complexity of the method is 8
Complex Method,Squared.Task.Http,HttpServer,C:\repos\sq_Fracture\Squared\TaskLib\Http\Request.cs,RequestTask,Cyclomatic complexity of the method is 13
Long Parameter List,Squared.Task,NetworkExtensionMethods,C:\repos\sq_Fracture\Squared\TaskLib\Network.cs,AsyncSend,The method has 5 parameters. Parameters: udpClient' datagram' bytes' hostname' port
Long Parameter List,Squared.Task,TaskEventSubscriber,C:\repos\sq_Fracture\Squared\TaskLib\Util.cs,Subscribe,The method has 5 parameters. Parameters: eventBus' source' type' scheduler' task
Long Parameter List,Squared.Task,TaskEventSubscriber,C:\repos\sq_Fracture\Squared\TaskLib\Util.cs,Subscribe,The method has 5 parameters. Parameters: eventBus' source' type' scheduler' task
Long Parameter List,Squared.Task.IO,FileDataAdapter,C:\repos\sq_Fracture\Squared\TaskLib\IO.cs,FileDataAdapter,The method has 5 parameters. Parameters: filename' mode' access' share' bufferSize
Long Parameter List,Squared.Task.Http,Request,C:\repos\sq_Fracture\Squared\TaskLib\Http\Request.cs,Request,The method has 6 parameters. Parameters: server' adapter' shouldKeepAlive' line' headers' body
Empty Catch Block,Squared.Task,BlockingQueue<T>,C:\repos\sq_Fracture\Squared\TaskLib\BlockingQueue.cs,Enqueue,The method has an empty catch block.
Empty Catch Block,Squared.Task.IO,SocketDataAdapter,C:\repos\sq_Fracture\Squared\TaskLib\Sockets.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Squared.Task.Internal,WorkerThread<Container>,C:\repos\sq_Fracture\Squared\TaskLib\WorkerThread.cs,Wake,The method has an empty catch block.
Empty Catch Block,Squared.Task.Internal,WorkerThread<Container>,C:\repos\sq_Fracture\Squared\TaskLib\WorkerThread.cs,Wake,The method has an empty catch block.
Magic Number,Squared.Task,TaskScheduler,C:\repos\sq_Fracture\Squared\TaskLib\TaskScheduler.cs,SleepWorkerThreadFunc,The following statement contains a magic number: while (true) {                  long now = TimeProvider.Ticks;                    SleepItem currentSleep;                  Monitor.Enter(pendingSleeps);                  if (pendingSleeps.Peek(out currentSleep)) {                      if (currentSleep.Tick(now)) {                          pendingSleeps.Dequeue();                          Monitor.Exit(pendingSleeps);                          continue;                      } else {                          Monitor.Exit(pendingSleeps);                      }                  } else {                      Monitor.Exit(pendingSleeps);                        if (!newSleepEvent.Wait(SleepThreadTimeoutMs))                          return;                        newSleepEvent.Reset();                      continue;                  }                    long sleepUntil = currentSleep.Until;                    now = TimeProvider.Ticks;                  long timeToSleep = (sleepUntil - now) + SleepFudgeFactor;                    if (timeToSleep < SleepSpinThreshold) {                      int iteration = 1;                        while (TimeProvider.Ticks < sleepUntil) {                          Thread.SpinWait(20 * iteration);                          iteration += 1;                      }                        timeToSleep = 0;                  }                    if (timeToSleep > 0) {                      if (timeToSleep > MaximumSleepLength)                          timeToSleep = MaximumSleepLength;                        int msToSleep = 0;                      if (timeToSleep >= MinimumSleepLength) {                          msToSleep = (int)(timeToSleep / Time.MillisecondInTicks);                      }                        if (newSleepEvent != null) {                          newSleepEvent.Reset();                          newSleepEvent.Wait(msToSleep);                      }                  }              }
Magic Number,Squared.Task,TaskScheduler,C:\repos\sq_Fracture\Squared\TaskLib\TaskScheduler.cs,WaitFor,The following statement contains a magic number: if (!_JobQueue.CanPumpOnThisThread) {                  var evt = future.GetCompletionEvent();                  if (timeout.HasValue) {                      if (evt.Wait((int)(timeout * 1000)))                          return future.Result;                      else                          throw new TimeoutException();                  } else                      evt.Wait();              }
Magic Number,Squared.Task,Web,C:\repos\sq_Fracture\Squared\TaskLib\Web.cs,BuildPostText,The following statement contains a magic number: for (int i = 0; i < pairs.Length; i += 2) {                  if (i != 0)                      sb.Append("&");                    sb.AppendFormat(                      "{0}={1}"'                      FormEncode(pairs[i])'                      FormEncode(pairs[i + 1])                  );              }
Magic Number,Squared.Task,WindowsMessageJobQueue,C:\repos\sq_Fracture\Squared\TaskLib\Win32.cs,WindowsMessageJobQueue,The following statement contains a magic number: var cp = new CreateParams {                  Caption = "Squared.TaskLib.Win32JobQueue"'                  X = 0'                  Y = 0'                  Width = 0'                  Height = 0'                  Style = 0'                  ExStyle = WS_EX_NOACTIVATE'                  Parent = new IntPtr(-3)              };
Magic Number,Squared.Task.IO,DiskMonitor,C:\repos\sq_Fracture\Squared\TaskLib\DiskMonitor.cs,CreateWatcher,The following statement contains a magic number: var result = new FileSystemWatcher(folder) {                  InternalBufferSize = 32*1024'                  IncludeSubdirectories = true'                  Filter = "*"'                  NotifyFilter = NotifyFilters.FileName | NotifyFilters.DirectoryName | NotifyFilters.LastWrite              };
Magic Number,Squared.Task.IO,DiskMonitor,C:\repos\sq_Fracture\Squared\TaskLib\DiskMonitor.cs,CreateWatcher,The following statement contains a magic number: var result = new FileSystemWatcher(folder) {                  InternalBufferSize = 32*1024'                  IncludeSubdirectories = true'                  Filter = "*"'                  NotifyFilter = NotifyFilters.FileName | NotifyFilters.DirectoryName | NotifyFilters.LastWrite              };
Magic Number,Squared.Task.IO,AsyncTextWriter,C:\repos\sq_Fracture\Squared\TaskLib\IO.cs,WriteLines,The following statement contains a magic number: char[][] chars = new char[lines.Length * 2][];
Magic Number,Squared.Task.IO,AsyncTextWriter,C:\repos\sq_Fracture\Squared\TaskLib\IO.cs,WriteLines,The following statement contains a magic number: for (int i = 0; i < lines.Length; i++) {                  chars[i * 2] = lines[i].ToCharArray();                  chars[i * 2 + 1] = NewLine;              }
Magic Number,Squared.Task.IO,AsyncTextWriter,C:\repos\sq_Fracture\Squared\TaskLib\IO.cs,WriteLines,The following statement contains a magic number: for (int i = 0; i < lines.Length; i++) {                  chars[i * 2] = lines[i].ToCharArray();                  chars[i * 2 + 1] = NewLine;              }
Magic Number,Squared.Task.Http,HttpServer,C:\repos\sq_Fracture\Squared\TaskLib\Http\Request.cs,RequestTask,The following statement contains a magic number: try {                  const int headerBufferSize = 1024 * 32;                  const int bodyBufferSize = 1024 * 128;                  const double requestLineTimeout = 5;                    // RFC2616:                  // Words of *TEXT MAY contain characters from character sets other than ISO-8859-1 [22]                  //  only when encoded according to the rules of RFC 2047 [14].                  Encoding headerEncoding;                  try {                      headerEncoding = Encoding.GetEncoding("ISO-8859-1");                  } catch {                      headerEncoding = Encoding.ASCII;                  }                    Request request;                  RequestBody body;                  HeaderCollection headers;                  long bodyBytesRead = 0;                  long? expectedBodyLength = null;                    var reader = new AsyncTextReader(adapter' headerEncoding' headerBufferSize' false);                  string requestLineText;                    while (true) {                      var fRequestLine = reader.ReadLine();                      var fRequestOrTimeout = Scheduler.Start(new WaitWithTimeout(fRequestLine' requestLineTimeout));                        yield return fRequestOrTimeout;                        if (fRequestOrTimeout.Failed) {                          if (!(fRequestOrTimeout.Error is TimeoutException))                              OnRequestError(fRequestOrTimeout.Error);                            yield break;                      }                        if (fRequestLine.Failed) {                          if (!(fRequestLine.Error is SocketDisconnectedException))                              OnRequestError(fRequestLine.Error);                            yield break;                      }                        requestLineText = fRequestLine.Result;                        // RFC2616:                       // In the interest of robustness' servers SHOULD ignore any empty line(s) received where a                       //  Request-Line is expected. In other words' if the server is reading the protocol stream                       //   at the beginning of a message and receives a CRLF first' it should ignore the CRLF.                       if ((requestLineText != null) && (requestLineText.Trim().Length == 0))                          continue;                        break;                  }                    var requestLineParsed = DateTime.UtcNow;                    headers = new HeaderCollection();                  while (true) {                      var fHeaderLine = reader.ReadLine();                      yield return fHeaderLine;                        if (String.IsNullOrWhiteSpace(fHeaderLine.Result))                          break;                        headers.Add(new Header(fHeaderLine.Result));                  }                    var headersParsed = DateTime.UtcNow;                    var expectHeader = (headers.GetValue("Expect") ?? "").ToLowerInvariant();                  var expectsContinue = expectHeader.Contains("100-continue");                    string hostName;                  if (headers.Contains("Host")) {                      hostName = String.Format("http://{0}"' headers["Host"].Value);                  } else {                      var lep = (IPEndPoint)adapter.Socket.LocalEndPoint;                      hostName = String.Format("http://{0}:{1}"' lep.Address' lep.Port);                  }                    var requestLine = new RequestLine(hostName' requestLineText);                    var remainingBytes = reader.DisposeAndGetRemainingBytes();                  bodyBytesRead += remainingBytes.Count;                    var connectionHeader = (headers.GetValue("Connection") ?? "").ToLowerInvariant();                  var shouldKeepAlive =                       ((requestLine.Version == "1.1") || connectionHeader.Contains("keep-alive")) &&                      !connectionHeader.Contains("close");                    if (headers.Contains("Content-Length"))                      expectedBodyLength = long.Parse(headers["Content-Length"].Value);                    body = new RequestBody(remainingBytes' expectedBodyLength);                    if (expectsContinue)                      yield return adapter.Write(Continue100' 0' Continue100.Length);                    request = new Request(                      this' adapter' shouldKeepAlive'                      requestLine' headers' body                  );                    IncomingRequests.Enqueue(request);                    var requestEnqueued = DateTime.UtcNow;                  DateTime? requestBodyRead = null;                    // FIXME: I think it's technically accepted to send a body without a content-length' but                  //  it seems to be impossible to make that work right.                  if (expectedBodyLength.HasValue) {                      using (var bodyBuffer = BufferPool<byte>.Allocate(bodyBufferSize))                      while (bodyBytesRead < expectedBodyLength.Value) {                          long bytesToRead = Math.Min(expectedBodyLength.Value - bodyBytesRead' bodyBufferSize);                            if (bytesToRead <= 0)                              break;                            var fBytesRead = adapter.Read(bodyBuffer.Data' 0' (int)bytesToRead);                          yield return fBytesRead;                            if (fBytesRead.Failed) {                              if (fBytesRead.Error is SocketDisconnectedException)                                  break;                                body.Failed(fBytesRead.Error);                              OnRequestError(fBytesRead.Error);                              yield break;                          }                            var bytesRead = fBytesRead.Result;                            bodyBytesRead += bytesRead;                          body.Append(bodyBuffer.Data' 0' bytesRead);                      }                        requestBodyRead = DateTime.UtcNow;                  }                    body.Finish();                  successful = true;                    request.Timing = new Request.TimingData {                      Line = (requestLineParsed - startedWhen)'                      Headers = (headersParsed - requestLineParsed)'                      Queue = (requestEnqueued - headersParsed)'                      Body = (requestBodyRead - requestEnqueued)                  };              } finally {                  if (!successful)                      adapter.Dispose();              }
Magic Number,Squared.Task.Http,HttpServer,C:\repos\sq_Fracture\Squared\TaskLib\Http\Request.cs,RequestTask,The following statement contains a magic number: try {                  const int headerBufferSize = 1024 * 32;                  const int bodyBufferSize = 1024 * 128;                  const double requestLineTimeout = 5;                    // RFC2616:                  // Words of *TEXT MAY contain characters from character sets other than ISO-8859-1 [22]                  //  only when encoded according to the rules of RFC 2047 [14].                  Encoding headerEncoding;                  try {                      headerEncoding = Encoding.GetEncoding("ISO-8859-1");                  } catch {                      headerEncoding = Encoding.ASCII;                  }                    Request request;                  RequestBody body;                  HeaderCollection headers;                  long bodyBytesRead = 0;                  long? expectedBodyLength = null;                    var reader = new AsyncTextReader(adapter' headerEncoding' headerBufferSize' false);                  string requestLineText;                    while (true) {                      var fRequestLine = reader.ReadLine();                      var fRequestOrTimeout = Scheduler.Start(new WaitWithTimeout(fRequestLine' requestLineTimeout));                        yield return fRequestOrTimeout;                        if (fRequestOrTimeout.Failed) {                          if (!(fRequestOrTimeout.Error is TimeoutException))                              OnRequestError(fRequestOrTimeout.Error);                            yield break;                      }                        if (fRequestLine.Failed) {                          if (!(fRequestLine.Error is SocketDisconnectedException))                              OnRequestError(fRequestLine.Error);                            yield break;                      }                        requestLineText = fRequestLine.Result;                        // RFC2616:                       // In the interest of robustness' servers SHOULD ignore any empty line(s) received where a                       //  Request-Line is expected. In other words' if the server is reading the protocol stream                       //   at the beginning of a message and receives a CRLF first' it should ignore the CRLF.                       if ((requestLineText != null) && (requestLineText.Trim().Length == 0))                          continue;                        break;                  }                    var requestLineParsed = DateTime.UtcNow;                    headers = new HeaderCollection();                  while (true) {                      var fHeaderLine = reader.ReadLine();                      yield return fHeaderLine;                        if (String.IsNullOrWhiteSpace(fHeaderLine.Result))                          break;                        headers.Add(new Header(fHeaderLine.Result));                  }                    var headersParsed = DateTime.UtcNow;                    var expectHeader = (headers.GetValue("Expect") ?? "").ToLowerInvariant();                  var expectsContinue = expectHeader.Contains("100-continue");                    string hostName;                  if (headers.Contains("Host")) {                      hostName = String.Format("http://{0}"' headers["Host"].Value);                  } else {                      var lep = (IPEndPoint)adapter.Socket.LocalEndPoint;                      hostName = String.Format("http://{0}:{1}"' lep.Address' lep.Port);                  }                    var requestLine = new RequestLine(hostName' requestLineText);                    var remainingBytes = reader.DisposeAndGetRemainingBytes();                  bodyBytesRead += remainingBytes.Count;                    var connectionHeader = (headers.GetValue("Connection") ?? "").ToLowerInvariant();                  var shouldKeepAlive =                       ((requestLine.Version == "1.1") || connectionHeader.Contains("keep-alive")) &&                      !connectionHeader.Contains("close");                    if (headers.Contains("Content-Length"))                      expectedBodyLength = long.Parse(headers["Content-Length"].Value);                    body = new RequestBody(remainingBytes' expectedBodyLength);                    if (expectsContinue)                      yield return adapter.Write(Continue100' 0' Continue100.Length);                    request = new Request(                      this' adapter' shouldKeepAlive'                      requestLine' headers' body                  );                    IncomingRequests.Enqueue(request);                    var requestEnqueued = DateTime.UtcNow;                  DateTime? requestBodyRead = null;                    // FIXME: I think it's technically accepted to send a body without a content-length' but                  //  it seems to be impossible to make that work right.                  if (expectedBodyLength.HasValue) {                      using (var bodyBuffer = BufferPool<byte>.Allocate(bodyBufferSize))                      while (bodyBytesRead < expectedBodyLength.Value) {                          long bytesToRead = Math.Min(expectedBodyLength.Value - bodyBytesRead' bodyBufferSize);                            if (bytesToRead <= 0)                              break;                            var fBytesRead = adapter.Read(bodyBuffer.Data' 0' (int)bytesToRead);                          yield return fBytesRead;                            if (fBytesRead.Failed) {                              if (fBytesRead.Error is SocketDisconnectedException)                                  break;                                body.Failed(fBytesRead.Error);                              OnRequestError(fBytesRead.Error);                              yield break;                          }                            var bytesRead = fBytesRead.Result;                            bodyBytesRead += bytesRead;                          body.Append(bodyBuffer.Data' 0' bytesRead);                      }                        requestBodyRead = DateTime.UtcNow;                  }                    body.Finish();                  successful = true;                    request.Timing = new Request.TimingData {                      Line = (requestLineParsed - startedWhen)'                      Headers = (headersParsed - requestLineParsed)'                      Queue = (requestEnqueued - headersParsed)'                      Body = (requestBodyRead - requestEnqueued)                  };              } finally {                  if (!successful)                      adapter.Dispose();              }
Magic Number,Squared.Task.Http,HttpServer,C:\repos\sq_Fracture\Squared\TaskLib\Http\Request.cs,RequestTask,The following statement contains a magic number: try {                  const int headerBufferSize = 1024 * 32;                  const int bodyBufferSize = 1024 * 128;                  const double requestLineTimeout = 5;                    // RFC2616:                  // Words of *TEXT MAY contain characters from character sets other than ISO-8859-1 [22]                  //  only when encoded according to the rules of RFC 2047 [14].                  Encoding headerEncoding;                  try {                      headerEncoding = Encoding.GetEncoding("ISO-8859-1");                  } catch {                      headerEncoding = Encoding.ASCII;                  }                    Request request;                  RequestBody body;                  HeaderCollection headers;                  long bodyBytesRead = 0;                  long? expectedBodyLength = null;                    var reader = new AsyncTextReader(adapter' headerEncoding' headerBufferSize' false);                  string requestLineText;                    while (true) {                      var fRequestLine = reader.ReadLine();                      var fRequestOrTimeout = Scheduler.Start(new WaitWithTimeout(fRequestLine' requestLineTimeout));                        yield return fRequestOrTimeout;                        if (fRequestOrTimeout.Failed) {                          if (!(fRequestOrTimeout.Error is TimeoutException))                              OnRequestError(fRequestOrTimeout.Error);                            yield break;                      }                        if (fRequestLine.Failed) {                          if (!(fRequestLine.Error is SocketDisconnectedException))                              OnRequestError(fRequestLine.Error);                            yield break;                      }                        requestLineText = fRequestLine.Result;                        // RFC2616:                       // In the interest of robustness' servers SHOULD ignore any empty line(s) received where a                       //  Request-Line is expected. In other words' if the server is reading the protocol stream                       //   at the beginning of a message and receives a CRLF first' it should ignore the CRLF.                       if ((requestLineText != null) && (requestLineText.Trim().Length == 0))                          continue;                        break;                  }                    var requestLineParsed = DateTime.UtcNow;                    headers = new HeaderCollection();                  while (true) {                      var fHeaderLine = reader.ReadLine();                      yield return fHeaderLine;                        if (String.IsNullOrWhiteSpace(fHeaderLine.Result))                          break;                        headers.Add(new Header(fHeaderLine.Result));                  }                    var headersParsed = DateTime.UtcNow;                    var expectHeader = (headers.GetValue("Expect") ?? "").ToLowerInvariant();                  var expectsContinue = expectHeader.Contains("100-continue");                    string hostName;                  if (headers.Contains("Host")) {                      hostName = String.Format("http://{0}"' headers["Host"].Value);                  } else {                      var lep = (IPEndPoint)adapter.Socket.LocalEndPoint;                      hostName = String.Format("http://{0}:{1}"' lep.Address' lep.Port);                  }                    var requestLine = new RequestLine(hostName' requestLineText);                    var remainingBytes = reader.DisposeAndGetRemainingBytes();                  bodyBytesRead += remainingBytes.Count;                    var connectionHeader = (headers.GetValue("Connection") ?? "").ToLowerInvariant();                  var shouldKeepAlive =                       ((requestLine.Version == "1.1") || connectionHeader.Contains("keep-alive")) &&                      !connectionHeader.Contains("close");                    if (headers.Contains("Content-Length"))                      expectedBodyLength = long.Parse(headers["Content-Length"].Value);                    body = new RequestBody(remainingBytes' expectedBodyLength);                    if (expectsContinue)                      yield return adapter.Write(Continue100' 0' Continue100.Length);                    request = new Request(                      this' adapter' shouldKeepAlive'                      requestLine' headers' body                  );                    IncomingRequests.Enqueue(request);                    var requestEnqueued = DateTime.UtcNow;                  DateTime? requestBodyRead = null;                    // FIXME: I think it's technically accepted to send a body without a content-length' but                  //  it seems to be impossible to make that work right.                  if (expectedBodyLength.HasValue) {                      using (var bodyBuffer = BufferPool<byte>.Allocate(bodyBufferSize))                      while (bodyBytesRead < expectedBodyLength.Value) {                          long bytesToRead = Math.Min(expectedBodyLength.Value - bodyBytesRead' bodyBufferSize);                            if (bytesToRead <= 0)                              break;                            var fBytesRead = adapter.Read(bodyBuffer.Data' 0' (int)bytesToRead);                          yield return fBytesRead;                            if (fBytesRead.Failed) {                              if (fBytesRead.Error is SocketDisconnectedException)                                  break;                                body.Failed(fBytesRead.Error);                              OnRequestError(fBytesRead.Error);                              yield break;                          }                            var bytesRead = fBytesRead.Result;                            bodyBytesRead += bytesRead;                          body.Append(bodyBuffer.Data' 0' bytesRead);                      }                        requestBodyRead = DateTime.UtcNow;                  }                    body.Finish();                  successful = true;                    request.Timing = new Request.TimingData {                      Line = (requestLineParsed - startedWhen)'                      Headers = (headersParsed - requestLineParsed)'                      Queue = (requestEnqueued - headersParsed)'                      Body = (requestBodyRead - requestEnqueued)                  };              } finally {                  if (!successful)                      adapter.Dispose();              }
Magic Number,Squared.Task.Http,HttpServer,C:\repos\sq_Fracture\Squared\TaskLib\Http\Request.cs,RequestTask,The following statement contains a magic number: try {                  const int headerBufferSize = 1024 * 32;                  const int bodyBufferSize = 1024 * 128;                  const double requestLineTimeout = 5;                    // RFC2616:                  // Words of *TEXT MAY contain characters from character sets other than ISO-8859-1 [22]                  //  only when encoded according to the rules of RFC 2047 [14].                  Encoding headerEncoding;                  try {                      headerEncoding = Encoding.GetEncoding("ISO-8859-1");                  } catch {                      headerEncoding = Encoding.ASCII;                  }                    Request request;                  RequestBody body;                  HeaderCollection headers;                  long bodyBytesRead = 0;                  long? expectedBodyLength = null;                    var reader = new AsyncTextReader(adapter' headerEncoding' headerBufferSize' false);                  string requestLineText;                    while (true) {                      var fRequestLine = reader.ReadLine();                      var fRequestOrTimeout = Scheduler.Start(new WaitWithTimeout(fRequestLine' requestLineTimeout));                        yield return fRequestOrTimeout;                        if (fRequestOrTimeout.Failed) {                          if (!(fRequestOrTimeout.Error is TimeoutException))                              OnRequestError(fRequestOrTimeout.Error);                            yield break;                      }                        if (fRequestLine.Failed) {                          if (!(fRequestLine.Error is SocketDisconnectedException))                              OnRequestError(fRequestLine.Error);                            yield break;                      }                        requestLineText = fRequestLine.Result;                        // RFC2616:                       // In the interest of robustness' servers SHOULD ignore any empty line(s) received where a                       //  Request-Line is expected. In other words' if the server is reading the protocol stream                       //   at the beginning of a message and receives a CRLF first' it should ignore the CRLF.                       if ((requestLineText != null) && (requestLineText.Trim().Length == 0))                          continue;                        break;                  }                    var requestLineParsed = DateTime.UtcNow;                    headers = new HeaderCollection();                  while (true) {                      var fHeaderLine = reader.ReadLine();                      yield return fHeaderLine;                        if (String.IsNullOrWhiteSpace(fHeaderLine.Result))                          break;                        headers.Add(new Header(fHeaderLine.Result));                  }                    var headersParsed = DateTime.UtcNow;                    var expectHeader = (headers.GetValue("Expect") ?? "").ToLowerInvariant();                  var expectsContinue = expectHeader.Contains("100-continue");                    string hostName;                  if (headers.Contains("Host")) {                      hostName = String.Format("http://{0}"' headers["Host"].Value);                  } else {                      var lep = (IPEndPoint)adapter.Socket.LocalEndPoint;                      hostName = String.Format("http://{0}:{1}"' lep.Address' lep.Port);                  }                    var requestLine = new RequestLine(hostName' requestLineText);                    var remainingBytes = reader.DisposeAndGetRemainingBytes();                  bodyBytesRead += remainingBytes.Count;                    var connectionHeader = (headers.GetValue("Connection") ?? "").ToLowerInvariant();                  var shouldKeepAlive =                       ((requestLine.Version == "1.1") || connectionHeader.Contains("keep-alive")) &&                      !connectionHeader.Contains("close");                    if (headers.Contains("Content-Length"))                      expectedBodyLength = long.Parse(headers["Content-Length"].Value);                    body = new RequestBody(remainingBytes' expectedBodyLength);                    if (expectsContinue)                      yield return adapter.Write(Continue100' 0' Continue100.Length);                    request = new Request(                      this' adapter' shouldKeepAlive'                      requestLine' headers' body                  );                    IncomingRequests.Enqueue(request);                    var requestEnqueued = DateTime.UtcNow;                  DateTime? requestBodyRead = null;                    // FIXME: I think it's technically accepted to send a body without a content-length' but                  //  it seems to be impossible to make that work right.                  if (expectedBodyLength.HasValue) {                      using (var bodyBuffer = BufferPool<byte>.Allocate(bodyBufferSize))                      while (bodyBytesRead < expectedBodyLength.Value) {                          long bytesToRead = Math.Min(expectedBodyLength.Value - bodyBytesRead' bodyBufferSize);                            if (bytesToRead <= 0)                              break;                            var fBytesRead = adapter.Read(bodyBuffer.Data' 0' (int)bytesToRead);                          yield return fBytesRead;                            if (fBytesRead.Failed) {                              if (fBytesRead.Error is SocketDisconnectedException)                                  break;                                body.Failed(fBytesRead.Error);                              OnRequestError(fBytesRead.Error);                              yield break;                          }                            var bytesRead = fBytesRead.Result;                            bodyBytesRead += bytesRead;                          body.Append(bodyBuffer.Data' 0' bytesRead);                      }                        requestBodyRead = DateTime.UtcNow;                  }                    body.Finish();                  successful = true;                    request.Timing = new Request.TimingData {                      Line = (requestLineParsed - startedWhen)'                      Headers = (headersParsed - requestLineParsed)'                      Queue = (requestEnqueued - headersParsed)'                      Body = (requestBodyRead - requestEnqueued)                  };              } finally {                  if (!successful)                      adapter.Dispose();              }
Magic Number,Squared.Task.Http,HttpServer,C:\repos\sq_Fracture\Squared\TaskLib\Http\Request.cs,RequestTask,The following statement contains a magic number: try {                  const int headerBufferSize = 1024 * 32;                  const int bodyBufferSize = 1024 * 128;                  const double requestLineTimeout = 5;                    // RFC2616:                  // Words of *TEXT MAY contain characters from character sets other than ISO-8859-1 [22]                  //  only when encoded according to the rules of RFC 2047 [14].                  Encoding headerEncoding;                  try {                      headerEncoding = Encoding.GetEncoding("ISO-8859-1");                  } catch {                      headerEncoding = Encoding.ASCII;                  }                    Request request;                  RequestBody body;                  HeaderCollection headers;                  long bodyBytesRead = 0;                  long? expectedBodyLength = null;                    var reader = new AsyncTextReader(adapter' headerEncoding' headerBufferSize' false);                  string requestLineText;                    while (true) {                      var fRequestLine = reader.ReadLine();                      var fRequestOrTimeout = Scheduler.Start(new WaitWithTimeout(fRequestLine' requestLineTimeout));                        yield return fRequestOrTimeout;                        if (fRequestOrTimeout.Failed) {                          if (!(fRequestOrTimeout.Error is TimeoutException))                              OnRequestError(fRequestOrTimeout.Error);                            yield break;                      }                        if (fRequestLine.Failed) {                          if (!(fRequestLine.Error is SocketDisconnectedException))                              OnRequestError(fRequestLine.Error);                            yield break;                      }                        requestLineText = fRequestLine.Result;                        // RFC2616:                       // In the interest of robustness' servers SHOULD ignore any empty line(s) received where a                       //  Request-Line is expected. In other words' if the server is reading the protocol stream                       //   at the beginning of a message and receives a CRLF first' it should ignore the CRLF.                       if ((requestLineText != null) && (requestLineText.Trim().Length == 0))                          continue;                        break;                  }                    var requestLineParsed = DateTime.UtcNow;                    headers = new HeaderCollection();                  while (true) {                      var fHeaderLine = reader.ReadLine();                      yield return fHeaderLine;                        if (String.IsNullOrWhiteSpace(fHeaderLine.Result))                          break;                        headers.Add(new Header(fHeaderLine.Result));                  }                    var headersParsed = DateTime.UtcNow;                    var expectHeader = (headers.GetValue("Expect") ?? "").ToLowerInvariant();                  var expectsContinue = expectHeader.Contains("100-continue");                    string hostName;                  if (headers.Contains("Host")) {                      hostName = String.Format("http://{0}"' headers["Host"].Value);                  } else {                      var lep = (IPEndPoint)adapter.Socket.LocalEndPoint;                      hostName = String.Format("http://{0}:{1}"' lep.Address' lep.Port);                  }                    var requestLine = new RequestLine(hostName' requestLineText);                    var remainingBytes = reader.DisposeAndGetRemainingBytes();                  bodyBytesRead += remainingBytes.Count;                    var connectionHeader = (headers.GetValue("Connection") ?? "").ToLowerInvariant();                  var shouldKeepAlive =                       ((requestLine.Version == "1.1") || connectionHeader.Contains("keep-alive")) &&                      !connectionHeader.Contains("close");                    if (headers.Contains("Content-Length"))                      expectedBodyLength = long.Parse(headers["Content-Length"].Value);                    body = new RequestBody(remainingBytes' expectedBodyLength);                    if (expectsContinue)                      yield return adapter.Write(Continue100' 0' Continue100.Length);                    request = new Request(                      this' adapter' shouldKeepAlive'                      requestLine' headers' body                  );                    IncomingRequests.Enqueue(request);                    var requestEnqueued = DateTime.UtcNow;                  DateTime? requestBodyRead = null;                    // FIXME: I think it's technically accepted to send a body without a content-length' but                  //  it seems to be impossible to make that work right.                  if (expectedBodyLength.HasValue) {                      using (var bodyBuffer = BufferPool<byte>.Allocate(bodyBufferSize))                      while (bodyBytesRead < expectedBodyLength.Value) {                          long bytesToRead = Math.Min(expectedBodyLength.Value - bodyBytesRead' bodyBufferSize);                            if (bytesToRead <= 0)                              break;                            var fBytesRead = adapter.Read(bodyBuffer.Data' 0' (int)bytesToRead);                          yield return fBytesRead;                            if (fBytesRead.Failed) {                              if (fBytesRead.Error is SocketDisconnectedException)                                  break;                                body.Failed(fBytesRead.Error);                              OnRequestError(fBytesRead.Error);                              yield break;                          }                            var bytesRead = fBytesRead.Result;                            bodyBytesRead += bytesRead;                          body.Append(bodyBuffer.Data' 0' bytesRead);                      }                        requestBodyRead = DateTime.UtcNow;                  }                    body.Finish();                  successful = true;                    request.Timing = new Request.TimingData {                      Line = (requestLineParsed - startedWhen)'                      Headers = (headersParsed - requestLineParsed)'                      Queue = (requestEnqueued - headersParsed)'                      Body = (requestBodyRead - requestEnqueued)                  };              } finally {                  if (!successful)                      adapter.Dispose();              }
Magic Number,Squared.Task.Http,HttpServer,C:\repos\sq_Fracture\Squared\TaskLib\Http\Request.cs,ListenerTask,The following statement contains a magic number: using (context) {                  yield return Future.RunInThread(context.Start);                    var wfns = new WaitForNextStep();                  var acceptedConnections = new List<IncomingConnection>();                  const int connectionsToAcceptPerStep = 4;                  Future<IncomingConnection> acceptedConnection = null;                    while (true) {                      if (acceptedConnection != null) {                          if (acceptedConnection.Failed)                              OnListenerError(acceptedConnection.Error);                          else                              acceptedConnections.Add(acceptedConnection.Result);                      }                        context.IncomingConnections.DequeueMultiple(                          acceptedConnections' connectionsToAcceptPerStep                      );                        foreach (var ac in acceptedConnections) {                          var fKeepAlive = Scheduler.Start(KeepAliveTask(context' ac));                          fKeepAlive.RegisterOnComplete(RequestOnComplete);                      }                        acceptedConnections.Clear();                      acceptedConnection = context.IncomingConnections.Dequeue();                        yield return acceptedConnection;                  }              }
Magic Number,Squared.Task.Http,RequestBody,C:\repos\sq_Fracture\Squared\TaskLib\Http\Request.cs,RequestBody,The following statement contains a magic number: const int minBufferSize = 1024 * 16;
Magic Number,Squared.Task.Http,RequestBody,C:\repos\sq_Fracture\Squared\TaskLib\Http\Request.cs,RequestBody,The following statement contains a magic number: const int minBufferSize = 1024 * 16;
Magic Number,Squared.Task.Http,Response,C:\repos\sq_Fracture\Squared\TaskLib\Http\Response.cs,SendHeadersTask,The following statement contains a magic number: const int writeBufferSize = 1024;
Magic Number,Squared.Task.Http,Response,C:\repos\sq_Fracture\Squared\TaskLib\Http\Response.cs,SendHeadersTask,The following statement contains a magic number: using (var atw = new AsyncTextWriter(Adapter' Encoding.ASCII' writeBufferSize' false)) {                      var prologue = String.Format(                          "HTTP/1.1 {0} {1}"'                          StatusCode' StatusText ?? (StatusCode == 200 ? "OK" : "Unknown")                      );                        yield return atw.WriteLine(prologue);                        foreach (var header in Headers)                          yield return atw.WriteLine(header.ToString());                        yield return atw.WriteLine("");                        yield return atw.Flush();                  }
Magic Number,Squared.Task.Http,Response,C:\repos\sq_Fracture\Squared\TaskLib\Http\Response.cs,SendResponseTask,The following statement contains a magic number: const int blockSize = 1024 * 128;
Magic Number,Squared.Task.Http,Response,C:\repos\sq_Fracture\Squared\TaskLib\Http\Response.cs,SendResponseTask,The following statement contains a magic number: const int blockSize = 1024 * 128;
Magic Number,Squared.Task.Internal,WorkerThread<Container>,C:\repos\sq_Fracture\Squared\TaskLib\WorkerThread.cs,WorkerThread,The following statement contains a magic number: const int maxNameLength = 48;
