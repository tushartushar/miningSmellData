Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Squared.Render.Text,FontSize,C:\repos\sq_Fracture\Squared\Render.Freetype\FTFont.cs,GetGlyph,Cyclomatic complexity of the method is 11
Magic Number,Squared.Render.Text,FreeTypeFont,C:\repos\sq_Fracture\Squared\Render.Freetype\FTFont.cs,Initialize,The following statement contains a magic number: DPIPercent = 100;
Magic Number,Squared.Render.Text,FreeTypeFont,C:\repos\sq_Fracture\Squared\Render.Freetype\FTFont.cs,Initialize,The following statement contains a magic number: DefaultSize = new FontSize(this' 12);
Magic Number,Squared.Render.Text,FreeTypeFont,C:\repos\sq_Fracture\Squared\Render.Freetype\FTFont.cs,Initialize,The following statement contains a magic number: TabSize = 4;
Magic Number,Squared.Render.Text,FontSize,C:\repos\sq_Fracture\Squared\Render.Freetype\FTFont.cs,Upload,The following statement contains a magic number: var widthW = bitmap.Width + (Font.GlyphMargin * 2);
Magic Number,Squared.Render.Text,FontSize,C:\repos\sq_Fracture\Squared\Render.Freetype\FTFont.cs,Upload,The following statement contains a magic number: var heightW = bitmap.Rows + (Font.GlyphMargin * 2);
Magic Number,Squared.Render.Text,FontSize,C:\repos\sq_Fracture\Squared\Render.Freetype\FTFont.cs,Upload,The following statement contains a magic number: if (!foundRoom) {                      var newAtlas = new DynamicAtlas<Color>(                          Font.RenderCoordinator' AtlasWidth' AtlasHeight'                           SurfaceFormat.Color' 4' Font.MipMapping ? PickMipGenerator(Font) : null                      );                      Atlases.Add(newAtlas);                      if (!newAtlas.TryReserve(widthW' heightW' out result))                          throw new InvalidOperationException("Character too large for atlas");                  }
Magic Number,Squared.Render.Text,FontSize,C:\repos\sq_Fracture\Squared\Render.Freetype\FTFont.cs,Upload,The following statement contains a magic number: switch (bitmap.PixelMode) {                      case PixelMode.Gray:                          double gInv = 1.0 / Font.Gamma;                          bool applyGamma = (Font.Gamma < 0.9999) || (Font.Gamma > 1.0001);                            for (var y = 0; y < bitmap.Rows; y++) {                              var rowOffset = result.Atlas.Width * (y + result.Y + Font.GlyphMargin) + (result.X + Font.GlyphMargin);                              int yPitch = y * bitmap.Pitch;                                if (applyGamma) {                                  for (var x = 0; x < bitmap.Width; x++) {                                      var gD = pSrc[x + yPitch] / 255.0;                                      var g = (int)(Math.Pow(gD' gInv) * 255.0);                                      pixels[rowOffset + x] = new Color(g' g' g' g);                                  }                              } else {                                  for (var x = 0; x < bitmap.Width; x++) {                                      var g = pSrc[x + yPitch];                                      pixels[rowOffset + x] = new Color(g' g' g' g);                                  }                              }                          }                          break;                        case PixelMode.Mono:                          for (var y = 0; y < bitmap.Rows; y++) {                              var rowOffset = result.Atlas.Width * (y + result.Y + Font.GlyphMargin) + (result.X + Font.GlyphMargin);                              int yPitch = y * bitmap.Pitch;                                for (int x = 0' outX = rowOffset; x < bitmap.Pitch; x++' outX += 8) {                                  var bits = pSrc[x + yPitch];                                    for (int i = 0; i < 8; i++) {                                      int iy = 7 - i;                                      int g = ((bits & (1 << iy)) != 0) ? 255 : 0;                                      pixels[outX + i] = new Color(g' g' g' g);                                  }                              }                          }                          break;                        default:                          throw new NotImplementedException("Unsupported pixel mode: " + bitmap.PixelMode);                  }
Magic Number,Squared.Render.Text,FontSize,C:\repos\sq_Fracture\Squared\Render.Freetype\FTFont.cs,Upload,The following statement contains a magic number: switch (bitmap.PixelMode) {                      case PixelMode.Gray:                          double gInv = 1.0 / Font.Gamma;                          bool applyGamma = (Font.Gamma < 0.9999) || (Font.Gamma > 1.0001);                            for (var y = 0; y < bitmap.Rows; y++) {                              var rowOffset = result.Atlas.Width * (y + result.Y + Font.GlyphMargin) + (result.X + Font.GlyphMargin);                              int yPitch = y * bitmap.Pitch;                                if (applyGamma) {                                  for (var x = 0; x < bitmap.Width; x++) {                                      var gD = pSrc[x + yPitch] / 255.0;                                      var g = (int)(Math.Pow(gD' gInv) * 255.0);                                      pixels[rowOffset + x] = new Color(g' g' g' g);                                  }                              } else {                                  for (var x = 0; x < bitmap.Width; x++) {                                      var g = pSrc[x + yPitch];                                      pixels[rowOffset + x] = new Color(g' g' g' g);                                  }                              }                          }                          break;                        case PixelMode.Mono:                          for (var y = 0; y < bitmap.Rows; y++) {                              var rowOffset = result.Atlas.Width * (y + result.Y + Font.GlyphMargin) + (result.X + Font.GlyphMargin);                              int yPitch = y * bitmap.Pitch;                                for (int x = 0' outX = rowOffset; x < bitmap.Pitch; x++' outX += 8) {                                  var bits = pSrc[x + yPitch];                                    for (int i = 0; i < 8; i++) {                                      int iy = 7 - i;                                      int g = ((bits & (1 << iy)) != 0) ? 255 : 0;                                      pixels[outX + i] = new Color(g' g' g' g);                                  }                              }                          }                          break;                        default:                          throw new NotImplementedException("Unsupported pixel mode: " + bitmap.PixelMode);                  }
Magic Number,Squared.Render.Text,FontSize,C:\repos\sq_Fracture\Squared\Render.Freetype\FTFont.cs,Upload,The following statement contains a magic number: switch (bitmap.PixelMode) {                      case PixelMode.Gray:                          double gInv = 1.0 / Font.Gamma;                          bool applyGamma = (Font.Gamma < 0.9999) || (Font.Gamma > 1.0001);                            for (var y = 0; y < bitmap.Rows; y++) {                              var rowOffset = result.Atlas.Width * (y + result.Y + Font.GlyphMargin) + (result.X + Font.GlyphMargin);                              int yPitch = y * bitmap.Pitch;                                if (applyGamma) {                                  for (var x = 0; x < bitmap.Width; x++) {                                      var gD = pSrc[x + yPitch] / 255.0;                                      var g = (int)(Math.Pow(gD' gInv) * 255.0);                                      pixels[rowOffset + x] = new Color(g' g' g' g);                                  }                              } else {                                  for (var x = 0; x < bitmap.Width; x++) {                                      var g = pSrc[x + yPitch];                                      pixels[rowOffset + x] = new Color(g' g' g' g);                                  }                              }                          }                          break;                        case PixelMode.Mono:                          for (var y = 0; y < bitmap.Rows; y++) {                              var rowOffset = result.Atlas.Width * (y + result.Y + Font.GlyphMargin) + (result.X + Font.GlyphMargin);                              int yPitch = y * bitmap.Pitch;                                for (int x = 0' outX = rowOffset; x < bitmap.Pitch; x++' outX += 8) {                                  var bits = pSrc[x + yPitch];                                    for (int i = 0; i < 8; i++) {                                      int iy = 7 - i;                                      int g = ((bits & (1 << iy)) != 0) ? 255 : 0;                                      pixels[outX + i] = new Color(g' g' g' g);                                  }                              }                          }                          break;                        default:                          throw new NotImplementedException("Unsupported pixel mode: " + bitmap.PixelMode);                  }
Magic Number,Squared.Render.Text,FontSize,C:\repos\sq_Fracture\Squared\Render.Freetype\FTFont.cs,Upload,The following statement contains a magic number: switch (bitmap.PixelMode) {                      case PixelMode.Gray:                          double gInv = 1.0 / Font.Gamma;                          bool applyGamma = (Font.Gamma < 0.9999) || (Font.Gamma > 1.0001);                            for (var y = 0; y < bitmap.Rows; y++) {                              var rowOffset = result.Atlas.Width * (y + result.Y + Font.GlyphMargin) + (result.X + Font.GlyphMargin);                              int yPitch = y * bitmap.Pitch;                                if (applyGamma) {                                  for (var x = 0; x < bitmap.Width; x++) {                                      var gD = pSrc[x + yPitch] / 255.0;                                      var g = (int)(Math.Pow(gD' gInv) * 255.0);                                      pixels[rowOffset + x] = new Color(g' g' g' g);                                  }                              } else {                                  for (var x = 0; x < bitmap.Width; x++) {                                      var g = pSrc[x + yPitch];                                      pixels[rowOffset + x] = new Color(g' g' g' g);                                  }                              }                          }                          break;                        case PixelMode.Mono:                          for (var y = 0; y < bitmap.Rows; y++) {                              var rowOffset = result.Atlas.Width * (y + result.Y + Font.GlyphMargin) + (result.X + Font.GlyphMargin);                              int yPitch = y * bitmap.Pitch;                                for (int x = 0' outX = rowOffset; x < bitmap.Pitch; x++' outX += 8) {                                  var bits = pSrc[x + yPitch];                                    for (int i = 0; i < 8; i++) {                                      int iy = 7 - i;                                      int g = ((bits & (1 << iy)) != 0) ? 255 : 0;                                      pixels[outX + i] = new Color(g' g' g' g);                                  }                              }                          }                          break;                        default:                          throw new NotImplementedException("Unsupported pixel mode: " + bitmap.PixelMode);                  }
Magic Number,Squared.Render.Text,FontSize,C:\repos\sq_Fracture\Squared\Render.Freetype\FTFont.cs,Upload,The following statement contains a magic number: switch (bitmap.PixelMode) {                      case PixelMode.Gray:                          double gInv = 1.0 / Font.Gamma;                          bool applyGamma = (Font.Gamma < 0.9999) || (Font.Gamma > 1.0001);                            for (var y = 0; y < bitmap.Rows; y++) {                              var rowOffset = result.Atlas.Width * (y + result.Y + Font.GlyphMargin) + (result.X + Font.GlyphMargin);                              int yPitch = y * bitmap.Pitch;                                if (applyGamma) {                                  for (var x = 0; x < bitmap.Width; x++) {                                      var gD = pSrc[x + yPitch] / 255.0;                                      var g = (int)(Math.Pow(gD' gInv) * 255.0);                                      pixels[rowOffset + x] = new Color(g' g' g' g);                                  }                              } else {                                  for (var x = 0; x < bitmap.Width; x++) {                                      var g = pSrc[x + yPitch];                                      pixels[rowOffset + x] = new Color(g' g' g' g);                                  }                              }                          }                          break;                        case PixelMode.Mono:                          for (var y = 0; y < bitmap.Rows; y++) {                              var rowOffset = result.Atlas.Width * (y + result.Y + Font.GlyphMargin) + (result.X + Font.GlyphMargin);                              int yPitch = y * bitmap.Pitch;                                for (int x = 0' outX = rowOffset; x < bitmap.Pitch; x++' outX += 8) {                                  var bits = pSrc[x + yPitch];                                    for (int i = 0; i < 8; i++) {                                      int iy = 7 - i;                                      int g = ((bits & (1 << iy)) != 0) ? 255 : 0;                                      pixels[outX + i] = new Color(g' g' g' g);                                  }                              }                          }                          break;                        default:                          throw new NotImplementedException("Unsupported pixel mode: " + bitmap.PixelMode);                  }
Magic Number,Squared.Render.Text,FontSize,C:\repos\sq_Fracture\Squared\Render.Freetype\FTFont.cs,Upload,The following statement contains a magic number: switch (bitmap.PixelMode) {                      case PixelMode.Gray:                          double gInv = 1.0 / Font.Gamma;                          bool applyGamma = (Font.Gamma < 0.9999) || (Font.Gamma > 1.0001);                            for (var y = 0; y < bitmap.Rows; y++) {                              var rowOffset = result.Atlas.Width * (y + result.Y + Font.GlyphMargin) + (result.X + Font.GlyphMargin);                              int yPitch = y * bitmap.Pitch;                                if (applyGamma) {                                  for (var x = 0; x < bitmap.Width; x++) {                                      var gD = pSrc[x + yPitch] / 255.0;                                      var g = (int)(Math.Pow(gD' gInv) * 255.0);                                      pixels[rowOffset + x] = new Color(g' g' g' g);                                  }                              } else {                                  for (var x = 0; x < bitmap.Width; x++) {                                      var g = pSrc[x + yPitch];                                      pixels[rowOffset + x] = new Color(g' g' g' g);                                  }                              }                          }                          break;                        case PixelMode.Mono:                          for (var y = 0; y < bitmap.Rows; y++) {                              var rowOffset = result.Atlas.Width * (y + result.Y + Font.GlyphMargin) + (result.X + Font.GlyphMargin);                              int yPitch = y * bitmap.Pitch;                                for (int x = 0' outX = rowOffset; x < bitmap.Pitch; x++' outX += 8) {                                  var bits = pSrc[x + yPitch];                                    for (int i = 0; i < 8; i++) {                                      int iy = 7 - i;                                      int g = ((bits & (1 << iy)) != 0) ? 255 : 0;                                      pixels[outX + i] = new Color(g' g' g' g);                                  }                              }                          }                          break;                        default:                          throw new NotImplementedException("Unsupported pixel mode: " + bitmap.PixelMode);                  }
Magic Number,Squared.Render.Text,FontSize,C:\repos\sq_Fracture\Squared\Render.Freetype\FTFont.cs,Upload,The following statement contains a magic number: switch (bitmap.PixelMode) {                      case PixelMode.Gray:                          double gInv = 1.0 / Font.Gamma;                          bool applyGamma = (Font.Gamma < 0.9999) || (Font.Gamma > 1.0001);                            for (var y = 0; y < bitmap.Rows; y++) {                              var rowOffset = result.Atlas.Width * (y + result.Y + Font.GlyphMargin) + (result.X + Font.GlyphMargin);                              int yPitch = y * bitmap.Pitch;                                if (applyGamma) {                                  for (var x = 0; x < bitmap.Width; x++) {                                      var gD = pSrc[x + yPitch] / 255.0;                                      var g = (int)(Math.Pow(gD' gInv) * 255.0);                                      pixels[rowOffset + x] = new Color(g' g' g' g);                                  }                              } else {                                  for (var x = 0; x < bitmap.Width; x++) {                                      var g = pSrc[x + yPitch];                                      pixels[rowOffset + x] = new Color(g' g' g' g);                                  }                              }                          }                          break;                        case PixelMode.Mono:                          for (var y = 0; y < bitmap.Rows; y++) {                              var rowOffset = result.Atlas.Width * (y + result.Y + Font.GlyphMargin) + (result.X + Font.GlyphMargin);                              int yPitch = y * bitmap.Pitch;                                for (int x = 0' outX = rowOffset; x < bitmap.Pitch; x++' outX += 8) {                                  var bits = pSrc[x + yPitch];                                    for (int i = 0; i < 8; i++) {                                      int iy = 7 - i;                                      int g = ((bits & (1 << iy)) != 0) ? 255 : 0;                                      pixels[outX + i] = new Color(g' g' g' g);                                  }                              }                          }                          break;                        default:                          throw new NotImplementedException("Unsupported pixel mode: " + bitmap.PixelMode);                  }
Magic Number,Squared.Render.Text,FontSize,C:\repos\sq_Fracture\Squared\Render.Freetype\FTFont.cs,Upload,The following statement contains a magic number: switch (bitmap.PixelMode) {                      case PixelMode.Gray:                          double gInv = 1.0 / Font.Gamma;                          bool applyGamma = (Font.Gamma < 0.9999) || (Font.Gamma > 1.0001);                            for (var y = 0; y < bitmap.Rows; y++) {                              var rowOffset = result.Atlas.Width * (y + result.Y + Font.GlyphMargin) + (result.X + Font.GlyphMargin);                              int yPitch = y * bitmap.Pitch;                                if (applyGamma) {                                  for (var x = 0; x < bitmap.Width; x++) {                                      var gD = pSrc[x + yPitch] / 255.0;                                      var g = (int)(Math.Pow(gD' gInv) * 255.0);                                      pixels[rowOffset + x] = new Color(g' g' g' g);                                  }                              } else {                                  for (var x = 0; x < bitmap.Width; x++) {                                      var g = pSrc[x + yPitch];                                      pixels[rowOffset + x] = new Color(g' g' g' g);                                  }                              }                          }                          break;                        case PixelMode.Mono:                          for (var y = 0; y < bitmap.Rows; y++) {                              var rowOffset = result.Atlas.Width * (y + result.Y + Font.GlyphMargin) + (result.X + Font.GlyphMargin);                              int yPitch = y * bitmap.Pitch;                                for (int x = 0' outX = rowOffset; x < bitmap.Pitch; x++' outX += 8) {                                  var bits = pSrc[x + yPitch];                                    for (int i = 0; i < 8; i++) {                                      int iy = 7 - i;                                      int g = ((bits & (1 << iy)) != 0) ? 255 : 0;                                      pixels[outX + i] = new Color(g' g' g' g);                                  }                              }                          }                          break;                        default:                          throw new NotImplementedException("Unsupported pixel mode: " + bitmap.PixelMode);                  }
Magic Number,Squared.Render.Text,FontSize,C:\repos\sq_Fracture\Squared\Render.Freetype\FTFont.cs,GetGlyph,The following statement contains a magic number: Font.Face.SetCharSize(                      0' _SizePoints'                       (uint)(BaseDPI * Font.DPIPercent / 100)' (uint)(BaseDPI * Font.DPIPercent / 100)                  );
Magic Number,Squared.Render.Text,FontSize,C:\repos\sq_Fracture\Squared\Render.Freetype\FTFont.cs,GetGlyph,The following statement contains a magic number: Font.Face.SetCharSize(                      0' _SizePoints'                       (uint)(BaseDPI * Font.DPIPercent / 100)' (uint)(BaseDPI * Font.DPIPercent / 100)                  );
