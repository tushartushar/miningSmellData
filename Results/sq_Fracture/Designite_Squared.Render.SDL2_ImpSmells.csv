Implementation smell,Namespace,Class,File,Method,Description
Long Method,Squared.Render,StringLayoutEngine,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,AppendText,The method has 163 lines of code.
Long Method,Squared.Render.Text,StringLayoutEngine,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,AppendText,The method has 163 lines of code.
Long Method,Text,StringLayoutEngine,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,AppendText,The method has 163 lines of code.
Complex Method,Squared.Render,BitmapBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,AddRange,Cyclomatic complexity of the method is 10
Complex Method,Squared.Render,BitmapBatchCombiner,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,CanCombine,Cyclomatic complexity of the method is 11
Complex Method,Squared.Render,MultimaterialBitmapBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,AddRange,Cyclomatic complexity of the method is 10
Complex Method,Squared.Render,PrimitiveBatch<T>,C:\repos\sq_Fracture\Squared\RenderLib\RenderPrimitives.cs,Add,Cyclomatic complexity of the method is 8
Complex Method,Squared.Render,StringLayoutEngine,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,AppendText,Cyclomatic complexity of the method is 27
Complex Method,Squared.Render.Internal,PrimitiveBatch<T>,C:\repos\sq_Fracture\Squared\RenderLib\RenderPrimitives.cs,Add,Cyclomatic complexity of the method is 8
Complex Method,Squared.Render.Text,StringLayoutEngine,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,AppendText,Cyclomatic complexity of the method is 27
Complex Method,Text,StringLayoutEngine,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,AppendText,Cyclomatic complexity of the method is 27
Long Parameter List,Squared.Render,ViewTransform,C:\repos\sq_Fracture\Squared\RenderLib\DefaultMaterialSet.cs,CreateOrthographic,The method has 6 parameters. Parameters: x' y' width' height' zNearPlane' zFarPlane
Long Parameter List,Squared.Render,DynamicAtlas<T>,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,DynamicAtlas,The method has 6 parameters. Parameters: coordinator' width' height' format' spacing' mipGenerator
Long Parameter List,Squared.Render,Reservation,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,Reservation,The method has 5 parameters. Parameters: atlas' x' y' w' h
Long Parameter List,Squared.Render,BitmapBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,New,The method has 6 parameters. Parameters: container' layer' material' samplerState' samplerState2' useZBuffer
Long Parameter List,Squared.Render,BitmapBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,Initialize,The method has 7 parameters. Parameters: container' layer' material' samplerState' samplerState2' useZBuffer' capacity
Long Parameter List,Squared.Render,BitmapBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,AddRange,The method has 9 parameters. Parameters: items' firstIndex' count' offset' multiplyColor' addColor' sortKey' scale' material
Long Parameter List,Squared.Render,NativeBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,NativeBatch,The method has 5 parameters. Parameters: softwareBuffer' textureSet' localIndexOffset' localVertexOffset' vertexCount
Long Parameter List,Squared.Render,NativeBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,Initialize,The method has 6 parameters. Parameters: container' layer' material' batchSetup' batchTeardown' userData
Long Parameter List,Squared.Render,NativeBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,New,The method has 6 parameters. Parameters: container' layer' material' batchSetup' batchTeardown' userData
Long Parameter List,Squared.Render,MultimaterialBitmapBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,AddRange,The method has 11 parameters. Parameters: items' firstIndex' count' offset' multiplyColor' addColor' sortKey' scale' customMaterial' samplerState1' samplerState2
Long Parameter List,Squared.Render,MultimaterialBitmapBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,New,The method has 5 parameters. Parameters: container' layer' material' useZBuffer' sorter
Long Parameter List,Squared.Render,MultimaterialBitmapBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,Initialize,The method has 6 parameters. Parameters: container' layer' material' sorter' useZBuffer' capacity
Long Parameter List,Squared.Render,BitmapDrawCall,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,BitmapDrawCall,The method has 5 parameters. Parameters: texture' position' textureRegion' color' scale
Long Parameter List,Squared.Render,BitmapDrawCall,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,BitmapDrawCall,The method has 5 parameters. Parameters: texture' position' textureRegion' color' scale
Long Parameter List,Squared.Render,BitmapDrawCall,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,BitmapDrawCall,The method has 6 parameters. Parameters: texture' position' textureRegion' color' scale' origin
Long Parameter List,Squared.Render,BitmapDrawCall,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,BitmapDrawCall,The method has 7 parameters. Parameters: texture' position' textureRegion' color' scale' origin' rotation
Long Parameter List,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,MakeDrawArguments,The method has 8 parameters. Parameters: primitiveType' vb' ib' vertexOffset' indexOffset' primCount' vertexCount' indexCount
Long Parameter List,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,AddGradientFilledQuad,The method has 5 parameters. Parameters: bounds' topLeft' topRight' bottomLeft' bottomRight
Long Parameter List,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,AddGradientFilledQuad,The method has 6 parameters. Parameters: topLeft' bottomRight' topLeftColor' topRightColor' bottomLeftColor' bottomRightColor
Long Parameter List,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,AddQuadBorder,The method has 5 parameters. Parameters: topLeft' bottomRight' colorInner' colorOuter' borderSize
Long Parameter List,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,AddFilledBorderedQuad,The method has 5 parameters. Parameters: topLeft' bottomRight' colorInner' colorOuter' borderSize
Long Parameter List,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,AddFilledRing,The method has 5 parameters. Parameters: center' innerRadius' outerRadius' innerColor' outerColor
Long Parameter List,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,AddFilledRing,The method has 9 parameters. Parameters: center' innerRadius' outerRadius' innerColorStart' outerColorStart' innerColorEnd' outerColorEnd' startAngle' endAngle
Long Parameter List,Squared.Render,ListBatch<T>,C:\repos\sq_Fracture\Squared\RenderLib\RenderManager.cs,Initialize,The method has 5 parameters. Parameters: container' layer' material' addToContainer' capacity
Long Parameter List,Squared.Render,ClearBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderManager.cs,Initialize,The method has 6 parameters. Parameters: container' layer' material' clearColor' clearZ' clearStencil
Long Parameter List,Squared.Render,ClearBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderManager.cs,AddNew,The method has 6 parameters. Parameters: container' layer' material' clearColor' clearZ' clearStencil
Long Parameter List,Squared.Render,BatchGroup,C:\repos\sq_Fracture\Squared\RenderLib\RenderManager.cs,ForRenderTarget,The method has 6 parameters. Parameters: container' layer' renderTarget' before' after' userData
Long Parameter List,Squared.Render,BatchGroup,C:\repos\sq_Fracture\Squared\RenderLib\RenderManager.cs,New,The method has 5 parameters. Parameters: container' layer' before' after' userData
Long Parameter List,Squared.Render,BatchGroup,C:\repos\sq_Fracture\Squared\RenderLib\RenderManager.cs,Initialize,The method has 6 parameters. Parameters: container' layer' before' after' userData' addToContainer
Long Parameter List,Squared.Render,PrimitiveBatch<T>,C:\repos\sq_Fracture\Squared\RenderLib\RenderPrimitives.cs,Initialize,The method has 5 parameters. Parameters: container' layer' material' batchSetup' userData
Long Parameter List,Squared.Render,PrimitiveBatch<T>,C:\repos\sq_Fracture\Squared\RenderLib\RenderPrimitives.cs,New,The method has 5 parameters. Parameters: container' layer' material' batchSetup' userData
Long Parameter List,Squared.Render,PrimitiveDrawCall,C:\repos\sq_Fracture\Squared\RenderLib\RenderPrimitives.cs,New,The method has 7 parameters. Parameters: primitiveType' vertices' vertexOffset' vertexCount' indices' indexOffset' primitiveCount
Long Parameter List,Squared.Render,PrimitiveDrawCall,C:\repos\sq_Fracture\Squared\RenderLib\RenderPrimitives.cs,PrimitiveDrawCall,The method has 10 parameters. Parameters: primitiveType' vertices' vertexOffset' vertexCount' indices' indexOffset' primitiveCount' sortKey' beforeDraw' userData
Long Parameter List,Squared.Render,NativeDrawCall,C:\repos\sq_Fracture\Squared\RenderLib\RenderPrimitives.cs,NativeDrawCall,The method has 9 parameters. Parameters: primitiveType' vertexBuffer' vertexOffset' indexBuffer' baseVertex' minVertexIndex' numVertices' startIndex' primitiveCount
Long Parameter List,Squared.Render,NativeDrawCall,C:\repos\sq_Fracture\Squared\RenderLib\RenderPrimitives.cs,NativeDrawCall,The method has 5 parameters. Parameters: primitiveType' vertexBuffer' vertexOffset' startVertex' primitiveCount
Long Parameter List,Squared.Render,StringLayout,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,StringLayout,The method has 6 parameters. Parameters: position' size' lineHeight' firstCharacter' lastCharacter' drawCalls
Long Parameter List,Squared.Render,StringLayoutEngine,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,WrapWord,The method has 6 parameters. Parameters: buffer' firstOffset' firstIndex' lastIndex' effectiveScale' effectiveLineSpacing
Long Parameter List,Squared.Render,SpriteFontExtensions,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,LayoutString,The method has 15 parameters. Parameters: font' text' buffer' position' color' scale' sortKey' characterSkipCount' characterLimit' xOffsetOfFirstLine' lineBreakAtX' alignToPixels' kerningAdjustments' wordWrap' wrapCharacter
Long Parameter List,Squared.Render,SpriteFontExtensions,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,LayoutString,The method has 15 parameters. Parameters: glyphSource' text' buffer' position' color' scale' sortKey' characterSkipCount' characterLimit' xOffsetOfFirstLine' lineBreakAtX' alignToPixels' kerningAdjustments' wordWrap' wrapCharacter
Long Parameter List,Squared.Render,Fixup,C:\repos\sq_Fracture\Squared\RenderLib\UniformBindingLayout.cs,Fixup,The method has 5 parameters. Parameters: fromOffset' toOffset' dataSize' paddingSize' transposeMatrix
Long Parameter List,Squared.Render.Convenience,ImperativeRenderer,C:\repos\sq_Fracture\Squared\RenderLib\Convenience.cs,ImperativeRenderer,The method has 14 parameters. Parameters: container' materials' layer' rasterizerState' depthStencilState' blendState' samplerState' worldSpace' useZBuffer' autoIncrementSortKey' autoIncrementLayer' lowPriorityMaterialOrdering' declarativeSorter' tags
Long Parameter List,Squared.Render.Convenience,ImperativeRenderer,C:\repos\sq_Fracture\Squared\RenderLib\Convenience.cs,Draw,The method has 6 parameters. Parameters: drawCall' layer' worldSpace' blendState' samplerState' material
Long Parameter List,Squared.Render.Convenience,ImperativeRenderer,C:\repos\sq_Fracture\Squared\RenderLib\Convenience.cs,Draw,The method has 6 parameters. Parameters: drawCall' layer' worldSpace' blendState' samplerState' material
Long Parameter List,Squared.Render.Convenience,ImperativeRenderer,C:\repos\sq_Fracture\Squared\RenderLib\Convenience.cs,Draw,The method has 16 parameters. Parameters: texture' position' sourceRectangle' multiplyColor' addColor' rotation' scale' origin' mirrorX' mirrorY' sortKey' layer' worldSpace' blendState' samplerState' material
Long Parameter List,Squared.Render.Convenience,ImperativeRenderer,C:\repos\sq_Fracture\Squared\RenderLib\Convenience.cs,Draw,The method has 19 parameters. Parameters: texture' x' y' sourceRectangle' multiplyColor' addColor' rotation' scaleX' scaleY' originX' originY' mirrorX' mirrorY' sortKey' layer' worldSpace' blendState' samplerState' material
Long Parameter List,Squared.Render.Convenience,ImperativeRenderer,C:\repos\sq_Fracture\Squared\RenderLib\Convenience.cs,Draw,The method has 16 parameters. Parameters: texture' destRectangle' sourceRectangle' multiplyColor' addColor' rotation' originX' originY' mirrorX' mirrorY' sortKey' layer' worldSpace' blendState' samplerState' material
Long Parameter List,Squared.Render.Convenience,ImperativeRenderer,C:\repos\sq_Fracture\Squared\RenderLib\Convenience.cs,DrawMultiple,The method has 11 parameters. Parameters: drawCalls' offset' multiplyColor' addColor' sortKey' layer' worldSpace' blendState' samplerState' scale' material
Long Parameter List,Squared.Render.Convenience,ImperativeRenderer,C:\repos\sq_Fracture\Squared\RenderLib\Convenience.cs,DrawString,The method has 12 parameters. Parameters: font' text' position' color' scale' sortKey' characterSkipCount' characterLimit' layer' worldSpace' blendState' samplerState
Long Parameter List,Squared.Render.Convenience,ImperativeRenderer,C:\repos\sq_Fracture\Squared\RenderLib\Convenience.cs,DrawString,The method has 12 parameters. Parameters: glyphSource' text' position' color' scale' sortKey' characterSkipCount' characterLimit' layer' worldSpace' blendState' samplerState
Long Parameter List,Squared.Render.Convenience,ImperativeRenderer,C:\repos\sq_Fracture\Squared\RenderLib\Convenience.cs,FillRectangle,The method has 5 parameters. Parameters: rectangle' fillColor' layer' worldSpace' blendState
Long Parameter List,Squared.Render.Convenience,ImperativeRenderer,C:\repos\sq_Fracture\Squared\RenderLib\Convenience.cs,FillRectangle,The method has 5 parameters. Parameters: bounds' fillColor' layer' worldSpace' blendState
Long Parameter List,Squared.Render.Convenience,ImperativeRenderer,C:\repos\sq_Fracture\Squared\RenderLib\Convenience.cs,OutlineRectangle,The method has 5 parameters. Parameters: rectangle' outlineColor' layer' worldSpace' blendState
Long Parameter List,Squared.Render.Convenience,ImperativeRenderer,C:\repos\sq_Fracture\Squared\RenderLib\Convenience.cs,OutlineRectangle,The method has 5 parameters. Parameters: bounds' outlineColor' layer' worldSpace' blendState
Long Parameter List,Squared.Render.Convenience,ImperativeRenderer,C:\repos\sq_Fracture\Squared\RenderLib\Convenience.cs,DrawLine,The method has 6 parameters. Parameters: start' end' lineColor' layer' worldSpace' blendState
Long Parameter List,Squared.Render.Convenience,ImperativeRenderer,C:\repos\sq_Fracture\Squared\RenderLib\Convenience.cs,DrawLine,The method has 7 parameters. Parameters: start' end' firstColor' secondColor' layer' worldSpace' blendState
Long Parameter List,Squared.Render.Convenience,ImperativeRenderer,C:\repos\sq_Fracture\Squared\RenderLib\Convenience.cs,DrawPoint,The method has 5 parameters. Parameters: position' color' layer' worldSpace' blendState
Long Parameter List,Squared.Render.Convenience,ImperativeRenderer,C:\repos\sq_Fracture\Squared\RenderLib\Convenience.cs,GetBitmapBatch,The method has 5 parameters. Parameters: layer' worldSpace' blendState' samplerState' customMaterial
Long Parameter List,Squared.Render.Convenience,CachedBatch,C:\repos\sq_Fracture\Squared\RenderLib\Convenience.cs,CachedBatch,The method has 10 parameters. Parameters: cbt' container' layer' worldSpace' rasterizerState' depthStencilState' blendState' samplerState' customMaterial' useZBuffer
Long Parameter List,Squared.Render.Convenience,CachedBatches,C:\repos\sq_Fracture\Squared\RenderLib\Convenience.cs,TryGet,The method has 11 parameters. Parameters: result' cbt' container' layer' worldSpace' rasterizerState' depthStencilState' blendState' samplerState' customMaterial' useZBuffer
Long Parameter List,Squared.Render.Convenience,Atlas,C:\repos\sq_Fracture\Squared\RenderLib\Convenience.cs,Atlas,The method has 7 parameters. Parameters: texture' cellWidth' cellHeight' marginLeft' marginTop' marginRight' marginBottom
Long Parameter List,Squared.Render.Convenience,Atlas,C:\repos\sq_Fracture\Squared\RenderLib\Convenience.cs,FromCount,The method has 7 parameters. Parameters: texture' countX' countY' marginLeft' marginTop' marginRight' marginBottom
Long Parameter List,Squared.Render.Convenience,SubRegion,C:\repos\sq_Fracture\Squared\RenderLib\Convenience.cs,SubRegion,The method has 5 parameters. Parameters: atlas' left' top' width' height
Long Parameter List,Squared.Render.Internal,PrimitiveBatch<T>,C:\repos\sq_Fracture\Squared\RenderLib\RenderPrimitives.cs,Initialize,The method has 5 parameters. Parameters: container' layer' material' batchSetup' userData
Long Parameter List,Squared.Render.Internal,PrimitiveBatch<T>,C:\repos\sq_Fracture\Squared\RenderLib\RenderPrimitives.cs,New,The method has 5 parameters. Parameters: container' layer' material' batchSetup' userData
Long Parameter List,Squared.Render.Internal,PrimitiveDrawCall,C:\repos\sq_Fracture\Squared\RenderLib\RenderPrimitives.cs,New,The method has 7 parameters. Parameters: primitiveType' vertices' vertexOffset' vertexCount' indices' indexOffset' primitiveCount
Long Parameter List,Squared.Render.Internal,PrimitiveDrawCall,C:\repos\sq_Fracture\Squared\RenderLib\RenderPrimitives.cs,PrimitiveDrawCall,The method has 10 parameters. Parameters: primitiveType' vertices' vertexOffset' vertexCount' indices' indexOffset' primitiveCount' sortKey' beforeDraw' userData
Long Parameter List,Squared.Render.Internal,NativeBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderPrimitives.cs,Initialize,The method has 6 parameters. Parameters: container' layer' material' batchSetup' batchTeardown' userData
Long Parameter List,Squared.Render.Internal,NativeBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderPrimitives.cs,New,The method has 6 parameters. Parameters: container' layer' material' batchSetup' batchTeardown' userData
Long Parameter List,Squared.Render.Internal,NativeDrawCall,C:\repos\sq_Fracture\Squared\RenderLib\RenderPrimitives.cs,NativeDrawCall,The method has 9 parameters. Parameters: primitiveType' vertexBuffer' vertexOffset' indexBuffer' baseVertex' minVertexIndex' numVertices' startIndex' primitiveCount
Long Parameter List,Squared.Render.Internal,NativeDrawCall,C:\repos\sq_Fracture\Squared\RenderLib\RenderPrimitives.cs,NativeDrawCall,The method has 5 parameters. Parameters: primitiveType' vertexBuffer' vertexOffset' startVertex' primitiveCount
Long Parameter List,Squared.Render.Internal,BufferGenerator<THardwareBuffer;TVertex;TIndex>,C:\repos\sq_Fracture\Squared\RenderLib\BufferGenerator.cs,PrepareToFillBuffer,The method has 6 parameters. Parameters: currentBufferEntry' vertexOffset' indexOffset' additionalVertexCount' additionalIndexCount' forceExclusiveBuffer
Long Parameter List,Squared.Render.Internal,HardwareBufferEntry,C:\repos\sq_Fracture\Squared\RenderLib\BufferGenerator.cs,HardwareBufferEntry,The method has 5 parameters. Parameters: buffer' vertexOffset' indexOffset' sourceVertexCount' sourceIndexCount
Long Parameter List,Squared.Render.Internal,SoftwareBuffer,C:\repos\sq_Fracture\Squared\RenderLib\BufferGenerator.cs,Initialize,The method has 5 parameters. Parameters: vertices' indices' hardwareBuffer' hardwareVertexOffset' hardwareIndexOffset
Long Parameter List,Squared.Render.Internal,XNABufferPair<TVertex>,C:\repos\sq_Fracture\Squared\RenderLib\BufferGenerator.cs,XNABufferPair,The method has 5 parameters. Parameters: graphicsDevice' id' vertexCount' indexCount' disposeResource
Long Parameter List,Squared.Render.Text,StringLayout,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,StringLayout,The method has 6 parameters. Parameters: position' size' lineHeight' firstCharacter' lastCharacter' drawCalls
Long Parameter List,Squared.Render.Text,StringLayoutEngine,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,WrapWord,The method has 6 parameters. Parameters: buffer' firstOffset' firstIndex' lastIndex' effectiveScale' effectiveLineSpacing
Long Parameter List,Squared.Render.Text,SpriteFontExtensions,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,LayoutString,The method has 15 parameters. Parameters: font' text' buffer' position' color' scale' sortKey' characterSkipCount' characterLimit' xOffsetOfFirstLine' lineBreakAtX' alignToPixels' kerningAdjustments' wordWrap' wrapCharacter
Long Parameter List,Squared.Render.Text,SpriteFontExtensions,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,LayoutString,The method has 15 parameters. Parameters: glyphSource' text' buffer' position' color' scale' sortKey' characterSkipCount' characterLimit' xOffsetOfFirstLine' lineBreakAtX' alignToPixels' kerningAdjustments' wordWrap' wrapCharacter
Long Parameter List,Text,StringLayout,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,StringLayout,The method has 6 parameters. Parameters: position' size' lineHeight' firstCharacter' lastCharacter' drawCalls
Long Parameter List,Text,StringLayoutEngine,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,WrapWord,The method has 6 parameters. Parameters: buffer' firstOffset' firstIndex' lastIndex' effectiveScale' effectiveLineSpacing
Long Parameter List,Text,SpriteFontExtensions,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,LayoutString,The method has 15 parameters. Parameters: font' text' buffer' position' color' scale' sortKey' characterSkipCount' characterLimit' xOffsetOfFirstLine' lineBreakAtX' alignToPixels' kerningAdjustments' wordWrap' wrapCharacter
Long Parameter List,Text,SpriteFontExtensions,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,LayoutString,The method has 15 parameters. Parameters: glyphSource' text' buffer' position' color' scale' sortKey' characterSkipCount' characterLimit' xOffsetOfFirstLine' lineBreakAtX' alignToPixels' kerningAdjustments' wordWrap' wrapCharacter
Long Identifier,Squared.Render,DefaultMaterialSet,C:\repos\sq_Fracture\Squared\RenderLib\DefaultMaterialSet.cs,,The length of the parameter ScreenSpaceHorizontalGaussianBlur5Tap is 37.
Long Identifier,Squared.Render,DefaultMaterialSet,C:\repos\sq_Fracture\Squared\RenderLib\DefaultMaterialSet.cs,,The length of the parameter ScreenSpaceVerticalGaussianBlur5Tap is 35.
Long Identifier,Squared.Render,DefaultMaterialSet,C:\repos\sq_Fracture\Squared\RenderLib\DefaultMaterialSet.cs,,The length of the parameter WorldSpaceHorizontalGaussianBlur5Tap is 36.
Long Identifier,Squared.Render,DefaultMaterialSet,C:\repos\sq_Fracture\Squared\RenderLib\DefaultMaterialSet.cs,,The length of the parameter WorldSpaceVerticalGaussianBlur5Tap is 34.
Long Identifier,Squared.Render,RenderCoordinator,C:\repos\sq_Fracture\Squared\RenderLib\ThreadedRenderCoordinator.cs,,The length of the parameter _SynchronousDrawFinishedSignal is 30.
Long Identifier,Squared.Render.Convenience,RenderStates,C:\repos\sq_Fracture\Squared\RenderLib\Convenience.cs,,The length of the parameter SubtractiveBlendNonPremultiplied is 32.
Long Identifier,Squared.Render.Internal,BufferGenerator<THardwareBuffer;TVertex;TIndex>,C:\repos\sq_Fracture\Squared\RenderLib\BufferGenerator.cs,,The length of the parameter MaxSoftwareBuffersPerHardwareBuffer is 35.
Long Statement,Squared.Render,ViewTransform,C:\repos\sq_Fracture\Squared\RenderLib\DefaultMaterialSet.cs,CreateOrthographic,The length of the statement  "            return CreateOrthographic(viewport.X' viewport.Y' viewport.Width' viewport.Height' viewport.MinDepth' viewport.MaxDepth); " is 121.
Long Statement,Squared.Render,ViewTransform,C:\repos\sq_Fracture\Squared\RenderLib\DefaultMaterialSet.cs,CreateOrthographic,The length of the statement  "                Projection = Matrix.CreateOrthographicOffCenter(offsetX' width + offsetX2' height + offsetY2' offsetY' zNearPlane' zFarPlane)' " is 126.
Long Statement,Squared.Render,NativeBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,Issue,The length of the statement  "                        device.DrawIndexedPrimitives(call.PrimitiveType' call.BaseVertex' call.MinVertexIndex' call.NumVertices' call.StartIndex' call.PrimitiveCount); " is 143.
Long Statement,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,Add,The length of the statement  "                throw new InternalBufferOverflowException("This GeometryBatch contains too many primitives. Split your primitives into multiple batches."); " is 139.
Long Statement,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,Issue,The length of the statement  "                        manager.Device.DrawIndexedPrimitives(da.PrimitiveType' 0' da.VertexOffset' da.VertexCount' da.IndexOffset' da.PrimitiveCount); " is 126.
Long Statement,Squared.Render,PrimitiveBatch<T>,C:\repos\sq_Fracture\Squared\RenderLib\RenderPrimitives.cs,Issue,The length of the statement  "                            call.PrimitiveType' call.Vertices' call.VertexOffset' call.VertexCount' call.Indices' call.IndexOffset' call.PrimitiveCount " is 123.
Long Statement,Squared.Render,StringLayoutEngine,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,AppendText,The length of the statement  "                        WrapWord(buffer' wordStartOffset' wordStartWritePosition' bufferWritePosition - 1' effectiveScale' effectiveLineSpacing); " is 121.
Long Statement,Squared.Render.Convenience,ImperativeRenderer,C:\repos\sq_Fracture\Squared\RenderLib\Convenience.cs,Draw,The length of the statement  "                        material = Materials.GetBitmapMaterial(worldSpace ?? WorldSpace' RasterizerState' DepthStencilState' blendState ?? BlendState); " is 127.
Long Statement,Squared.Render.Convenience,ImperativeRenderer,C:\repos\sq_Fracture\Squared\RenderLib\Convenience.cs,Draw,The length of the statement  "            Draw(ref drawCall' layer: layer' worldSpace: worldSpace' blendState: blendState' samplerState: samplerState' material: material); " is 129.
Long Statement,Squared.Render.Convenience,ImperativeRenderer,C:\repos\sq_Fracture\Squared\RenderLib\Convenience.cs,Draw,The length of the statement  "            Draw(ref drawCall' layer: layer' worldSpace: worldSpace' blendState: blendState' samplerState: samplerState' material: material); " is 129.
Long Statement,Squared.Render.Convenience,ImperativeRenderer,C:\repos\sq_Fracture\Squared\RenderLib\Convenience.cs,DrawMultiple,The length of the statement  "                        material = Materials.GetBitmapMaterial(worldSpace ?? WorldSpace' RasterizerState' DepthStencilState' blendState ?? BlendState); " is 127.
Long Statement,Squared.Render.Internal,PrimitiveBatch<T>,C:\repos\sq_Fracture\Squared\RenderLib\RenderPrimitives.cs,Issue,The length of the statement  "                            call.PrimitiveType' call.Vertices' call.VertexOffset' call.VertexCount' call.Indices' call.IndexOffset' call.PrimitiveCount " is 123.
Long Statement,Squared.Render.Internal,NativeBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderPrimitives.cs,Issue,The length of the statement  "                        device.DrawIndexedPrimitives(call.PrimitiveType' call.BaseVertex' call.MinVertexIndex' call.NumVertices' call.StartIndex' call.PrimitiveCount); " is 143.
Long Statement,Squared.Render.Internal,BufferGenerator<THardwareBuffer;TVertex;TIndex>,C:\repos\sq_Fracture\Squared\RenderLib\BufferGenerator.cs,Allocate,The length of the statement  "                throw new ArgumentOutOfRangeException("vertexCount"' vertexCount' "Maximum vertex count on this platform is " + MaxVerticesPerHardwareBuffer); " is 142.
Long Statement,Squared.Render.Internal,BufferGenerator<THardwareBuffer;TVertex;TIndex>,C:\repos\sq_Fracture\Squared\RenderLib\BufferGenerator.cs,Allocate,The length of the statement  "                // This is because while Allocate is thread-safe' consumers are allowed to write to their allocations without synchronization' " is 126.
Long Statement,Squared.Render.Internal,BufferGenerator<THardwareBuffer;TVertex;TIndex>,C:\repos\sq_Fracture\Squared\RenderLib\BufferGenerator.cs,Allocate,The length of the statement  "                // Flush() is responsible for doing all these copies to ensure that all vertex data eventually makes it into the large array " is 124.
Long Statement,Squared.Render.Text,StringLayoutEngine,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,AppendText,The length of the statement  "                        WrapWord(buffer' wordStartOffset' wordStartWritePosition' bufferWritePosition - 1' effectiveScale' effectiveLineSpacing); " is 121.
Long Statement,Text,StringLayoutEngine,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,AppendText,The length of the statement  "                        WrapWord(buffer' wordStartOffset' wordStartWritePosition' bufferWritePosition - 1' effectiveScale' effectiveLineSpacing); " is 121.
Complex Conditional,Squared.Render,MultimaterialBitmapBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,Prepare,The conditional expression  "(currentBatch == null) ||                      (currentBatch.Material != material) ||                      (currentBatch.SamplerState != ss1) ||                      (currentBatch.SamplerState2 != ss2)"  is complex.
Virtual Method Call from Constructor,Squared.Render,ActiveMaterial,C:\repos\sq_Fracture\Squared\RenderLib\RenderManager.cs,ActiveMaterial,The constructor "ActiveMaterial" calls a virtual method "End".
Virtual Method Call from Constructor,Squared.Render,ActiveMaterial,C:\repos\sq_Fracture\Squared\RenderLib\RenderManager.cs,ActiveMaterial,The constructor "ActiveMaterial" calls a virtual method "Begin".
Virtual Method Call from Constructor,Squared.Render,ActiveMaterial,C:\repos\sq_Fracture\Squared\RenderLib\RenderManager.cs,ActiveMaterial,The constructor "ActiveMaterial" calls a virtual method "Flush".
Empty Catch Block,Squared.Render,RenderCoordinator,C:\repos\sq_Fracture\Squared\RenderLib\ThreadedRenderCoordinator.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Squared.Render,RenderCoordinator,C:\repos\sq_Fracture\Squared\RenderLib\ThreadedRenderCoordinator.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Squared.Render,RenderCoordinator,C:\repos\sq_Fracture\Squared\RenderLib\ThreadedRenderCoordinator.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Squared.Render,RenderCoordinator,C:\repos\sq_Fracture\Squared\RenderLib\ThreadedRenderCoordinator.cs,FlushDisposeList,The method has an empty catch block.
Magic Number,Squared.Render,DefaultMaterialSet,C:\repos\sq_Fracture\Squared\RenderLib\DefaultMaterialSet.cs,DefaultMaterialSet,The following statement contains a magic number: ScreenSpaceShadowedBitmap.Parameters.ShadowOffset.SetValue(new Vector2(2' 2));
Magic Number,Squared.Render,DefaultMaterialSet,C:\repos\sq_Fracture\Squared\RenderLib\DefaultMaterialSet.cs,DefaultMaterialSet,The following statement contains a magic number: ScreenSpaceShadowedBitmap.Parameters.ShadowOffset.SetValue(new Vector2(2' 2));
Magic Number,Squared.Render,DefaultMaterialSet,C:\repos\sq_Fracture\Squared\RenderLib\DefaultMaterialSet.cs,DefaultMaterialSet,The following statement contains a magic number: WorldSpaceShadowedBitmap.Parameters.ShadowOffset.SetValue(new Vector2(2' 2));
Magic Number,Squared.Render,DefaultMaterialSet,C:\repos\sq_Fracture\Squared\RenderLib\DefaultMaterialSet.cs,DefaultMaterialSet,The following statement contains a magic number: WorldSpaceShadowedBitmap.Parameters.ShadowOffset.SetValue(new Vector2(2' 2));
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,ToLinear,The following statement contains a magic number: double fv = v / 255.0;
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,ToLinear,The following statement contains a magic number: if (fv < 0.04045)                  return fv / 12.92;              else                  return Math.Pow((fv + 0.055) / 1.055' 2.4);
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,ToLinear,The following statement contains a magic number: if (fv < 0.04045)                  return fv / 12.92;              else                  return Math.Pow((fv + 0.055) / 1.055' 2.4);
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,ToLinear,The following statement contains a magic number: if (fv < 0.04045)                  return fv / 12.92;              else                  return Math.Pow((fv + 0.055) / 1.055' 2.4);
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,ToLinear,The following statement contains a magic number: if (fv < 0.04045)                  return fv / 12.92;              else                  return Math.Pow((fv + 0.055) / 1.055' 2.4);
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,ToLinear,The following statement contains a magic number: if (fv < 0.04045)                  return fv / 12.92;              else                  return Math.Pow((fv + 0.055) / 1.055' 2.4);
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,FromLinear,The following statement contains a magic number: if (v <= 0.0031308)  		        scaled = 12.92 * v;  	        else                  scaled = (Math.Pow(v' 1.0 / 2.4) - 0.055) * 1.055;
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,FromLinear,The following statement contains a magic number: if (v <= 0.0031308)  		        scaled = 12.92 * v;  	        else                  scaled = (Math.Pow(v' 1.0 / 2.4) - 0.055) * 1.055;
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,FromLinear,The following statement contains a magic number: if (v <= 0.0031308)  		        scaled = 12.92 * v;  	        else                  scaled = (Math.Pow(v' 1.0 / 2.4) - 0.055) * 1.055;
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,FromLinear,The following statement contains a magic number: if (v <= 0.0031308)  		        scaled = 12.92 * v;  	        else                  scaled = (Math.Pow(v' 1.0 / 2.4) - 0.055) * 1.055;
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,FromLinear,The following statement contains a magic number: if (v <= 0.0031308)  		        scaled = 12.92 * v;  	        else                  scaled = (Math.Pow(v' 1.0 / 2.4) - 0.055) * 1.055;
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,FromLinear,The following statement contains a magic number: return (byte)(scaled * 255.0);
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,Average_sRGB,The following statement contains a magic number: return FromLinear(sum / 4);
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,Color,The following statement contains a magic number: var destWidth = srcWidth / 2;
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,Color,The following statement contains a magic number: var destHeight = srcHeight / 2;
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,Color,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = (byte)((a[0] + b[0] + c[0] + d[0]) / 4);                          result[1] = (byte)((a[1] + b[1] + c[1] + d[1]) / 4);                          result[2] = (byte)((a[2] + b[2] + c[2] + d[2]) / 4);                          result[3] = (byte)((a[3] + b[3] + c[3] + d[3]) / 4);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,Color,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = (byte)((a[0] + b[0] + c[0] + d[0]) / 4);                          result[1] = (byte)((a[1] + b[1] + c[1] + d[1]) / 4);                          result[2] = (byte)((a[2] + b[2] + c[2] + d[2]) / 4);                          result[3] = (byte)((a[3] + b[3] + c[3] + d[3]) / 4);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,Color,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = (byte)((a[0] + b[0] + c[0] + d[0]) / 4);                          result[1] = (byte)((a[1] + b[1] + c[1] + d[1]) / 4);                          result[2] = (byte)((a[2] + b[2] + c[2] + d[2]) / 4);                          result[3] = (byte)((a[3] + b[3] + c[3] + d[3]) / 4);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,Color,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = (byte)((a[0] + b[0] + c[0] + d[0]) / 4);                          result[1] = (byte)((a[1] + b[1] + c[1] + d[1]) / 4);                          result[2] = (byte)((a[2] + b[2] + c[2] + d[2]) / 4);                          result[3] = (byte)((a[3] + b[3] + c[3] + d[3]) / 4);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,Color,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = (byte)((a[0] + b[0] + c[0] + d[0]) / 4);                          result[1] = (byte)((a[1] + b[1] + c[1] + d[1]) / 4);                          result[2] = (byte)((a[2] + b[2] + c[2] + d[2]) / 4);                          result[3] = (byte)((a[3] + b[3] + c[3] + d[3]) / 4);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,Color,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = (byte)((a[0] + b[0] + c[0] + d[0]) / 4);                          result[1] = (byte)((a[1] + b[1] + c[1] + d[1]) / 4);                          result[2] = (byte)((a[2] + b[2] + c[2] + d[2]) / 4);                          result[3] = (byte)((a[3] + b[3] + c[3] + d[3]) / 4);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,Color,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = (byte)((a[0] + b[0] + c[0] + d[0]) / 4);                          result[1] = (byte)((a[1] + b[1] + c[1] + d[1]) / 4);                          result[2] = (byte)((a[2] + b[2] + c[2] + d[2]) / 4);                          result[3] = (byte)((a[3] + b[3] + c[3] + d[3]) / 4);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,Color,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = (byte)((a[0] + b[0] + c[0] + d[0]) / 4);                          result[1] = (byte)((a[1] + b[1] + c[1] + d[1]) / 4);                          result[2] = (byte)((a[2] + b[2] + c[2] + d[2]) / 4);                          result[3] = (byte)((a[3] + b[3] + c[3] + d[3]) / 4);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,Color,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = (byte)((a[0] + b[0] + c[0] + d[0]) / 4);                          result[1] = (byte)((a[1] + b[1] + c[1] + d[1]) / 4);                          result[2] = (byte)((a[2] + b[2] + c[2] + d[2]) / 4);                          result[3] = (byte)((a[3] + b[3] + c[3] + d[3]) / 4);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,Color,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = (byte)((a[0] + b[0] + c[0] + d[0]) / 4);                          result[1] = (byte)((a[1] + b[1] + c[1] + d[1]) / 4);                          result[2] = (byte)((a[2] + b[2] + c[2] + d[2]) / 4);                          result[3] = (byte)((a[3] + b[3] + c[3] + d[3]) / 4);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,Color,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = (byte)((a[0] + b[0] + c[0] + d[0]) / 4);                          result[1] = (byte)((a[1] + b[1] + c[1] + d[1]) / 4);                          result[2] = (byte)((a[2] + b[2] + c[2] + d[2]) / 4);                          result[3] = (byte)((a[3] + b[3] + c[3] + d[3]) / 4);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,Color,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = (byte)((a[0] + b[0] + c[0] + d[0]) / 4);                          result[1] = (byte)((a[1] + b[1] + c[1] + d[1]) / 4);                          result[2] = (byte)((a[2] + b[2] + c[2] + d[2]) / 4);                          result[3] = (byte)((a[3] + b[3] + c[3] + d[3]) / 4);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,Color,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = (byte)((a[0] + b[0] + c[0] + d[0]) / 4);                          result[1] = (byte)((a[1] + b[1] + c[1] + d[1]) / 4);                          result[2] = (byte)((a[2] + b[2] + c[2] + d[2]) / 4);                          result[3] = (byte)((a[3] + b[3] + c[3] + d[3]) / 4);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,Color,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = (byte)((a[0] + b[0] + c[0] + d[0]) / 4);                          result[1] = (byte)((a[1] + b[1] + c[1] + d[1]) / 4);                          result[2] = (byte)((a[2] + b[2] + c[2] + d[2]) / 4);                          result[3] = (byte)((a[3] + b[3] + c[3] + d[3]) / 4);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,Color,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = (byte)((a[0] + b[0] + c[0] + d[0]) / 4);                          result[1] = (byte)((a[1] + b[1] + c[1] + d[1]) / 4);                          result[2] = (byte)((a[2] + b[2] + c[2] + d[2]) / 4);                          result[3] = (byte)((a[3] + b[3] + c[3] + d[3]) / 4);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,Color,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = (byte)((a[0] + b[0] + c[0] + d[0]) / 4);                          result[1] = (byte)((a[1] + b[1] + c[1] + d[1]) / 4);                          result[2] = (byte)((a[2] + b[2] + c[2] + d[2]) / 4);                          result[3] = (byte)((a[3] + b[3] + c[3] + d[3]) / 4);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,Color,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = (byte)((a[0] + b[0] + c[0] + d[0]) / 4);                          result[1] = (byte)((a[1] + b[1] + c[1] + d[1]) / 4);                          result[2] = (byte)((a[2] + b[2] + c[2] + d[2]) / 4);                          result[3] = (byte)((a[3] + b[3] + c[3] + d[3]) / 4);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,Color,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = (byte)((a[0] + b[0] + c[0] + d[0]) / 4);                          result[1] = (byte)((a[1] + b[1] + c[1] + d[1]) / 4);                          result[2] = (byte)((a[2] + b[2] + c[2] + d[2]) / 4);                          result[3] = (byte)((a[3] + b[3] + c[3] + d[3]) / 4);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,Color,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = (byte)((a[0] + b[0] + c[0] + d[0]) / 4);                          result[1] = (byte)((a[1] + b[1] + c[1] + d[1]) / 4);                          result[2] = (byte)((a[2] + b[2] + c[2] + d[2]) / 4);                          result[3] = (byte)((a[3] + b[3] + c[3] + d[3]) / 4);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,Color,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = (byte)((a[0] + b[0] + c[0] + d[0]) / 4);                          result[1] = (byte)((a[1] + b[1] + c[1] + d[1]) / 4);                          result[2] = (byte)((a[2] + b[2] + c[2] + d[2]) / 4);                          result[3] = (byte)((a[3] + b[3] + c[3] + d[3]) / 4);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,Color,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = (byte)((a[0] + b[0] + c[0] + d[0]) / 4);                          result[1] = (byte)((a[1] + b[1] + c[1] + d[1]) / 4);                          result[2] = (byte)((a[2] + b[2] + c[2] + d[2]) / 4);                          result[3] = (byte)((a[3] + b[3] + c[3] + d[3]) / 4);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,sRGBColor,The following statement contains a magic number: var destWidth = srcWidth / 2;
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,sRGBColor,The following statement contains a magic number: var destHeight = srcHeight / 2;
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,sRGBColor,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = Average_sRGB(a[0]' b[0]' c[0]' d[0]);                          result[1] = Average_sRGB(a[1]' b[1]' c[1]' d[1]);                          result[2] = Average_sRGB(a[2]' b[2]' c[2]' d[2]);                          result[3] = Average_sRGB(a[3]' b[3]' c[3]' d[3]);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,sRGBColor,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = Average_sRGB(a[0]' b[0]' c[0]' d[0]);                          result[1] = Average_sRGB(a[1]' b[1]' c[1]' d[1]);                          result[2] = Average_sRGB(a[2]' b[2]' c[2]' d[2]);                          result[3] = Average_sRGB(a[3]' b[3]' c[3]' d[3]);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,sRGBColor,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = Average_sRGB(a[0]' b[0]' c[0]' d[0]);                          result[1] = Average_sRGB(a[1]' b[1]' c[1]' d[1]);                          result[2] = Average_sRGB(a[2]' b[2]' c[2]' d[2]);                          result[3] = Average_sRGB(a[3]' b[3]' c[3]' d[3]);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,sRGBColor,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = Average_sRGB(a[0]' b[0]' c[0]' d[0]);                          result[1] = Average_sRGB(a[1]' b[1]' c[1]' d[1]);                          result[2] = Average_sRGB(a[2]' b[2]' c[2]' d[2]);                          result[3] = Average_sRGB(a[3]' b[3]' c[3]' d[3]);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,sRGBColor,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = Average_sRGB(a[0]' b[0]' c[0]' d[0]);                          result[1] = Average_sRGB(a[1]' b[1]' c[1]' d[1]);                          result[2] = Average_sRGB(a[2]' b[2]' c[2]' d[2]);                          result[3] = Average_sRGB(a[3]' b[3]' c[3]' d[3]);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,sRGBColor,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = Average_sRGB(a[0]' b[0]' c[0]' d[0]);                          result[1] = Average_sRGB(a[1]' b[1]' c[1]' d[1]);                          result[2] = Average_sRGB(a[2]' b[2]' c[2]' d[2]);                          result[3] = Average_sRGB(a[3]' b[3]' c[3]' d[3]);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,sRGBColor,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = Average_sRGB(a[0]' b[0]' c[0]' d[0]);                          result[1] = Average_sRGB(a[1]' b[1]' c[1]' d[1]);                          result[2] = Average_sRGB(a[2]' b[2]' c[2]' d[2]);                          result[3] = Average_sRGB(a[3]' b[3]' c[3]' d[3]);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,sRGBColor,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = Average_sRGB(a[0]' b[0]' c[0]' d[0]);                          result[1] = Average_sRGB(a[1]' b[1]' c[1]' d[1]);                          result[2] = Average_sRGB(a[2]' b[2]' c[2]' d[2]);                          result[3] = Average_sRGB(a[3]' b[3]' c[3]' d[3]);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,sRGBColor,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = Average_sRGB(a[0]' b[0]' c[0]' d[0]);                          result[1] = Average_sRGB(a[1]' b[1]' c[1]' d[1]);                          result[2] = Average_sRGB(a[2]' b[2]' c[2]' d[2]);                          result[3] = Average_sRGB(a[3]' b[3]' c[3]' d[3]);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,sRGBColor,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = Average_sRGB(a[0]' b[0]' c[0]' d[0]);                          result[1] = Average_sRGB(a[1]' b[1]' c[1]' d[1]);                          result[2] = Average_sRGB(a[2]' b[2]' c[2]' d[2]);                          result[3] = Average_sRGB(a[3]' b[3]' c[3]' d[3]);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,sRGBColor,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = Average_sRGB(a[0]' b[0]' c[0]' d[0]);                          result[1] = Average_sRGB(a[1]' b[1]' c[1]' d[1]);                          result[2] = Average_sRGB(a[2]' b[2]' c[2]' d[2]);                          result[3] = Average_sRGB(a[3]' b[3]' c[3]' d[3]);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,sRGBColor,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = Average_sRGB(a[0]' b[0]' c[0]' d[0]);                          result[1] = Average_sRGB(a[1]' b[1]' c[1]' d[1]);                          result[2] = Average_sRGB(a[2]' b[2]' c[2]' d[2]);                          result[3] = Average_sRGB(a[3]' b[3]' c[3]' d[3]);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,sRGBColor,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = Average_sRGB(a[0]' b[0]' c[0]' d[0]);                          result[1] = Average_sRGB(a[1]' b[1]' c[1]' d[1]);                          result[2] = Average_sRGB(a[2]' b[2]' c[2]' d[2]);                          result[3] = Average_sRGB(a[3]' b[3]' c[3]' d[3]);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,sRGBColor,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = Average_sRGB(a[0]' b[0]' c[0]' d[0]);                          result[1] = Average_sRGB(a[1]' b[1]' c[1]' d[1]);                          result[2] = Average_sRGB(a[2]' b[2]' c[2]' d[2]);                          result[3] = Average_sRGB(a[3]' b[3]' c[3]' d[3]);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,sRGBColor,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = Average_sRGB(a[0]' b[0]' c[0]' d[0]);                          result[1] = Average_sRGB(a[1]' b[1]' c[1]' d[1]);                          result[2] = Average_sRGB(a[2]' b[2]' c[2]' d[2]);                          result[3] = Average_sRGB(a[3]' b[3]' c[3]' d[3]);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,sRGBColor,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = Average_sRGB(a[0]' b[0]' c[0]' d[0]);                          result[1] = Average_sRGB(a[1]' b[1]' c[1]' d[1]);                          result[2] = Average_sRGB(a[2]' b[2]' c[2]' d[2]);                          result[3] = Average_sRGB(a[3]' b[3]' c[3]' d[3]);                      }                  }              }
Magic Number,Squared.Render,MipGenerator,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,sRGBColor,The following statement contains a magic number: fixed (Color* pSrcColor = src' pDestColor = dest) {                  byte* pSrc = (byte*)pSrcColor' pDest = (byte*)pDestColor;                  var srcRowSize = srcWidth * 4;                                for (var y = 0; y < destHeight; y++) {                      byte* srcRow = pSrc + ((y * 2) * srcRowSize);                      byte* destRow = pDest + (y * destWidth * 4);                        for (var x = 0; x < destWidth; x++) {                          var a = srcRow + ((x * 2) * 4);                          var b = a + 4;                          var c = a + srcRowSize;                          var d = b + srcRowSize;                            var result = destRow + (x * 4);                          result[0] = Average_sRGB(a[0]' b[0]' c[0]' d[0]);                          result[1] = Average_sRGB(a[1]' b[1]' c[1]' d[1]);                          result[2] = Average_sRGB(a[2]' b[2]' c[2]' d[2]);                          result[3] = Average_sRGB(a[3]' b[3]' c[3]' d[3]);                      }                  }              }
Magic Number,Squared.Render,DynamicAtlas<T>,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,DynamicAtlas,The following statement contains a magic number: if (mipGenerator != null)                  MipBuffer = new T[(width / 2) * (height / 2)];
Magic Number,Squared.Render,DynamicAtlas<T>,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,DynamicAtlas,The following statement contains a magic number: if (mipGenerator != null)                  MipBuffer = new T[(width / 2) * (height / 2)];
Magic Number,Squared.Render,DynamicAtlas<T>,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,GenerateMips,The following statement contains a magic number: for (var i = 1; i < MipLevelCount; i++) {                  var destWidth = srcWidth / 2;                  var destHeight = srcHeight / 2;                    GenerateMip(srcBuffer' srcWidth' srcHeight' MipBuffer);                  lock (Coordinator.UseResourceLock)                      Texture.SetData(i' null' MipBuffer' 0' destWidth * destHeight);                    srcBuffer = MipBuffer;                  srcWidth = destWidth;                  srcHeight = destHeight;              }
Magic Number,Squared.Render,DynamicAtlas<T>,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,GenerateMips,The following statement contains a magic number: for (var i = 1; i < MipLevelCount; i++) {                  var destWidth = srcWidth / 2;                  var destHeight = srcHeight / 2;                    GenerateMip(srcBuffer' srcWidth' srcHeight' MipBuffer);                  lock (Coordinator.UseResourceLock)                      Texture.SetData(i' null' MipBuffer' 0' destWidth * destHeight);                    srcBuffer = MipBuffer;                  srcWidth = destWidth;                  srcHeight = destHeight;              }
Magic Number,Squared.Render,Reservation,C:\repos\sq_Fracture\Squared\RenderLib\DynamicAtlas.cs,Reservation,The following statement contains a magic number: if (CaptureStackTraces)                      Stack = new StackTrace(2' true);                  else                      Stack = null;
Magic Number,Squared.Render,UniformBindingKey,C:\repos\sq_Fracture\Squared\RenderLib\MaterialSet.cs,UniformBindingKey,The following statement contains a magic number: HashCode = Type.GetHashCode() ^                       (Effect.GetHashCode() << 4) ^                      (UniformName.GetHashCode() << 8);
Magic Number,Squared.Render,UniformBindingKey,C:\repos\sq_Fracture\Squared\RenderLib\MaterialSet.cs,UniformBindingKey,The following statement contains a magic number: HashCode = Type.GetHashCode() ^                       (Effect.GetHashCode() << 4) ^                      (UniformName.GetHashCode() << 8);
Magic Number,Squared.Render,BaseObjectPool<T>,C:\repos\sq_Fracture\Squared\RenderLib\Pools.cs,BaseObjectPool,The following statement contains a magic number: _Pool = new UnorderedList<T>(Math.Max(poolCapacity / 2' 64));
Magic Number,Squared.Render,BaseObjectPool<T>,C:\repos\sq_Fracture\Squared\RenderLib\Pools.cs,BaseObjectPool,The following statement contains a magic number: _Pool = new UnorderedList<T>(Math.Max(poolCapacity / 2' 64));
Magic Number,Squared.Render,ArrayPoolAllocator<T>,C:\repos\sq_Fracture\Squared\RenderLib\Pools.cs,IntLog2,The following statement contains a magic number: if (x >= 1 << 16) {                  x >>= 16;                  l |= 16;              }
Magic Number,Squared.Render,ArrayPoolAllocator<T>,C:\repos\sq_Fracture\Squared\RenderLib\Pools.cs,IntLog2,The following statement contains a magic number: if (x >= 1 << 16) {                  x >>= 16;                  l |= 16;              }
Magic Number,Squared.Render,ArrayPoolAllocator<T>,C:\repos\sq_Fracture\Squared\RenderLib\Pools.cs,IntLog2,The following statement contains a magic number: if (x >= 1 << 16) {                  x >>= 16;                  l |= 16;              }
Magic Number,Squared.Render,ArrayPoolAllocator<T>,C:\repos\sq_Fracture\Squared\RenderLib\Pools.cs,IntLog2,The following statement contains a magic number: if (x >= 1 << 8) {                  x >>= 8;                  l |= 8;              }
Magic Number,Squared.Render,ArrayPoolAllocator<T>,C:\repos\sq_Fracture\Squared\RenderLib\Pools.cs,IntLog2,The following statement contains a magic number: if (x >= 1 << 8) {                  x >>= 8;                  l |= 8;              }
Magic Number,Squared.Render,ArrayPoolAllocator<T>,C:\repos\sq_Fracture\Squared\RenderLib\Pools.cs,IntLog2,The following statement contains a magic number: if (x >= 1 << 8) {                  x >>= 8;                  l |= 8;              }
Magic Number,Squared.Render,ArrayPoolAllocator<T>,C:\repos\sq_Fracture\Squared\RenderLib\Pools.cs,IntLog2,The following statement contains a magic number: if (x >= 1 << 4) {                  x >>= 4;                  l |= 4;              }
Magic Number,Squared.Render,ArrayPoolAllocator<T>,C:\repos\sq_Fracture\Squared\RenderLib\Pools.cs,IntLog2,The following statement contains a magic number: if (x >= 1 << 4) {                  x >>= 4;                  l |= 4;              }
Magic Number,Squared.Render,ArrayPoolAllocator<T>,C:\repos\sq_Fracture\Squared\RenderLib\Pools.cs,IntLog2,The following statement contains a magic number: if (x >= 1 << 4) {                  x >>= 4;                  l |= 4;              }
Magic Number,Squared.Render,ArrayPoolAllocator<T>,C:\repos\sq_Fracture\Squared\RenderLib\Pools.cs,IntLog2,The following statement contains a magic number: if (x >= 1 << 2) {                  x >>= 2;                  l |= 2;              }
Magic Number,Squared.Render,ArrayPoolAllocator<T>,C:\repos\sq_Fracture\Squared\RenderLib\Pools.cs,IntLog2,The following statement contains a magic number: if (x >= 1 << 2) {                  x >>= 2;                  l |= 2;              }
Magic Number,Squared.Render,ArrayPoolAllocator<T>,C:\repos\sq_Fracture\Squared\RenderLib\Pools.cs,IntLog2,The following statement contains a magic number: if (x >= 1 << 2) {                  x >>= 2;                  l |= 2;              }
Magic Number,Squared.Render,BitmapVertex,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,BitmapVertex,The following statement contains a magic number: Elements = new VertexElement[] {                  new VertexElement( Marshal.OffsetOf(tThis' "Position").ToInt32()'                       VertexElementFormat.Vector3' VertexElementUsage.Position' 0 )'                  // TextureRegion                  new VertexElement( Marshal.OffsetOf(tThis' "TextureTopLeft").ToInt32()'                       VertexElementFormat.Vector4' VertexElementUsage.Position' 1 )'                  // ScaleOrigin                  new VertexElement( Marshal.OffsetOf(tThis' "Scale").ToInt32()'                       VertexElementFormat.Vector4' VertexElementUsage.Position' 2 )'                  new VertexElement( Marshal.OffsetOf(tThis' "Rotation").ToInt32()'                       VertexElementFormat.Single' VertexElementUsage.Position' 3 )'                  new VertexElement( Marshal.OffsetOf(tThis' "MultiplyColor").ToInt32()'                       VertexElementFormat.Color' VertexElementUsage.Color' 0 )'                  new VertexElement( Marshal.OffsetOf(tThis' "AddColor").ToInt32()'                       VertexElementFormat.Color' VertexElementUsage.Color' 1 )'                  new VertexElement( Marshal.OffsetOf(tThis' "Corner").ToInt32()'                       VertexElementFormat.Short2' VertexElementUsage.BlendIndices' 0 )              };
Magic Number,Squared.Render,BitmapVertex,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,BitmapVertex,The following statement contains a magic number: Elements = new VertexElement[] {                  new VertexElement( Marshal.OffsetOf(tThis' "Position").ToInt32()'                       VertexElementFormat.Vector3' VertexElementUsage.Position' 0 )'                  // TextureRegion                  new VertexElement( Marshal.OffsetOf(tThis' "TextureTopLeft").ToInt32()'                       VertexElementFormat.Vector4' VertexElementUsage.Position' 1 )'                  // ScaleOrigin                  new VertexElement( Marshal.OffsetOf(tThis' "Scale").ToInt32()'                       VertexElementFormat.Vector4' VertexElementUsage.Position' 2 )'                  new VertexElement( Marshal.OffsetOf(tThis' "Rotation").ToInt32()'                       VertexElementFormat.Single' VertexElementUsage.Position' 3 )'                  new VertexElement( Marshal.OffsetOf(tThis' "MultiplyColor").ToInt32()'                       VertexElementFormat.Color' VertexElementUsage.Color' 0 )'                  new VertexElement( Marshal.OffsetOf(tThis' "AddColor").ToInt32()'                       VertexElementFormat.Color' VertexElementUsage.Color' 1 )'                  new VertexElement( Marshal.OffsetOf(tThis' "Corner").ToInt32()'                       VertexElementFormat.Short2' VertexElementUsage.BlendIndices' 0 )              };
Magic Number,Squared.Render,BitmapBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,FillOneSoftwareBuffer,The following statement contains a magic number: int nativeBatchSizeLimit = NativeBatchSize * 4;
Magic Number,Squared.Render,BitmapBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,FillOneSoftwareBuffer,The following statement contains a magic number: var remainingVertices = remainingDrawCalls * 4;
Magic Number,Squared.Render,BitmapBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,FillOneSoftwareBuffer,The following statement contains a magic number: var softwareBuffer = _BufferGenerator.Allocate(nativeBatchSize' (nativeBatchSize / 4) * 6);
Magic Number,Squared.Render,BitmapBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,FillOneSoftwareBuffer,The following statement contains a magic number: var softwareBuffer = _BufferGenerator.Allocate(nativeBatchSize' (nativeBatchSize / 4) * 6);
Magic Number,Squared.Render,BitmapBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,FillOneSoftwareBuffer,The following statement contains a magic number: fixed (BitmapVertex* pVertices = &softwareBuffer.Vertices.Array[softwareBuffer.Vertices.Offset])              fixed (ushort* pIndices = &softwareBuffer.Indices.Array[softwareBuffer.Indices.Offset])                  for (int i = drawCallsPrepared; i < count; i++) {                      if (totalVertCount >= nativeBatchSizeLimit)                          break;                        var call = drawCalls[i];                      if (!call.IsValid)                          throw new InvalidDataException("Invalid draw call");                        bool texturesEqual = call.Textures.Equals(ref currentTextures);                        if (!texturesEqual) {                          if (vertCount > 0) {                              _NativeBatches.Add(new NativeBatch(                                  softwareBuffer' currentTextures'                                  indexOffset'                                  vertOffset'                                  vertCount                              ));                                indexOffset += indexCount;                              vertOffset += vertCount;                              indexCount = 0;                              vertCount = 0;                          }                            currentTextures = call.Textures;                      }                        vertex.Position.X = call.Position.X;                      vertex.Position.Y = call.Position.Y;                      vertex.Position.Z = call.SortKey.Order * zBufferFactor;                      var tr = call.TextureRegion;                      vertex.TextureTopLeft = tr.TopLeft;                      vertex.TextureBottomRight = tr.BottomRight;                      vertex.MultiplyColor = call.MultiplyColor;                      vertex.AddColor = call.AddColor;                      vertex.Scale = call.Scale;                      vertex.Origin = call.Origin;                      vertex.Rotation = call.Rotation;                        for (var j = 0; j < 6; j++)                          pIndices[indexWritePosition + j] = (ushort)(indexBase + QuadIndices[j]);                        indexWritePosition += 6;                        for (short j = 0; j < 4; j++) {                          vertex.Unused = vertex.Corner = j;                          pVertices[vertexWritePosition + j] = vertex;                      }                        vertexWritePosition += 4;                      indexBase += 4;                        totalVertCount += 4;                      vertCount += 4;                      indexCount += 6;                        drawCallsPrepared += 1;                  }
Magic Number,Squared.Render,BitmapBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,FillOneSoftwareBuffer,The following statement contains a magic number: fixed (BitmapVertex* pVertices = &softwareBuffer.Vertices.Array[softwareBuffer.Vertices.Offset])              fixed (ushort* pIndices = &softwareBuffer.Indices.Array[softwareBuffer.Indices.Offset])                  for (int i = drawCallsPrepared; i < count; i++) {                      if (totalVertCount >= nativeBatchSizeLimit)                          break;                        var call = drawCalls[i];                      if (!call.IsValid)                          throw new InvalidDataException("Invalid draw call");                        bool texturesEqual = call.Textures.Equals(ref currentTextures);                        if (!texturesEqual) {                          if (vertCount > 0) {                              _NativeBatches.Add(new NativeBatch(                                  softwareBuffer' currentTextures'                                  indexOffset'                                  vertOffset'                                  vertCount                              ));                                indexOffset += indexCount;                              vertOffset += vertCount;                              indexCount = 0;                              vertCount = 0;                          }                            currentTextures = call.Textures;                      }                        vertex.Position.X = call.Position.X;                      vertex.Position.Y = call.Position.Y;                      vertex.Position.Z = call.SortKey.Order * zBufferFactor;                      var tr = call.TextureRegion;                      vertex.TextureTopLeft = tr.TopLeft;                      vertex.TextureBottomRight = tr.BottomRight;                      vertex.MultiplyColor = call.MultiplyColor;                      vertex.AddColor = call.AddColor;                      vertex.Scale = call.Scale;                      vertex.Origin = call.Origin;                      vertex.Rotation = call.Rotation;                        for (var j = 0; j < 6; j++)                          pIndices[indexWritePosition + j] = (ushort)(indexBase + QuadIndices[j]);                        indexWritePosition += 6;                        for (short j = 0; j < 4; j++) {                          vertex.Unused = vertex.Corner = j;                          pVertices[vertexWritePosition + j] = vertex;                      }                        vertexWritePosition += 4;                      indexBase += 4;                        totalVertCount += 4;                      vertCount += 4;                      indexCount += 6;                        drawCallsPrepared += 1;                  }
Magic Number,Squared.Render,BitmapBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,FillOneSoftwareBuffer,The following statement contains a magic number: fixed (BitmapVertex* pVertices = &softwareBuffer.Vertices.Array[softwareBuffer.Vertices.Offset])              fixed (ushort* pIndices = &softwareBuffer.Indices.Array[softwareBuffer.Indices.Offset])                  for (int i = drawCallsPrepared; i < count; i++) {                      if (totalVertCount >= nativeBatchSizeLimit)                          break;                        var call = drawCalls[i];                      if (!call.IsValid)                          throw new InvalidDataException("Invalid draw call");                        bool texturesEqual = call.Textures.Equals(ref currentTextures);                        if (!texturesEqual) {                          if (vertCount > 0) {                              _NativeBatches.Add(new NativeBatch(                                  softwareBuffer' currentTextures'                                  indexOffset'                                  vertOffset'                                  vertCount                              ));                                indexOffset += indexCount;                              vertOffset += vertCount;                              indexCount = 0;                              vertCount = 0;                          }                            currentTextures = call.Textures;                      }                        vertex.Position.X = call.Position.X;                      vertex.Position.Y = call.Position.Y;                      vertex.Position.Z = call.SortKey.Order * zBufferFactor;                      var tr = call.TextureRegion;                      vertex.TextureTopLeft = tr.TopLeft;                      vertex.TextureBottomRight = tr.BottomRight;                      vertex.MultiplyColor = call.MultiplyColor;                      vertex.AddColor = call.AddColor;                      vertex.Scale = call.Scale;                      vertex.Origin = call.Origin;                      vertex.Rotation = call.Rotation;                        for (var j = 0; j < 6; j++)                          pIndices[indexWritePosition + j] = (ushort)(indexBase + QuadIndices[j]);                        indexWritePosition += 6;                        for (short j = 0; j < 4; j++) {                          vertex.Unused = vertex.Corner = j;                          pVertices[vertexWritePosition + j] = vertex;                      }                        vertexWritePosition += 4;                      indexBase += 4;                        totalVertCount += 4;                      vertCount += 4;                      indexCount += 6;                        drawCallsPrepared += 1;                  }
Magic Number,Squared.Render,BitmapBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,FillOneSoftwareBuffer,The following statement contains a magic number: fixed (BitmapVertex* pVertices = &softwareBuffer.Vertices.Array[softwareBuffer.Vertices.Offset])              fixed (ushort* pIndices = &softwareBuffer.Indices.Array[softwareBuffer.Indices.Offset])                  for (int i = drawCallsPrepared; i < count; i++) {                      if (totalVertCount >= nativeBatchSizeLimit)                          break;                        var call = drawCalls[i];                      if (!call.IsValid)                          throw new InvalidDataException("Invalid draw call");                        bool texturesEqual = call.Textures.Equals(ref currentTextures);                        if (!texturesEqual) {                          if (vertCount > 0) {                              _NativeBatches.Add(new NativeBatch(                                  softwareBuffer' currentTextures'                                  indexOffset'                                  vertOffset'                                  vertCount                              ));                                indexOffset += indexCount;                              vertOffset += vertCount;                              indexCount = 0;                              vertCount = 0;                          }                            currentTextures = call.Textures;                      }                        vertex.Position.X = call.Position.X;                      vertex.Position.Y = call.Position.Y;                      vertex.Position.Z = call.SortKey.Order * zBufferFactor;                      var tr = call.TextureRegion;                      vertex.TextureTopLeft = tr.TopLeft;                      vertex.TextureBottomRight = tr.BottomRight;                      vertex.MultiplyColor = call.MultiplyColor;                      vertex.AddColor = call.AddColor;                      vertex.Scale = call.Scale;                      vertex.Origin = call.Origin;                      vertex.Rotation = call.Rotation;                        for (var j = 0; j < 6; j++)                          pIndices[indexWritePosition + j] = (ushort)(indexBase + QuadIndices[j]);                        indexWritePosition += 6;                        for (short j = 0; j < 4; j++) {                          vertex.Unused = vertex.Corner = j;                          pVertices[vertexWritePosition + j] = vertex;                      }                        vertexWritePosition += 4;                      indexBase += 4;                        totalVertCount += 4;                      vertCount += 4;                      indexCount += 6;                        drawCallsPrepared += 1;                  }
Magic Number,Squared.Render,BitmapBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,FillOneSoftwareBuffer,The following statement contains a magic number: fixed (BitmapVertex* pVertices = &softwareBuffer.Vertices.Array[softwareBuffer.Vertices.Offset])              fixed (ushort* pIndices = &softwareBuffer.Indices.Array[softwareBuffer.Indices.Offset])                  for (int i = drawCallsPrepared; i < count; i++) {                      if (totalVertCount >= nativeBatchSizeLimit)                          break;                        var call = drawCalls[i];                      if (!call.IsValid)                          throw new InvalidDataException("Invalid draw call");                        bool texturesEqual = call.Textures.Equals(ref currentTextures);                        if (!texturesEqual) {                          if (vertCount > 0) {                              _NativeBatches.Add(new NativeBatch(                                  softwareBuffer' currentTextures'                                  indexOffset'                                  vertOffset'                                  vertCount                              ));                                indexOffset += indexCount;                              vertOffset += vertCount;                              indexCount = 0;                              vertCount = 0;                          }                            currentTextures = call.Textures;                      }                        vertex.Position.X = call.Position.X;                      vertex.Position.Y = call.Position.Y;                      vertex.Position.Z = call.SortKey.Order * zBufferFactor;                      var tr = call.TextureRegion;                      vertex.TextureTopLeft = tr.TopLeft;                      vertex.TextureBottomRight = tr.BottomRight;                      vertex.MultiplyColor = call.MultiplyColor;                      vertex.AddColor = call.AddColor;                      vertex.Scale = call.Scale;                      vertex.Origin = call.Origin;                      vertex.Rotation = call.Rotation;                        for (var j = 0; j < 6; j++)                          pIndices[indexWritePosition + j] = (ushort)(indexBase + QuadIndices[j]);                        indexWritePosition += 6;                        for (short j = 0; j < 4; j++) {                          vertex.Unused = vertex.Corner = j;                          pVertices[vertexWritePosition + j] = vertex;                      }                        vertexWritePosition += 4;                      indexBase += 4;                        totalVertCount += 4;                      vertCount += 4;                      indexCount += 6;                        drawCallsPrepared += 1;                  }
Magic Number,Squared.Render,BitmapBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,FillOneSoftwareBuffer,The following statement contains a magic number: fixed (BitmapVertex* pVertices = &softwareBuffer.Vertices.Array[softwareBuffer.Vertices.Offset])              fixed (ushort* pIndices = &softwareBuffer.Indices.Array[softwareBuffer.Indices.Offset])                  for (int i = drawCallsPrepared; i < count; i++) {                      if (totalVertCount >= nativeBatchSizeLimit)                          break;                        var call = drawCalls[i];                      if (!call.IsValid)                          throw new InvalidDataException("Invalid draw call");                        bool texturesEqual = call.Textures.Equals(ref currentTextures);                        if (!texturesEqual) {                          if (vertCount > 0) {                              _NativeBatches.Add(new NativeBatch(                                  softwareBuffer' currentTextures'                                  indexOffset'                                  vertOffset'                                  vertCount                              ));                                indexOffset += indexCount;                              vertOffset += vertCount;                              indexCount = 0;                              vertCount = 0;                          }                            currentTextures = call.Textures;                      }                        vertex.Position.X = call.Position.X;                      vertex.Position.Y = call.Position.Y;                      vertex.Position.Z = call.SortKey.Order * zBufferFactor;                      var tr = call.TextureRegion;                      vertex.TextureTopLeft = tr.TopLeft;                      vertex.TextureBottomRight = tr.BottomRight;                      vertex.MultiplyColor = call.MultiplyColor;                      vertex.AddColor = call.AddColor;                      vertex.Scale = call.Scale;                      vertex.Origin = call.Origin;                      vertex.Rotation = call.Rotation;                        for (var j = 0; j < 6; j++)                          pIndices[indexWritePosition + j] = (ushort)(indexBase + QuadIndices[j]);                        indexWritePosition += 6;                        for (short j = 0; j < 4; j++) {                          vertex.Unused = vertex.Corner = j;                          pVertices[vertexWritePosition + j] = vertex;                      }                        vertexWritePosition += 4;                      indexBase += 4;                        totalVertCount += 4;                      vertCount += 4;                      indexCount += 6;                        drawCallsPrepared += 1;                  }
Magic Number,Squared.Render,BitmapBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,FillOneSoftwareBuffer,The following statement contains a magic number: fixed (BitmapVertex* pVertices = &softwareBuffer.Vertices.Array[softwareBuffer.Vertices.Offset])              fixed (ushort* pIndices = &softwareBuffer.Indices.Array[softwareBuffer.Indices.Offset])                  for (int i = drawCallsPrepared; i < count; i++) {                      if (totalVertCount >= nativeBatchSizeLimit)                          break;                        var call = drawCalls[i];                      if (!call.IsValid)                          throw new InvalidDataException("Invalid draw call");                        bool texturesEqual = call.Textures.Equals(ref currentTextures);                        if (!texturesEqual) {                          if (vertCount > 0) {                              _NativeBatches.Add(new NativeBatch(                                  softwareBuffer' currentTextures'                                  indexOffset'                                  vertOffset'                                  vertCount                              ));                                indexOffset += indexCount;                              vertOffset += vertCount;                              indexCount = 0;                              vertCount = 0;                          }                            currentTextures = call.Textures;                      }                        vertex.Position.X = call.Position.X;                      vertex.Position.Y = call.Position.Y;                      vertex.Position.Z = call.SortKey.Order * zBufferFactor;                      var tr = call.TextureRegion;                      vertex.TextureTopLeft = tr.TopLeft;                      vertex.TextureBottomRight = tr.BottomRight;                      vertex.MultiplyColor = call.MultiplyColor;                      vertex.AddColor = call.AddColor;                      vertex.Scale = call.Scale;                      vertex.Origin = call.Origin;                      vertex.Rotation = call.Rotation;                        for (var j = 0; j < 6; j++)                          pIndices[indexWritePosition + j] = (ushort)(indexBase + QuadIndices[j]);                        indexWritePosition += 6;                        for (short j = 0; j < 4; j++) {                          vertex.Unused = vertex.Corner = j;                          pVertices[vertexWritePosition + j] = vertex;                      }                        vertexWritePosition += 4;                      indexBase += 4;                        totalVertCount += 4;                      vertCount += 4;                      indexCount += 6;                        drawCallsPrepared += 1;                  }
Magic Number,Squared.Render,BitmapBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,FillOneSoftwareBuffer,The following statement contains a magic number: fixed (BitmapVertex* pVertices = &softwareBuffer.Vertices.Array[softwareBuffer.Vertices.Offset])              fixed (ushort* pIndices = &softwareBuffer.Indices.Array[softwareBuffer.Indices.Offset])                  for (int i = drawCallsPrepared; i < count; i++) {                      if (totalVertCount >= nativeBatchSizeLimit)                          break;                        var call = drawCalls[i];                      if (!call.IsValid)                          throw new InvalidDataException("Invalid draw call");                        bool texturesEqual = call.Textures.Equals(ref currentTextures);                        if (!texturesEqual) {                          if (vertCount > 0) {                              _NativeBatches.Add(new NativeBatch(                                  softwareBuffer' currentTextures'                                  indexOffset'                                  vertOffset'                                  vertCount                              ));                                indexOffset += indexCount;                              vertOffset += vertCount;                              indexCount = 0;                              vertCount = 0;                          }                            currentTextures = call.Textures;                      }                        vertex.Position.X = call.Position.X;                      vertex.Position.Y = call.Position.Y;                      vertex.Position.Z = call.SortKey.Order * zBufferFactor;                      var tr = call.TextureRegion;                      vertex.TextureTopLeft = tr.TopLeft;                      vertex.TextureBottomRight = tr.BottomRight;                      vertex.MultiplyColor = call.MultiplyColor;                      vertex.AddColor = call.AddColor;                      vertex.Scale = call.Scale;                      vertex.Origin = call.Origin;                      vertex.Rotation = call.Rotation;                        for (var j = 0; j < 6; j++)                          pIndices[indexWritePosition + j] = (ushort)(indexBase + QuadIndices[j]);                        indexWritePosition += 6;                        for (short j = 0; j < 4; j++) {                          vertex.Unused = vertex.Corner = j;                          pVertices[vertexWritePosition + j] = vertex;                      }                        vertexWritePosition += 4;                      indexBase += 4;                        totalVertCount += 4;                      vertCount += 4;                      indexCount += 6;                        drawCallsPrepared += 1;                  }
Magic Number,Squared.Render,BitmapBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,Prepare,The following statement contains a magic number: Squared.Render.NativeBatch.RecordPrimitives(_DrawCalls.Count * 2);
Magic Number,Squared.Render,BitmapBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,Prepare,The following statement contains a magic number: if (_NativeBatches == null) {                  // If the batch contains a lot of draw calls' try to make sure we allocate our native batch from the large pool.                  int? nativeBatchCapacity = null;                  if (_DrawCalls.Count >= BatchCapacityLimit)                      nativeBatchCapacity = Math.Min(NativeBatchCapacityLimit + 2' _DrawCalls.Count / 8);                    _NativeBatches = _NativePool.Allocate(nativeBatchCapacity);              }
Magic Number,Squared.Render,BitmapBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,Prepare,The following statement contains a magic number: if (_NativeBatches == null) {                  // If the batch contains a lot of draw calls' try to make sure we allocate our native batch from the large pool.                  int? nativeBatchCapacity = null;                  if (_DrawCalls.Count >= BatchCapacityLimit)                      nativeBatchCapacity = Math.Min(NativeBatchCapacityLimit + 2' _DrawCalls.Count / 8);                    _NativeBatches = _NativePool.Allocate(nativeBatchCapacity);              }
Magic Number,Squared.Render,BitmapBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,Issue,The following statement contains a magic number: using (manager.ApplyMaterial(Material)) {                  TextureSet currentTexture = new TextureSet();                  var paramSize = manager.CurrentParameters.BitmapTextureSize;                  var paramHalfTexel = manager.CurrentParameters.HalfTexel;                    var m = manager.CurrentMaterial;                  var paramTexture1 = m.Effect.Parameters["BitmapTexture"];                  var paramTexture2 = m.Effect.Parameters["SecondTexture"];                    foreach (var nb in _NativeBatches) {                      if (nb.TextureSet != currentTexture) {                          currentTexture = nb.TextureSet;                          var tex1 = currentTexture.Texture1;                            device.SamplerStates[0] = SamplerState;                          device.SamplerStates[1] = SamplerState2;                            // FIXME: What is going wrong with XNA here?                          paramTexture1.SetValue((Texture2D)null);                          paramTexture1.SetValue(tex1);                          if (paramTexture2 != null) {                              paramTexture2.SetValue((Texture2D)null);                              paramTexture2.SetValue(currentTexture.Texture2);                          }                            var vSize = new Vector2(tex1.Width' tex1.Height);                          paramSize.SetValue(vSize);                          paramHalfTexel.SetValue(new Vector2(1.0f / vSize.X' 1.0f / vSize.Y) * 0.5f);                            manager.CurrentMaterial.Flush();                      }                        if (UseZBuffer) {                          var dss = device.DepthStencilState;                          if (dss.DepthBufferEnable == false)                              throw new InvalidOperationException("UseZBuffer set to true but depth buffer is disabled");                      }                        var swb = nb.SoftwareBuffer;                      var hwb = swb.HardwareBuffer;                      if (previousHardwareBuffer != hwb) {                          if (previousHardwareBuffer != null)                              previousHardwareBuffer.SetInactive(device);                            hwb.SetActive(device);                          previousHardwareBuffer = hwb;                      }                        var primitiveCount = nb.VertexCount / 2;                        device.DrawIndexedPrimitives(                          PrimitiveType.TriangleList' 0'                           swb.HardwareVertexOffset + nb.LocalVertexOffset'                           nb.VertexCount'                           swb.HardwareIndexOffset + nb.LocalIndexOffset'                          primitiveCount                      );                  }                    if (previousHardwareBuffer != null)                      previousHardwareBuffer.SetInactive(device);              }
Magic Number,Squared.Render,BitmapDrawCall,C:\repos\sq_Fracture\Squared\RenderLib\RenderBitmaps.cs,Crop,The following statement contains a magic number: if (Math.Abs(Rotation) >= 0.01)                  return false;
Magic Number,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,AddOutlinedQuad,The following statement contains a magic number: Add(ref dc' 4' OutlinedQuadIndices.Length);
Magic Number,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,_PrepareOutlinedQuad,The following statement contains a magic number: var vw = vb.GetWriter(4);
Magic Number,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,AddFilledQuad,The following statement contains a magic number: Add(ref dc' 4' QuadIndices.Length);
Magic Number,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,_PrepareQuad,The following statement contains a magic number: var vw = vb.GetWriter(4);
Magic Number,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,AddGradientFilledQuad,The following statement contains a magic number: Add(ref dc' 4' QuadIndices.Length);
Magic Number,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,_PrepareGradientQuad,The following statement contains a magic number: var vw = vb.GetWriter(4);
Magic Number,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,AddQuadBorder,The following statement contains a magic number: Add(ref dc' 8' QuadBorderIndices.Length);
Magic Number,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,_PrepareQuadBorder,The following statement contains a magic number: var vw = vb.GetWriter(8);
Magic Number,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,AddLine,The following statement contains a magic number: Add(ref dc' 2' LineIndices.Length);
Magic Number,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,_PrepareLine,The following statement contains a magic number: var vw = vb.GetWriter(2);
Magic Number,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,ComputeRingPoints,The following statement contains a magic number: var result = (int)Math.Ceiling(Math.Abs(radius.X + radius.Y) / 3.75f) + 8;
Magic Number,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,ComputeRingPoints,The following statement contains a magic number: if (result < 8)                  result = 8;
Magic Number,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,ComputeRingPoints,The following statement contains a magic number: if (result < 8)                  result = 8;
Magic Number,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,ComputeRingPoints,The following statement contains a magic number: if (result > 1024)                  result = 1024;
Magic Number,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,ComputeRingPoints,The following statement contains a magic number: if (result > 1024)                  result = 1024;
Magic Number,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,AddFilledRing,The following statement contains a magic number: Add(ref dc' numPoints * 2' (numPoints - 1) * 6);
Magic Number,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,AddFilledRing,The following statement contains a magic number: Add(ref dc' numPoints * 2' (numPoints - 1) * 6);
Magic Number,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,_PrepareRing,The following statement contains a magic number: const int vertexStride = 2;
Magic Number,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,_PrepareRing,The following statement contains a magic number: const int indexStride = 6;
Magic Number,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,_PrepareRing,The following statement contains a magic number: fixed (GeometryVertex * pVertices = &vw.Storage.Array[vw.Storage.Offset])              fixed (ushort * pIndices = &iw.Storage.Array[iw.Storage.Offset])              for (int i = 0' j = 0' k = 0; i < numPoints; i++' j += vertexStride' k += indexStride) {                  cos = (float)Math.Cos(a);                  sin = (float)Math.Sin(a);                    vertexInner.Position.X = dc.Vector0.X + (float)(cos * dc.Vector1.X);                  vertexInner.Position.Y = dc.Vector0.Y + (float)(sin * dc.Vector1.Y);                  vertexInner.Color = Color.Lerp(dc.Color0' dc.Color2' colorA);                  pVertices[j] = vertexInner;                    vertexOuter.Position.X = dc.Vector0.X + (float)(cos * dc.Vector2.X);                  vertexOuter.Position.Y = dc.Vector0.Y + (float)(sin * dc.Vector2.Y);                  vertexOuter.Color = Color.Lerp(dc.Color1' dc.Color3' colorA);                  pVertices[j + 1] = vertexOuter;                    if (i == (numPoints - 1))                      break;                    pIndices[k]     = (ushort)(j +     vw.IndexOffset);                  pIndices[k + 1] = (ushort)(j + 1 + vw.IndexOffset);                  pIndices[k + 2] = (ushort)(j + 3 + vw.IndexOffset);                  pIndices[k + 3] = (ushort)(j + 2 + vw.IndexOffset);                  pIndices[k + 4] = (ushort)(j +     vw.IndexOffset);                  pIndices[k + 5] = (ushort)(j + 3 + vw.IndexOffset);                    a += step;                  colorA += colorStep;              }
Magic Number,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,_PrepareRing,The following statement contains a magic number: fixed (GeometryVertex * pVertices = &vw.Storage.Array[vw.Storage.Offset])              fixed (ushort * pIndices = &iw.Storage.Array[iw.Storage.Offset])              for (int i = 0' j = 0' k = 0; i < numPoints; i++' j += vertexStride' k += indexStride) {                  cos = (float)Math.Cos(a);                  sin = (float)Math.Sin(a);                    vertexInner.Position.X = dc.Vector0.X + (float)(cos * dc.Vector1.X);                  vertexInner.Position.Y = dc.Vector0.Y + (float)(sin * dc.Vector1.Y);                  vertexInner.Color = Color.Lerp(dc.Color0' dc.Color2' colorA);                  pVertices[j] = vertexInner;                    vertexOuter.Position.X = dc.Vector0.X + (float)(cos * dc.Vector2.X);                  vertexOuter.Position.Y = dc.Vector0.Y + (float)(sin * dc.Vector2.Y);                  vertexOuter.Color = Color.Lerp(dc.Color1' dc.Color3' colorA);                  pVertices[j + 1] = vertexOuter;                    if (i == (numPoints - 1))                      break;                    pIndices[k]     = (ushort)(j +     vw.IndexOffset);                  pIndices[k + 1] = (ushort)(j + 1 + vw.IndexOffset);                  pIndices[k + 2] = (ushort)(j + 3 + vw.IndexOffset);                  pIndices[k + 3] = (ushort)(j + 2 + vw.IndexOffset);                  pIndices[k + 4] = (ushort)(j +     vw.IndexOffset);                  pIndices[k + 5] = (ushort)(j + 3 + vw.IndexOffset);                    a += step;                  colorA += colorStep;              }
Magic Number,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,_PrepareRing,The following statement contains a magic number: fixed (GeometryVertex * pVertices = &vw.Storage.Array[vw.Storage.Offset])              fixed (ushort * pIndices = &iw.Storage.Array[iw.Storage.Offset])              for (int i = 0' j = 0' k = 0; i < numPoints; i++' j += vertexStride' k += indexStride) {                  cos = (float)Math.Cos(a);                  sin = (float)Math.Sin(a);                    vertexInner.Position.X = dc.Vector0.X + (float)(cos * dc.Vector1.X);                  vertexInner.Position.Y = dc.Vector0.Y + (float)(sin * dc.Vector1.Y);                  vertexInner.Color = Color.Lerp(dc.Color0' dc.Color2' colorA);                  pVertices[j] = vertexInner;                    vertexOuter.Position.X = dc.Vector0.X + (float)(cos * dc.Vector2.X);                  vertexOuter.Position.Y = dc.Vector0.Y + (float)(sin * dc.Vector2.Y);                  vertexOuter.Color = Color.Lerp(dc.Color1' dc.Color3' colorA);                  pVertices[j + 1] = vertexOuter;                    if (i == (numPoints - 1))                      break;                    pIndices[k]     = (ushort)(j +     vw.IndexOffset);                  pIndices[k + 1] = (ushort)(j + 1 + vw.IndexOffset);                  pIndices[k + 2] = (ushort)(j + 3 + vw.IndexOffset);                  pIndices[k + 3] = (ushort)(j + 2 + vw.IndexOffset);                  pIndices[k + 4] = (ushort)(j +     vw.IndexOffset);                  pIndices[k + 5] = (ushort)(j + 3 + vw.IndexOffset);                    a += step;                  colorA += colorStep;              }
Magic Number,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,_PrepareRing,The following statement contains a magic number: fixed (GeometryVertex * pVertices = &vw.Storage.Array[vw.Storage.Offset])              fixed (ushort * pIndices = &iw.Storage.Array[iw.Storage.Offset])              for (int i = 0' j = 0' k = 0; i < numPoints; i++' j += vertexStride' k += indexStride) {                  cos = (float)Math.Cos(a);                  sin = (float)Math.Sin(a);                    vertexInner.Position.X = dc.Vector0.X + (float)(cos * dc.Vector1.X);                  vertexInner.Position.Y = dc.Vector0.Y + (float)(sin * dc.Vector1.Y);                  vertexInner.Color = Color.Lerp(dc.Color0' dc.Color2' colorA);                  pVertices[j] = vertexInner;                    vertexOuter.Position.X = dc.Vector0.X + (float)(cos * dc.Vector2.X);                  vertexOuter.Position.Y = dc.Vector0.Y + (float)(sin * dc.Vector2.Y);                  vertexOuter.Color = Color.Lerp(dc.Color1' dc.Color3' colorA);                  pVertices[j + 1] = vertexOuter;                    if (i == (numPoints - 1))                      break;                    pIndices[k]     = (ushort)(j +     vw.IndexOffset);                  pIndices[k + 1] = (ushort)(j + 1 + vw.IndexOffset);                  pIndices[k + 2] = (ushort)(j + 3 + vw.IndexOffset);                  pIndices[k + 3] = (ushort)(j + 2 + vw.IndexOffset);                  pIndices[k + 4] = (ushort)(j +     vw.IndexOffset);                  pIndices[k + 5] = (ushort)(j + 3 + vw.IndexOffset);                    a += step;                  colorA += colorStep;              }
Magic Number,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,_PrepareRing,The following statement contains a magic number: fixed (GeometryVertex * pVertices = &vw.Storage.Array[vw.Storage.Offset])              fixed (ushort * pIndices = &iw.Storage.Array[iw.Storage.Offset])              for (int i = 0' j = 0' k = 0; i < numPoints; i++' j += vertexStride' k += indexStride) {                  cos = (float)Math.Cos(a);                  sin = (float)Math.Sin(a);                    vertexInner.Position.X = dc.Vector0.X + (float)(cos * dc.Vector1.X);                  vertexInner.Position.Y = dc.Vector0.Y + (float)(sin * dc.Vector1.Y);                  vertexInner.Color = Color.Lerp(dc.Color0' dc.Color2' colorA);                  pVertices[j] = vertexInner;                    vertexOuter.Position.X = dc.Vector0.X + (float)(cos * dc.Vector2.X);                  vertexOuter.Position.Y = dc.Vector0.Y + (float)(sin * dc.Vector2.Y);                  vertexOuter.Color = Color.Lerp(dc.Color1' dc.Color3' colorA);                  pVertices[j + 1] = vertexOuter;                    if (i == (numPoints - 1))                      break;                    pIndices[k]     = (ushort)(j +     vw.IndexOffset);                  pIndices[k + 1] = (ushort)(j + 1 + vw.IndexOffset);                  pIndices[k + 2] = (ushort)(j + 3 + vw.IndexOffset);                  pIndices[k + 3] = (ushort)(j + 2 + vw.IndexOffset);                  pIndices[k + 4] = (ushort)(j +     vw.IndexOffset);                  pIndices[k + 5] = (ushort)(j + 3 + vw.IndexOffset);                    a += step;                  colorA += colorStep;              }
Magic Number,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,_PrepareRing,The following statement contains a magic number: fixed (GeometryVertex * pVertices = &vw.Storage.Array[vw.Storage.Offset])              fixed (ushort * pIndices = &iw.Storage.Array[iw.Storage.Offset])              for (int i = 0' j = 0' k = 0; i < numPoints; i++' j += vertexStride' k += indexStride) {                  cos = (float)Math.Cos(a);                  sin = (float)Math.Sin(a);                    vertexInner.Position.X = dc.Vector0.X + (float)(cos * dc.Vector1.X);                  vertexInner.Position.Y = dc.Vector0.Y + (float)(sin * dc.Vector1.Y);                  vertexInner.Color = Color.Lerp(dc.Color0' dc.Color2' colorA);                  pVertices[j] = vertexInner;                    vertexOuter.Position.X = dc.Vector0.X + (float)(cos * dc.Vector2.X);                  vertexOuter.Position.Y = dc.Vector0.Y + (float)(sin * dc.Vector2.Y);                  vertexOuter.Color = Color.Lerp(dc.Color1' dc.Color3' colorA);                  pVertices[j + 1] = vertexOuter;                    if (i == (numPoints - 1))                      break;                    pIndices[k]     = (ushort)(j +     vw.IndexOffset);                  pIndices[k + 1] = (ushort)(j + 1 + vw.IndexOffset);                  pIndices[k + 2] = (ushort)(j + 3 + vw.IndexOffset);                  pIndices[k + 3] = (ushort)(j + 2 + vw.IndexOffset);                  pIndices[k + 4] = (ushort)(j +     vw.IndexOffset);                  pIndices[k + 5] = (ushort)(j + 3 + vw.IndexOffset);                    a += step;                  colorA += colorStep;              }
Magic Number,Squared.Render,GeometryBatch,C:\repos\sq_Fracture\Squared\RenderLib\RenderGeometry.cs,_PrepareRing,The following statement contains a magic number: fixed (GeometryVertex * pVertices = &vw.Storage.Array[vw.Storage.Offset])              fixed (ushort * pIndices = &iw.Storage.Array[iw.Storage.Offset])              for (int i = 0' j = 0' k = 0; i < numPoints; i++' j += vertexStride' k += indexStride) {                  cos = (float)Math.Cos(a);                  sin = (float)Math.Sin(a);                    vertexInner.Position.X = dc.Vector0.X + (float)(cos * dc.Vector1.X);                  vertexInner.Position.Y = dc.Vector0.Y + (float)(sin * dc.Vector1.Y);                  vertexInner.Color = Color.Lerp(dc.Color0' dc.Color2' colorA);                  pVertices[j] = vertexInner;                    vertexOuter.Position.X = dc.Vector0.X + (float)(cos * dc.Vector2.X);                  vertexOuter.Position.Y = dc.Vector0.Y + (float)(sin * dc.Vector2.Y);                  vertexOuter.Color = Color.Lerp(dc.Color1' dc.Color3' colorA);                  pVertices[j + 1] = vertexOuter;                    if (i == (numPoints - 1))                      break;                    pIndices[k]     = (ushort)(j +     vw.IndexOffset);                  pIndices[k + 1] = (ushort)(j + 1 + vw.IndexOffset);                  pIndices[k + 2] = (ushort)(j + 3 + vw.IndexOffset);                  pIndices[k + 3] = (ushort)(j + 2 + vw.IndexOffset);                  pIndices[k + 4] = (ushort)(j +     vw.IndexOffset);                  pIndices[k + 5] = (ushort)(j + 3 + vw.IndexOffset);                    a += step;                  colorA += colorStep;              }
Magic Number,Squared.Render,RenderExtensionMethods,C:\repos\sq_Fracture\Squared\RenderLib\RenderManager.cs,ComputePrimitiveCount,The following statement contains a magic number: switch (primitiveType) {                  case PrimitiveType.LineStrip:                      return vertexCount - 1;                  case PrimitiveType.LineList:                      return vertexCount / 2;                  case PrimitiveType.TriangleStrip:                      return vertexCount - 2;                  case PrimitiveType.TriangleList:                      return vertexCount / 3;                  default:                      throw new ArgumentException();              }
Magic Number,Squared.Render,RenderExtensionMethods,C:\repos\sq_Fracture\Squared\RenderLib\RenderManager.cs,ComputePrimitiveCount,The following statement contains a magic number: switch (primitiveType) {                  case PrimitiveType.LineStrip:                      return vertexCount - 1;                  case PrimitiveType.LineList:                      return vertexCount / 2;                  case PrimitiveType.TriangleStrip:                      return vertexCount - 2;                  case PrimitiveType.TriangleList:                      return vertexCount / 3;                  default:                      throw new ArgumentException();              }
Magic Number,Squared.Render,RenderExtensionMethods,C:\repos\sq_Fracture\Squared\RenderLib\RenderManager.cs,ComputePrimitiveCount,The following statement contains a magic number: switch (primitiveType) {                  case PrimitiveType.LineStrip:                      return vertexCount - 1;                  case PrimitiveType.LineList:                      return vertexCount / 2;                  case PrimitiveType.TriangleStrip:                      return vertexCount - 2;                  case PrimitiveType.TriangleList:                      return vertexCount / 3;                  default:                      throw new ArgumentException();              }
Magic Number,Squared.Render,RenderExtensionMethods,C:\repos\sq_Fracture\Squared\RenderLib\RenderManager.cs,ComputeVertexCount,The following statement contains a magic number: switch (primitiveType) {                  case PrimitiveType.LineStrip:                      return primitiveCount + 1;                  case PrimitiveType.LineList:                      return primitiveCount * 2;                  case PrimitiveType.TriangleStrip:                      return primitiveCount + 2;                  case PrimitiveType.TriangleList:                      return primitiveCount * 3;                  default:                      throw new ArgumentException();              }
Magic Number,Squared.Render,RenderExtensionMethods,C:\repos\sq_Fracture\Squared\RenderLib\RenderManager.cs,ComputeVertexCount,The following statement contains a magic number: switch (primitiveType) {                  case PrimitiveType.LineStrip:                      return primitiveCount + 1;                  case PrimitiveType.LineList:                      return primitiveCount * 2;                  case PrimitiveType.TriangleStrip:                      return primitiveCount + 2;                  case PrimitiveType.TriangleList:                      return primitiveCount * 3;                  default:                      throw new ArgumentException();              }
Magic Number,Squared.Render,RenderExtensionMethods,C:\repos\sq_Fracture\Squared\RenderLib\RenderManager.cs,ComputeVertexCount,The following statement contains a magic number: switch (primitiveType) {                  case PrimitiveType.LineStrip:                      return primitiveCount + 1;                  case PrimitiveType.LineList:                      return primitiveCount * 2;                  case PrimitiveType.TriangleStrip:                      return primitiveCount + 2;                  case PrimitiveType.TriangleList:                      return primitiveCount * 3;                  default:                      throw new ArgumentException();              }
Magic Number,Squared.Render,RenderManager,C:\repos\sq_Fracture\Squared\RenderLib\RenderManager.cs,ResetDeviceState,The following statement contains a magic number: const int numStages = 8;
Magic Number,Squared.Render,RenderManager,C:\repos\sq_Fracture\Squared\RenderLib\RenderManager.cs,ResetDeviceState,The following statement contains a magic number: const int numVertexStages = 4;
Magic Number,Squared.Render,Frame,C:\repos\sq_Fracture\Squared\RenderLib\RenderManager.cs,Prepare,The following statement contains a magic number: if (!Monitor.TryEnter(PrepareLock' 5000)) {                  throw new InvalidOperationException("Spent more than five seconds waiting for a previous prepare operation.");              }
Magic Number,Squared.Render,PrepareManager,C:\repos\sq_Fracture\Squared\RenderLib\RenderManager.cs,PrepareMany,The following statement contains a magic number: const int blockSize = 256;
Magic Number,Squared.Render,Batch,C:\repos\sq_Fracture\Squared\RenderLib\RenderManager.cs,CaptureStack,The following statement contains a magic number: if (CaptureStackTraces)                  StackTrace = new StackTrace(2 + extraFramesToSkip' true);
Magic Number,Squared.Render,StringLayoutEngine,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,Snap,The following statement contains a magic number: switch (alignToPixels.Horizontal) {                  case PixelAlignmentMode.Floor:                      x = (float)Math.Floor(pos.X);                      break;                  case PixelAlignmentMode.FloorHalf:                      x = (float)Math.Floor(pos.X * 2) / 2;                      break;                  default:                      x = pos.X;                      break;              }
Magic Number,Squared.Render,StringLayoutEngine,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,Snap,The following statement contains a magic number: switch (alignToPixels.Horizontal) {                  case PixelAlignmentMode.Floor:                      x = (float)Math.Floor(pos.X);                      break;                  case PixelAlignmentMode.FloorHalf:                      x = (float)Math.Floor(pos.X * 2) / 2;                      break;                  default:                      x = pos.X;                      break;              }
Magic Number,Squared.Render,StringLayoutEngine,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,Snap,The following statement contains a magic number: switch (alignToPixels.Vertical) {                  case PixelAlignmentMode.Floor:                      y = (float)Math.Floor(pos.Y);                      break;                  case PixelAlignmentMode.FloorHalf:                      y = (float)Math.Floor(pos.Y * 2) / 2;                      break;                  default:                      y = pos.Y;                      break;              }
Magic Number,Squared.Render,StringLayoutEngine,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,Snap,The following statement contains a magic number: switch (alignToPixels.Vertical) {                  case PixelAlignmentMode.Floor:                      y = (float)Math.Floor(pos.Y);                      break;                  case PixelAlignmentMode.FloorHalf:                      y = (float)Math.Floor(pos.Y * 2) / 2;                      break;                  default:                      y = pos.Y;                      break;              }
Magic Number,Squared.Render,StringLayoutEngine,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,AlignLine,The following statement contains a magic number: if (alignment == HorizontalAlignment.Center)                  whitespace /= 2;
Magic Number,Squared.Render,StringLayoutEngine,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,EnsureBufferCapacity,The following statement contains a magic number: if (buffer.Array == null) {                  ownsBuffer = true;                  buffer = new ArraySegment<BitmapDrawCall>(                      new BitmapDrawCall[paddedCount]                  );              } else if (buffer.Count < paddedCount) {                  if (ownsBuffer) {                      var oldBuffer = buffer;                      var newSize = Math.Min(paddedCount + 256' oldBuffer.Count * 2);                      buffer = new ArraySegment<BitmapDrawCall>(                          new BitmapDrawCall[newSize]                      );                      Array.Copy(oldBuffer.Array' buffer.Array' oldBuffer.Count);                  } else if (buffer.Count >= count) {                      // This is OK' there should be enough room...                  } else {                      throw new InvalidOperationException("Buffer too small");                  }              }
Magic Number,Squared.Render,StringLayoutEngine,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,EnsureBufferCapacity,The following statement contains a magic number: if (buffer.Array == null) {                  ownsBuffer = true;                  buffer = new ArraySegment<BitmapDrawCall>(                      new BitmapDrawCall[paddedCount]                  );              } else if (buffer.Count < paddedCount) {                  if (ownsBuffer) {                      var oldBuffer = buffer;                      var newSize = Math.Min(paddedCount + 256' oldBuffer.Count * 2);                      buffer = new ArraySegment<BitmapDrawCall>(                          new BitmapDrawCall[newSize]                      );                      Array.Copy(oldBuffer.Array' buffer.Array' oldBuffer.Count);                  } else if (buffer.Count >= count) {                      // This is OK' there should be enough room...                  } else {                      throw new InvalidOperationException("Buffer too small");                  }              }
Magic Number,Squared.Render,MultithreadedGame,C:\repos\sq_Fracture\Squared\RenderLib\ThreadedRenderGame.cs,MultithreadedGame,The following statement contains a magic number: ThreadGroup = new ThreadGroup(1' 5' comThreadingModel: ApartmentState.MTA) {                  NewThreadBusyThresholdMs = 2.0f              };
Magic Number,Squared.Render,UniformBinding<T>,C:\repos\sq_Fracture\Squared\RenderLib\UniformBinding.cs,InPlaceTranspose,The following statement contains a magic number: float temp = pMatrix[4];
Magic Number,Squared.Render,UniformBinding<T>,C:\repos\sq_Fracture\Squared\RenderLib\UniformBinding.cs,InPlaceTranspose,The following statement contains a magic number: pMatrix[4] = pMatrix[1];
Magic Number,Squared.Render,UniformBinding<T>,C:\repos\sq_Fracture\Squared\RenderLib\UniformBinding.cs,InPlaceTranspose,The following statement contains a magic number: temp = pMatrix[8];
Magic Number,Squared.Render,UniformBinding<T>,C:\repos\sq_Fracture\Squared\RenderLib\UniformBinding.cs,InPlaceTranspose,The following statement contains a magic number: pMatrix[8] = pMatrix[2];
Magic Number,Squared.Render,UniformBinding<T>,C:\repos\sq_Fracture\Squared\RenderLib\UniformBinding.cs,InPlaceTranspose,The following statement contains a magic number: pMatrix[8] = pMatrix[2];
Magic Number,Squared.Render,UniformBinding<T>,C:\repos\sq_Fracture\Squared\RenderLib\UniformBinding.cs,InPlaceTranspose,The following statement contains a magic number: pMatrix[2] = temp;
Magic Number,Squared.Render,UniformBinding<T>,C:\repos\sq_Fracture\Squared\RenderLib\UniformBinding.cs,InPlaceTranspose,The following statement contains a magic number: temp = pMatrix[12];
Magic Number,Squared.Render,UniformBinding<T>,C:\repos\sq_Fracture\Squared\RenderLib\UniformBinding.cs,InPlaceTranspose,The following statement contains a magic number: pMatrix[12] = pMatrix[3];
Magic Number,Squared.Render,UniformBinding<T>,C:\repos\sq_Fracture\Squared\RenderLib\UniformBinding.cs,InPlaceTranspose,The following statement contains a magic number: pMatrix[12] = pMatrix[3];
Magic Number,Squared.Render,UniformBinding<T>,C:\repos\sq_Fracture\Squared\RenderLib\UniformBinding.cs,InPlaceTranspose,The following statement contains a magic number: pMatrix[3] = temp;
Magic Number,Squared.Render,UniformBinding<T>,C:\repos\sq_Fracture\Squared\RenderLib\UniformBinding.cs,InPlaceTranspose,The following statement contains a magic number: temp = pMatrix[9];
Magic Number,Squared.Render,UniformBinding<T>,C:\repos\sq_Fracture\Squared\RenderLib\UniformBinding.cs,InPlaceTranspose,The following statement contains a magic number: pMatrix[9] = pMatrix[6];
Magic Number,Squared.Render,UniformBinding<T>,C:\repos\sq_Fracture\Squared\RenderLib\UniformBinding.cs,InPlaceTranspose,The following statement contains a magic number: pMatrix[9] = pMatrix[6];
Magic Number,Squared.Render,UniformBinding<T>,C:\repos\sq_Fracture\Squared\RenderLib\UniformBinding.cs,InPlaceTranspose,The following statement contains a magic number: pMatrix[6] = temp;
Magic Number,Squared.Render,UniformBinding<T>,C:\repos\sq_Fracture\Squared\RenderLib\UniformBinding.cs,InPlaceTranspose,The following statement contains a magic number: temp = pMatrix[13];
Magic Number,Squared.Render,UniformBinding<T>,C:\repos\sq_Fracture\Squared\RenderLib\UniformBinding.cs,InPlaceTranspose,The following statement contains a magic number: pMatrix[13] = pMatrix[7];
Magic Number,Squared.Render,UniformBinding<T>,C:\repos\sq_Fracture\Squared\RenderLib\UniformBinding.cs,InPlaceTranspose,The following statement contains a magic number: pMatrix[13] = pMatrix[7];
Magic Number,Squared.Render,UniformBinding<T>,C:\repos\sq_Fracture\Squared\RenderLib\UniformBinding.cs,InPlaceTranspose,The following statement contains a magic number: pMatrix[7] = temp;
Magic Number,Squared.Render,UniformBinding<T>,C:\repos\sq_Fracture\Squared\RenderLib\UniformBinding.cs,InPlaceTranspose,The following statement contains a magic number: temp = pMatrix[14];
Magic Number,Squared.Render,UniformBinding<T>,C:\repos\sq_Fracture\Squared\RenderLib\UniformBinding.cs,InPlaceTranspose,The following statement contains a magic number: pMatrix[14] = pMatrix[11];
Magic Number,Squared.Render,UniformBinding<T>,C:\repos\sq_Fracture\Squared\RenderLib\UniformBinding.cs,InPlaceTranspose,The following statement contains a magic number: pMatrix[14] = pMatrix[11];
Magic Number,Squared.Render,UniformBinding<T>,C:\repos\sq_Fracture\Squared\RenderLib\UniformBinding.cs,InPlaceTranspose,The following statement contains a magic number: pMatrix[11] = temp;
Magic Number,Squared.Render,Storage,C:\repos\sq_Fracture\Squared\RenderLib\UniformBinding.cs,Storage,The following statement contains a magic number: const int size = 1024 * 4;
Magic Number,Squared.Render,Storage,C:\repos\sq_Fracture\Squared\RenderLib\UniformBinding.cs,Storage,The following statement contains a magic number: const int size = 1024 * 4;
Magic Number,Squared.Render.Convenience,CachedBatches,C:\repos\sq_Fracture\Squared\RenderLib\Convenience.cs,GetItemAtIndex,The following statement contains a magic number: switch (index) {                      case 0:                          result = Batch0;                          break;                      case 1:                          result = Batch1;                          break;                      case 2:                          result = Batch2;                          break;                      case 3:                          result = Batch3;                          break;                      default:                          throw new ArgumentOutOfRangeException("index");                  }
Magic Number,Squared.Render.Convenience,CachedBatches,C:\repos\sq_Fracture\Squared\RenderLib\Convenience.cs,GetItemAtIndex,The following statement contains a magic number: switch (index) {                      case 0:                          result = Batch0;                          break;                      case 1:                          result = Batch1;                          break;                      case 2:                          result = Batch2;                          break;                      case 3:                          result = Batch3;                          break;                      default:                          throw new ArgumentOutOfRangeException("index");                  }
Magic Number,Squared.Render.Convenience,CachedBatches,C:\repos\sq_Fracture\Squared\RenderLib\Convenience.cs,SetItemAtIndex,The following statement contains a magic number: switch (index) {                      case 0:                          Batch0 = value;                          break;                      case 1:                          Batch1 = value;                          break;                      case 2:                          Batch2 = value;                          break;                      case 3:                          Batch3 = value;                          break;                      default:                          throw new ArgumentOutOfRangeException("index");                  }
Magic Number,Squared.Render.Convenience,CachedBatches,C:\repos\sq_Fracture\Squared\RenderLib\Convenience.cs,SetItemAtIndex,The following statement contains a magic number: switch (index) {                      case 0:                          Batch0 = value;                          break;                      case 1:                          Batch1 = value;                          break;                      case 2:                          Batch2 = value;                          break;                      case 3:                          Batch3 = value;                          break;                      default:                          throw new ArgumentOutOfRangeException("index");                  }
Magic Number,Squared.Render.Internal,BufferGenerator<THardwareBuffer;TVertex;TIndex>,C:\repos\sq_Fracture\Squared\RenderLib\BufferGenerator.cs,PickNewArraySize,The following statement contains a magic number: var newSize = 1 << (int)Math.Ceiling(Math.Log(requestedSize' 2));
Magic Number,Squared.Render.Internal,BufferGenerator<THardwareBuffer;TVertex;TIndex>,C:\repos\sq_Fracture\Squared\RenderLib\BufferGenerator.cs,AllocateSuitablySizedHardwareBuffer,The following statement contains a magic number: using (var e = _UnusedHardwareBuffers.GetEnumerator())              while (e.GetNext(out buffer)) {                  if (                      (buffer.VertexCount >= vertexCount) &&                      (buffer.IndexCount >= indexCount)                  ) {                      // This buffer is large enough' so return it.                      e.RemoveCurrent();                        buffer.Age = Arithmetic.Clamp(buffer.Age - 2' 0' MaxBufferAge);                      return buffer;                  }              }
Magic Number,Squared.Render.Internal,XNABufferGenerator<TVertex>,C:\repos\sq_Fracture\Squared\RenderLib\BufferGenerator.cs,XNABufferGenerator,The following statement contains a magic number: MaxSoftwareBuffersPerHardwareBuffer = 512;
Magic Number,Squared.Render.Text,StringLayoutEngine,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,Snap,The following statement contains a magic number: switch (alignToPixels.Horizontal) {                  case PixelAlignmentMode.Floor:                      x = (float)Math.Floor(pos.X);                      break;                  case PixelAlignmentMode.FloorHalf:                      x = (float)Math.Floor(pos.X * 2) / 2;                      break;                  default:                      x = pos.X;                      break;              }
Magic Number,Squared.Render.Text,StringLayoutEngine,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,Snap,The following statement contains a magic number: switch (alignToPixels.Horizontal) {                  case PixelAlignmentMode.Floor:                      x = (float)Math.Floor(pos.X);                      break;                  case PixelAlignmentMode.FloorHalf:                      x = (float)Math.Floor(pos.X * 2) / 2;                      break;                  default:                      x = pos.X;                      break;              }
Magic Number,Squared.Render.Text,StringLayoutEngine,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,Snap,The following statement contains a magic number: switch (alignToPixels.Vertical) {                  case PixelAlignmentMode.Floor:                      y = (float)Math.Floor(pos.Y);                      break;                  case PixelAlignmentMode.FloorHalf:                      y = (float)Math.Floor(pos.Y * 2) / 2;                      break;                  default:                      y = pos.Y;                      break;              }
Magic Number,Squared.Render.Text,StringLayoutEngine,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,Snap,The following statement contains a magic number: switch (alignToPixels.Vertical) {                  case PixelAlignmentMode.Floor:                      y = (float)Math.Floor(pos.Y);                      break;                  case PixelAlignmentMode.FloorHalf:                      y = (float)Math.Floor(pos.Y * 2) / 2;                      break;                  default:                      y = pos.Y;                      break;              }
Magic Number,Squared.Render.Text,StringLayoutEngine,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,AlignLine,The following statement contains a magic number: if (alignment == HorizontalAlignment.Center)                  whitespace /= 2;
Magic Number,Squared.Render.Text,StringLayoutEngine,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,EnsureBufferCapacity,The following statement contains a magic number: if (buffer.Array == null) {                  ownsBuffer = true;                  buffer = new ArraySegment<BitmapDrawCall>(                      new BitmapDrawCall[paddedCount]                  );              } else if (buffer.Count < paddedCount) {                  if (ownsBuffer) {                      var oldBuffer = buffer;                      var newSize = Math.Min(paddedCount + 256' oldBuffer.Count * 2);                      buffer = new ArraySegment<BitmapDrawCall>(                          new BitmapDrawCall[newSize]                      );                      Array.Copy(oldBuffer.Array' buffer.Array' oldBuffer.Count);                  } else if (buffer.Count >= count) {                      // This is OK' there should be enough room...                  } else {                      throw new InvalidOperationException("Buffer too small");                  }              }
Magic Number,Squared.Render.Text,StringLayoutEngine,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,EnsureBufferCapacity,The following statement contains a magic number: if (buffer.Array == null) {                  ownsBuffer = true;                  buffer = new ArraySegment<BitmapDrawCall>(                      new BitmapDrawCall[paddedCount]                  );              } else if (buffer.Count < paddedCount) {                  if (ownsBuffer) {                      var oldBuffer = buffer;                      var newSize = Math.Min(paddedCount + 256' oldBuffer.Count * 2);                      buffer = new ArraySegment<BitmapDrawCall>(                          new BitmapDrawCall[newSize]                      );                      Array.Copy(oldBuffer.Array' buffer.Array' oldBuffer.Count);                  } else if (buffer.Count >= count) {                      // This is OK' there should be enough room...                  } else {                      throw new InvalidOperationException("Buffer too small");                  }              }
Magic Number,Squared.Render.Text,DynamicStringLayout,C:\repos\sq_Fracture\Squared\RenderLib\TextUtils.cs,Get,The following statement contains a magic number: if (!_CachedStringLayout.HasValue) {                  int length = _Text.Length;                    int capacity = length + StringLayoutEngine.DefaultBufferPadding;                    if ((_Buffer.Array != null) && (_Buffer.Count < capacity))                      _Buffer = default(ArraySegment<BitmapDrawCall>);                    if (_Buffer.Array == null) {                      var newCapacity = 1 << (int)Math.Ceiling(Math.Log(capacity' 2));                      var array = new BitmapDrawCall[newCapacity];                      _Buffer = new ArraySegment<BitmapDrawCall>(array);                  }                    if (_Buffer.Count < capacity)                      throw new InvalidOperationException("Buffer too small");                    using (                      var le = new StringLayoutEngine {                          buffer = _Buffer'                          position = _Position'                          color = _Color'                          scale = _Scale'                          sortKey = _SortKey'                          characterSkipCount = _CharacterSkipCount'                          characterLimit = _CharacterLimit'                          xOffsetOfFirstLine = _XOffsetOfFirstLine'                          xOffsetOfWrappedLine = _XOffsetOfNewLine + _WrapIndentation'                          xOffsetOfNewLine = _XOffsetOfNewLine'                          lineBreakAtX = _LineBreakAtX'                          alignToPixels = _AlignToPixels'                          characterWrap = _CharacterWrap'                          wordWrap = _WordWrap'                          wrapCharacter = _WrapCharacter'                          alignment = (HorizontalAlignment)_Alignment'                          reverseOrder = _ReverseOrder                      }                  ) {                      le.Initialize();                      le.AppendText(_GlyphSource' _Text' _KerningAdjustments);                        _CachedGlyphVersion = _GlyphSource.Version;                      _CachedStringLayout = le.Finish();                  }              }
Magic Number,Text,StringLayoutEngine,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,Snap,The following statement contains a magic number: switch (alignToPixels.Horizontal) {                  case PixelAlignmentMode.Floor:                      x = (float)Math.Floor(pos.X);                      break;                  case PixelAlignmentMode.FloorHalf:                      x = (float)Math.Floor(pos.X * 2) / 2;                      break;                  default:                      x = pos.X;                      break;              }
Magic Number,Text,StringLayoutEngine,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,Snap,The following statement contains a magic number: switch (alignToPixels.Horizontal) {                  case PixelAlignmentMode.Floor:                      x = (float)Math.Floor(pos.X);                      break;                  case PixelAlignmentMode.FloorHalf:                      x = (float)Math.Floor(pos.X * 2) / 2;                      break;                  default:                      x = pos.X;                      break;              }
Magic Number,Text,StringLayoutEngine,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,Snap,The following statement contains a magic number: switch (alignToPixels.Vertical) {                  case PixelAlignmentMode.Floor:                      y = (float)Math.Floor(pos.Y);                      break;                  case PixelAlignmentMode.FloorHalf:                      y = (float)Math.Floor(pos.Y * 2) / 2;                      break;                  default:                      y = pos.Y;                      break;              }
Magic Number,Text,StringLayoutEngine,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,Snap,The following statement contains a magic number: switch (alignToPixels.Vertical) {                  case PixelAlignmentMode.Floor:                      y = (float)Math.Floor(pos.Y);                      break;                  case PixelAlignmentMode.FloorHalf:                      y = (float)Math.Floor(pos.Y * 2) / 2;                      break;                  default:                      y = pos.Y;                      break;              }
Magic Number,Text,StringLayoutEngine,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,AlignLine,The following statement contains a magic number: if (alignment == HorizontalAlignment.Center)                  whitespace /= 2;
Magic Number,Text,StringLayoutEngine,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,EnsureBufferCapacity,The following statement contains a magic number: if (buffer.Array == null) {                  ownsBuffer = true;                  buffer = new ArraySegment<BitmapDrawCall>(                      new BitmapDrawCall[paddedCount]                  );              } else if (buffer.Count < paddedCount) {                  if (ownsBuffer) {                      var oldBuffer = buffer;                      var newSize = Math.Min(paddedCount + 256' oldBuffer.Count * 2);                      buffer = new ArraySegment<BitmapDrawCall>(                          new BitmapDrawCall[newSize]                      );                      Array.Copy(oldBuffer.Array' buffer.Array' oldBuffer.Count);                  } else if (buffer.Count >= count) {                      // This is OK' there should be enough room...                  } else {                      throw new InvalidOperationException("Buffer too small");                  }              }
Magic Number,Text,StringLayoutEngine,C:\repos\sq_Fracture\Squared\RenderLib\RenderText.cs,EnsureBufferCapacity,The following statement contains a magic number: if (buffer.Array == null) {                  ownsBuffer = true;                  buffer = new ArraySegment<BitmapDrawCall>(                      new BitmapDrawCall[paddedCount]                  );              } else if (buffer.Count < paddedCount) {                  if (ownsBuffer) {                      var oldBuffer = buffer;                      var newSize = Math.Min(paddedCount + 256' oldBuffer.Count * 2);                      buffer = new ArraySegment<BitmapDrawCall>(                          new BitmapDrawCall[newSize]                      );                      Array.Copy(oldBuffer.Array' buffer.Array' oldBuffer.Count);                  } else if (buffer.Count >= count) {                      // This is OK' there should be enough room...                  } else {                      throw new InvalidOperationException("Buffer too small");                  }              }
