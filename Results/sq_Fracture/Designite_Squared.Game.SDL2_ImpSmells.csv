Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Squared.Game,Geometry,C:\repos\sq_Fracture\Squared\GameLib\Geometry3.cs,Triangulate,Cyclomatic complexity of the method is 10
Complex Method,Squared.Game,SerializationExtensions,C:\repos\sq_Fracture\Squared\GameLib\Serialization.cs,ReadDictionary,Cyclomatic complexity of the method is 13
Complex Method,Squared.Game,ItemBoundsEnumerator,C:\repos\sq_Fracture\Squared\GameLib\SpatialCollection.cs,MoveNext,Cyclomatic complexity of the method is 9
Complex Method,Squared.Game.Serialization,SerializationExtensions,C:\repos\sq_Fracture\Squared\GameLib\Serialization.cs,ReadDictionary,Cyclomatic complexity of the method is 13
Long Parameter List,Squared.Game,Geometry,C:\repos\sq_Fracture\Squared\GameLib\Geometry3.cs,DoLinesIntersect,The method has 5 parameters. Parameters: startA' endA' startB' endB' distanceAlongA
Long Parameter List,Squared.Game,Geometry,C:\repos\sq_Fracture\Squared\GameLib\Geometry3.cs,DoLinesIntersect,The method has 5 parameters. Parameters: startA' endA' startB' endB' intersection
Long Parameter List,Squared.Game,Geometry,C:\repos\sq_Fracture\Squared\GameLib\Geometry3.cs,DoLinesIntersect,The method has 5 parameters. Parameters: startA' endA' startB' endB' distanceAlongA
Long Parameter List,Squared.Game,Geometry,C:\repos\sq_Fracture\Squared\GameLib\Geometry3.cs,DoLinesIntersect,The method has 5 parameters. Parameters: startA' endA' startB' endB' intersection
Long Statement,Squared.Game,GameExtensionMethods,C:\repos\sq_Fracture\Squared\GameLib\GameExtensionMethods.cs,Round,The length of the statement  "            return new Vector3((float)Math.Round(vector.X' decimals)' (float)Math.Round(vector.Y' decimals)' (float)Math.Round(vector.Z' decimals)); " is 136.
Long Statement,Squared.Game,Geometry,C:\repos\sq_Fracture\Squared\GameLib\Geometry3.cs,Triangulate,The length of the statement  "                        throw new System.TimeoutException("Triangulate made a complete pass over its remaining vertices without finding an ear"); " is 121.
Long Statement,Squared.Game,Geometry,C:\repos\sq_Fracture\Squared\GameLib\Geometry3.cs,ClosestPointOnLine,The length of the statement  "            var u = (((sourcePoint.X - lineStart.X) * lineDelta.X) + ((sourcePoint.Y - lineStart.Y) * lineDelta.Y)) / lineDelta.LengthSquared(); " is 132.
Long Statement,Squared.Game,SerializationExtensions,C:\repos\sq_Fracture\Squared\GameLib\Serialization.cs,ReadDictionary,The length of the statement  "                            throw new InvalidDataException(String.Format("Cannot store an {0} into a Dictionary<String' {1}>."' t.Name' outputType.Name)); " is 126.
Long Statement,Squared.Game.Serialization,SerializationExtensions,C:\repos\sq_Fracture\Squared\GameLib\Serialization.cs,ReadDictionary,The length of the statement  "                            throw new InvalidDataException(String.Format("Cannot store an {0} into a Dictionary<String' {1}>."' t.Name' outputType.Name)); " is 126.
Complex Conditional,Squared.Game,Geometry,C:\repos\sq_Fracture\Squared\GameLib\Geometry3.cs,PointInPolygon,The conditional expression  "(Math.Abs(a.Y - pt.Y) < IntersectionEpsilon) ||                          (Math.Abs(b.Y - pt.Y) < IntersectionEpsilon) ||                          (Math.Abs(a.X - pt.X) < IntersectionEpsilon) ||                          (Math.Abs(b.X - pt.X) < IntersectionEpsilon)"  is complex.
Complex Conditional,Squared.Game,SpatialCollection<T>,C:\repos\sq_Fracture\Squared\GameLib\SpatialCollection.cs,UpdateItemBounds,The conditional expression  "(oldTopLeft.First == info.TopLeft.First) &&                      (oldTopLeft.Second == info.TopLeft.Second) &&                       (oldBottomRight.First == info.BottomRight.First) &&                      (oldBottomRight.Second == info.BottomRight.Second)"  is complex.
Empty Catch Block,Squared.Game,TypeResolverChain,C:\repos\sq_Fracture\Squared\GameLib\Serialization.cs,TypeToName,The method has an empty catch block.
Empty Catch Block,Squared.Game,TypeResolverChain,C:\repos\sq_Fracture\Squared\GameLib\Serialization.cs,NameToType,The method has an empty catch block.
Empty Catch Block,Squared.Game,NameReplacementTypeResolver,C:\repos\sq_Fracture\Squared\GameLib\Serialization.cs,NameToType,The method has an empty catch block.
Empty Catch Block,Squared.Game.Serialization,TypeResolverChain,C:\repos\sq_Fracture\Squared\GameLib\Serialization.cs,TypeToName,The method has an empty catch block.
Empty Catch Block,Squared.Game.Serialization,TypeResolverChain,C:\repos\sq_Fracture\Squared\GameLib\Serialization.cs,NameToType,The method has an empty catch block.
Empty Catch Block,Squared.Game.Serialization,NameReplacementTypeResolver,C:\repos\sq_Fracture\Squared\GameLib\Serialization.cs,NameToType,The method has an empty catch block.
Magic Number,Squared.Game.Animation,Animator,C:\repos\sq_Fracture\Squared\GameLib\Animation.cs,Delay,The following statement contains a magic number: _SuspendUntil = _SuspendUntil + (duration * 10000 / _Speed);
Magic Number,Squared.Game.Animation,Animator,C:\repos\sq_Fracture\Squared\GameLib\Animation.cs,SetSpeed,The following statement contains a magic number: _Speed = (long)Math.Round(speed * 10000);
Magic Number,Squared.Game.Animation,Animator,C:\repos\sq_Fracture\Squared\GameLib\Animation.cs,SetSpeed,The following statement contains a magic number: _SuspendUntil = _SuspendSince + (_SuspendDuration * 10000 / _Speed);
Magic Number,Squared.Game,Geometry,C:\repos\sq_Fracture\Squared\GameLib\Geometry3.cs,PointInPolygon,The following statement contains a magic number: var rayEnd = new Vector2(pt.X + 99999' pt.Y);
Magic Number,Squared.Game,Geometry,C:\repos\sq_Fracture\Squared\GameLib\Geometry3.cs,PointInPolygon,The following statement contains a magic number: var isInside = (numIntersections % 2) == 1;
Magic Number,Squared.Game,Geometry,C:\repos\sq_Fracture\Squared\GameLib\Geometry3.cs,PointInTriangle,The following statement contains a magic number: if (triangle.Length != 3)                  throw new ArgumentException("Triangle must contain 3 vertices"' "triangle");
Magic Number,Squared.Game,Geometry,C:\repos\sq_Fracture\Squared\GameLib\Geometry3.cs,PointInTriangle,The following statement contains a magic number: return PointInTriangle(pt' triangle[0]' triangle[1]' triangle[2]);
Magic Number,Squared.Game,Geometry,C:\repos\sq_Fracture\Squared\GameLib\Geometry3.cs,Triangulate,The following statement contains a magic number: if (ll.Count < 3)                  yield break;              else if (ll.Count == 3) {                  yield return ll.ToArray();                  yield break;              }
Magic Number,Squared.Game,Geometry,C:\repos\sq_Fracture\Squared\GameLib\Geometry3.cs,Triangulate,The following statement contains a magic number: if (ll.Count < 3)                  yield break;              else if (ll.Count == 3) {                  yield return ll.ToArray();                  yield break;              }
Magic Number,Squared.Game,Geometry,C:\repos\sq_Fracture\Squared\GameLib\Geometry3.cs,Triangulate,The following statement contains a magic number: while (!done) {                  var prev = ll.Last;                  var current = ll.First;                  var next = current.Next;                    while (current != null) {                      bool isEar = true;                      foreach (var pt in ll) {                          if (PointInTriangle(pt' prev.Value' current.Value' next.Value)) {                              isEar = false;                              break;                          }                      }                        if (isEar) {                          yield return new Vector2[] { prev.Value' current.Value' next.Value };                          ll.Remove(current);                          steps = 0;                          break;                      } else {                          steps += 1;                      }                        if (next == ll.First)                          break;                        if (steps > ll.Count) {                          throw new System.TimeoutException("Triangulate made a complete pass over its remaining vertices without finding an ear");                      }                        prev = current;                      current = next;                      next = current.Next ?? ll.First;                  }                    done |= (ll.Count <= 3);              }
Magic Number,Squared.Game,Geometry,C:\repos\sq_Fracture\Squared\GameLib\Geometry3.cs,ResolvePolygonMotion,The following statement contains a magic number: int bufferSize = polygonA.Count + polygonB.Count + 4;
Magic Number,Squared.Game,Geometry,C:\repos\sq_Fracture\Squared\GameLib\Geometry3.cs,ResolvePolygonMotion,The following statement contains a magic number: using (var axisBuffer = BufferPool<Vector2>.Allocate(bufferSize)) {                  int axisCount = 0;                    if (velocityA.LengthSquared() > 0) {                      axisCount += 4;                      axisBuffer.Data[0] = Vector2.Normalize(velocityA);                      axisBuffer.Data[1] = new Vector2(-axisBuffer.Data[0].X' axisBuffer.Data[0].Y);                      axisBuffer.Data[2] = new Vector2(axisBuffer.Data[0].X' -axisBuffer.Data[0].Y);                      axisBuffer.Data[3] = new Vector2(-axisBuffer.Data[0].X' -axisBuffer.Data[0].Y);                  }                    GetPolygonAxes(axisBuffer.Data' ref axisCount' polygonA);                  GetPolygonAxes(axisBuffer.Data' ref axisCount' polygonB);                    for (int i = 0; i < axisCount; i++) {                      var axis = axisBuffer.Data[i];                        intervalA = ProjectOntoAxis(axis' polygonA' offset);                      intervalB = ProjectOntoAxis(axis' polygonB' offset);                        bool intersects = intervalA.Intersects(intervalB' Geometry.IntersectionEpsilon);                      if (!intersects)                          result.AreIntersecting = false;                                            velocityProjection = axis.Dot(ref velocityA);                        newIntervalA = intervalA;                      newIntervalA.Min += velocityProjection;                      newIntervalA.Max += velocityProjection;                        var intersectionDistance = newIntervalA.GetDistance(intervalB);                      intersects = intersectionDistance < 0;                      if (!intersects)                          result.WouldHaveIntersected = false;                        if (result.WouldHaveIntersected == false) {                          result.WillBeIntersecting = false;                          result.ResultVelocity = velocityA;                          break;                      }                        if ((velocityDistance > 0) && (intersectionDistance < minDistance)) {                          var minVect = axis * intersectionDistance;                          var newVelocity = velocityA + minVect;                          var newLength = Vector2.Dot(velocityAxis' newVelocity);                          newVelocity = velocityAxis * newLength;                            if (newVelocity.LengthSquared() > velocityA.LengthSquared())                              continue;                          if (Vector2.Dot(velocityA' newVelocity) < 0.0f)                              newVelocity = Vector2.Zero;                                                    velocityProjection = axis.Dot(ref newVelocity);                          newIntervalA.Min = (intervalA.Min + velocityProjection);                          newIntervalA.Max = (intervalA.Max + velocityProjection);                          intersectionDistance = newIntervalA.GetDistance(intervalB);                            if (intersectionDistance < -IntersectionEpsilon)                              continue;                            result.ResultVelocity = newVelocity;                          result.WillBeIntersecting = false;                          minDistance = intersectionDistance;                      }                  }              }
Magic Number,Squared.Game,Geometry,C:\repos\sq_Fracture\Squared\GameLib\Geometry3.cs,ResolvePolygonMotion,The following statement contains a magic number: using (var axisBuffer = BufferPool<Vector2>.Allocate(bufferSize)) {                  int axisCount = 0;                    if (velocityA.LengthSquared() > 0) {                      axisCount += 4;                      axisBuffer.Data[0] = Vector2.Normalize(velocityA);                      axisBuffer.Data[1] = new Vector2(-axisBuffer.Data[0].X' axisBuffer.Data[0].Y);                      axisBuffer.Data[2] = new Vector2(axisBuffer.Data[0].X' -axisBuffer.Data[0].Y);                      axisBuffer.Data[3] = new Vector2(-axisBuffer.Data[0].X' -axisBuffer.Data[0].Y);                  }                    GetPolygonAxes(axisBuffer.Data' ref axisCount' polygonA);                  GetPolygonAxes(axisBuffer.Data' ref axisCount' polygonB);                    for (int i = 0; i < axisCount; i++) {                      var axis = axisBuffer.Data[i];                        intervalA = ProjectOntoAxis(axis' polygonA' offset);                      intervalB = ProjectOntoAxis(axis' polygonB' offset);                        bool intersects = intervalA.Intersects(intervalB' Geometry.IntersectionEpsilon);                      if (!intersects)                          result.AreIntersecting = false;                                            velocityProjection = axis.Dot(ref velocityA);                        newIntervalA = intervalA;                      newIntervalA.Min += velocityProjection;                      newIntervalA.Max += velocityProjection;                        var intersectionDistance = newIntervalA.GetDistance(intervalB);                      intersects = intersectionDistance < 0;                      if (!intersects)                          result.WouldHaveIntersected = false;                        if (result.WouldHaveIntersected == false) {                          result.WillBeIntersecting = false;                          result.ResultVelocity = velocityA;                          break;                      }                        if ((velocityDistance > 0) && (intersectionDistance < minDistance)) {                          var minVect = axis * intersectionDistance;                          var newVelocity = velocityA + minVect;                          var newLength = Vector2.Dot(velocityAxis' newVelocity);                          newVelocity = velocityAxis * newLength;                            if (newVelocity.LengthSquared() > velocityA.LengthSquared())                              continue;                          if (Vector2.Dot(velocityA' newVelocity) < 0.0f)                              newVelocity = Vector2.Zero;                                                    velocityProjection = axis.Dot(ref newVelocity);                          newIntervalA.Min = (intervalA.Min + velocityProjection);                          newIntervalA.Max = (intervalA.Max + velocityProjection);                          intersectionDistance = newIntervalA.GetDistance(intervalB);                            if (intersectionDistance < -IntersectionEpsilon)                              continue;                            result.ResultVelocity = newVelocity;                          result.WillBeIntersecting = false;                          minDistance = intersectionDistance;                      }                  }              }
Magic Number,Squared.Game,Geometry,C:\repos\sq_Fracture\Squared\GameLib\Geometry3.cs,ResolvePolygonMotion,The following statement contains a magic number: using (var axisBuffer = BufferPool<Vector2>.Allocate(bufferSize)) {                  int axisCount = 0;                    if (velocityA.LengthSquared() > 0) {                      axisCount += 4;                      axisBuffer.Data[0] = Vector2.Normalize(velocityA);                      axisBuffer.Data[1] = new Vector2(-axisBuffer.Data[0].X' axisBuffer.Data[0].Y);                      axisBuffer.Data[2] = new Vector2(axisBuffer.Data[0].X' -axisBuffer.Data[0].Y);                      axisBuffer.Data[3] = new Vector2(-axisBuffer.Data[0].X' -axisBuffer.Data[0].Y);                  }                    GetPolygonAxes(axisBuffer.Data' ref axisCount' polygonA);                  GetPolygonAxes(axisBuffer.Data' ref axisCount' polygonB);                    for (int i = 0; i < axisCount; i++) {                      var axis = axisBuffer.Data[i];                        intervalA = ProjectOntoAxis(axis' polygonA' offset);                      intervalB = ProjectOntoAxis(axis' polygonB' offset);                        bool intersects = intervalA.Intersects(intervalB' Geometry.IntersectionEpsilon);                      if (!intersects)                          result.AreIntersecting = false;                                            velocityProjection = axis.Dot(ref velocityA);                        newIntervalA = intervalA;                      newIntervalA.Min += velocityProjection;                      newIntervalA.Max += velocityProjection;                        var intersectionDistance = newIntervalA.GetDistance(intervalB);                      intersects = intersectionDistance < 0;                      if (!intersects)                          result.WouldHaveIntersected = false;                        if (result.WouldHaveIntersected == false) {                          result.WillBeIntersecting = false;                          result.ResultVelocity = velocityA;                          break;                      }                        if ((velocityDistance > 0) && (intersectionDistance < minDistance)) {                          var minVect = axis * intersectionDistance;                          var newVelocity = velocityA + minVect;                          var newLength = Vector2.Dot(velocityAxis' newVelocity);                          newVelocity = velocityAxis * newLength;                            if (newVelocity.LengthSquared() > velocityA.LengthSquared())                              continue;                          if (Vector2.Dot(velocityA' newVelocity) < 0.0f)                              newVelocity = Vector2.Zero;                                                    velocityProjection = axis.Dot(ref newVelocity);                          newIntervalA.Min = (intervalA.Min + velocityProjection);                          newIntervalA.Max = (intervalA.Max + velocityProjection);                          intersectionDistance = newIntervalA.GetDistance(intervalB);                            if (intersectionDistance < -IntersectionEpsilon)                              continue;                            result.ResultVelocity = newVelocity;                          result.WillBeIntersecting = false;                          minDistance = intersectionDistance;                      }                  }              }
Magic Number,Squared.Game,IntPairComparer,C:\repos\sq_Fracture\Squared\GameLib\SpatialCollection.cs,GetHashCode,The following statement contains a magic number: return obj.First + (obj.Second << 16);
Magic Number,Squared.Game.Serialization,ColorSerializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: return new Color(data[0]' data[1]' data[2]' data[3]);
Magic Number,Squared.Game.Serialization,ColorSerializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: return new Color(data[0]' data[1]' data[2]' data[3]);
Magic Number,Squared.Game.Serialization,ColorSerializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Write,The following statement contains a magic number: var result = new byte[4];
Magic Number,Squared.Game.Serialization,ColorSerializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Write,The following statement contains a magic number: result[2] = inst.B;
Magic Number,Squared.Game.Serialization,ColorSerializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Write,The following statement contains a magic number: result[3] = inst.A;
Magic Number,Squared.Game.Serialization,Vector2Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: if (!BitConverter.IsLittleEndian) {                  Array.Reverse(data' 0' 4);                  Array.Reverse(data' 4' 4);              }
Magic Number,Squared.Game.Serialization,Vector2Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: if (!BitConverter.IsLittleEndian) {                  Array.Reverse(data' 0' 4);                  Array.Reverse(data' 4' 4);              }
Magic Number,Squared.Game.Serialization,Vector2Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: if (!BitConverter.IsLittleEndian) {                  Array.Reverse(data' 0' 4);                  Array.Reverse(data' 4' 4);              }
Magic Number,Squared.Game.Serialization,Vector2Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: return new Vector2(                  BitConverter.ToSingle(data' 0)'                  BitConverter.ToSingle(data' 4)              );
Magic Number,Squared.Game.Serialization,Vector2Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Write,The following statement contains a magic number: var result = new byte[8];
Magic Number,Squared.Game.Serialization,Vector2Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Write,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(inst.X)' 0' result' 0' 4);
Magic Number,Squared.Game.Serialization,Vector2Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Write,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(inst.Y)' 0' result' 4' 4);
Magic Number,Squared.Game.Serialization,Vector2Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Write,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(inst.Y)' 0' result' 4' 4);
Magic Number,Squared.Game.Serialization,Vector3Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: if (!BitConverter.IsLittleEndian) {                  Array.Reverse(data' 0' 4);                  Array.Reverse(data' 4' 4);                  Array.Reverse(data' 8' 4);              }
Magic Number,Squared.Game.Serialization,Vector3Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: if (!BitConverter.IsLittleEndian) {                  Array.Reverse(data' 0' 4);                  Array.Reverse(data' 4' 4);                  Array.Reverse(data' 8' 4);              }
Magic Number,Squared.Game.Serialization,Vector3Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: if (!BitConverter.IsLittleEndian) {                  Array.Reverse(data' 0' 4);                  Array.Reverse(data' 4' 4);                  Array.Reverse(data' 8' 4);              }
Magic Number,Squared.Game.Serialization,Vector3Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: if (!BitConverter.IsLittleEndian) {                  Array.Reverse(data' 0' 4);                  Array.Reverse(data' 4' 4);                  Array.Reverse(data' 8' 4);              }
Magic Number,Squared.Game.Serialization,Vector3Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: if (!BitConverter.IsLittleEndian) {                  Array.Reverse(data' 0' 4);                  Array.Reverse(data' 4' 4);                  Array.Reverse(data' 8' 4);              }
Magic Number,Squared.Game.Serialization,Vector3Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: return new Vector3(                  BitConverter.ToSingle(data' 0)'                  BitConverter.ToSingle(data' 4)'                  BitConverter.ToSingle(data' 8)              );
Magic Number,Squared.Game.Serialization,Vector3Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: return new Vector3(                  BitConverter.ToSingle(data' 0)'                  BitConverter.ToSingle(data' 4)'                  BitConverter.ToSingle(data' 8)              );
Magic Number,Squared.Game.Serialization,Vector3Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Write,The following statement contains a magic number: var result = new byte[12];
Magic Number,Squared.Game.Serialization,Vector3Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Write,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(inst.X)' 0' result' 0' 4);
Magic Number,Squared.Game.Serialization,Vector3Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Write,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(inst.Y)' 0' result' 4' 4);
Magic Number,Squared.Game.Serialization,Vector3Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Write,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(inst.Y)' 0' result' 4' 4);
Magic Number,Squared.Game.Serialization,Vector3Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Write,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(inst.Z)' 0' result' 8' 4);
Magic Number,Squared.Game.Serialization,Vector3Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Write,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(inst.Z)' 0' result' 8' 4);
Magic Number,Squared.Game.Serialization,Vector4Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: if (!BitConverter.IsLittleEndian) {                  Array.Reverse(data' 0' 4);                  Array.Reverse(data' 4' 4);                  Array.Reverse(data' 8' 4);                  Array.Reverse(data' 12' 4);              }
Magic Number,Squared.Game.Serialization,Vector4Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: if (!BitConverter.IsLittleEndian) {                  Array.Reverse(data' 0' 4);                  Array.Reverse(data' 4' 4);                  Array.Reverse(data' 8' 4);                  Array.Reverse(data' 12' 4);              }
Magic Number,Squared.Game.Serialization,Vector4Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: if (!BitConverter.IsLittleEndian) {                  Array.Reverse(data' 0' 4);                  Array.Reverse(data' 4' 4);                  Array.Reverse(data' 8' 4);                  Array.Reverse(data' 12' 4);              }
Magic Number,Squared.Game.Serialization,Vector4Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: if (!BitConverter.IsLittleEndian) {                  Array.Reverse(data' 0' 4);                  Array.Reverse(data' 4' 4);                  Array.Reverse(data' 8' 4);                  Array.Reverse(data' 12' 4);              }
Magic Number,Squared.Game.Serialization,Vector4Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: if (!BitConverter.IsLittleEndian) {                  Array.Reverse(data' 0' 4);                  Array.Reverse(data' 4' 4);                  Array.Reverse(data' 8' 4);                  Array.Reverse(data' 12' 4);              }
Magic Number,Squared.Game.Serialization,Vector4Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: if (!BitConverter.IsLittleEndian) {                  Array.Reverse(data' 0' 4);                  Array.Reverse(data' 4' 4);                  Array.Reverse(data' 8' 4);                  Array.Reverse(data' 12' 4);              }
Magic Number,Squared.Game.Serialization,Vector4Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: if (!BitConverter.IsLittleEndian) {                  Array.Reverse(data' 0' 4);                  Array.Reverse(data' 4' 4);                  Array.Reverse(data' 8' 4);                  Array.Reverse(data' 12' 4);              }
Magic Number,Squared.Game.Serialization,Vector4Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: return new Vector4(                  BitConverter.ToSingle(data' 0)'                  BitConverter.ToSingle(data' 4)'                  BitConverter.ToSingle(data' 8)'                  BitConverter.ToSingle(data' 12)              );
Magic Number,Squared.Game.Serialization,Vector4Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: return new Vector4(                  BitConverter.ToSingle(data' 0)'                  BitConverter.ToSingle(data' 4)'                  BitConverter.ToSingle(data' 8)'                  BitConverter.ToSingle(data' 12)              );
Magic Number,Squared.Game.Serialization,Vector4Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: return new Vector4(                  BitConverter.ToSingle(data' 0)'                  BitConverter.ToSingle(data' 4)'                  BitConverter.ToSingle(data' 8)'                  BitConverter.ToSingle(data' 12)              );
Magic Number,Squared.Game.Serialization,Vector4Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Write,The following statement contains a magic number: var result = new byte[16];
Magic Number,Squared.Game.Serialization,Vector4Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Write,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(inst.X)' 0' result' 0' 4);
Magic Number,Squared.Game.Serialization,Vector4Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Write,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(inst.Y)' 0' result' 4' 4);
Magic Number,Squared.Game.Serialization,Vector4Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Write,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(inst.Y)' 0' result' 4' 4);
Magic Number,Squared.Game.Serialization,Vector4Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Write,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(inst.Z)' 0' result' 8' 4);
Magic Number,Squared.Game.Serialization,Vector4Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Write,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(inst.Z)' 0' result' 8' 4);
Magic Number,Squared.Game.Serialization,Vector4Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Write,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(inst.W)' 0' result' 12' 4);
Magic Number,Squared.Game.Serialization,Vector4Serializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Write,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(inst.W)' 0' result' 12' 4);
Magic Number,Squared.Game.Serialization,PointSerializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: if (!BitConverter.IsLittleEndian) {                  Array.Reverse(data' 0' 4);                  Array.Reverse(data' 4' 4);              }
Magic Number,Squared.Game.Serialization,PointSerializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: if (!BitConverter.IsLittleEndian) {                  Array.Reverse(data' 0' 4);                  Array.Reverse(data' 4' 4);              }
Magic Number,Squared.Game.Serialization,PointSerializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: if (!BitConverter.IsLittleEndian) {                  Array.Reverse(data' 0' 4);                  Array.Reverse(data' 4' 4);              }
Magic Number,Squared.Game.Serialization,PointSerializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: return new Point(                  BitConverter.ToInt32(data' 0)'                  BitConverter.ToInt32(data' 4)              );
Magic Number,Squared.Game.Serialization,PointSerializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Write,The following statement contains a magic number: var result = new byte[8];
Magic Number,Squared.Game.Serialization,PointSerializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Write,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(inst.X)' 0' result' 0' 4);
Magic Number,Squared.Game.Serialization,PointSerializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Write,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(inst.Y)' 0' result' 4' 4);
Magic Number,Squared.Game.Serialization,PointSerializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Write,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(inst.Y)' 0' result' 4' 4);
Magic Number,Squared.Game.Serialization,BoundsSerializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: if (!BitConverter.IsLittleEndian) {                  Array.Reverse(data' 0' 4);                  Array.Reverse(data' 4' 4);                  Array.Reverse(data' 8' 4);                  Array.Reverse(data' 12' 4);              }
Magic Number,Squared.Game.Serialization,BoundsSerializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: if (!BitConverter.IsLittleEndian) {                  Array.Reverse(data' 0' 4);                  Array.Reverse(data' 4' 4);                  Array.Reverse(data' 8' 4);                  Array.Reverse(data' 12' 4);              }
Magic Number,Squared.Game.Serialization,BoundsSerializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: if (!BitConverter.IsLittleEndian) {                  Array.Reverse(data' 0' 4);                  Array.Reverse(data' 4' 4);                  Array.Reverse(data' 8' 4);                  Array.Reverse(data' 12' 4);              }
Magic Number,Squared.Game.Serialization,BoundsSerializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: if (!BitConverter.IsLittleEndian) {                  Array.Reverse(data' 0' 4);                  Array.Reverse(data' 4' 4);                  Array.Reverse(data' 8' 4);                  Array.Reverse(data' 12' 4);              }
Magic Number,Squared.Game.Serialization,BoundsSerializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: if (!BitConverter.IsLittleEndian) {                  Array.Reverse(data' 0' 4);                  Array.Reverse(data' 4' 4);                  Array.Reverse(data' 8' 4);                  Array.Reverse(data' 12' 4);              }
Magic Number,Squared.Game.Serialization,BoundsSerializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: if (!BitConverter.IsLittleEndian) {                  Array.Reverse(data' 0' 4);                  Array.Reverse(data' 4' 4);                  Array.Reverse(data' 8' 4);                  Array.Reverse(data' 12' 4);              }
Magic Number,Squared.Game.Serialization,BoundsSerializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: if (!BitConverter.IsLittleEndian) {                  Array.Reverse(data' 0' 4);                  Array.Reverse(data' 4' 4);                  Array.Reverse(data' 8' 4);                  Array.Reverse(data' 12' 4);              }
Magic Number,Squared.Game.Serialization,BoundsSerializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: return new Bounds(                  new Vector2(                      BitConverter.ToSingle(data' 0)'                      BitConverter.ToSingle(data' 4)                  )'                  new Vector2(                      BitConverter.ToSingle(data' 8)'                      BitConverter.ToSingle(data' 12)                  )              );
Magic Number,Squared.Game.Serialization,BoundsSerializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: return new Bounds(                  new Vector2(                      BitConverter.ToSingle(data' 0)'                      BitConverter.ToSingle(data' 4)                  )'                  new Vector2(                      BitConverter.ToSingle(data' 8)'                      BitConverter.ToSingle(data' 12)                  )              );
Magic Number,Squared.Game.Serialization,BoundsSerializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Read,The following statement contains a magic number: return new Bounds(                  new Vector2(                      BitConverter.ToSingle(data' 0)'                      BitConverter.ToSingle(data' 4)                  )'                  new Vector2(                      BitConverter.ToSingle(data' 8)'                      BitConverter.ToSingle(data' 12)                  )              );
Magic Number,Squared.Game.Serialization,BoundsSerializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Write,The following statement contains a magic number: var result = new byte[16];
Magic Number,Squared.Game.Serialization,BoundsSerializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Write,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(inst.TopLeft.X)' 0' result' 0' 4);
Magic Number,Squared.Game.Serialization,BoundsSerializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Write,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(inst.TopLeft.Y)' 0' result' 4' 4);
Magic Number,Squared.Game.Serialization,BoundsSerializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Write,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(inst.TopLeft.Y)' 0' result' 4' 4);
Magic Number,Squared.Game.Serialization,BoundsSerializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Write,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(inst.BottomRight.X)' 0' result' 8' 4);
Magic Number,Squared.Game.Serialization,BoundsSerializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Write,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(inst.BottomRight.X)' 0' result' 8' 4);
Magic Number,Squared.Game.Serialization,BoundsSerializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Write,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(inst.BottomRight.Y)' 0' result' 12' 4);
Magic Number,Squared.Game.Serialization,BoundsSerializer,C:\repos\sq_Fracture\Squared\GameLib\Serializers.cs,Write,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(inst.BottomRight.Y)' 0' result' 12' 4);
