Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Squared.Util,CurveBase<TValue;TData>,C:\repos\sq_Fracture\Squared\Util\Curve.cs,GetLowerIndexForPosition,Cyclomatic complexity of the method is 10
Complex Method,Squared.Util,CurveExtensions,C:\repos\sq_Fracture\Squared\Util\Curve.cs,SearchInternal,Cyclomatic complexity of the method is 9
Complex Method,Squared.Util.DeclarativeSort,TagOrderingCollection,C:\repos\sq_Fracture\Squared\Util\DeclarativeSort.cs,ToposortVisit,Cyclomatic complexity of the method is 9
Complex Method,Squared.Util.DeclarativeSort,EdgeGraph,C:\repos\sq_Fracture\Squared\Util\DeclarativeSort.cs,Finalize,Cyclomatic complexity of the method is 10
Complex Method,Squared.Util.Event,EventBus,C:\repos\sq_Fracture\Squared\Util\EventBus.cs,BroadcastToSubscribers,Cyclomatic complexity of the method is 8
Long Parameter List,Squared.Util,CurveUtil,C:\repos\sq_Fracture\Squared\Util\Curve.cs,CubicToHermite,The method has 6 parameters. Parameters: a' b' c' d' u' v
Long Parameter List,Squared.Util,CurveUtil,C:\repos\sq_Fracture\Squared\Util\Curve.cs,HermiteToCubic,The method has 6 parameters. Parameters: a' u' d' v' b' c
Long Parameter List,Squared.Util,CurveExtensions,C:\repos\sq_Fracture\Squared\Util\Curve.cs,Search,The method has 7 parameters. Parameters: curve' heuristic' low' high' subdivision' maxRecursion' epsilon
Long Parameter List,Squared.Util,CurveExtensions,C:\repos\sq_Fracture\Squared\Util\Curve.cs,SearchInternal,The method has 10 parameters. Parameters: curve' heuristic' low' high' subdivision' maxRecursion' epsilon' bestScoringPosition' bestScore' depth
Long Parameter List,Squared.Util,IO,C:\repos\sq_Fracture\Squared\Util\IO.cs,SHGetFileInfo,The method has 5 parameters. Parameters: pszPath' dwFileAttributes' psfi' cbSizeFileInfo' uFlags
Long Parameter List,Squared.Util.DeclarativeSort,TagOrderingCollection,C:\repos\sq_Fracture\Squared\Util\DeclarativeSort.cs,ToposortVisit,The method has 6 parameters. Parameters: allEdges' tag' isTopLevel' result' state' nextIndex
Long Parameter List,Squared.Util.Event,EventInfo,C:\repos\sq_Fracture\Squared\Util\EventBus.cs,EventInfo,The method has 6 parameters. Parameters: bus' source' categoryToken' categoryName' type' arguments
Long Parameter List,Squared.Util.RegexExtensions,Extensions,C:\repos\sq_Fracture\Squared\Util\ExpressionParser.cs,TryMatch,The method has 5 parameters. Parameters: regex' input' start' length' match
Long Parameter List,Squared.Util.Expressions,Extensions,C:\repos\sq_Fracture\Squared\Util\ExpressionParser.cs,TryMatch,The method has 5 parameters. Parameters: regex' input' start' length' match
Long Statement,Squared.Util,Arithmetic,C:\repos\sq_Fracture\Squared\Util\Arithmetic.cs,EmitConversion,The length of the statement  "                throw new InvalidOperationException(String.Format("Conversions to type {0} not supported in expressions"' desiredType.Name)); " is 125.
Long Statement,Squared.Util,Arithmetic,C:\repos\sq_Fracture\Squared\Util\Arithmetic.cs,EmitExpressionNode,The length of the statement  "                throw new InvalidOperationException(String.Format("Method calls of type {0} not supported in expressions"' expr.NodeType)); " is 123.
Long Statement,Squared.Util,Arithmetic,C:\repos\sq_Fracture\Squared\Util\Arithmetic.cs,EmitExpressionNode,The length of the statement  "                throw new InvalidOperationException(String.Format("Constants of type {0} not supported in expressions"' expr.Type.Name)); " is 121.
Long Statement,Squared.Util,FastCLRSorter,C:\repos\sq_Fracture\Squared\Util\CLRSort.cs,PickPivotAndPartition,The length of the statement  "            int left = lo' right = hi - 1;  // We already partitioned lo and hi and put the pivot in hi - 1.  And we pre-increment & decrement below. " is 137.
Long Statement,Squared.Util,CurveExtensions,C:\repos\sq_Fracture\Squared\Util\Curve.cs,SplitInto,The length of the statement  "            float firstPosition = spline.GetPositionAtIndex(splitFirstPoint)' secondPosition = spline.GetPositionAtIndex(splitSecondPoint); " is 127.
Long Statement,Squared.Util.DeclarativeSort,PropertySortRule<TProperty>,C:\repos\sq_Fracture\Squared\Util\DeclarativeSort.cs,MakeCompareExpression,The length of the statement  "                var compare = RuntimeComparer.GetType().GetMethod("Compare"' BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance); " is 131.
Long Statement,Squared.Util.LambdaCompiler,Compiler,C:\repos\sq_Fracture\Squared\Util\LambdaCompiler.cs,CompileLambda,The length of the statement  "            var delegateInvokeMethod = delegateType.GetMethod("Invoke"' BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance); " is 130.
Virtual Method Call from Constructor,Squared.Util.DeclarativeSort,SorterComparer,C:\repos\sq_Fracture\Squared\Util\DeclarativeSort.cs,SorterComparer,The constructor "SorterComparer" calls a virtual method "Prepare".
Magic Number,Squared.Util,Arithmetic,C:\repos\sq_Fracture\Squared\Util\Arithmetic.cs,PulseSine,The following statement contains a magic number: const double multiplier = Math.PI / 2;
Magic Number,Squared.Util,Arithmetic,C:\repos\sq_Fracture\Squared\Util\Arithmetic.cs,EmitExpressionNode,The following statement contains a magic number: switch (paramIndex) {                  case 0:                      es.ILGenerator.Emit(OpCodes.Ldarg_0);                      break;                  case 1:                      es.ILGenerator.Emit(OpCodes.Ldarg_1);                      break;                  case 2:                      es.ILGenerator.Emit(OpCodes.Ldarg_2);                      break;                  case 3:                      es.ILGenerator.Emit(OpCodes.Ldarg_3);                      break;                  default:                      es.ILGenerator.Emit(OpCodes.Ldarg' paramIndex);                      break;              }
Magic Number,Squared.Util,Arithmetic,C:\repos\sq_Fracture\Squared\Util\Arithmetic.cs,EmitExpressionNode,The following statement contains a magic number: switch (paramIndex) {                  case 0:                      es.ILGenerator.Emit(OpCodes.Ldarg_0);                      break;                  case 1:                      es.ILGenerator.Emit(OpCodes.Ldarg_1);                      break;                  case 2:                      es.ILGenerator.Emit(OpCodes.Ldarg_2);                      break;                  case 3:                      es.ILGenerator.Emit(OpCodes.Ldarg_3);                      break;                  default:                      es.ILGenerator.Emit(OpCodes.Ldarg' paramIndex);                      break;              }
Magic Number,Squared.Util,Arithmetic,C:\repos\sq_Fracture\Squared\Util\Arithmetic.cs,GenerateArithmeticIL,The following statement contains a magic number: if (argumentTypes.Length >= 2)                  ilGenerator.Emit(OpCodes.Ldarg_1);
Magic Number,Squared.Util,LerpSource<T>,C:\repos\sq_Fracture\Squared\Util\Arithmetic.cs,LerpSource,The following statement contains a magic number: Values = new T[2];
Magic Number,Squared.Util,FastCLRSorter,C:\repos\sq_Fracture\Squared\Util\CLRSort.cs,FloorLog2,The following statement contains a magic number: while (n >= 1) {                  result++;                  n /= 2;              }
Magic Number,Squared.Util,FastCLRSorter,C:\repos\sq_Fracture\Squared\Util\CLRSort.cs,IntrospectiveSort,The following statement contains a magic number: if (length < 2)                  return;
Magic Number,Squared.Util,FastCLRSorter,C:\repos\sq_Fracture\Squared\Util\CLRSort.cs,IntrospectiveSort,The following statement contains a magic number: IntroSort(left' length + left - 1' 2 * FloorLog2(Items.Length));
Magic Number,Squared.Util,FastCLRSorter,C:\repos\sq_Fracture\Squared\Util\CLRSort.cs,IntroSort,The following statement contains a magic number: while (hi > lo) {                  int partitionSize = hi - lo + 1;                  if (partitionSize <= IntrosortSizeThreshold) {                      if (partitionSize == 1) {                          return;                      }                      if (partitionSize == 2) {                          SwapIfGreaterWithItems(lo' hi);                          return;                      }                      if (partitionSize == 3) {                          SwapIfGreaterWithItems(lo' hi-1);                          SwapIfGreaterWithItems(lo' hi);                          SwapIfGreaterWithItems(hi-1' hi);                          return;                      }                        InsertionSort(lo' hi);                      return;                  }                    if (depthLimit == 0) {                      Heapsort(lo' hi);                      return;                  }                    depthLimit--;                    int p = PickPivotAndPartition(lo' hi);                  IntroSort(p + 1' hi' depthLimit);                  hi = p - 1;              }
Magic Number,Squared.Util,FastCLRSorter,C:\repos\sq_Fracture\Squared\Util\CLRSort.cs,IntroSort,The following statement contains a magic number: while (hi > lo) {                  int partitionSize = hi - lo + 1;                  if (partitionSize <= IntrosortSizeThreshold) {                      if (partitionSize == 1) {                          return;                      }                      if (partitionSize == 2) {                          SwapIfGreaterWithItems(lo' hi);                          return;                      }                      if (partitionSize == 3) {                          SwapIfGreaterWithItems(lo' hi-1);                          SwapIfGreaterWithItems(lo' hi);                          SwapIfGreaterWithItems(hi-1' hi);                          return;                      }                        InsertionSort(lo' hi);                      return;                  }                    if (depthLimit == 0) {                      Heapsort(lo' hi);                      return;                  }                    depthLimit--;                    int p = PickPivotAndPartition(lo' hi);                  IntroSort(p + 1' hi' depthLimit);                  hi = p - 1;              }
Magic Number,Squared.Util,FastCLRSorter,C:\repos\sq_Fracture\Squared\Util\CLRSort.cs,PickPivotAndPartition,The following statement contains a magic number: int mid = lo + (hi - lo) / 2;
Magic Number,Squared.Util,FastCLRSorter,C:\repos\sq_Fracture\Squared\Util\CLRSort.cs,Heapsort,The following statement contains a magic number: for (int i = n / 2; i >= 1; i = i - 1) {                  DownHeap(i' n' lo);              }
Magic Number,Squared.Util,FastCLRSorter,C:\repos\sq_Fracture\Squared\Util\CLRSort.cs,DownHeap,The following statement contains a magic number: while (i <= n / 2) {                  child = 2 * i;                  if (child < n && Comparer.Compare(Items[lo + child - 1]' Items[lo + child]) < 0) {                      child++;                  }                    if (!(Comparer.Compare(d' Items[lo + child - 1]) < 0))                      break;                    Items[lo + i - 1] = Items[lo + child - 1];                  i = child;              }
Magic Number,Squared.Util,FastCLRSorter,C:\repos\sq_Fracture\Squared\Util\CLRSort.cs,DownHeap,The following statement contains a magic number: while (i <= n / 2) {                  child = 2 * i;                  if (child < n && Comparer.Compare(Items[lo + child - 1]' Items[lo + child]) < 0) {                      child++;                  }                    if (!(Comparer.Compare(d' Items[lo + child - 1]) < 0))                      break;                    Items[lo + i - 1] = Items[lo + child - 1];                  i = child;              }
Magic Number,Squared.Util,GrowableBuffer<T>,C:\repos\sq_Fracture\Squared\Util\Buffer.cs,Grow,The following statement contains a magic number: while (bufferSize < newLength)                  bufferSize *= 2;
Magic Number,Squared.Util,GrowableBuffer<T>,C:\repos\sq_Fracture\Squared\Util\Buffer.cs,Append,The following statement contains a magic number: while (bufferSize < newLength)                  bufferSize *= 2;
Magic Number,Squared.Util,GrowableBuffer<T>,C:\repos\sq_Fracture\Squared\Util\Buffer.cs,Append,The following statement contains a magic number: if (_Length == bufferSize)                  ResizeBuffer(bufferSize * 2);
Magic Number,Squared.Util,CurveBase<TValue;TData>,C:\repos\sq_Fracture\Squared\Util\Curve.cs,GetLowerIndexForPosition,The following statement contains a magic number: while (low <= high) {                  if (low == high)                      return low;                    index = (low + high) / 2;                  nextIndex = (index >= max) ? max : index + 1;                    var indexItem = _Items[index];                    if (indexItem.Position < position) {                      if (_Items[nextIndex].Position > position) {                          return index;                      } else {                          low = index + 1;                      }                  } else if (indexItem.Position == position) {                      return index;                  } else {                      high = index - 1;                  }              }
Magic Number,Squared.Util,HermiteSpline<T>,C:\repos\sq_Fracture\Squared\Util\Curve.cs,GetValueAtPosition,The following statement contains a magic number: if (lowerItem.Position < upperItem.Position) {                  float offset = (position - lowerItem.Position) / (upperItem.Position - lowerItem.Position);                    if (offset < 0.0f)                      offset = 0.0f;                  else if (offset > 1.0f)                      offset = 1.0f;                    return _Interpolator(_InterpolatorSource' (index * 2)' offset);              } else {                  return lowerItem.Value;              }
Magic Number,Squared.Util,HermiteSpline<T>,C:\repos\sq_Fracture\Squared\Util\Curve.cs,GetHermiteInputForIndex,The following statement contains a magic number: int quadIndex = index / 4' itemInQuad = index % 4;
Magic Number,Squared.Util,HermiteSpline<T>,C:\repos\sq_Fracture\Squared\Util\Curve.cs,GetHermiteInputForIndex,The following statement contains a magic number: int quadIndex = index / 4' itemInQuad = index % 4;
Magic Number,Squared.Util,HermiteSpline<T>,C:\repos\sq_Fracture\Squared\Util\Curve.cs,GetHermiteInputForIndex,The following statement contains a magic number: int aIndex = (quadIndex * 2)' dIndex = aIndex + 1;
Magic Number,Squared.Util,HermiteSpline<T>,C:\repos\sq_Fracture\Squared\Util\Curve.cs,GetHermiteInputForIndex,The following statement contains a magic number: switch (itemInQuad) {                  case 0: // A                      return GetValueAtIndex(aIndex);                  case 1: // U                      return GetDataAtIndex(aIndex).Velocity;                  case 2: // D                      return GetValueAtIndex(dIndex);                  default:                  case 3: // V                      return GetDataAtIndex(dIndex).Velocity;              }
Magic Number,Squared.Util,HermiteSpline<T>,C:\repos\sq_Fracture\Squared\Util\Curve.cs,GetHermiteInputForIndex,The following statement contains a magic number: switch (itemInQuad) {                  case 0: // A                      return GetValueAtIndex(aIndex);                  case 1: // U                      return GetDataAtIndex(aIndex).Velocity;                  case 2: // D                      return GetValueAtIndex(dIndex);                  default:                  case 3: // V                      return GetDataAtIndex(dIndex).Velocity;              }
Magic Number,Squared.Util,HermiteSpline<T>,C:\repos\sq_Fracture\Squared\Util\Curve.cs,ConvertToCardinal,The following statement contains a magic number: for (int start = 1' end = _Items.Count - 2' i = start; i <= end; i++) {                  var previous = _Items[i - 1];                  var pt = _Items[i];                  var next = _Items[i + 1];                    var tangent = _Sub(next.Value' previous.Value);                  pt.Data.Velocity = _Mul(tangent' tensionFactor);                  _Items[i] = pt;              }
Magic Number,Squared.Util,CurveExtensions,C:\repos\sq_Fracture\Squared\Util\Curve.cs,SearchInternal,The following statement contains a magic number: if (subdivision < 2)                  subdivision = 2;
Magic Number,Squared.Util,CurveExtensions,C:\repos\sq_Fracture\Squared\Util\Curve.cs,SearchInternal,The following statement contains a magic number: if (subdivision < 2)                  subdivision = 2;
Magic Number,Squared.Util,CurveExtensions,C:\repos\sq_Fracture\Squared\Util\Curve.cs,SearchInternal,The following statement contains a magic number: if (depth == 0) {                  actualSubdivision = Math.Min(1024' curve.Count * 2);                  actualSubdivision = Math.Max(actualSubdivision' subdivision);              }
Magic Number,Squared.Util,CurveExtensions,C:\repos\sq_Fracture\Squared\Util\Curve.cs,SearchInternal,The following statement contains a magic number: if (depth == 0) {                  actualSubdivision = Math.Min(1024' curve.Count * 2);                  actualSubdivision = Math.Max(actualSubdivision' subdivision);              }
Magic Number,Squared.Util,CurveExtensions,C:\repos\sq_Fracture\Squared\Util\Curve.cs,Split,The following statement contains a magic number: var resultList = new List<HermiteSpline<T>>(4);
Magic Number,Squared.Util,Interpolators<T>,C:\repos\sq_Fracture\Squared\Util\Interpolators.cs,Cubic,The following statement contains a magic number: T d = data(dataOffset + 2);
Magic Number,Squared.Util,Interpolators<T>,C:\repos\sq_Fracture\Squared\Util\Interpolators.cs,Hermite,The following statement contains a magic number: T d = data(dataOffset + 2);
Magic Number,Squared.Util,Interpolators<T>,C:\repos\sq_Fracture\Squared\Util\Interpolators.cs,Hermite,The following statement contains a magic number: T v = data(dataOffset + 3);
Magic Number,Squared.Util,Interpolators<T>,C:\repos\sq_Fracture\Squared\Util\Interpolators.cs,Hermite,The following statement contains a magic number: var t2 = positionInWindow * 2;
Magic Number,Squared.Util,Interpolators<T>,C:\repos\sq_Fracture\Squared\Util\Interpolators.cs,Hermite,The following statement contains a magic number: var s2 = s * 2;
Magic Number,Squared.Util,Interpolators<T>,C:\repos\sq_Fracture\Squared\Util\Interpolators.cs,Cubic,The following statement contains a magic number: T d = data(ref obj' dataOffset + 2);
Magic Number,Squared.Util,Interpolators<T>,C:\repos\sq_Fracture\Squared\Util\Interpolators.cs,Hermite,The following statement contains a magic number: T d = data(ref obj' dataOffset + 2);
Magic Number,Squared.Util,Interpolators<T>,C:\repos\sq_Fracture\Squared\Util\Interpolators.cs,Hermite,The following statement contains a magic number: T v = data(ref obj' dataOffset + 3);
Magic Number,Squared.Util,Interpolators<T>,C:\repos\sq_Fracture\Squared\Util\Interpolators.cs,Hermite,The following statement contains a magic number: var t2 = positionInWindow * 2;
Magic Number,Squared.Util,Interpolators<T>,C:\repos\sq_Fracture\Squared\Util\Interpolators.cs,Hermite,The following statement contains a magic number: var s2 = s * 2;
Magic Number,Squared.Util,Interpolators<T>,C:\repos\sq_Fracture\Squared\Util\Interpolators.cs,Interpolate,The following statement contains a magic number: if ((_TemporaryValues == null) || (_TemporaryValues.Length < 2))                  _TemporaryValues = new T[2];
Magic Number,Squared.Util,Interpolators<T>,C:\repos\sq_Fracture\Squared\Util\Interpolators.cs,Interpolate,The following statement contains a magic number: if ((_TemporaryValues == null) || (_TemporaryValues.Length < 2))                  _TemporaryValues = new T[2];
Magic Number,Squared.Util,Interpolators<T>,C:\repos\sq_Fracture\Squared\Util\Interpolators.cs,Interpolate,The following statement contains a magic number: _NumTemporaryValues = 2;
Magic Number,Squared.Util,IO,C:\repos\sq_Fracture\Squared\Util\IO.cs,DetectStreamEncoding,The following statement contains a magic number: var buffer = new char[256];
Magic Number,Squared.Util,IO,C:\repos\sq_Fracture\Squared\Util\IO.cs,GlobToRegex,The following statement contains a magic number: if (glob.EndsWith(".*"))                  glob = glob.Substring(0' glob.Length - 2);
Magic Number,Squared.Util,HeapQueue<T>,C:\repos\sq_Fracture\Squared\Util\PriorityQueue.cs,SiftUp,The following statement contains a magic number: int childPosition = 2 * position + 1;
Magic Number,Squared.Util,HeapQueue<T>,C:\repos\sq_Fracture\Squared\Util\PriorityQueue.cs,SiftUp,The following statement contains a magic number: while (childPosition < endPosition) {                  rightPosition = childPosition + 1;                  if ((rightPosition < endPosition) && (                      comparer(buffer[rightPosition]' buffer[childPosition]) <= 0                  ))                      childPosition = rightPosition;                    buffer[position] = buffer[childPosition];                  buffer[childPosition] = default(T);                    position = childPosition;                  childPosition = 2 * position + 1;              }
Magic Number,Squared.Util,HeapQueue<T>,C:\repos\sq_Fracture\Squared\Util\PriorityQueue.cs,Heapify,The following statement contains a magic number: var positions = Enumerable.Range(0' count / 2).Reverse();
Magic Number,Squared.Util,PriorityQueue<T>,C:\repos\sq_Fracture\Squared\Util\PriorityQueue.cs,Grow,The following statement contains a magic number: if (_Count > _Buffer.Length)                  Resize(_Buffer.Length * 2);
Magic Number,Squared.Util,ScalableTimeProvider,C:\repos\sq_Fracture\Squared\Util\TimeProvider.cs,OnTimeScaleChange,The following statement contains a magic number: _Offset += (ticks - offset) * oldTimeScale / 10000;
Magic Number,Squared.Util,UnorderedList<T>,C:\repos\sq_Fracture\Squared\Util\UnorderedList.cs,EnsureCapacity,The following statement contains a magic number: var newCapacity = 1 << (int)Math.Ceiling(Math.Log(capacity' 2));
Magic Number,Squared.Util.DeclarativeSort,TagArrayComparer,C:\repos\sq_Fracture\Squared\Util\DeclarativeSort.cs,GetHashCode,The following statement contains a magic number: foreach (var tag in tags)                      result = (result << 2) ^ tag.Id;
Magic Number,Squared.Util.DeclarativeSort,TagOrdering,C:\repos\sq_Fracture\Squared\Util\DeclarativeSort.cs,TagOrdering,The following statement contains a magic number: HashCode = Lower.GetHashCode() ^ (Higher.GetHashCode() << 2);
Magic Number,Squared.Util.Event,EventBus,C:\repos\sq_Fracture\Squared\Util\EventBus.cs,BroadcastToSubscribers,The following statement contains a magic number: for (int i = 0; i < 6; i++) {                  string typeFilter = (i & 1) == 1 ? type : AnyType;                  object sourceFilter;                    switch (i) {                      case 0:                      case 1:                          sourceFilter = AnySource;                          break;                      case 2:                      case 3:                          sourceFilter = categoryToken;                          break;                      default:                          sourceFilter = source;                          break;                  }                    if ((sourceFilter == null) || (typeFilter == null))                      continue;                    CreateFilter(                      sourceFilter'                      typeFilter'                      out filter'                      false                  );                    if (!_Subscribers.TryGetValue(filter' out subscribers))                      continue;                    int count = subscribers.Count;                  if (count <= 0)                      continue;                    if (info == null)                      info = new EventInfo(this' source' categoryToken' categoryName' type' arguments);                    using (var b = BufferPool<EventSubscriber>.Allocate(count)) {                      var temp = b.Data;                      subscribers.CopyTo(temp);                        for (int j = count - 1; j >= 0; j--) {                          temp[j](info);                            if (info.IsConsumed)                              return;                      }                        b.Clear();                  }              }
Magic Number,Squared.Util.Event,EventBus,C:\repos\sq_Fracture\Squared\Util\EventBus.cs,BroadcastToSubscribers,The following statement contains a magic number: for (int i = 0; i < 6; i++) {                  string typeFilter = (i & 1) == 1 ? type : AnyType;                  object sourceFilter;                    switch (i) {                      case 0:                      case 1:                          sourceFilter = AnySource;                          break;                      case 2:                      case 3:                          sourceFilter = categoryToken;                          break;                      default:                          sourceFilter = source;                          break;                  }                    if ((sourceFilter == null) || (typeFilter == null))                      continue;                    CreateFilter(                      sourceFilter'                      typeFilter'                      out filter'                      false                  );                    if (!_Subscribers.TryGetValue(filter' out subscribers))                      continue;                    int count = subscribers.Count;                  if (count <= 0)                      continue;                    if (info == null)                      info = new EventInfo(this' source' categoryToken' categoryName' type' arguments);                    using (var b = BufferPool<EventSubscriber>.Allocate(count)) {                      var temp = b.Data;                      subscribers.CopyTo(temp);                        for (int j = count - 1; j >= 0; j--) {                          temp[j](info);                            if (info.IsConsumed)                              return;                      }                        b.Clear();                  }              }
Magic Number,Squared.Util.Event,EventBus,C:\repos\sq_Fracture\Squared\Util\EventBus.cs,BroadcastToSubscribers,The following statement contains a magic number: for (int i = 0; i < 6; i++) {                  string typeFilter = (i & 1) == 1 ? type : AnyType;                  object sourceFilter;                    switch (i) {                      case 0:                      case 1:                          sourceFilter = AnySource;                          break;                      case 2:                      case 3:                          sourceFilter = categoryToken;                          break;                      default:                          sourceFilter = source;                          break;                  }                    if ((sourceFilter == null) || (typeFilter == null))                      continue;                    CreateFilter(                      sourceFilter'                      typeFilter'                      out filter'                      false                  );                    if (!_Subscribers.TryGetValue(filter' out subscribers))                      continue;                    int count = subscribers.Count;                  if (count <= 0)                      continue;                    if (info == null)                      info = new EventInfo(this' source' categoryToken' categoryName' type' arguments);                    using (var b = BufferPool<EventSubscriber>.Allocate(count)) {                      var temp = b.Data;                      subscribers.CopyTo(temp);                        for (int j = count - 1; j >= 0; j--) {                          temp[j](info);                            if (info.IsConsumed)                              return;                      }                        b.Clear();                  }              }
