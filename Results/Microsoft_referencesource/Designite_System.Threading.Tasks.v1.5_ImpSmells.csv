Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,ExecuteSelfReplicating,The method has 104 lines of code.
Long Method,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Wait,The method has 126 lines of code.
Complex Method,System.Collections.Concurrent,ConcurrentDictionary<TKey;TValue>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,TryAddInternal,Cyclomatic complexity of the method is 10
Complex Method,System.Collections.Concurrent,ConcurrentDictionary<TKey;TValue>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,CopyTo,Cyclomatic complexity of the method is 8
Complex Method,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,InternalRunSynchronously,Cyclomatic complexity of the method is 8
Complex Method,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,WaitAll,Cyclomatic complexity of the method is 14
Complex Method,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,ExecuteCallbackHandlers,Cyclomatic complexity of the method is 9
Complex Method,System.Threading,SparselyPopulatedArray<T>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,Add,Cyclomatic complexity of the method is 10
Complex Method,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Wait,Cyclomatic complexity of the method is 8
Complex Method,System.Threading,SpinWait,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\SpinWait.cs,SpinUntil,Cyclomatic complexity of the method is 8
Long Parameter List,System,Lightup,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Lightup\Lightup.cs,TryCall,The method has 5 parameters. Parameters: storage' instance' methodName' parameter1' parameter2
Long Parameter List,System.Collections.Concurrent,ConcurrentDictionary<TKey;TValue>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,TryAddInternal,The method has 5 parameters. Parameters: key' value' updateIfExists' acquireLock' resultingValue
Long Parameter List,System.Threading.Tasks,Task<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,Task,The method has 7 parameters. Parameters: valueSelector' parent' cancellationToken' creationOptions' internalOptions' scheduler' stackMark
Long Parameter List,System.Threading.Tasks,Task<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,Task,The method has 6 parameters. Parameters: valueSelector' parent' cancellationToken' creationOptions' internalOptions' scheduler
Long Parameter List,System.Threading.Tasks,Task<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,Task,The method has 8 parameters. Parameters: valueSelector' state' parent' cancellationToken' creationOptions' internalOptions' scheduler' stackMark
Long Parameter List,System.Threading.Tasks,Task<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,Task,The method has 7 parameters. Parameters: valueSelector' state' parent' cancellationToken' creationOptions' internalOptions' scheduler
Long Parameter List,System.Threading.Tasks,Task<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,StartNew,The method has 7 parameters. Parameters: parent' function' cancellationToken' creationOptions' internalOptions' scheduler' stackMark
Long Parameter List,System.Threading.Tasks,Task<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,StartNew,The method has 8 parameters. Parameters: parent' function' state' cancellationToken' creationOptions' internalOptions' scheduler' stackMark
Long Parameter List,System.Threading.Tasks,Task<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,ContinueWith,The method has 5 parameters. Parameters: continuationAction' scheduler' cancellationToken' continuationOptions' stackMark
Long Parameter List,System.Threading.Tasks,Task<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,ContinueWith,The method has 5 parameters. Parameters: continuationFunction' scheduler' cancellationToken' continuationOptions' stackMark
Long Parameter List,System.Threading.Tasks,TaskFactory<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,StartNew,The method has 5 parameters. Parameters: function' state' cancellationToken' creationOptions' scheduler
Long Parameter List,System.Threading.Tasks,TaskFactory<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,FromAsyncImpl,The method has 5 parameters. Parameters: asyncResult' endMethod' creationOptions' scheduler' stackMark
Long Parameter List,System.Threading.Tasks,TaskFactory<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,FromAsync,The method has 5 parameters. Parameters: beginMethod' endMethod' arg1' state' creationOptions
Long Parameter List,System.Threading.Tasks,TaskFactory<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,FromAsyncImpl,The method has 5 parameters. Parameters: beginMethod' endMethod' arg1' state' creationOptions
Long Parameter List,System.Threading.Tasks,TaskFactory<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,FromAsync,The method has 5 parameters. Parameters: beginMethod' endMethod' arg1' arg2' state
Long Parameter List,System.Threading.Tasks,TaskFactory<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,FromAsync,The method has 6 parameters. Parameters: beginMethod' endMethod' arg1' arg2' state' creationOptions
Long Parameter List,System.Threading.Tasks,TaskFactory<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,FromAsyncImpl,The method has 6 parameters. Parameters: beginMethod' endMethod' arg1' arg2' state' creationOptions
Long Parameter List,System.Threading.Tasks,TaskFactory<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,FromAsync,The method has 6 parameters. Parameters: beginMethod' endMethod' arg1' arg2' arg3' state
Long Parameter List,System.Threading.Tasks,TaskFactory<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,FromAsync,The method has 7 parameters. Parameters: beginMethod' endMethod' arg1' arg2' arg3' state' creationOptions
Long Parameter List,System.Threading.Tasks,TaskFactory<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,FromAsyncImpl,The method has 7 parameters. Parameters: beginMethod' endMethod' arg1' arg2' arg3' state' creationOptions
Long Parameter List,System.Threading.Tasks,TaskFactory<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAll,The method has 5 parameters. Parameters: tasks' continuationFunction' cancellationToken' continuationOptions' scheduler
Long Parameter List,System.Threading.Tasks,TaskFactory<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAll,The method has 6 parameters. Parameters: tasks' continuationFunction' continuationOptions' cancellationToken' scheduler' stackMark
Long Parameter List,System.Threading.Tasks,TaskFactory<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAll,The method has 5 parameters. Parameters: tasks' continuationFunction' cancellationToken' continuationOptions' scheduler
Long Parameter List,System.Threading.Tasks,TaskFactory<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAll,The method has 6 parameters. Parameters: tasks' continuationFunction' continuationOptions' cancellationToken' scheduler' stackMark
Long Parameter List,System.Threading.Tasks,TaskFactory<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAny,The method has 5 parameters. Parameters: tasks' continuationFunction' cancellationToken' continuationOptions' scheduler
Long Parameter List,System.Threading.Tasks,TaskFactory<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAny,The method has 6 parameters. Parameters: tasks' continuationFunction' continuationOptions' cancellationToken' scheduler' stackMark
Long Parameter List,System.Threading.Tasks,TaskFactory<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAny,The method has 5 parameters. Parameters: tasks' continuationFunction' cancellationToken' continuationOptions' scheduler
Long Parameter List,System.Threading.Tasks,TaskFactory<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAny,The method has 6 parameters. Parameters: tasks' continuationFunction' continuationOptions' cancellationToken' scheduler' stackMark
Long Parameter List,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,Task,The method has 5 parameters. Parameters: state' cancelationToken' creationOptions' internalOptions' promiseStyle
Long Parameter List,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,Task,The method has 8 parameters. Parameters: action' state' parent' cancellationToken' creationOptions' internalOptions' scheduler' stackMark
Long Parameter List,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,Task,The method has 7 parameters. Parameters: action' state' parent' cancellationToken' creationOptions' internalOptions' scheduler
Long Parameter List,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,TaskConstructorCore,The method has 6 parameters. Parameters: action' state' cancellationToken' creationOptions' internalOptions' scheduler
Long Parameter List,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,InternalStartNew,The method has 8 parameters. Parameters: creatingTask' action' state' cancellationToken' scheduler' options' internalOptions' stackMark
Long Parameter List,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,CreateReplicaTask,The method has 6 parameters. Parameters: taskReplicaDelegate' stateObject' parentTask' taskScheduler' creationOptionsForReplica' internalOptionsForReplica
Long Parameter List,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,ContinueWith,The method has 5 parameters. Parameters: continuationAction' scheduler' cancellationToken' continuationOptions' stackMark
Long Parameter List,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,ContinueWith,The method has 5 parameters. Parameters: continuationFunction' scheduler' cancellationToken' continuationOptions' stackMark
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,StartNew,The method has 5 parameters. Parameters: action' cancellationToken' creationOptions' internalOptions' scheduler
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,StartNew,The method has 5 parameters. Parameters: action' state' cancellationToken' creationOptions' scheduler
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,StartNew,The method has 5 parameters. Parameters: function' state' cancellationToken' creationOptions' scheduler
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,FromAsync,The method has 5 parameters. Parameters: asyncResult' endMethod' creationOptions' scheduler' stackMark
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,FromAsync,The method has 5 parameters. Parameters: beginMethod' endMethod' arg1' state' creationOptions
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,FromAsync,The method has 5 parameters. Parameters: beginMethod' endMethod' arg1' arg2' state
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,FromAsync,The method has 6 parameters. Parameters: beginMethod' endMethod' arg1' arg2' state' creationOptions
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,FromAsync,The method has 6 parameters. Parameters: beginMethod' endMethod' arg1' arg2' arg3' state
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,FromAsync,The method has 7 parameters. Parameters: beginMethod' endMethod' arg1' arg2' arg3' state' creationOptions
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,FromAsync,The method has 5 parameters. Parameters: beginMethod' endMethod' arg1' state' creationOptions
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,FromAsync,The method has 5 parameters. Parameters: beginMethod' endMethod' arg1' arg2' state
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,FromAsync,The method has 6 parameters. Parameters: beginMethod' endMethod' arg1' arg2' state' creationOptions
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,FromAsync,The method has 6 parameters. Parameters: beginMethod' endMethod' arg1' arg2' arg3' state
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,FromAsync,The method has 7 parameters. Parameters: beginMethod' endMethod' arg1' arg2' arg3' state' creationOptions
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The method has 5 parameters. Parameters: tasks' continuationAction' cancellationToken' continuationOptions' scheduler
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The method has 6 parameters. Parameters: tasks' continuationAction' continuationOptions' cancellationToken' scheduler' stackMark
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The method has 5 parameters. Parameters: tasks' continuationAction' cancellationToken' continuationOptions' scheduler
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The method has 6 parameters. Parameters: tasks' continuationAction' continuationOptions' cancellationToken' scheduler' stackMark
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The method has 5 parameters. Parameters: tasks' continuationFunction' cancellationToken' continuationOptions' scheduler
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The method has 6 parameters. Parameters: tasks' continuationFunction' continuationOptions' cancellationToken' scheduler' stackMark
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The method has 5 parameters. Parameters: tasks' continuationFunction' cancellationToken' continuationOptions' scheduler
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The method has 6 parameters. Parameters: tasks' continuationFunction' continuationOptions' cancellationToken' scheduler' stackMark
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The method has 5 parameters. Parameters: tasks' continuationAction' cancellationToken' continuationOptions' scheduler
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The method has 6 parameters. Parameters: tasks' continuationAction' continuationOptions' cancellationToken' scheduler' stackMark
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The method has 5 parameters. Parameters: tasks' continuationFunction' cancellationToken' continuationOptions' scheduler
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The method has 6 parameters. Parameters: tasks' continuationFunction' continuationOptions' cancellationToken' scheduler' stackMark
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The method has 5 parameters. Parameters: tasks' continuationFunction' cancellationToken' continuationOptions' scheduler
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The method has 6 parameters. Parameters: tasks' continuationFunction' continuationOptions' cancellationToken' scheduler' stackMark
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The method has 5 parameters. Parameters: tasks' continuationAction' cancellationToken' continuationOptions' scheduler
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The method has 6 parameters. Parameters: tasks' continuationAction' continuationOptions' cancellationToken' scheduler' stackMark
Long Identifier,System.Collections.Concurrent,ConcurrentDictionary<TKey;TValue>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,,The length of the parameter m_serializationConcurrencyLevel is 31.
Long Identifier,System.Collections.Concurrent,ConcurrentDictionary<TKey;TValue>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,,The length of the parameter DEFAULT_CONCURRENCY_MULTIPLIER is 30.
Long Identifier,System.Runtime.CompilerServices,AsyncVoidMethodBuilder,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Runtime\CompilerServices\AsyncVoidMethodBuilder.cs,,The length of the parameter s_preventUnobservedTaskExceptionsInvoked is 40.
Long Identifier,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,InternalCancel,The length of the parameter bRequiresAtomicStartTransition is 30.
Long Identifier,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,,The length of the parameter TASK_STATE_EXCEPTIONOBSERVEDBYPARENT is 36.
Long Identifier,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,,The length of the parameter TASK_STATE_CANCELLATIONACKNOWLEDGED is 35.
Long Identifier,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,,The length of the parameter TASK_STATE_WAITING_ON_CHILDREN is 30.
Long Identifier,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,,The length of the parameter TASK_STATE_WAITINGFORACTIVATION is 31.
Long Identifier,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,,The length of the parameter TASK_STATE_COMPLETION_RESERVED is 30.
Long Identifier,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,,The length of the parameter s_IsExceptionObservedByParentPredicate is 38.
Long Identifier,System.Threading.Tasks,ContingentProperties,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,,The length of the parameter m_internalCancellationRequested is 31.
Long Identifier,System.Threading.Tasks,TaskScheduler,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskScheduler.cs,,The length of the parameter _unobservedTaskExceptionLockObject is 34.
Long Identifier,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,UpdateTimeOut,The length of the parameter originalWaitMillisecondsTimeout is 31.
Long Identifier,System.Threading,PlatformHelper,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\SpinWait.cs,,The length of the parameter PROCESSOR_COUNT_REFRESH_INTERVAL_MS is 35.
Long Identifier,System.Threading,PlatformHelper,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\SpinWait.cs,,The length of the parameter s_nextProcessorCountRefreshTime is 31.
Long Identifier,System.Threading,ThreadingServices,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ThreadingServices.cs,,The length of the parameter AppDomainUnloadedExceptionType is 30.
Long Statement,System,AggregateException,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\AggregateException.cs,GetBaseException,The length of the statement  "            // Recursively traverse the inner exceptions as long as the inner exception of type AggregateException and has only one inner exception " is 135.
Long Statement,System,ExecutionContextLightup,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Lightup\ExecutionContextLightup.cs,Run,The length of the statement  "            Type actionRepresentingSignature = typeof(Action<''>).MakeGenericType(LightupType.ExecutionContext' LightupType.ContextCallback' typeof(object)); " is 145.
Long Statement,System,LightupServices,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Lightup\Lightup.cs,IsActionType,The length of the statement  "            return type == typeof(Action) || type == typeof(Action<>) || type == typeof(Action<'>) || type == typeof(Action<''>) || type == typeof(Action<'''>); " is 148.
Long Statement,System.Collections.Concurrent,ConcurrentDictionary<TKey;TValue>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,Remove,The length of the statement  "            if (keyValuePair.Key == null) throw new ArgumentNullException(Strings.ConcurrentDictionary_ItemKeyIsNull' "keyValuePair"); " is 122.
Long Statement,System.Collections.Concurrent,ConcurrentDictionary<TKey;TValue>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The length of the statement  "                // Compute the new table size. We find the smallest integer larger than twice the previous table size' and not divisible by " is 123.
Long Statement,System.Runtime.CompilerServices,AsyncMethodBuilderCore,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Runtime\CompilerServices\AsyncMethodBuilderCore.cs,GetCompletionAction,The length of the statement  "                Contract.Assert(!Object.ReferenceEquals((object)stateMachine' (object)stateMachine)' "Expected an unboxed state machine reference"); " is 132.
Long Statement,System.Threading.Tasks,Task<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,StartNew,The length of the statement  "            Task<TResult> f = new Task<TResult>(function' parent' cancellationToken' creationOptions' internalOptions | InternalTaskOptions.QueuedByRuntime' scheduler' ref stackMark); " is 171.
Long Statement,System.Threading.Tasks,Task<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,StartNew,The length of the statement  "            Task<TResult> f = new Task<TResult>(function' state' parent' cancellationToken' creationOptions' internalOptions | InternalTaskOptions.QueuedByRuntime' scheduler' ref stackMark); " is 178.
Long Statement,System.Threading.Tasks,Task<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,ContinueWith,The length of the statement  "            return ContinueWith(continuationAction' TaskScheduler.Current' CancellationToken.None' TaskContinuationOptions.None' ref stackMark); " is 132.
Long Statement,System.Threading.Tasks,Task<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,ContinueWith,The length of the statement  "            return ContinueWith(continuationAction' TaskScheduler.Current' cancellationToken' TaskContinuationOptions.None' ref stackMark); " is 127.
Long Statement,System.Threading.Tasks,Task<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,ContinueWith,The length of the statement  "            return ContinueWith(continuationAction' scheduler' CancellationToken.None' TaskContinuationOptions.None' ref stackMark); " is 120.
Long Statement,System.Threading.Tasks,Task<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,ContinueWith,The length of the statement  "            return ContinueWith(continuationAction' TaskScheduler.Current' CancellationToken.None' continuationOptions' ref stackMark); " is 123.
Long Statement,System.Threading.Tasks,Task<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,ContinueWith,The length of the statement  "            return ContinueWith<TNewResult>(continuationFunction' TaskScheduler.Current' CancellationToken.None' TaskContinuationOptions.None' ref stackMark); " is 146.
Long Statement,System.Threading.Tasks,Task<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,ContinueWith,The length of the statement  "            return ContinueWith<TNewResult>(continuationFunction' TaskScheduler.Current' cancellationToken' TaskContinuationOptions.None' ref stackMark); " is 141.
Long Statement,System.Threading.Tasks,Task<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,ContinueWith,The length of the statement  "            return ContinueWith<TNewResult>(continuationFunction' scheduler' CancellationToken.None' TaskContinuationOptions.None' ref stackMark); " is 134.
Long Statement,System.Threading.Tasks,Task<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,ContinueWith,The length of the statement  "            return ContinueWith<TNewResult>(continuationFunction' TaskScheduler.Current' CancellationToken.None' continuationOptions' ref stackMark); " is 137.
Long Statement,System.Threading.Tasks,Task<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,ContinueWith,The length of the statement  "            return ContinueWith<TNewResult>(continuationFunction' scheduler' cancellationToken' continuationOptions' ref stackMark); " is 120.
Long Statement,System.Threading.Tasks,TaskFactory<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAll,The length of the statement  "            return ContinueWhenAll(tasks' continuationFunction' m_defaultContinuationOptions' m_defaultCancellationToken' DefaultScheduler' ref stackMark); " is 143.
Long Statement,System.Threading.Tasks,TaskFactory<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAll,The length of the statement  "            return ContinueWhenAll(tasks' continuationFunction' m_defaultContinuationOptions' cancellationToken' DefaultScheduler' ref stackMark); " is 134.
Long Statement,System.Threading.Tasks,TaskFactory<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAll,The length of the statement  "            return ContinueWhenAll(tasks' continuationFunction' continuationOptions' m_defaultCancellationToken' DefaultScheduler' ref stackMark); " is 134.
Long Statement,System.Threading.Tasks,TaskFactory<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAll,The length of the statement  "            return ContinueWhenAll<TAntecedentResult>(tasks' continuationFunction' m_defaultContinuationOptions' m_defaultCancellationToken' DefaultScheduler' ref stackMark); " is 162.
Long Statement,System.Threading.Tasks,TaskFactory<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAll,The length of the statement  "            return ContinueWhenAll<TAntecedentResult>(tasks' continuationFunction' m_defaultContinuationOptions' cancellationToken' DefaultScheduler' ref stackMark); " is 153.
Long Statement,System.Threading.Tasks,TaskFactory<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAll,The length of the statement  "            return ContinueWhenAll<TAntecedentResult>(tasks' continuationFunction' continuationOptions' m_defaultCancellationToken' DefaultScheduler' ref stackMark); " is 153.
Long Statement,System.Threading.Tasks,TaskFactory<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAll,The length of the statement  "            return ContinueWhenAll<TAntecedentResult>(tasks' continuationFunction' continuationOptions' cancellationToken' scheduler' ref stackMark); " is 137.
Long Statement,System.Threading.Tasks,TaskFactory<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAny,The length of the statement  "            return ContinueWhenAny(tasks' continuationFunction' m_defaultContinuationOptions' m_defaultCancellationToken' DefaultScheduler' ref stackMark); " is 143.
Long Statement,System.Threading.Tasks,TaskFactory<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAny,The length of the statement  "            return ContinueWhenAny(tasks' continuationFunction' m_defaultContinuationOptions' cancellationToken' DefaultScheduler' ref stackMark); " is 134.
Long Statement,System.Threading.Tasks,TaskFactory<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAny,The length of the statement  "            return ContinueWhenAny(tasks' continuationFunction' continuationOptions' m_defaultCancellationToken' DefaultScheduler' ref stackMark); " is 134.
Long Statement,System.Threading.Tasks,TaskFactory<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAny,The length of the statement  "            return ContinueWhenAny<TAntecedentResult>(tasks' continuationFunction' m_defaultContinuationOptions' m_defaultCancellationToken' DefaultScheduler' ref stackMark); " is 162.
Long Statement,System.Threading.Tasks,TaskFactory<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAny,The length of the statement  "            return ContinueWhenAny<TAntecedentResult>(tasks' continuationFunction' m_defaultContinuationOptions' cancellationToken' DefaultScheduler' ref stackMark); " is 153.
Long Statement,System.Threading.Tasks,TaskFactory<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAny,The length of the statement  "            return ContinueWhenAny<TAntecedentResult>(tasks' continuationFunction' continuationOptions' m_defaultCancellationToken' DefaultScheduler' ref stackMark); " is 153.
Long Statement,System.Threading.Tasks,TaskFactory<TResult>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAny,The length of the statement  "            return ContinueWhenAny<TAntecedentResult>(tasks' continuationFunction' continuationOptions' cancellationToken' scheduler' ref stackMark); " is 137.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,TaskConstructorCore,The length of the statement  "            Contract.Assert((((int)creationOptions) | OptionsMask) == OptionsMask' "TaskConstructorCore: options take too many bits"); " is 122.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,TaskConstructorCore,The length of the statement  "            // we need to do this as the very last thing in the construction path' because the CT registration could modify m_stateFlags " is 124.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,TaskConstructorCore,The length of the statement  "                    // We exclude Promise tasks from this' because TasckCompletionSource needs to fully control the inner tasks's lifetime (i.e. not allow external cancellations)                 " is 158.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,AddNewChild,The length of the statement  "            Contract.Assert(Task.InternalCurrent == this || this.IsSelfReplicatingRoot' "Task.AddNewChild(): Called from an external context"); " is 131.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,DisregardChild,The length of the statement  "            Contract.Assert((m_contingentProperties != null) && (m_contingentProperties.m_completionCountdown >= 2)' "Task.DisregardChild(): Expected parent count to be >= 2"); " is 164.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,InternalRunSynchronously,The length of the statement  "                    // we 1) either received an unexpected exception originating from a custom scheduler' which needs to be wrapped in a TSE and thrown " is 131.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,InternalRunSynchronously,The length of the statement  "                    //    2) or a a ThreadAbortException' which we need to skip here' because it would already have been handled in Task.Execute " is 124.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,InternalRunSynchronously,The length of the statement  "                Contract.Assert((m_stateFlags & TASK_STATE_CANCELED) != 0' "Task.RunSynchronously: expected TASK_STATE_CANCELED to be set"); " is 124.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,InternalStartNew,The length of the statement  "            // Here we add the InternalTaskOptions.QueuedByRuntime to the internalOptions' so that TaskConstructorCore can skip the cancellation token registration " is 151.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,InternalStartNew,The length of the statement  "            Task t = new Task(action' state' creatingTask' cancellationToken' options' internalOptions | InternalTaskOptions.QueuedByRuntime' scheduler); " is 141.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,ScheduleAndStart,The length of the statement  "                    // or from the self replicating logic' because in both cases the exception is either propagated outside directly' or added " is 122.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,ScheduleAndStart,The length of the statement  "                    // to an enclosing parent. However we won't do this for continuation tasks' because in that case we internally eat the exception " is 128.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,Finish,The length of the statement  "                    Interlocked.Decrement(ref properties.m_completionCountdown) == 0) // Reaching this sub clause means there may be remaining active children' " is 139.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,Finish,The length of the statement  "                    // Apparently some children still remain. It will be up to the last one to process the completion of this task on their own thread. " is 131.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,Finish,The length of the statement  "                    // Otherwise we risk overwriting the TASK_STATE_RAN_TO_COMPLETION' _CANCELED or _FAULTED bit which may have been set by that child task. " is 136.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,Finish,The length of the statement  "                    // Note that the concurrent update by the last child happening in FinishStageTwo could still wipe out the TASK_STATE_WAITING_ON_CHILDREN flag'  " is 142.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,Finish,The length of the statement  "                    AtomicStateUpdate(TASK_STATE_WAITING_ON_CHILDREN' TASK_STATE_FAULTED | TASK_STATE_CANCELED | TASK_STATE_RAN_TO_COMPLETION); " is 123.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,Finish,The length of the statement  "            // Now is the time to prune exceptional children. We'll walk the list and removes the ones whose exceptions we might have observed after they threw. " is 148.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,Finish,The length of the statement  "            // we use a local variable for exceptional children here because some other thread may be nulling out m_contingentProperties.m_exceptionalChildren  " is 146.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,Finish,The length of the statement  "                    //exceptionalChildren.RemoveAll(s_IsExceptionObservedByParentPredicate); // RemoveAll has better performance than doing it ourselves " is 132.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,ProcessChildCompletion,The length of the statement  "                // This call came from the final child to complete' and apparently we have previously given up this task's right to complete itself. " is 132.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,FinishThreadAbortedTask,The length of the statement  "            Contract.Assert(!bTAEAddedToExceptionHolder || (m_contingentProperties != null && m_contingentProperties.m_exceptionsHolder != null)' " is 133.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,FinishThreadAbortedTask,The length of the statement  "            // this will only be false for non-root self replicating task copies' because all of their exceptions go to the root task. " is 122.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,ExecuteSelfReplicating,The length of the statement  "                InternalTaskOptions.QueuedByRuntime;   // we queue and cancel these tasks internally' so don't allow CT registration to take place " is 130.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,ExecuteSelfReplicating,The length of the statement  "            // Important Note: The child replicas we launch from here will be attached the root replica (by virtue of the root.CreateReplicaTask call) " is 138.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,ExecuteSelfReplicating,The length of the statement  "                // Note that we are directly calling root.InnerInvoke() even though we are currently be in the action delegate of a child replica  " is 129.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,ExecuteSelfReplicating,The length of the statement  "                // This is because the actual work was passed down in that delegate' and the action delegate of the child replica simply contains this " is 134.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,ExecuteSelfReplicating,The length of the statement  "                    Task replacementReplica = root.CreateReplicaTask(taskReplicaDelegate' root.m_stateObject' root' root.ExecutingTaskScheduler' " is 124.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,WrappedTryRunInline,The length of the statement  "                // we 1) either received an unexpected exception originating from a custom scheduler' which needs to be wrapped in a TSE and thrown " is 131.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,WrappedTryRunInline,The length of the statement  "                //    2) or a a ThreadAbortException' which we need to skip here' because it would already have been handled in Task.Execute " is 124.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,WrappedTryRunInline,The length of the statement  "                // we 1) either received an unexpected exception originating from a custom scheduler' which needs to be wrapped in a TSE and thrown " is 131.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,WrappedTryRunInline,The length of the statement  "                //    2) or a a ThreadAbortException' which we need to skip here' because it would already have been handled in Task.Execute " is 124.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,InternalWait,The length of the statement  "                TplEtwProvider.Log.TaskWaitBegin((currentTask != null ? currentTask.m_taskScheduler.Id : TaskScheduler.Current.Id)' (currentTask != null ? currentTask.Id : 0)' " is 159.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,InternalWait,The length of the statement  "                    WrappedTryRunInline() && IsCompleted) // TryRunInline doesn't guarantee completion' as there may be unfinished children. " is 120.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,InternalWait,The length of the statement  "                TplEtwProvider.Log.TaskWaitEnd((currentTask != null ? currentTask.m_taskScheduler.Id : TaskScheduler.Current.Id)' (currentTask != null ? currentTask.Id : 0)' " is 157.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,InternalCancel,The length of the statement  "            Contract.Assert((Options & (TaskCreationOptions)InternalTaskOptions.PromiseTask) == 0' "Task.InternalCancel() did not expect promise-style task"); " is 146.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,InternalCancel,The length of the statement  "                    // the cancellation logic run its course (record the request' attempt atomic state transition and do cleanup where appropriate) " is 127.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,InternalCancel,The length of the statement  "                bool bRequiresAtomicStartTransition = (ts != null && ts.RequiresAtomicStartTransition) || ((Options & (TaskCreationOptions)InternalTaskOptions.SelfReplicating) != 0); " is 166.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,InternalCancel,The length of the statement  "                    // An atomic transition here is only safe if we know we're on a custom task scheduler' which also forces a CAS on ExecuteEntry " is 126.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,CancellationCleanupLogic,The length of the statement  "            Contract.Assert((m_stateFlags & (TASK_STATE_CANCELED | TASK_STATE_COMPLETION_RESERVED)) != 0' "Task.CancellationCleanupLogic(): Task not canceled or reserved."); " is 161.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,CancellationCleanupLogic,The length of the statement  "            // I'd like to do this' but there is a small window for a race condition.  If someone calls Wait() between InternalCancel() and " is 127.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,CancellationCleanupLogic,The length of the statement  "            //Contract.Assert((m_completionEvent == null) || !m_completionEvent.IsSet' "Task.CancellationCleanupLogic(): Completion event already set."); " is 141.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,SetCancellationAcknowledged,The length of the statement  "            Contract.Assert(this == Task.InternalCurrent' "SetCancellationAcknowledged() should only be called while this is still the current task"); " is 138.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,SetCancellationAcknowledged,The length of the statement  "            Contract.Assert(IsCancellationRequested' "SetCancellationAcknowledged() should not be called if the task's CT wasn't signaled"); " is 128.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,FinishContinuations,The length of the statement  "            List<TaskContinuation> continuations = (m_contingentProperties == null) ? null : m_contingentProperties.m_continuations; " is 120.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,ContinueWith,The length of the statement  "            return ContinueWith(continuationAction' TaskScheduler.Current' CancellationToken.None' TaskContinuationOptions.None' ref stackMark); " is 132.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,ContinueWith,The length of the statement  "            return ContinueWith(continuationAction' TaskScheduler.Current' cancellationToken' TaskContinuationOptions.None' ref stackMark); " is 127.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,ContinueWith,The length of the statement  "            return ContinueWith(continuationAction' scheduler' CancellationToken.None' TaskContinuationOptions.None' ref stackMark); " is 120.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,ContinueWith,The length of the statement  "            return ContinueWith(continuationAction' TaskScheduler.Current' CancellationToken.None' continuationOptions' ref stackMark); " is 123.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,ContinueWith,The length of the statement  "            return ContinueWith<TResult>(continuationFunction' TaskScheduler.Current' cancellationToken' TaskContinuationOptions.None' ref stackMark); " is 138.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,ContinueWith,The length of the statement  "            return ContinueWith<TResult>(continuationFunction' scheduler' CancellationToken.None' TaskContinuationOptions.None' ref stackMark); " is 131.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,ContinueWith,The length of the statement  "            return ContinueWith<TResult>(continuationFunction' TaskScheduler.Current' CancellationToken.None' continuationOptions' ref stackMark); " is 134.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,CreationOptionsFromContinuationOptions,The length of the statement  "            TaskContinuationOptions illegalMask = TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.LongRunning; " is 121.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,WaitAll,The length of the statement  "            // We make sure that the exception behavior of Task.Wait() is replicated the same for tasks handled in either of these codepaths " is 128.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,WaitAll,The length of the statement  "                // This is necessary so that the Parallel Debugger can traverse it during the long wait and deduce waiter/waitee relationships " is 126.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,WaitAllSTAAnd64Aware,The length of the statement  "            // The ability to use WaitAny to probe for cancellation during one by one waits makes it easy to support CT without introducing racy code paths. " is 144.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,WaitAny,The length of the statement  "            // This is necessary so that the Parallel Debugger can traverse it during the long wait and deduce waiter/waitee relationships " is 126.
Long Statement,System.Threading.Tasks,TaskContinuation,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,Run,The length of the statement  "                                      (task.m_stateFlags & TASK_STATE_THREAD_WAS_ABORTED) != 0))    // this ensures TAEs from QueueTask will be wrapped in TSE " is 120.
Long Statement,System.Threading.Tasks,TaskContinuation,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,Run,The length of the statement  "                    // This is probably not too importnat right now' because the internal use of continuationActions only involve short actions. " is 124.
Long Statement,System.Threading.Tasks,TaskContinuation,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,Run,The length of the statement  "                    // However if we ever make these public' we need to turn them into tasks if the antecedent threw a ThreadAbortException. " is 120.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,StartNew,The length of the statement  "            return Task.InternalStartNew(currTask' action' null' m_defaultCancellationToken' GetDefaultScheduler(currTask)' creationOptions'  " is 128.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,StartNew,The length of the statement  "            return Task.InternalStartNew(Task.InternalCurrent' action' null' cancellationToken' scheduler' creationOptions' internalOptions' ref stackMark); " is 144.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,FromAsync,The length of the statement  "            return TaskFactory<TResult>.FromAsyncImpl(asyncResult' endMethod' m_defaultCreationOptions' DefaultScheduler' ref stackMark); " is 125.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The length of the statement  "            return ContinueWhenAll(tasks' continuationAction' m_defaultContinuationOptions' m_defaultCancellationToken' DefaultScheduler' ref stackMark); " is 141.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The length of the statement  "            return ContinueWhenAll(tasks' continuationAction' m_defaultContinuationOptions' cancellationToken' DefaultScheduler' ref stackMark); " is 132.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The length of the statement  "            return ContinueWhenAll(tasks' continuationAction' continuationOptions' m_defaultCancellationToken' DefaultScheduler' ref stackMark); " is 132.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The length of the statement  "            return ContinueWhenAll(tasks' continuationAction' m_defaultContinuationOptions' m_defaultCancellationToken' DefaultScheduler' ref stackMark); " is 141.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The length of the statement  "            return ContinueWhenAll(tasks' continuationAction' m_defaultContinuationOptions' cancellationToken' DefaultScheduler' ref stackMark); " is 132.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The length of the statement  "            return ContinueWhenAll(tasks' continuationAction' continuationOptions' m_defaultCancellationToken' DefaultScheduler' ref stackMark); " is 132.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The length of the statement  "            return ContinueWhenAll(tasks' continuationFunction' m_defaultContinuationOptions' m_defaultCancellationToken' DefaultScheduler' ref stackMark); " is 143.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The length of the statement  "            return ContinueWhenAll(tasks' continuationFunction' m_defaultContinuationOptions' cancellationToken' DefaultScheduler' ref stackMark); " is 134.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The length of the statement  "            return ContinueWhenAll(tasks' continuationFunction' continuationOptions' m_defaultCancellationToken' DefaultScheduler' ref stackMark); " is 134.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The length of the statement  "            return TaskFactory<TResult>.ContinueWhenAll(tasks' continuationFunction' continuationOptions' cancellationToken' scheduler' ref stackMark); " is 139.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The length of the statement  "            return ContinueWhenAll(tasks' continuationFunction' m_defaultContinuationOptions' m_defaultCancellationToken' DefaultScheduler' ref stackMark); " is 143.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The length of the statement  "            return ContinueWhenAll(tasks' continuationFunction' m_defaultContinuationOptions' cancellationToken' DefaultScheduler' ref stackMark); " is 134.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The length of the statement  "            return ContinueWhenAll(tasks' continuationFunction' continuationOptions' m_defaultCancellationToken' DefaultScheduler' ref stackMark); " is 134.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The length of the statement  "            return TaskFactory<TResult>.ContinueWhenAll<TAntecedentResult>(tasks' continuationFunction' continuationOptions' cancellationToken' scheduler' ref stackMark); " is 158.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The length of the statement  "            return ContinueWhenAny(tasks' continuationAction' m_defaultContinuationOptions' m_defaultCancellationToken' DefaultScheduler' ref stackMark); " is 141.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The length of the statement  "            return ContinueWhenAny(tasks' continuationAction' m_defaultContinuationOptions' cancellationToken' DefaultScheduler' ref stackMark); " is 132.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The length of the statement  "            return ContinueWhenAny(tasks' continuationAction' continuationOptions' m_defaultCancellationToken' DefaultScheduler' ref stackMark); " is 132.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The length of the statement  "            return ContinueWhenAny<TResult>(tasks' continuationFunction' m_defaultContinuationOptions' m_defaultCancellationToken' DefaultScheduler' ref stackMark); " is 152.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The length of the statement  "            return ContinueWhenAny<TResult>(tasks' continuationFunction' m_defaultContinuationOptions' cancellationToken' DefaultScheduler' ref stackMark); " is 143.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The length of the statement  "            return ContinueWhenAny<TResult>(tasks' continuationFunction' continuationOptions' m_defaultCancellationToken' DefaultScheduler' ref stackMark); " is 143.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The length of the statement  "            return TaskFactory<TResult>.ContinueWhenAny(tasks' continuationFunction' continuationOptions' cancellationToken' scheduler' ref stackMark); " is 139.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The length of the statement  "            return ContinueWhenAny<TAntecedentResult' TResult>(tasks' continuationFunction' m_defaultContinuationOptions' m_defaultCancellationToken' DefaultScheduler' ref stackMark); " is 171.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The length of the statement  "            return ContinueWhenAny<TAntecedentResult' TResult>(tasks' continuationFunction' m_defaultContinuationOptions' cancellationToken' DefaultScheduler' ref stackMark); " is 162.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The length of the statement  "            return ContinueWhenAny<TAntecedentResult' TResult>(tasks' continuationFunction' continuationOptions' m_defaultCancellationToken' DefaultScheduler' ref stackMark); " is 162.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The length of the statement  "            return ContinueWhenAny<TAntecedentResult' TResult>(tasks' continuationFunction' continuationOptions' cancellationToken' scheduler' ref stackMark); " is 146.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The length of the statement  "            return TaskFactory<TResult>.ContinueWhenAny<TAntecedentResult>(tasks' continuationFunction' continuationOptions' cancellationToken' scheduler' ref stackMark); " is 158.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The length of the statement  "            return ContinueWhenAny<TAntecedentResult>(tasks' continuationAction' m_defaultContinuationOptions' m_defaultCancellationToken' DefaultScheduler' ref stackMark); " is 160.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The length of the statement  "            return ContinueWhenAny<TAntecedentResult>(tasks' continuationAction' m_defaultContinuationOptions' cancellationToken' DefaultScheduler' ref stackMark); " is 151.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The length of the statement  "            return ContinueWhenAny<TAntecedentResult>(tasks' continuationAction' continuationOptions' m_defaultCancellationToken' DefaultScheduler' ref stackMark); " is 151.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The length of the statement  "            return ContinueWhenAny<TAntecedentResult>(tasks' continuationAction' continuationOptions' cancellationToken' scheduler' ref stackMark); " is 135.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactory.cs,CheckMultiTaskContinuationOptions,The length of the statement  "            TaskContinuationOptions illegalMask = TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.LongRunning; " is 121.
Long Statement,System.Threading.Tasks,TaskScheduler,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskScheduler.cs,TryRunInline,The length of the statement  "            // No need to attempt inlining if the task body was already run (i.e. either TASK_STATE_DELEGATE_INVOKED or TASK_STATE_CANCELED bits set) " is 137.
Long Statement,System.Threading.Tasks,TaskScheduler,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskScheduler.cs,TryRunInline,The length of the statement  "            // 2) we maintain a mechanism for the TLS lookup optimization that we used to have for the ConcRT scheduler (will potentially introduce the same for TP) " is 152.
Long Statement,System.Threading.Tasks,TaskScheduler,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskScheduler.cs,TryRunInline,The length of the statement  "            // If the custom scheduler returned true' we should either have the TASK_STATE_DELEGATE_INVOKED or TASK_STATE_CANCELED bit set " is 126.
Long Statement,System.Threading.Tasks,SynchronizationContextTaskScheduler,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskScheduler.cs,PostCallback,The length of the statement  "            // calling ExecuteEntry with double execute check enabled because a user implemented SynchronizationContext could be buggy " is 122.
Long Statement,System.Threading,CancellationToken,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationToken.cs,Register,The length of the statement  "                return new CancellationTokenRegistration(); // nothing to do for tokens than can never reach the canceled state. Give them a dummy registration. " is 144.
Long Statement,System.Threading,CancellationToken,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationToken.cs,InitializeDefaultSource,The length of the statement  "            // Alternative: LazyInititalizer.EnsureInitialized(ref m_source' ()=>CancellationTokenSource.InternalGetStaticSource(false)); " is 125.
Long Statement,System.Threading,CancellationTokenRegistration,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenRegistration.cs,TryDeregister,The length of the statement  "            CancellationCallbackInfo prevailingCallbackInfoInSlot = m_registrationInfo.Source.SafeAtomicRemove(m_registrationInfo.Index' m_callbackInfo); " is 141.
Long Statement,System.Threading,CancellationTokenRegistration,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenRegistration.cs,Dispose,The length of the statement  "            // We guarantee that we will not return if the callback is being executed (assuming we are not currently called by the callback itself) " is 135.
Long Statement,System.Threading,CancellationTokenRegistration,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenRegistration.cs,Dispose,The length of the statement  "            //    1. if we are called in the context of an executing callback' no need to wait (determined by tracking callback-executor threadID) " is 134.
Long Statement,System.Threading,CancellationTokenRegistration,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenRegistration.cs,Dispose,The length of the statement  "            //       - if the currently executing callback is this CTR' then waiting would deadlock. (We choose to return rather than deadlock) " is 131.
Long Statement,System.Threading,CancellationTokenRegistration,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenRegistration.cs,Dispose,The length of the statement  "            //    2. if deregistration failed' and we are on a different thread' then the callback may be running under control of cts.Cancel() " is 131.
Long Statement,System.Threading,CancellationTokenRegistration,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenRegistration.cs,Dispose,The length of the statement  "                m_tokenSource.ThreadIDExecutingCallbacks != Thread.CurrentThread.ManagedThreadId) //the executingThreadID is not this threadID. " is 127.
Long Statement,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,InternalRegister,The length of the statement  "                CancellationCallbackInfo callbackInfo = new CancellationCallbackInfo(callback' stateForCallback' targetSyncContext' this); " is 122.
Long Statement,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,InternalRegister,The length of the statement  "                    SparselyPopulatedArray<CancellationCallbackInfo>[] list = new SparselyPopulatedArray<CancellationCallbackInfo>[s_nLists]; " is 121.
Long Statement,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,InternalRegister,The length of the statement  "                    SparselyPopulatedArray<CancellationCallbackInfo> callBackArray = new SparselyPopulatedArray<CancellationCallbackInfo>(4); " is 121.
Long Statement,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,ExecuteCallbackHandlers,The length of the statement  "            Contract.Assert(IsCancellationRequested' "ExecuteCallbackHandlers should only be called after setting IsCancellationRequested->true"); " is 134.
Long Statement,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,CancellationCallbackCoreWork_OnSyncContext,The length of the statement  "            CancellationCallbackInfo callback = args.m_currArrayFragment.SafeAtomicRemove(args.m_currArrayIndex' m_executingCallback); " is 122.
Long Statement,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,CreateLinkedTokenSource,The length of the statement  "                linkedTokenSource.m_linkingRegistrations.Add(token1.InternalRegisterWithoutEC(s_LinkedTokenCancelDelegate' linkedTokenSource)); " is 127.
Long Statement,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,CreateLinkedTokenSource,The length of the statement  "                linkedTokenSource.m_linkingRegistrations.Add(token2.InternalRegisterWithoutEC(s_LinkedTokenCancelDelegate' linkedTokenSource)); " is 127.
Long Statement,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,CreateLinkedTokenSource,The length of the statement  "                    linkedTokenSource.m_linkingRegistrations.Add(tokens[i].InternalRegisterWithoutEC(s_LinkedTokenCancelDelegate' linkedTokenSource)); " is 130.
Long Statement,System.Threading,SparselyPopulatedArray<T>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,Add,The length of the statement  "                            if (curr.m_elements[tryIndex] == null && Interlocked.CompareExchange(ref curr.m_elements[tryIndex]' element' null) == null) " is 123.
Long Statement,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Initialize,The length of the statement  "            Contract.Assert(DEFAULT_SPIN_SP <= SpinCountState_MaxValue' "Internal error - DEFAULT_SPIN_SP is outside the legal range."); " is 124.
Long Statement,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Set,The length of the statement  "            //Design-decision: do not set the event if we are in cancellation -> better to deadlock than to wake up waiters incorrectly " is 123.
Long Statement,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Wait,The length of the statement  "                            //update timeout (delays in wait commencement are due to spinning and/or spurious wakeups from other waits being canceled) " is 122.
Complex Conditional,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,Finish,The conditional expression  "properties == null ||                    // no contingent properties' no children. Safe to complete ourselves                      (properties.m_completionCountdown == 1 && !IsSelfReplicatingRoot) ||                      // Count of 1 => either all children finished' or there were none. Safe to complete ourselves                       // without paying the price of an Interlocked.Decrement.                      // However we need to exclude self replicating root tasks from this optimization' because                      // they can have children joining in' or finishing even after the root task delegate is done.                      Interlocked.Decrement(ref properties.m_completionCountdown) == 0"  is complex.
Complex Conditional,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,InternalWait,The conditional expression  "millisecondsTimeout == Timeout.Infinite && !cancellationToken.CanBeCanceled &&                      WrappedTryRunInline() && IsCompleted"  is complex.
Complex Conditional,System.Threading.Tasks,TaskScheduler,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskScheduler.cs,TryRunInline,The conditional expression  "(ets == null) ||                  (task.m_action == null) ||                  task.IsDelegateInvoked ||                   task.IsCanceled"  is complex.
Complex Conditional,System.Threading,CancellationTokenRegistration,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenRegistration.cs,Dispose,The conditional expression  "m_tokenSource != null &&                   m_tokenSource.IsCancellationRequested && //running callbacks has commenced.                  ! m_tokenSource.IsCancellationCompleted && //running callbacks hasn't finished                  !deregisterOccured && //deregistration failed (ie the callback is missing from the list)                  m_tokenSource.ThreadIDExecutingCallbacks != Thread.CurrentThread.ManagedThreadId"  is complex.
Empty Catch Block,System,LightupServices,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Lightup\Lightup.cs,CreateDelegate,The method has an empty catch block.
Empty Catch Block,System,LightupServices,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Lightup\Lightup.cs,CreateDelegate,The method has an empty catch block.
Empty Catch Block,System.Runtime.CompilerServices,AsyncTaskMethodBuilder,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Runtime\CompilerServices\AsyncTaskMethodBuilder.cs,AsyncTaskMethodBuilder,The method has an empty catch block.
Empty Catch Block,System.Runtime.CompilerServices,AsyncVoidMethodBuilder,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Runtime\CompilerServices\AsyncVoidMethodBuilder.cs,AsyncVoidMethodBuilder,The method has an empty catch block.
Empty Catch Block,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,DeregisterCancellationCallback,The method has an empty catch block.
Empty Catch Block,System.Threading.Tasks,TaskContinuation,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,Run,The method has an empty catch block.
Magic Number,System.Collections.Concurrent,ConcurrentDictionary<TKey;TValue>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: try              {                  // The thread that first obtains m_locks[0] will be the one doing the resize operation                  AcquireLocks(0' 1' ref locksAcquired);                    // Make sure nobody resized the table while we were waiting for lock 0:                  if (buckets != m_buckets)                  {                      // We assume that since the table reference is different' it was already resized. If we ever                      // decide to do table shrinking' or replace the table for other reasons' we will have to revisit                      // this logic.                      return;                  }                    // Compute the new table size. We find the smallest integer larger than twice the previous table size' and not divisible by                  // 2'3'5 or 7. We can consider a different table-sizing policy in the future.                  int newLength;                  try                  {                      checked                      {                          // Double the size of the buckets table and add one' so that we have an odd integer.                          newLength = buckets.Length * 2 + 1;                            // Now' we only need to check odd integers' and find the first that is not divisible                          // by 3' 5 or 7.                          while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0)                          {                              newLength += 2;                          }                            Assert(newLength % 2 != 0);                      }                  }                  catch (OverflowException)                  {                      // If we were to resize the table' its new size will not fit into a 32-bit signed int. Just return.                      return;                  }                    Node[] newBuckets = new Node[newLength];                  int[] newCountPerLock = new int[m_locks.Length];                    // Now acquire all other locks for the table                  AcquireLocks(1' m_locks.Length' ref locksAcquired);                    // Copy all data into a new table' creating new nodes for all elements                  for (int i = 0; i < buckets.Length; i++)                  {                      Node current = buckets[i];                      while (current != null)                      {                          Node next = current.m_next;                          int newBucketNo' newLockNo;                          GetBucketAndLockNo(current.m_hashcode' out newBucketNo' out newLockNo' newBuckets.Length);                            newBuckets[newBucketNo] = new Node(current.m_key' current.m_value' current.m_hashcode' newBuckets[newBucketNo]);                            checked                          {                              newCountPerLock[newLockNo]++;                          }                            current = next;                      }                  }                    // And finally adjust m_buckets and m_countPerLock to point to data for the new table                  m_buckets = newBuckets;                  m_countPerLock = newCountPerLock;                }              finally              {                  // Release all locks that we took earlier                  ReleaseLocks(0' locksAcquired);              }
Magic Number,System.Collections.Concurrent,ConcurrentDictionary<TKey;TValue>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: try              {                  // The thread that first obtains m_locks[0] will be the one doing the resize operation                  AcquireLocks(0' 1' ref locksAcquired);                    // Make sure nobody resized the table while we were waiting for lock 0:                  if (buckets != m_buckets)                  {                      // We assume that since the table reference is different' it was already resized. If we ever                      // decide to do table shrinking' or replace the table for other reasons' we will have to revisit                      // this logic.                      return;                  }                    // Compute the new table size. We find the smallest integer larger than twice the previous table size' and not divisible by                  // 2'3'5 or 7. We can consider a different table-sizing policy in the future.                  int newLength;                  try                  {                      checked                      {                          // Double the size of the buckets table and add one' so that we have an odd integer.                          newLength = buckets.Length * 2 + 1;                            // Now' we only need to check odd integers' and find the first that is not divisible                          // by 3' 5 or 7.                          while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0)                          {                              newLength += 2;                          }                            Assert(newLength % 2 != 0);                      }                  }                  catch (OverflowException)                  {                      // If we were to resize the table' its new size will not fit into a 32-bit signed int. Just return.                      return;                  }                    Node[] newBuckets = new Node[newLength];                  int[] newCountPerLock = new int[m_locks.Length];                    // Now acquire all other locks for the table                  AcquireLocks(1' m_locks.Length' ref locksAcquired);                    // Copy all data into a new table' creating new nodes for all elements                  for (int i = 0; i < buckets.Length; i++)                  {                      Node current = buckets[i];                      while (current != null)                      {                          Node next = current.m_next;                          int newBucketNo' newLockNo;                          GetBucketAndLockNo(current.m_hashcode' out newBucketNo' out newLockNo' newBuckets.Length);                            newBuckets[newBucketNo] = new Node(current.m_key' current.m_value' current.m_hashcode' newBuckets[newBucketNo]);                            checked                          {                              newCountPerLock[newLockNo]++;                          }                            current = next;                      }                  }                    // And finally adjust m_buckets and m_countPerLock to point to data for the new table                  m_buckets = newBuckets;                  m_countPerLock = newCountPerLock;                }              finally              {                  // Release all locks that we took earlier                  ReleaseLocks(0' locksAcquired);              }
Magic Number,System.Collections.Concurrent,ConcurrentDictionary<TKey;TValue>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: try              {                  // The thread that first obtains m_locks[0] will be the one doing the resize operation                  AcquireLocks(0' 1' ref locksAcquired);                    // Make sure nobody resized the table while we were waiting for lock 0:                  if (buckets != m_buckets)                  {                      // We assume that since the table reference is different' it was already resized. If we ever                      // decide to do table shrinking' or replace the table for other reasons' we will have to revisit                      // this logic.                      return;                  }                    // Compute the new table size. We find the smallest integer larger than twice the previous table size' and not divisible by                  // 2'3'5 or 7. We can consider a different table-sizing policy in the future.                  int newLength;                  try                  {                      checked                      {                          // Double the size of the buckets table and add one' so that we have an odd integer.                          newLength = buckets.Length * 2 + 1;                            // Now' we only need to check odd integers' and find the first that is not divisible                          // by 3' 5 or 7.                          while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0)                          {                              newLength += 2;                          }                            Assert(newLength % 2 != 0);                      }                  }                  catch (OverflowException)                  {                      // If we were to resize the table' its new size will not fit into a 32-bit signed int. Just return.                      return;                  }                    Node[] newBuckets = new Node[newLength];                  int[] newCountPerLock = new int[m_locks.Length];                    // Now acquire all other locks for the table                  AcquireLocks(1' m_locks.Length' ref locksAcquired);                    // Copy all data into a new table' creating new nodes for all elements                  for (int i = 0; i < buckets.Length; i++)                  {                      Node current = buckets[i];                      while (current != null)                      {                          Node next = current.m_next;                          int newBucketNo' newLockNo;                          GetBucketAndLockNo(current.m_hashcode' out newBucketNo' out newLockNo' newBuckets.Length);                            newBuckets[newBucketNo] = new Node(current.m_key' current.m_value' current.m_hashcode' newBuckets[newBucketNo]);                            checked                          {                              newCountPerLock[newLockNo]++;                          }                            current = next;                      }                  }                    // And finally adjust m_buckets and m_countPerLock to point to data for the new table                  m_buckets = newBuckets;                  m_countPerLock = newCountPerLock;                }              finally              {                  // Release all locks that we took earlier                  ReleaseLocks(0' locksAcquired);              }
Magic Number,System.Collections.Concurrent,ConcurrentDictionary<TKey;TValue>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: try              {                  // The thread that first obtains m_locks[0] will be the one doing the resize operation                  AcquireLocks(0' 1' ref locksAcquired);                    // Make sure nobody resized the table while we were waiting for lock 0:                  if (buckets != m_buckets)                  {                      // We assume that since the table reference is different' it was already resized. If we ever                      // decide to do table shrinking' or replace the table for other reasons' we will have to revisit                      // this logic.                      return;                  }                    // Compute the new table size. We find the smallest integer larger than twice the previous table size' and not divisible by                  // 2'3'5 or 7. We can consider a different table-sizing policy in the future.                  int newLength;                  try                  {                      checked                      {                          // Double the size of the buckets table and add one' so that we have an odd integer.                          newLength = buckets.Length * 2 + 1;                            // Now' we only need to check odd integers' and find the first that is not divisible                          // by 3' 5 or 7.                          while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0)                          {                              newLength += 2;                          }                            Assert(newLength % 2 != 0);                      }                  }                  catch (OverflowException)                  {                      // If we were to resize the table' its new size will not fit into a 32-bit signed int. Just return.                      return;                  }                    Node[] newBuckets = new Node[newLength];                  int[] newCountPerLock = new int[m_locks.Length];                    // Now acquire all other locks for the table                  AcquireLocks(1' m_locks.Length' ref locksAcquired);                    // Copy all data into a new table' creating new nodes for all elements                  for (int i = 0; i < buckets.Length; i++)                  {                      Node current = buckets[i];                      while (current != null)                      {                          Node next = current.m_next;                          int newBucketNo' newLockNo;                          GetBucketAndLockNo(current.m_hashcode' out newBucketNo' out newLockNo' newBuckets.Length);                            newBuckets[newBucketNo] = new Node(current.m_key' current.m_value' current.m_hashcode' newBuckets[newBucketNo]);                            checked                          {                              newCountPerLock[newLockNo]++;                          }                            current = next;                      }                  }                    // And finally adjust m_buckets and m_countPerLock to point to data for the new table                  m_buckets = newBuckets;                  m_countPerLock = newCountPerLock;                }              finally              {                  // Release all locks that we took earlier                  ReleaseLocks(0' locksAcquired);              }
Magic Number,System.Collections.Concurrent,ConcurrentDictionary<TKey;TValue>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: try              {                  // The thread that first obtains m_locks[0] will be the one doing the resize operation                  AcquireLocks(0' 1' ref locksAcquired);                    // Make sure nobody resized the table while we were waiting for lock 0:                  if (buckets != m_buckets)                  {                      // We assume that since the table reference is different' it was already resized. If we ever                      // decide to do table shrinking' or replace the table for other reasons' we will have to revisit                      // this logic.                      return;                  }                    // Compute the new table size. We find the smallest integer larger than twice the previous table size' and not divisible by                  // 2'3'5 or 7. We can consider a different table-sizing policy in the future.                  int newLength;                  try                  {                      checked                      {                          // Double the size of the buckets table and add one' so that we have an odd integer.                          newLength = buckets.Length * 2 + 1;                            // Now' we only need to check odd integers' and find the first that is not divisible                          // by 3' 5 or 7.                          while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0)                          {                              newLength += 2;                          }                            Assert(newLength % 2 != 0);                      }                  }                  catch (OverflowException)                  {                      // If we were to resize the table' its new size will not fit into a 32-bit signed int. Just return.                      return;                  }                    Node[] newBuckets = new Node[newLength];                  int[] newCountPerLock = new int[m_locks.Length];                    // Now acquire all other locks for the table                  AcquireLocks(1' m_locks.Length' ref locksAcquired);                    // Copy all data into a new table' creating new nodes for all elements                  for (int i = 0; i < buckets.Length; i++)                  {                      Node current = buckets[i];                      while (current != null)                      {                          Node next = current.m_next;                          int newBucketNo' newLockNo;                          GetBucketAndLockNo(current.m_hashcode' out newBucketNo' out newLockNo' newBuckets.Length);                            newBuckets[newBucketNo] = new Node(current.m_key' current.m_value' current.m_hashcode' newBuckets[newBucketNo]);                            checked                          {                              newCountPerLock[newLockNo]++;                          }                            current = next;                      }                  }                    // And finally adjust m_buckets and m_countPerLock to point to data for the new table                  m_buckets = newBuckets;                  m_countPerLock = newCountPerLock;                }              finally              {                  // Release all locks that we took earlier                  ReleaseLocks(0' locksAcquired);              }
Magic Number,System.Collections.Concurrent,ConcurrentDictionary<TKey;TValue>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: try              {                  // The thread that first obtains m_locks[0] will be the one doing the resize operation                  AcquireLocks(0' 1' ref locksAcquired);                    // Make sure nobody resized the table while we were waiting for lock 0:                  if (buckets != m_buckets)                  {                      // We assume that since the table reference is different' it was already resized. If we ever                      // decide to do table shrinking' or replace the table for other reasons' we will have to revisit                      // this logic.                      return;                  }                    // Compute the new table size. We find the smallest integer larger than twice the previous table size' and not divisible by                  // 2'3'5 or 7. We can consider a different table-sizing policy in the future.                  int newLength;                  try                  {                      checked                      {                          // Double the size of the buckets table and add one' so that we have an odd integer.                          newLength = buckets.Length * 2 + 1;                            // Now' we only need to check odd integers' and find the first that is not divisible                          // by 3' 5 or 7.                          while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0)                          {                              newLength += 2;                          }                            Assert(newLength % 2 != 0);                      }                  }                  catch (OverflowException)                  {                      // If we were to resize the table' its new size will not fit into a 32-bit signed int. Just return.                      return;                  }                    Node[] newBuckets = new Node[newLength];                  int[] newCountPerLock = new int[m_locks.Length];                    // Now acquire all other locks for the table                  AcquireLocks(1' m_locks.Length' ref locksAcquired);                    // Copy all data into a new table' creating new nodes for all elements                  for (int i = 0; i < buckets.Length; i++)                  {                      Node current = buckets[i];                      while (current != null)                      {                          Node next = current.m_next;                          int newBucketNo' newLockNo;                          GetBucketAndLockNo(current.m_hashcode' out newBucketNo' out newLockNo' newBuckets.Length);                            newBuckets[newBucketNo] = new Node(current.m_key' current.m_value' current.m_hashcode' newBuckets[newBucketNo]);                            checked                          {                              newCountPerLock[newLockNo]++;                          }                            current = next;                      }                  }                    // And finally adjust m_buckets and m_countPerLock to point to data for the new table                  m_buckets = newBuckets;                  m_countPerLock = newCountPerLock;                }              finally              {                  // Release all locks that we took earlier                  ReleaseLocks(0' locksAcquired);              }
Magic Number,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,DisregardChild,The following statement contains a magic number: Contract.Assert((m_contingentProperties != null) && (m_contingentProperties.m_completionCountdown >= 2)' "Task.DisregardChild(): Expected parent count to be >= 2");
Magic Number,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\Task.cs,WaitAllSTAAnd64Aware,The following statement contains a magic number: if (cancellationToken.CanBeCanceled)              {                  cancelableWHPair = new WaitHandle[2]; // one for the actual wait handle' other for the cancellation event                   cancelableWHPair[1] = cancellationToken.WaitHandle;              }
Magic Number,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,InternalRegister,The following statement contains a magic number: if (!IsCancellationRequested)              {                  int myIndex = Thread.CurrentThread.ManagedThreadId % s_nLists;                    CancellationCallbackInfo callbackInfo = new CancellationCallbackInfo(callback' stateForCallback' targetSyncContext' this);                    //allocate the callback list array                  if (m_registeredCallbacksLists == null)                  {                      SparselyPopulatedArray<CancellationCallbackInfo>[] list = new SparselyPopulatedArray<CancellationCallbackInfo>[s_nLists];                      Interlocked.CompareExchange(ref m_registeredCallbacksLists' list' null);                  }                    //allocate the actual lists on-demand to save mem in low-use situations' and to avoid false-sharing.                  if (m_registeredCallbacksLists[myIndex] == null)                  {                      SparselyPopulatedArray<CancellationCallbackInfo> callBackArray = new SparselyPopulatedArray<CancellationCallbackInfo>(4);                      Interlocked.CompareExchange(ref (m_registeredCallbacksLists[myIndex])' callBackArray' null);                  }                    // Now add the registration to the list.                  SparselyPopulatedArray<CancellationCallbackInfo> callbacks = m_registeredCallbacksLists[myIndex];                  SparselyPopulatedArrayAddInfo<CancellationCallbackInfo> addInfo = callbacks.Add(callbackInfo);                  CancellationTokenRegistration registration = new CancellationTokenRegistration(this' callbackInfo' addInfo);                    if (!IsCancellationRequested)                      return registration;                    //If a cancellation has since come in' we will try to undo the registration and run the callback directly here.                  bool deregisterOccurred = registration.TryDeregister();                    if (!deregisterOccurred)                  {                      // the callback execution process must have snagged the callback for execution' so                       // 1. wait for the callback to complete' then                      // 2. return a dummy registration.                      WaitForCallbackToComplete(callbackInfo);                      return new CancellationTokenRegistration();                  }              }
Magic Number,System.Threading,SparselyPopulatedArray<T>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,Add,The following statement contains a magic number: while (true)              {                  // Get the tail' and ensure it's up to date.                  SparselyPopulatedArrayFragment<T> tail = m_tail;                  while (tail.m_next != null)                      m_tail = (tail = tail.m_next);                    // Search for a free index' starting from the tail.                  SparselyPopulatedArrayFragment<T> curr = tail;                  while (curr != null)                  {                      const int RE_SEARCH_THRESHOLD = -10; // Every 10 skips' force a search.                      if (curr.m_freeCount < 1)                          --curr.m_freeCount;                        if (curr.m_freeCount > 0 || curr.m_freeCount < RE_SEARCH_THRESHOLD)                      {                          int c = curr.Length;                            // We'll compute a start offset based on how many free slots we think there                          // are.  This optimizes for ordinary the LIFO deregistration pattern' and is                          // far from perfect due to the non-threadsafe ++ and -- of the free counter.                          int start = ((c - curr.m_freeCount) % c);                          if (start < 0)                          {                              start = 0;                              curr.m_freeCount--; // Too many free elements; fix up.                          }                          Contract.Assert(start >= 0 && start < c' "start is outside of bounds");                            // Now walk the array until we find a free slot (or reach the end).                          for (int i = 0; i < c; i++)                          {                              // If the slot is null' try to CAS our element into it.                              int tryIndex = (start + i) % c;                              Contract.Assert(tryIndex >= 0 && tryIndex < curr.m_elements.Length' "tryIndex is outside of bounds");                                                            if (curr.m_elements[tryIndex] == null && Interlocked.CompareExchange(ref curr.m_elements[tryIndex]' element' null) == null)                              {                                  // We adjust the free count by --. Note: if this drops to 0' we will skip                                  // the fragment on the next search iteration.  Searching threads will -- the                                  // count and force a search every so often' just in case fragmentation occurs.                                  int newFreeCount = curr.m_freeCount - 1;                                  curr.m_freeCount = newFreeCount > 0 ? newFreeCount : 0;                                  return new SparselyPopulatedArrayAddInfo<T>(curr' tryIndex);                              }                          }                      }                        curr = curr.m_prev;                  }                    // If we got here' we need to add a new chunk to the tail and try again.                  SparselyPopulatedArrayFragment<T> newTail = new SparselyPopulatedArrayFragment<T>(                      tail.m_elements.Length == 4096 ? 4096 : tail.m_elements.Length * 2' tail);                  if (Interlocked.CompareExchange(ref tail.m_next' newTail' null) == null)                  {                      m_tail = newTail;                  }              }
Magic Number,System.Threading,SparselyPopulatedArray<T>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,Add,The following statement contains a magic number: while (true)              {                  // Get the tail' and ensure it's up to date.                  SparselyPopulatedArrayFragment<T> tail = m_tail;                  while (tail.m_next != null)                      m_tail = (tail = tail.m_next);                    // Search for a free index' starting from the tail.                  SparselyPopulatedArrayFragment<T> curr = tail;                  while (curr != null)                  {                      const int RE_SEARCH_THRESHOLD = -10; // Every 10 skips' force a search.                      if (curr.m_freeCount < 1)                          --curr.m_freeCount;                        if (curr.m_freeCount > 0 || curr.m_freeCount < RE_SEARCH_THRESHOLD)                      {                          int c = curr.Length;                            // We'll compute a start offset based on how many free slots we think there                          // are.  This optimizes for ordinary the LIFO deregistration pattern' and is                          // far from perfect due to the non-threadsafe ++ and -- of the free counter.                          int start = ((c - curr.m_freeCount) % c);                          if (start < 0)                          {                              start = 0;                              curr.m_freeCount--; // Too many free elements; fix up.                          }                          Contract.Assert(start >= 0 && start < c' "start is outside of bounds");                            // Now walk the array until we find a free slot (or reach the end).                          for (int i = 0; i < c; i++)                          {                              // If the slot is null' try to CAS our element into it.                              int tryIndex = (start + i) % c;                              Contract.Assert(tryIndex >= 0 && tryIndex < curr.m_elements.Length' "tryIndex is outside of bounds");                                                            if (curr.m_elements[tryIndex] == null && Interlocked.CompareExchange(ref curr.m_elements[tryIndex]' element' null) == null)                              {                                  // We adjust the free count by --. Note: if this drops to 0' we will skip                                  // the fragment on the next search iteration.  Searching threads will -- the                                  // count and force a search every so often' just in case fragmentation occurs.                                  int newFreeCount = curr.m_freeCount - 1;                                  curr.m_freeCount = newFreeCount > 0 ? newFreeCount : 0;                                  return new SparselyPopulatedArrayAddInfo<T>(curr' tryIndex);                              }                          }                      }                        curr = curr.m_prev;                  }                    // If we got here' we need to add a new chunk to the tail and try again.                  SparselyPopulatedArrayFragment<T> newTail = new SparselyPopulatedArrayFragment<T>(                      tail.m_elements.Length == 4096 ? 4096 : tail.m_elements.Length * 2' tail);                  if (Interlocked.CompareExchange(ref tail.m_next' newTail' null) == null)                  {                      m_tail = newTail;                  }              }
Magic Number,System.Threading,SparselyPopulatedArray<T>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,Add,The following statement contains a magic number: while (true)              {                  // Get the tail' and ensure it's up to date.                  SparselyPopulatedArrayFragment<T> tail = m_tail;                  while (tail.m_next != null)                      m_tail = (tail = tail.m_next);                    // Search for a free index' starting from the tail.                  SparselyPopulatedArrayFragment<T> curr = tail;                  while (curr != null)                  {                      const int RE_SEARCH_THRESHOLD = -10; // Every 10 skips' force a search.                      if (curr.m_freeCount < 1)                          --curr.m_freeCount;                        if (curr.m_freeCount > 0 || curr.m_freeCount < RE_SEARCH_THRESHOLD)                      {                          int c = curr.Length;                            // We'll compute a start offset based on how many free slots we think there                          // are.  This optimizes for ordinary the LIFO deregistration pattern' and is                          // far from perfect due to the non-threadsafe ++ and -- of the free counter.                          int start = ((c - curr.m_freeCount) % c);                          if (start < 0)                          {                              start = 0;                              curr.m_freeCount--; // Too many free elements; fix up.                          }                          Contract.Assert(start >= 0 && start < c' "start is outside of bounds");                            // Now walk the array until we find a free slot (or reach the end).                          for (int i = 0; i < c; i++)                          {                              // If the slot is null' try to CAS our element into it.                              int tryIndex = (start + i) % c;                              Contract.Assert(tryIndex >= 0 && tryIndex < curr.m_elements.Length' "tryIndex is outside of bounds");                                                            if (curr.m_elements[tryIndex] == null && Interlocked.CompareExchange(ref curr.m_elements[tryIndex]' element' null) == null)                              {                                  // We adjust the free count by --. Note: if this drops to 0' we will skip                                  // the fragment on the next search iteration.  Searching threads will -- the                                  // count and force a search every so often' just in case fragmentation occurs.                                  int newFreeCount = curr.m_freeCount - 1;                                  curr.m_freeCount = newFreeCount > 0 ? newFreeCount : 0;                                  return new SparselyPopulatedArrayAddInfo<T>(curr' tryIndex);                              }                          }                      }                        curr = curr.m_prev;                  }                    // If we got here' we need to add a new chunk to the tail and try again.                  SparselyPopulatedArrayFragment<T> newTail = new SparselyPopulatedArrayFragment<T>(                      tail.m_elements.Length == 4096 ? 4096 : tail.m_elements.Length * 2' tail);                  if (Interlocked.CompareExchange(ref tail.m_next' newTail' null) == null)                  {                      m_tail = newTail;                  }              }
Magic Number,System.Threading,SparselyPopulatedArray<T>,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,Add,The following statement contains a magic number: while (true)              {                  // Get the tail' and ensure it's up to date.                  SparselyPopulatedArrayFragment<T> tail = m_tail;                  while (tail.m_next != null)                      m_tail = (tail = tail.m_next);                    // Search for a free index' starting from the tail.                  SparselyPopulatedArrayFragment<T> curr = tail;                  while (curr != null)                  {                      const int RE_SEARCH_THRESHOLD = -10; // Every 10 skips' force a search.                      if (curr.m_freeCount < 1)                          --curr.m_freeCount;                        if (curr.m_freeCount > 0 || curr.m_freeCount < RE_SEARCH_THRESHOLD)                      {                          int c = curr.Length;                            // We'll compute a start offset based on how many free slots we think there                          // are.  This optimizes for ordinary the LIFO deregistration pattern' and is                          // far from perfect due to the non-threadsafe ++ and -- of the free counter.                          int start = ((c - curr.m_freeCount) % c);                          if (start < 0)                          {                              start = 0;                              curr.m_freeCount--; // Too many free elements; fix up.                          }                          Contract.Assert(start >= 0 && start < c' "start is outside of bounds");                            // Now walk the array until we find a free slot (or reach the end).                          for (int i = 0; i < c; i++)                          {                              // If the slot is null' try to CAS our element into it.                              int tryIndex = (start + i) % c;                              Contract.Assert(tryIndex >= 0 && tryIndex < curr.m_elements.Length' "tryIndex is outside of bounds");                                                            if (curr.m_elements[tryIndex] == null && Interlocked.CompareExchange(ref curr.m_elements[tryIndex]' element' null) == null)                              {                                  // We adjust the free count by --. Note: if this drops to 0' we will skip                                  // the fragment on the next search iteration.  Searching threads will -- the                                  // count and force a search every so often' just in case fragmentation occurs.                                  int newFreeCount = curr.m_freeCount - 1;                                  curr.m_freeCount = newFreeCount > 0 ? newFreeCount : 0;                                  return new SparselyPopulatedArrayAddInfo<T>(curr' tryIndex);                              }                          }                      }                        curr = curr.m_prev;                  }                    // If we got here' we need to add a new chunk to the tail and try again.                  SparselyPopulatedArrayFragment<T> newTail = new SparselyPopulatedArrayFragment<T>(                      tail.m_elements.Length == 4096 ? 4096 : tail.m_elements.Length * 2' tail);                  if (Interlocked.CompareExchange(ref tail.m_next' newTail' null) == null)                  {                      m_tail = newTail;                  }              }
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Wait,The following statement contains a magic number: if (!IsSet)              {                  if (millisecondsTimeout == 0)                  {                      // For 0-timeouts' we just return immediately.                      return false;                  }                      // We spin briefly before falling back to allocating and/or waiting on a true event.                  long startTimeTicks = 0;                  bool bNeedTimeoutAdjustment = false;                  int realMillisecondsTimeout = millisecondsTimeout; //this will be adjusted if necessary.                    if (millisecondsTimeout != Timeout.Infinite)                  {                      // We will account for time spent spinning' so that we can decrement it from our                      // timeout.  In most cases the time spent in this section will be negligible.  But                      // we can't discount the possibility of our thread being switched out for a lengthy                      // period of time.  The timeout adjustments only take effect when and if we actually                      // decide to block in the kernel below.                        startTimeTicks = DateTime.UtcNow.Ticks;                      bNeedTimeoutAdjustment = true;                  }                    //spin                  int HOW_MANY_SPIN_BEFORE_YIELD = 10;                  int HOW_MANY_YIELD_EVERY_SLEEP_0 = 5;                  int HOW_MANY_YIELD_EVERY_SLEEP_1 = 20;                    for (int i = 0; i < SpinCount; i++)                  {                      if (IsSet)                      {                          return true;                      }                        else if (i < HOW_MANY_SPIN_BEFORE_YIELD)                      {                          if (i == HOW_MANY_SPIN_BEFORE_YIELD / 2)                          {  #if PFX_LEGACY_3_5                              Platform.Yield();  #else                              ThreadLightup.Current.Yield();  #endif                          }                          else                          {                              ThreadLightup.Current.SpinWait(PlatformHelper.ProcessorCount * (4 << i));                          }                      }                      else if (i % HOW_MANY_YIELD_EVERY_SLEEP_1 == 0)                      {                          ThreadLightup.Current.Sleep(1);                      }                      else if (i % HOW_MANY_YIELD_EVERY_SLEEP_0 == 0)                      {                          ThreadLightup.Current.Sleep(0);                      }                      else                      {  #if PFX_LEGACY_3_5                          Platform.Yield();  #else                          ThreadLightup.Current.Yield();  #endif                      }                        if (i >= 100 && i % 10 == 0) // check the cancellation token if the user passed a very large spin count                          cancellationToken.ThrowIfCancellationRequested();                  }                    // Now enter the lock and wait.                  EnsureLockObjectCreated();                    // We must register and deregister the token outside of the lock' to avoid deadlocks.                  using (cancellationToken.Register(s_cancellationTokenCallback' this))                  {                      lock (m_lock)                      {                          // Loop to cope with spurious wakeups from other waits being canceled                          while (!IsSet)                          {                              // If our token was canceled' we must throw and exit.                              cancellationToken.ThrowIfCancellationRequested();                                //update timeout (delays in wait commencement are due to spinning and/or spurious wakeups from other waits being canceled)                              if (bNeedTimeoutAdjustment)                              {                                  realMillisecondsTimeout = UpdateTimeOut(startTimeTicks' millisecondsTimeout);                                  if (realMillisecondsTimeout <= 0)                                      return false;                              }                                // There is a race that Set will fail to see that there are waiters as Set does not take the lock'                               // so after updating waiters' we must check IsSet again.                              // Also' we must ensure there cannot be any reordering of the assignment to Waiters and the                              // read from IsSet.  This is guaranteed as Waiters{set;} involves an Interlocked.CompareExchange                              // operation which provides a full memory barrier.                              // If we see IsSet=false' then we are guaranteed that Set() will see that we are                              // waiting and will pulse the monitor correctly.                                Waiters = Waiters + 1;                                if (IsSet) //This check must occur after updating Waiters.                              {                                  Waiters--; //revert the increment.                                  return true;                              }                                // Now finally perform the wait.                              try                              {                                  // ** the actual wait **                                  if (!Monitor.Wait(m_lock' realMillisecondsTimeout))                                      return false; //return immediately if the timeout has expired.                              }                              finally                              {                                  // Clean up: we're done waiting.                                  Waiters = Waiters - 1;                              }                                // Now just loop back around' and the right thing will happen.  Either:                              //     1. We had a spurious wake-up due to some other wait being canceled via a different cancellationToken (rewait)                              // or  2. the wait was successful. (the loop will break)                            }                      }                  }              }
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Wait,The following statement contains a magic number: if (!IsSet)              {                  if (millisecondsTimeout == 0)                  {                      // For 0-timeouts' we just return immediately.                      return false;                  }                      // We spin briefly before falling back to allocating and/or waiting on a true event.                  long startTimeTicks = 0;                  bool bNeedTimeoutAdjustment = false;                  int realMillisecondsTimeout = millisecondsTimeout; //this will be adjusted if necessary.                    if (millisecondsTimeout != Timeout.Infinite)                  {                      // We will account for time spent spinning' so that we can decrement it from our                      // timeout.  In most cases the time spent in this section will be negligible.  But                      // we can't discount the possibility of our thread being switched out for a lengthy                      // period of time.  The timeout adjustments only take effect when and if we actually                      // decide to block in the kernel below.                        startTimeTicks = DateTime.UtcNow.Ticks;                      bNeedTimeoutAdjustment = true;                  }                    //spin                  int HOW_MANY_SPIN_BEFORE_YIELD = 10;                  int HOW_MANY_YIELD_EVERY_SLEEP_0 = 5;                  int HOW_MANY_YIELD_EVERY_SLEEP_1 = 20;                    for (int i = 0; i < SpinCount; i++)                  {                      if (IsSet)                      {                          return true;                      }                        else if (i < HOW_MANY_SPIN_BEFORE_YIELD)                      {                          if (i == HOW_MANY_SPIN_BEFORE_YIELD / 2)                          {  #if PFX_LEGACY_3_5                              Platform.Yield();  #else                              ThreadLightup.Current.Yield();  #endif                          }                          else                          {                              ThreadLightup.Current.SpinWait(PlatformHelper.ProcessorCount * (4 << i));                          }                      }                      else if (i % HOW_MANY_YIELD_EVERY_SLEEP_1 == 0)                      {                          ThreadLightup.Current.Sleep(1);                      }                      else if (i % HOW_MANY_YIELD_EVERY_SLEEP_0 == 0)                      {                          ThreadLightup.Current.Sleep(0);                      }                      else                      {  #if PFX_LEGACY_3_5                          Platform.Yield();  #else                          ThreadLightup.Current.Yield();  #endif                      }                        if (i >= 100 && i % 10 == 0) // check the cancellation token if the user passed a very large spin count                          cancellationToken.ThrowIfCancellationRequested();                  }                    // Now enter the lock and wait.                  EnsureLockObjectCreated();                    // We must register and deregister the token outside of the lock' to avoid deadlocks.                  using (cancellationToken.Register(s_cancellationTokenCallback' this))                  {                      lock (m_lock)                      {                          // Loop to cope with spurious wakeups from other waits being canceled                          while (!IsSet)                          {                              // If our token was canceled' we must throw and exit.                              cancellationToken.ThrowIfCancellationRequested();                                //update timeout (delays in wait commencement are due to spinning and/or spurious wakeups from other waits being canceled)                              if (bNeedTimeoutAdjustment)                              {                                  realMillisecondsTimeout = UpdateTimeOut(startTimeTicks' millisecondsTimeout);                                  if (realMillisecondsTimeout <= 0)                                      return false;                              }                                // There is a race that Set will fail to see that there are waiters as Set does not take the lock'                               // so after updating waiters' we must check IsSet again.                              // Also' we must ensure there cannot be any reordering of the assignment to Waiters and the                              // read from IsSet.  This is guaranteed as Waiters{set;} involves an Interlocked.CompareExchange                              // operation which provides a full memory barrier.                              // If we see IsSet=false' then we are guaranteed that Set() will see that we are                              // waiting and will pulse the monitor correctly.                                Waiters = Waiters + 1;                                if (IsSet) //This check must occur after updating Waiters.                              {                                  Waiters--; //revert the increment.                                  return true;                              }                                // Now finally perform the wait.                              try                              {                                  // ** the actual wait **                                  if (!Monitor.Wait(m_lock' realMillisecondsTimeout))                                      return false; //return immediately if the timeout has expired.                              }                              finally                              {                                  // Clean up: we're done waiting.                                  Waiters = Waiters - 1;                              }                                // Now just loop back around' and the right thing will happen.  Either:                              //     1. We had a spurious wake-up due to some other wait being canceled via a different cancellationToken (rewait)                              // or  2. the wait was successful. (the loop will break)                            }                      }                  }              }
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Wait,The following statement contains a magic number: if (!IsSet)              {                  if (millisecondsTimeout == 0)                  {                      // For 0-timeouts' we just return immediately.                      return false;                  }                      // We spin briefly before falling back to allocating and/or waiting on a true event.                  long startTimeTicks = 0;                  bool bNeedTimeoutAdjustment = false;                  int realMillisecondsTimeout = millisecondsTimeout; //this will be adjusted if necessary.                    if (millisecondsTimeout != Timeout.Infinite)                  {                      // We will account for time spent spinning' so that we can decrement it from our                      // timeout.  In most cases the time spent in this section will be negligible.  But                      // we can't discount the possibility of our thread being switched out for a lengthy                      // period of time.  The timeout adjustments only take effect when and if we actually                      // decide to block in the kernel below.                        startTimeTicks = DateTime.UtcNow.Ticks;                      bNeedTimeoutAdjustment = true;                  }                    //spin                  int HOW_MANY_SPIN_BEFORE_YIELD = 10;                  int HOW_MANY_YIELD_EVERY_SLEEP_0 = 5;                  int HOW_MANY_YIELD_EVERY_SLEEP_1 = 20;                    for (int i = 0; i < SpinCount; i++)                  {                      if (IsSet)                      {                          return true;                      }                        else if (i < HOW_MANY_SPIN_BEFORE_YIELD)                      {                          if (i == HOW_MANY_SPIN_BEFORE_YIELD / 2)                          {  #if PFX_LEGACY_3_5                              Platform.Yield();  #else                              ThreadLightup.Current.Yield();  #endif                          }                          else                          {                              ThreadLightup.Current.SpinWait(PlatformHelper.ProcessorCount * (4 << i));                          }                      }                      else if (i % HOW_MANY_YIELD_EVERY_SLEEP_1 == 0)                      {                          ThreadLightup.Current.Sleep(1);                      }                      else if (i % HOW_MANY_YIELD_EVERY_SLEEP_0 == 0)                      {                          ThreadLightup.Current.Sleep(0);                      }                      else                      {  #if PFX_LEGACY_3_5                          Platform.Yield();  #else                          ThreadLightup.Current.Yield();  #endif                      }                        if (i >= 100 && i % 10 == 0) // check the cancellation token if the user passed a very large spin count                          cancellationToken.ThrowIfCancellationRequested();                  }                    // Now enter the lock and wait.                  EnsureLockObjectCreated();                    // We must register and deregister the token outside of the lock' to avoid deadlocks.                  using (cancellationToken.Register(s_cancellationTokenCallback' this))                  {                      lock (m_lock)                      {                          // Loop to cope with spurious wakeups from other waits being canceled                          while (!IsSet)                          {                              // If our token was canceled' we must throw and exit.                              cancellationToken.ThrowIfCancellationRequested();                                //update timeout (delays in wait commencement are due to spinning and/or spurious wakeups from other waits being canceled)                              if (bNeedTimeoutAdjustment)                              {                                  realMillisecondsTimeout = UpdateTimeOut(startTimeTicks' millisecondsTimeout);                                  if (realMillisecondsTimeout <= 0)                                      return false;                              }                                // There is a race that Set will fail to see that there are waiters as Set does not take the lock'                               // so after updating waiters' we must check IsSet again.                              // Also' we must ensure there cannot be any reordering of the assignment to Waiters and the                              // read from IsSet.  This is guaranteed as Waiters{set;} involves an Interlocked.CompareExchange                              // operation which provides a full memory barrier.                              // If we see IsSet=false' then we are guaranteed that Set() will see that we are                              // waiting and will pulse the monitor correctly.                                Waiters = Waiters + 1;                                if (IsSet) //This check must occur after updating Waiters.                              {                                  Waiters--; //revert the increment.                                  return true;                              }                                // Now finally perform the wait.                              try                              {                                  // ** the actual wait **                                  if (!Monitor.Wait(m_lock' realMillisecondsTimeout))                                      return false; //return immediately if the timeout has expired.                              }                              finally                              {                                  // Clean up: we're done waiting.                                  Waiters = Waiters - 1;                              }                                // Now just loop back around' and the right thing will happen.  Either:                              //     1. We had a spurious wake-up due to some other wait being canceled via a different cancellationToken (rewait)                              // or  2. the wait was successful. (the loop will break)                            }                      }                  }              }
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Wait,The following statement contains a magic number: if (!IsSet)              {                  if (millisecondsTimeout == 0)                  {                      // For 0-timeouts' we just return immediately.                      return false;                  }                      // We spin briefly before falling back to allocating and/or waiting on a true event.                  long startTimeTicks = 0;                  bool bNeedTimeoutAdjustment = false;                  int realMillisecondsTimeout = millisecondsTimeout; //this will be adjusted if necessary.                    if (millisecondsTimeout != Timeout.Infinite)                  {                      // We will account for time spent spinning' so that we can decrement it from our                      // timeout.  In most cases the time spent in this section will be negligible.  But                      // we can't discount the possibility of our thread being switched out for a lengthy                      // period of time.  The timeout adjustments only take effect when and if we actually                      // decide to block in the kernel below.                        startTimeTicks = DateTime.UtcNow.Ticks;                      bNeedTimeoutAdjustment = true;                  }                    //spin                  int HOW_MANY_SPIN_BEFORE_YIELD = 10;                  int HOW_MANY_YIELD_EVERY_SLEEP_0 = 5;                  int HOW_MANY_YIELD_EVERY_SLEEP_1 = 20;                    for (int i = 0; i < SpinCount; i++)                  {                      if (IsSet)                      {                          return true;                      }                        else if (i < HOW_MANY_SPIN_BEFORE_YIELD)                      {                          if (i == HOW_MANY_SPIN_BEFORE_YIELD / 2)                          {  #if PFX_LEGACY_3_5                              Platform.Yield();  #else                              ThreadLightup.Current.Yield();  #endif                          }                          else                          {                              ThreadLightup.Current.SpinWait(PlatformHelper.ProcessorCount * (4 << i));                          }                      }                      else if (i % HOW_MANY_YIELD_EVERY_SLEEP_1 == 0)                      {                          ThreadLightup.Current.Sleep(1);                      }                      else if (i % HOW_MANY_YIELD_EVERY_SLEEP_0 == 0)                      {                          ThreadLightup.Current.Sleep(0);                      }                      else                      {  #if PFX_LEGACY_3_5                          Platform.Yield();  #else                          ThreadLightup.Current.Yield();  #endif                      }                        if (i >= 100 && i % 10 == 0) // check the cancellation token if the user passed a very large spin count                          cancellationToken.ThrowIfCancellationRequested();                  }                    // Now enter the lock and wait.                  EnsureLockObjectCreated();                    // We must register and deregister the token outside of the lock' to avoid deadlocks.                  using (cancellationToken.Register(s_cancellationTokenCallback' this))                  {                      lock (m_lock)                      {                          // Loop to cope with spurious wakeups from other waits being canceled                          while (!IsSet)                          {                              // If our token was canceled' we must throw and exit.                              cancellationToken.ThrowIfCancellationRequested();                                //update timeout (delays in wait commencement are due to spinning and/or spurious wakeups from other waits being canceled)                              if (bNeedTimeoutAdjustment)                              {                                  realMillisecondsTimeout = UpdateTimeOut(startTimeTicks' millisecondsTimeout);                                  if (realMillisecondsTimeout <= 0)                                      return false;                              }                                // There is a race that Set will fail to see that there are waiters as Set does not take the lock'                               // so after updating waiters' we must check IsSet again.                              // Also' we must ensure there cannot be any reordering of the assignment to Waiters and the                              // read from IsSet.  This is guaranteed as Waiters{set;} involves an Interlocked.CompareExchange                              // operation which provides a full memory barrier.                              // If we see IsSet=false' then we are guaranteed that Set() will see that we are                              // waiting and will pulse the monitor correctly.                                Waiters = Waiters + 1;                                if (IsSet) //This check must occur after updating Waiters.                              {                                  Waiters--; //revert the increment.                                  return true;                              }                                // Now finally perform the wait.                              try                              {                                  // ** the actual wait **                                  if (!Monitor.Wait(m_lock' realMillisecondsTimeout))                                      return false; //return immediately if the timeout has expired.                              }                              finally                              {                                  // Clean up: we're done waiting.                                  Waiters = Waiters - 1;                              }                                // Now just loop back around' and the right thing will happen.  Either:                              //     1. We had a spurious wake-up due to some other wait being canceled via a different cancellationToken (rewait)                              // or  2. the wait was successful. (the loop will break)                            }                      }                  }              }
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Wait,The following statement contains a magic number: if (!IsSet)              {                  if (millisecondsTimeout == 0)                  {                      // For 0-timeouts' we just return immediately.                      return false;                  }                      // We spin briefly before falling back to allocating and/or waiting on a true event.                  long startTimeTicks = 0;                  bool bNeedTimeoutAdjustment = false;                  int realMillisecondsTimeout = millisecondsTimeout; //this will be adjusted if necessary.                    if (millisecondsTimeout != Timeout.Infinite)                  {                      // We will account for time spent spinning' so that we can decrement it from our                      // timeout.  In most cases the time spent in this section will be negligible.  But                      // we can't discount the possibility of our thread being switched out for a lengthy                      // period of time.  The timeout adjustments only take effect when and if we actually                      // decide to block in the kernel below.                        startTimeTicks = DateTime.UtcNow.Ticks;                      bNeedTimeoutAdjustment = true;                  }                    //spin                  int HOW_MANY_SPIN_BEFORE_YIELD = 10;                  int HOW_MANY_YIELD_EVERY_SLEEP_0 = 5;                  int HOW_MANY_YIELD_EVERY_SLEEP_1 = 20;                    for (int i = 0; i < SpinCount; i++)                  {                      if (IsSet)                      {                          return true;                      }                        else if (i < HOW_MANY_SPIN_BEFORE_YIELD)                      {                          if (i == HOW_MANY_SPIN_BEFORE_YIELD / 2)                          {  #if PFX_LEGACY_3_5                              Platform.Yield();  #else                              ThreadLightup.Current.Yield();  #endif                          }                          else                          {                              ThreadLightup.Current.SpinWait(PlatformHelper.ProcessorCount * (4 << i));                          }                      }                      else if (i % HOW_MANY_YIELD_EVERY_SLEEP_1 == 0)                      {                          ThreadLightup.Current.Sleep(1);                      }                      else if (i % HOW_MANY_YIELD_EVERY_SLEEP_0 == 0)                      {                          ThreadLightup.Current.Sleep(0);                      }                      else                      {  #if PFX_LEGACY_3_5                          Platform.Yield();  #else                          ThreadLightup.Current.Yield();  #endif                      }                        if (i >= 100 && i % 10 == 0) // check the cancellation token if the user passed a very large spin count                          cancellationToken.ThrowIfCancellationRequested();                  }                    // Now enter the lock and wait.                  EnsureLockObjectCreated();                    // We must register and deregister the token outside of the lock' to avoid deadlocks.                  using (cancellationToken.Register(s_cancellationTokenCallback' this))                  {                      lock (m_lock)                      {                          // Loop to cope with spurious wakeups from other waits being canceled                          while (!IsSet)                          {                              // If our token was canceled' we must throw and exit.                              cancellationToken.ThrowIfCancellationRequested();                                //update timeout (delays in wait commencement are due to spinning and/or spurious wakeups from other waits being canceled)                              if (bNeedTimeoutAdjustment)                              {                                  realMillisecondsTimeout = UpdateTimeOut(startTimeTicks' millisecondsTimeout);                                  if (realMillisecondsTimeout <= 0)                                      return false;                              }                                // There is a race that Set will fail to see that there are waiters as Set does not take the lock'                               // so after updating waiters' we must check IsSet again.                              // Also' we must ensure there cannot be any reordering of the assignment to Waiters and the                              // read from IsSet.  This is guaranteed as Waiters{set;} involves an Interlocked.CompareExchange                              // operation which provides a full memory barrier.                              // If we see IsSet=false' then we are guaranteed that Set() will see that we are                              // waiting and will pulse the monitor correctly.                                Waiters = Waiters + 1;                                if (IsSet) //This check must occur after updating Waiters.                              {                                  Waiters--; //revert the increment.                                  return true;                              }                                // Now finally perform the wait.                              try                              {                                  // ** the actual wait **                                  if (!Monitor.Wait(m_lock' realMillisecondsTimeout))                                      return false; //return immediately if the timeout has expired.                              }                              finally                              {                                  // Clean up: we're done waiting.                                  Waiters = Waiters - 1;                              }                                // Now just loop back around' and the right thing will happen.  Either:                              //     1. We had a spurious wake-up due to some other wait being canceled via a different cancellationToken (rewait)                              // or  2. the wait was successful. (the loop will break)                            }                      }                  }              }
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Wait,The following statement contains a magic number: if (!IsSet)              {                  if (millisecondsTimeout == 0)                  {                      // For 0-timeouts' we just return immediately.                      return false;                  }                      // We spin briefly before falling back to allocating and/or waiting on a true event.                  long startTimeTicks = 0;                  bool bNeedTimeoutAdjustment = false;                  int realMillisecondsTimeout = millisecondsTimeout; //this will be adjusted if necessary.                    if (millisecondsTimeout != Timeout.Infinite)                  {                      // We will account for time spent spinning' so that we can decrement it from our                      // timeout.  In most cases the time spent in this section will be negligible.  But                      // we can't discount the possibility of our thread being switched out for a lengthy                      // period of time.  The timeout adjustments only take effect when and if we actually                      // decide to block in the kernel below.                        startTimeTicks = DateTime.UtcNow.Ticks;                      bNeedTimeoutAdjustment = true;                  }                    //spin                  int HOW_MANY_SPIN_BEFORE_YIELD = 10;                  int HOW_MANY_YIELD_EVERY_SLEEP_0 = 5;                  int HOW_MANY_YIELD_EVERY_SLEEP_1 = 20;                    for (int i = 0; i < SpinCount; i++)                  {                      if (IsSet)                      {                          return true;                      }                        else if (i < HOW_MANY_SPIN_BEFORE_YIELD)                      {                          if (i == HOW_MANY_SPIN_BEFORE_YIELD / 2)                          {  #if PFX_LEGACY_3_5                              Platform.Yield();  #else                              ThreadLightup.Current.Yield();  #endif                          }                          else                          {                              ThreadLightup.Current.SpinWait(PlatformHelper.ProcessorCount * (4 << i));                          }                      }                      else if (i % HOW_MANY_YIELD_EVERY_SLEEP_1 == 0)                      {                          ThreadLightup.Current.Sleep(1);                      }                      else if (i % HOW_MANY_YIELD_EVERY_SLEEP_0 == 0)                      {                          ThreadLightup.Current.Sleep(0);                      }                      else                      {  #if PFX_LEGACY_3_5                          Platform.Yield();  #else                          ThreadLightup.Current.Yield();  #endif                      }                        if (i >= 100 && i % 10 == 0) // check the cancellation token if the user passed a very large spin count                          cancellationToken.ThrowIfCancellationRequested();                  }                    // Now enter the lock and wait.                  EnsureLockObjectCreated();                    // We must register and deregister the token outside of the lock' to avoid deadlocks.                  using (cancellationToken.Register(s_cancellationTokenCallback' this))                  {                      lock (m_lock)                      {                          // Loop to cope with spurious wakeups from other waits being canceled                          while (!IsSet)                          {                              // If our token was canceled' we must throw and exit.                              cancellationToken.ThrowIfCancellationRequested();                                //update timeout (delays in wait commencement are due to spinning and/or spurious wakeups from other waits being canceled)                              if (bNeedTimeoutAdjustment)                              {                                  realMillisecondsTimeout = UpdateTimeOut(startTimeTicks' millisecondsTimeout);                                  if (realMillisecondsTimeout <= 0)                                      return false;                              }                                // There is a race that Set will fail to see that there are waiters as Set does not take the lock'                               // so after updating waiters' we must check IsSet again.                              // Also' we must ensure there cannot be any reordering of the assignment to Waiters and the                              // read from IsSet.  This is guaranteed as Waiters{set;} involves an Interlocked.CompareExchange                              // operation which provides a full memory barrier.                              // If we see IsSet=false' then we are guaranteed that Set() will see that we are                              // waiting and will pulse the monitor correctly.                                Waiters = Waiters + 1;                                if (IsSet) //This check must occur after updating Waiters.                              {                                  Waiters--; //revert the increment.                                  return true;                              }                                // Now finally perform the wait.                              try                              {                                  // ** the actual wait **                                  if (!Monitor.Wait(m_lock' realMillisecondsTimeout))                                      return false; //return immediately if the timeout has expired.                              }                              finally                              {                                  // Clean up: we're done waiting.                                  Waiters = Waiters - 1;                              }                                // Now just loop back around' and the right thing will happen.  Either:                              //     1. We had a spurious wake-up due to some other wait being canceled via a different cancellationToken (rewait)                              // or  2. the wait was successful. (the loop will break)                            }                      }                  }              }
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Wait,The following statement contains a magic number: if (!IsSet)              {                  if (millisecondsTimeout == 0)                  {                      // For 0-timeouts' we just return immediately.                      return false;                  }                      // We spin briefly before falling back to allocating and/or waiting on a true event.                  long startTimeTicks = 0;                  bool bNeedTimeoutAdjustment = false;                  int realMillisecondsTimeout = millisecondsTimeout; //this will be adjusted if necessary.                    if (millisecondsTimeout != Timeout.Infinite)                  {                      // We will account for time spent spinning' so that we can decrement it from our                      // timeout.  In most cases the time spent in this section will be negligible.  But                      // we can't discount the possibility of our thread being switched out for a lengthy                      // period of time.  The timeout adjustments only take effect when and if we actually                      // decide to block in the kernel below.                        startTimeTicks = DateTime.UtcNow.Ticks;                      bNeedTimeoutAdjustment = true;                  }                    //spin                  int HOW_MANY_SPIN_BEFORE_YIELD = 10;                  int HOW_MANY_YIELD_EVERY_SLEEP_0 = 5;                  int HOW_MANY_YIELD_EVERY_SLEEP_1 = 20;                    for (int i = 0; i < SpinCount; i++)                  {                      if (IsSet)                      {                          return true;                      }                        else if (i < HOW_MANY_SPIN_BEFORE_YIELD)                      {                          if (i == HOW_MANY_SPIN_BEFORE_YIELD / 2)                          {  #if PFX_LEGACY_3_5                              Platform.Yield();  #else                              ThreadLightup.Current.Yield();  #endif                          }                          else                          {                              ThreadLightup.Current.SpinWait(PlatformHelper.ProcessorCount * (4 << i));                          }                      }                      else if (i % HOW_MANY_YIELD_EVERY_SLEEP_1 == 0)                      {                          ThreadLightup.Current.Sleep(1);                      }                      else if (i % HOW_MANY_YIELD_EVERY_SLEEP_0 == 0)                      {                          ThreadLightup.Current.Sleep(0);                      }                      else                      {  #if PFX_LEGACY_3_5                          Platform.Yield();  #else                          ThreadLightup.Current.Yield();  #endif                      }                        if (i >= 100 && i % 10 == 0) // check the cancellation token if the user passed a very large spin count                          cancellationToken.ThrowIfCancellationRequested();                  }                    // Now enter the lock and wait.                  EnsureLockObjectCreated();                    // We must register and deregister the token outside of the lock' to avoid deadlocks.                  using (cancellationToken.Register(s_cancellationTokenCallback' this))                  {                      lock (m_lock)                      {                          // Loop to cope with spurious wakeups from other waits being canceled                          while (!IsSet)                          {                              // If our token was canceled' we must throw and exit.                              cancellationToken.ThrowIfCancellationRequested();                                //update timeout (delays in wait commencement are due to spinning and/or spurious wakeups from other waits being canceled)                              if (bNeedTimeoutAdjustment)                              {                                  realMillisecondsTimeout = UpdateTimeOut(startTimeTicks' millisecondsTimeout);                                  if (realMillisecondsTimeout <= 0)                                      return false;                              }                                // There is a race that Set will fail to see that there are waiters as Set does not take the lock'                               // so after updating waiters' we must check IsSet again.                              // Also' we must ensure there cannot be any reordering of the assignment to Waiters and the                              // read from IsSet.  This is guaranteed as Waiters{set;} involves an Interlocked.CompareExchange                              // operation which provides a full memory barrier.                              // If we see IsSet=false' then we are guaranteed that Set() will see that we are                              // waiting and will pulse the monitor correctly.                                Waiters = Waiters + 1;                                if (IsSet) //This check must occur after updating Waiters.                              {                                  Waiters--; //revert the increment.                                  return true;                              }                                // Now finally perform the wait.                              try                              {                                  // ** the actual wait **                                  if (!Monitor.Wait(m_lock' realMillisecondsTimeout))                                      return false; //return immediately if the timeout has expired.                              }                              finally                              {                                  // Clean up: we're done waiting.                                  Waiters = Waiters - 1;                              }                                // Now just loop back around' and the right thing will happen.  Either:                              //     1. We had a spurious wake-up due to some other wait being canceled via a different cancellationToken (rewait)                              // or  2. the wait was successful. (the loop will break)                            }                      }                  }              }
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,UpdateTimeOut,The following statement contains a magic number: if (elapsedMilliseconds > int.MaxValue)              {                  return -2;              }
Magic Number,System.Threading,SpinWait,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\SpinWait.cs,SpinOnce,The following statement contains a magic number: if (NextSpinWillYield)              {                  //                  // We must yield.                  //                  // We prefer to call Thread.Yield first' triggering a SwitchToThread. This                  // unfortunately doesn't consider all runnable threads on all OS SKUs. In                  // some cases' it may only consult the runnable threads whose ideal processor                  // is the one currently executing code. Thus we ocassionally issue a call to                  // Sleep(0)' which considers all runnable threads at equal priority. Even this                  // is insufficient since we may be spin waiting for lower priority threads to                  // execute; we therefore must call Sleep(1) once in a while too' which considers                  // all runnable threads' regardless of ideal processor and priority' but may                  // remove the thread from the scheduler's queue for 10+ms' if the system is                  // configured to use the (default) coarse-grained system timer.                  //    #if ETW_EVENTING  // PAL doesn't support  eventing' and we don't compile CDS providers for Coreclr                  CdsSyncEtwBCLProvider.Log.SpinWait_NextSpinWillYield();  #endif                  int yieldsSoFar = (m_count >= YIELD_THRESHOLD ? m_count - YIELD_THRESHOLD : m_count);                    if ((yieldsSoFar % SLEEP_1_EVERY_HOW_MANY_TIMES) == (SLEEP_1_EVERY_HOW_MANY_TIMES - 1))                  {                      ThreadLightup.Current.Sleep(1);                  }                  else if ((yieldsSoFar % SLEEP_0_EVERY_HOW_MANY_TIMES) == (SLEEP_0_EVERY_HOW_MANY_TIMES - 1))                  {                      ThreadLightup.Current.Sleep(0);                  }                  else                  {  #if PFX_LEGACY_3_5                      Platform.Yield();  #else                      ThreadLightup.Current.Yield();  #endif                  }              }              else              {                  //                  // Otherwise' we will spin.                  //                  // We do this using the CLR's SpinWait API' which is just a busy loop that                  // issues YIELD/PAUSE instructions to ensure multi-threaded CPUs can react                  // intelligently to avoid starving. (These are NOOPs on other CPUs.) We                  // choose a number for the loop iteration count such that each successive                  // call spins for longer' to reduce cache contention.  We cap the total                  // number of spins we are willing to tolerate to reduce delay to the caller'                  // since we expect most callers will eventually block anyway.                  //                  ThreadLightup.Current.SpinWait(4 << m_count);              }
Missing Default,System.Threading.Tasks,TaskExtensions,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskExtensions.cs,Unwrap,The following switch statement is missing a default case: switch (task.Status)                  {                      // If task did not run to completion' then record the cancellation/fault information                      // to tcs.Task.                      case TaskStatus.Canceled:                      case TaskStatus.Faulted:                          result = tcs.TrySetFromTask(task);                          Contract.Assert(result' "Unwrap(Task<Task>): Expected TrySetFromTask #1 to succeed");                          break;                        case TaskStatus.RanToCompletion:                          // task.Result == null ==> proxy should be canceled.                          if (task.Result == null) tcs.TrySetCanceled();                            // When task.Result completes' take some action to set the completion state of tcs.Task.                          else                          {                              task.Result.ContinueWith(_ =>                              {                                  // Copy completion/cancellation/exception info from task.Result to tcs.Task.                                  result = tcs.TrySetFromTask(task.Result);                                  Contract.Assert(result' "Unwrap(Task<Task>): Expected TrySetFromTask #2 to succeed");                              }' CancellationToken.None' TaskContinuationOptions.ExecuteSynchronously' TaskScheduler.Default);                          }                          break;                  }
Missing Default,System.Threading.Tasks,TaskExtensions,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskExtensions.cs,Unwrap,The following switch statement is missing a default case: switch (task.Status)                  {                      // If task did not run to completion' then record the cancellation/fault information                      // to tcs.Task.                      case TaskStatus.Canceled:                      case TaskStatus.Faulted:                          result = tcs.TrySetFromTask(task);                          Contract.Assert(result' "Unwrap(Task<Task<T>>): Expected TrySetFromTask #1 to succeed");                          break;                        case TaskStatus.RanToCompletion:                          // task.Result == null ==> proxy should be canceled.                          if (task.Result == null) tcs.TrySetCanceled();                            // When task.Result completes' take some action to set the completion state of tcs.Task.                          else                          {                              task.Result.ContinueWith(_ =>                              {                                  // Copy completion/cancellation/exception info from task.Result to tcs.Task.                                  result = tcs.TrySetFromTask(task.Result);                                  Contract.Assert(result' "Unwrap(Task<Task<T>>): Expected TrySetFromTask #2 to succeed");                              }' CancellationToken.None' TaskContinuationOptions.ExecuteSynchronously' TaskScheduler.Default);                          }                            break;                  }
Missing Default,System.Threading.Tasks,TaskExtensions,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskExtensions.cs,TrySetFromTask,The following switch statement is missing a default case: switch(source.Status)              {                  case TaskStatus.Canceled:                      rval = me.TrySetCanceled();                      break;                    case TaskStatus.Faulted:                      rval = me.TrySetException(source.Exception.InnerExceptions);                      break;                    case TaskStatus.RanToCompletion:                      if(source is Task<TResult>)                          rval = me.TrySetResult( ((Task<TResult>)source).Result);                      else                          rval = me.TrySetResult(default(TResult));                      break;              }
