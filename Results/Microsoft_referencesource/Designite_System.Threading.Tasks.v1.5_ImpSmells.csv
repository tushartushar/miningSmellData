Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Wait,The method has 114 lines of code.
Complex Method,System.Collections.Concurrent,ConcurrentDictionary,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,TryAddInternal,Cyclomatic complexity of the method is 10
Complex Method,System.Collections.Concurrent,ConcurrentDictionary,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,AddOrUpdate,Cyclomatic complexity of the method is 8
Complex Method,System.Collections.Concurrent,ConcurrentDictionary,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,CopyTo,Cyclomatic complexity of the method is 8
Complex Method,System.Threading.Tasks,TaskCompletionSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskCompletionSource.cs,TrySetException,Cyclomatic complexity of the method is 8
Complex Method,System.Threading.Tasks,TaskExtensions,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskExtensions.cs,TrySetFromTask,Cyclomatic complexity of the method is 10
Complex Method,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,ExecuteCallbackHandlers,Cyclomatic complexity of the method is 10
Complex Method,System.Threading,SparselyPopulatedArray,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,Add,Cyclomatic complexity of the method is 11
Complex Method,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Wait,Cyclomatic complexity of the method is 14
Complex Method,System.Threading,SpinWait,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\SpinWait.cs,SpinUntil,Cyclomatic complexity of the method is 8
Long Parameter List,System,Lightup,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Lightup\Lightup.cs,TryCall,The method has 5 parameters.
Long Parameter List,System.Collections.Concurrent,ConcurrentDictionary,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,TryAddInternal,The method has 5 parameters.
Long Parameter List,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,Task,The method has 7 parameters.
Long Parameter List,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,Task,The method has 6 parameters.
Long Parameter List,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,Task,The method has 8 parameters.
Long Parameter List,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,Task,The method has 7 parameters.
Long Parameter List,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,StartNew,The method has 7 parameters.
Long Parameter List,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,StartNew,The method has 8 parameters.
Long Parameter List,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,ContinueWith,The method has 6 parameters.
Long Parameter List,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,ContinueWith,The method has 5 parameters.
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,StartNew,The method has 5 parameters.
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,FromAsyncImpl,The method has 6 parameters.
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,FromAsyncImpl,The method has 5 parameters.
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,FromAsync,The method has 5 parameters.
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,FromAsyncImpl,The method has 6 parameters.
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,FromAsync,The method has 5 parameters.
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,FromAsync,The method has 6 parameters.
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,FromAsyncImpl,The method has 7 parameters.
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,FromAsync,The method has 6 parameters.
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,FromAsync,The method has 7 parameters.
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,FromAsyncImpl,The method has 8 parameters.
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAll,The method has 5 parameters.
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAll,The method has 7 parameters.
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAll,The method has 5 parameters.
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAll,The method has 7 parameters.
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAny,The method has 5 parameters.
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAny,The method has 7 parameters.
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAny,The method has 5 parameters.
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAny,The method has 7 parameters.
Long Identifier,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,UpdateTimeOut,The length of the parameter originalWaitMillisecondsTimeout is 31.
Long Statement,System,AggregateException,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\AggregateException.cs,GetBaseException,The length of the statement  "	// Recursively traverse the inner exceptions as long as the inner exception of type AggregateException and has only one inner exception " is 135.
Long Statement,System,AggregateException,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\AggregateException.cs,ToString,The length of the statement  "		text = String.Format (CultureInfo.InvariantCulture' Strings.AggregateException_ToString' text' Environment.NewLine' i' m_innerExceptions [i].ToString ()' "<---"' Environment.NewLine); " is 183.
Long Statement,System,ExecutionContextLightup,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Lightup\ExecutionContextLightup.cs,Run,The length of the statement  "	Type actionRepresentingSignature = typeof(Action<' ' >).MakeGenericType (LightupType.ExecutionContext' LightupType.ContextCallback' typeof(object)); " is 148.
Long Statement,System,LightupServices,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Lightup\Lightup.cs,IsActionType,The length of the statement  "	return type == typeof(Action) || type == typeof(Action<>) || type == typeof(Action<' >) || type == typeof(Action<' ' >) || type == typeof(Action<' ' ' >); " is 154.
Long Statement,System.Collections.Concurrent,ConcurrentDictionary,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The length of the statement  "		// Compute the new table size. We find the smallest integer larger than twice the previous table size' and not divisible by " is 123.
Long Statement,System.Runtime.CompilerServices,AsyncMethodBuilderCore,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Runtime\CompilerServices\AsyncMethodBuilderCore.cs,GetCompletionAction,The length of the statement  "		Contract.Assert (!Object.ReferenceEquals ((object)stateMachine' (object)stateMachine)' "Expected an unboxed state machine reference"); " is 134.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,StartNew,The length of the statement  "	Task<TResult> f = new Task<TResult> (function' parent' cancellationToken' creationOptions' internalOptions | InternalTaskOptions.QueuedByRuntime' scheduler' ref stackMark); " is 172.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,StartNew,The length of the statement  "	Task<TResult> f = new Task<TResult> (function' state' parent' cancellationToken' creationOptions' internalOptions | InternalTaskOptions.QueuedByRuntime' scheduler' ref stackMark); " is 179.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,TrySetResult,The length of the statement  "	if (AtomicStateUpdate (TASK_STATE_COMPLETION_RESERVED' TASK_STATE_COMPLETION_RESERVED | TASK_STATE_RAN_TO_COMPLETION | TASK_STATE_FAULTED | TASK_STATE_CANCELED)) { " is 163.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,TrySetException,The length of the statement  "	Contract.Assert ((exceptionObject is Exception) || (exceptionObject is IEnumerable<Exception>)' "Expected exceptionObject to be either Exception or IEnumerable<Exception>"); " is 173.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,TrySetException,The length of the statement  "	if (AtomicStateUpdate (TASK_STATE_COMPLETION_RESERVED' TASK_STATE_COMPLETION_RESERVED | TASK_STATE_RAN_TO_COMPLETION | TASK_STATE_FAULTED | TASK_STATE_CANCELED)) { " is 163.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,ContinueWith,The length of the statement  "	return ContinueWith (continuationAction' TaskScheduler.Current' CancellationToken.None' TaskContinuationOptions.None' ref stackMark); " is 133.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,ContinueWith,The length of the statement  "	return ContinueWith (continuationAction' TaskScheduler.Current' cancellationToken' TaskContinuationOptions.None' ref stackMark); " is 128.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,ContinueWith,The length of the statement  "	return ContinueWith (continuationAction' scheduler' CancellationToken.None' TaskContinuationOptions.None' ref stackMark); " is 121.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,ContinueWith,The length of the statement  "	return ContinueWith (continuationAction' TaskScheduler.Current' CancellationToken.None' continuationOptions' ref stackMark); " is 124.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,ContinueWith,The length of the statement  "	}' null' Task.InternalCurrent' cancellationToken' creationOptions' internalOptions' null' // leave scheduler null until TaskContinuation.Run() is called " is 152.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,ContinueWith,The length of the statement  "	return ContinueWith<TNewResult> (continuationFunction' TaskScheduler.Current' CancellationToken.None' TaskContinuationOptions.None' ref stackMark); " is 147.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,ContinueWith,The length of the statement  "	return ContinueWith<TNewResult> (continuationFunction' TaskScheduler.Current' cancellationToken' TaskContinuationOptions.None' ref stackMark); " is 142.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,ContinueWith,The length of the statement  "	return ContinueWith<TNewResult> (continuationFunction' scheduler' CancellationToken.None' TaskContinuationOptions.None' ref stackMark); " is 135.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,ContinueWith,The length of the statement  "	return ContinueWith<TNewResult> (continuationFunction' TaskScheduler.Current' CancellationToken.None' continuationOptions' ref stackMark); " is 138.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,ContinueWith,The length of the statement  "	return ContinueWith<TNewResult> (continuationFunction' scheduler' cancellationToken' continuationOptions' ref stackMark); " is 121.
Long Statement,System.Threading.Tasks,Task,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskOfTResult.cs,ContinueWith,The length of the statement  "	}' Task.InternalCurrent' cancellationToken' creationOptions' internalOptions' null' // leave scheduler null until TaskContinuation.Run() is called. " is 147.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,StartNew,The length of the statement  "	return Task<TResult>.StartNew (currTask' function' m_defaultCancellationToken' m_defaultCreationOptions' InternalTaskOptions.None' GetDefaultScheduler (currTask)' ref stackMark); " is 178.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,StartNew,The length of the statement  "	return Task<TResult>.StartNew (currTask' function' cancellationToken' m_defaultCreationOptions' InternalTaskOptions.None' GetDefaultScheduler (currTask)' ref stackMark); " is 169.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,StartNew,The length of the statement  "	return Task<TResult>.StartNew (currTask' function' m_defaultCancellationToken' creationOptions' InternalTaskOptions.None' GetDefaultScheduler (currTask)' ref stackMark); " is 169.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,StartNew,The length of the statement  "	return Task<TResult>.StartNew (Task.InternalCurrent' function' cancellationToken' creationOptions' InternalTaskOptions.None' scheduler' ref stackMark); " is 151.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,StartNew,The length of the statement  "	return Task<TResult>.StartNew (currTask' function' state' m_defaultCancellationToken' m_defaultCreationOptions' InternalTaskOptions.None' GetDefaultScheduler (currTask)' ref stackMark); " is 185.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,StartNew,The length of the statement  "	return Task<TResult>.StartNew (currTask' function' state' cancellationToken' m_defaultCreationOptions' InternalTaskOptions.None' GetDefaultScheduler (currTask)' ref stackMark); " is 176.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,StartNew,The length of the statement  "	return Task<TResult>.StartNew (currTask' function' state' m_defaultCancellationToken' creationOptions' InternalTaskOptions.None' GetDefaultScheduler (currTask)' ref stackMark); " is 176.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,StartNew,The length of the statement  "	return Task<TResult>.StartNew (Task.InternalCurrent' function' state' cancellationToken' creationOptions' InternalTaskOptions.None' scheduler' ref stackMark); " is 158.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,FromAsyncImpl,The length of the statement  "	}' (object)null' Task.InternalCurrent' CancellationToken.None' TaskCreationOptions.None' InternalTaskOptions.None' null' ref stackMark); " is 136.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAll,The length of the statement  "	return ContinueWhenAll (tasks' continuationFunction' m_defaultContinuationOptions' m_defaultCancellationToken' DefaultScheduler' ref stackMark); " is 144.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAll,The length of the statement  "	return ContinueWhenAll (tasks' continuationFunction' m_defaultContinuationOptions' cancellationToken' DefaultScheduler' ref stackMark); " is 135.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAll,The length of the statement  "	return ContinueWhenAll (tasks' continuationFunction' continuationOptions' m_defaultCancellationToken' DefaultScheduler' ref stackMark); " is 135.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAll,The length of the statement  "	return ContinueWhenAll<TAntecedentResult> (tasks' continuationFunction' m_defaultContinuationOptions' m_defaultCancellationToken' DefaultScheduler' ref stackMark); " is 163.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAll,The length of the statement  "	return ContinueWhenAll<TAntecedentResult> (tasks' continuationFunction' m_defaultContinuationOptions' cancellationToken' DefaultScheduler' ref stackMark); " is 154.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAll,The length of the statement  "	return ContinueWhenAll<TAntecedentResult> (tasks' continuationFunction' continuationOptions' m_defaultCancellationToken' DefaultScheduler' ref stackMark); " is 154.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAll,The length of the statement  "	return ContinueWhenAll<TAntecedentResult> (tasks' continuationFunction' continuationOptions' cancellationToken' scheduler' ref stackMark); " is 138.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAny,The length of the statement  "	return ContinueWhenAny (tasks' continuationFunction' m_defaultContinuationOptions' m_defaultCancellationToken' DefaultScheduler' ref stackMark); " is 144.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAny,The length of the statement  "	return ContinueWhenAny (tasks' continuationFunction' m_defaultContinuationOptions' cancellationToken' DefaultScheduler' ref stackMark); " is 135.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAny,The length of the statement  "	return ContinueWhenAny (tasks' continuationFunction' continuationOptions' m_defaultCancellationToken' DefaultScheduler' ref stackMark); " is 135.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAny,The length of the statement  "	return ContinueWhenAny<TAntecedentResult> (tasks' continuationFunction' m_defaultContinuationOptions' m_defaultCancellationToken' DefaultScheduler' ref stackMark); " is 163.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAny,The length of the statement  "	return ContinueWhenAny<TAntecedentResult> (tasks' continuationFunction' m_defaultContinuationOptions' cancellationToken' DefaultScheduler' ref stackMark); " is 154.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAny,The length of the statement  "	return ContinueWhenAny<TAntecedentResult> (tasks' continuationFunction' continuationOptions' m_defaultCancellationToken' DefaultScheduler' ref stackMark); " is 154.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskFactoryOfTResult.cs,ContinueWhenAny,The length of the statement  "	return ContinueWhenAny<TAntecedentResult> (tasks' continuationFunction' continuationOptions' cancellationToken' scheduler' ref stackMark); " is 138.
Long Statement,System.Threading.Tasks,TaskCompletionSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskCompletionSource.cs,TrySetCanceled,The length of the statement  "	if (m_task.AtomicStateUpdate (Task<object>.TASK_STATE_COMPLETION_RESERVED' Task<object>.TASK_STATE_COMPLETION_RESERVED | Task<object>.TASK_STATE_CANCELED | Task<object>.TASK_STATE_FAULTED | Task<object>.TASK_STATE_RAN_TO_COMPLETION)) { " is 235.
Long Statement,System.Threading.Tasks,TaskExceptionHolder,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskExceptionHolder.cs,Add,The length of the statement  "	Contract.Assert (exceptionObject is Exception || exceptionObject is IEnumerable<Exception>' "TaskExceptionHolder.Add(): Expected Exception or IEnumerable<Exception>"); " is 167.
Long Statement,System.Threading.Tasks,TaskExceptionHolder,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskExceptionHolder.cs,Add,The length of the statement  "		if (m_exceptions [i].GetType () != ThreadingServices.ThreadAbortExceptionType && m_exceptions [i].GetType () != ThreadingServices.AppDomainUnloadedExceptionType) { " is 163.
Long Statement,System.Threading.Tasks,TaskScheduler,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskScheduler.cs,TryRunInline,The length of the statement  "	// No need to attempt inlining if the task body was already run (i.e. either TASK_STATE_DELEGATE_INVOKED or TASK_STATE_CANCELED bits set) " is 137.
Long Statement,System.Threading.Tasks,TaskScheduler,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskScheduler.cs,TryRunInline,The length of the statement  "	// 2) we maintain a mechanism for the TLS lookup optimization that we used to have for the ConcRT scheduler (will potentially introduce the same for TP) " is 152.
Long Statement,System.Threading.Tasks,TaskScheduler,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskScheduler.cs,TryRunInline,The length of the statement  "	// If the custom scheduler returned true' we should either have the TASK_STATE_DELEGATE_INVOKED or TASK_STATE_CANCELED bit set " is 126.
Long Statement,System.Threading.Tasks,SynchronizationContextTaskScheduler,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskScheduler.cs,PostCallback,The length of the statement  "	// calling ExecuteEntry with double execute check enabled because a user implemented SynchronizationContext could be buggy " is 122.
Long Statement,System.Threading,CancellationToken,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationToken.cs,InitializeDefaultSource,The length of the statement  "	// Alternative: LazyInititalizer.EnsureInitialized(ref m_source' ()=>CancellationTokenSource.InternalGetStaticSource(false)); " is 125.
Long Statement,System.Threading,CancellationTokenRegistration,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenRegistration.cs,TryDeregister,The length of the statement  "	CancellationCallbackInfo prevailingCallbackInfoInSlot = m_registrationInfo.Source.SafeAtomicRemove (m_registrationInfo.Index' m_callbackInfo); " is 142.
Long Statement,System.Threading,CancellationTokenRegistration,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenRegistration.cs,Dispose,The length of the statement  "	// We guarantee that we will not return if the callback is being executed (assuming we are not currently called by the callback itself) " is 135.
Long Statement,System.Threading,CancellationTokenRegistration,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenRegistration.cs,Dispose,The length of the statement  "	//    1. if we are called in the context of an executing callback' no need to wait (determined by tracking callback-executor threadID) " is 134.
Long Statement,System.Threading,CancellationTokenRegistration,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenRegistration.cs,Dispose,The length of the statement  "	//       - if the currently executing callback is this CTR' then waiting would deadlock. (We choose to return rather than deadlock) " is 131.
Long Statement,System.Threading,CancellationTokenRegistration,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenRegistration.cs,Dispose,The length of the statement  "	//    2. if deregistration failed' and we are on a different thread' then the callback may be running under control of cts.Cancel() " is 131.
Long Statement,System.Threading,CancellationTokenRegistration,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenRegistration.cs,Dispose,The length of the statement  "	m_tokenSource.ThreadIDExecutingCallbacks != Thread.CurrentThread.ManagedThreadId)//the executingThreadID is not this threadID. " is 126.
Long Statement,System.Threading,CancellationTokenRegistration,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenRegistration.cs,Equals,The length of the statement  "	return m_tokenSource == other.m_tokenSource && m_callbackInfo == other.m_callbackInfo && m_registrationInfo.Source == other.m_registrationInfo.Source && m_registrationInfo.Index == other.m_registrationInfo.Index; " is 212.
Long Statement,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,InternalRegister,The length of the statement  "		CancellationCallbackInfo callbackInfo = new CancellationCallbackInfo (callback' stateForCallback' targetSyncContext' this); " is 123.
Long Statement,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,InternalRegister,The length of the statement  "			SparselyPopulatedArray<CancellationCallbackInfo>[] list = new SparselyPopulatedArray<CancellationCallbackInfo>[s_nLists]; " is 121.
Long Statement,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,InternalRegister,The length of the statement  "			SparselyPopulatedArray<CancellationCallbackInfo> callBackArray = new SparselyPopulatedArray<CancellationCallbackInfo> (4); " is 122.
Long Statement,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,ExecuteCallbackHandlers,The length of the statement  "	Contract.Assert (IsCancellationRequested' "ExecuteCallbackHandlers should only be called after setting IsCancellationRequested->true"); " is 135.
Long Statement,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,CancellationCallbackCoreWork_OnSyncContext,The length of the statement  "	CancellationCallbackInfo callback = args.m_currArrayFragment.SafeAtomicRemove (args.m_currArrayIndex' m_executingCallback); " is 123.
Long Statement,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,CreateLinkedTokenSource,The length of the statement  "		linkedTokenSource.m_linkingRegistrations.Add (token1.InternalRegisterWithoutEC (s_LinkedTokenCancelDelegate' linkedTokenSource)); " is 129.
Long Statement,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,CreateLinkedTokenSource,The length of the statement  "		linkedTokenSource.m_linkingRegistrations.Add (token2.InternalRegisterWithoutEC (s_LinkedTokenCancelDelegate' linkedTokenSource)); " is 129.
Long Statement,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,CreateLinkedTokenSource,The length of the statement  "			linkedTokenSource.m_linkingRegistrations.Add (tokens [i].InternalRegisterWithoutEC (s_LinkedTokenCancelDelegate' linkedTokenSource)); " is 133.
Long Statement,System.Threading,SparselyPopulatedArray,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,Add,The length of the statement  "					if (curr.m_elements [tryIndex] == null && Interlocked.CompareExchange (ref curr.m_elements [tryIndex]' element' null) == null) { " is 128.
Long Statement,System.Threading,SparselyPopulatedArray,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,Add,The length of the statement  "		SparselyPopulatedArrayFragment<T> newTail = new SparselyPopulatedArrayFragment<T> (tail.m_elements.Length == 4096 ? 4096 : tail.m_elements.Length * 2' tail); " is 157.
Long Statement,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Initialize,The length of the statement  "	Contract.Assert (DEFAULT_SPIN_SP <= SpinCountState_MaxValue' "Internal error - DEFAULT_SPIN_SP is outside the legal range."); " is 125.
Long Statement,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Set,The length of the statement  "	//Design-decision: do not set the event if we are in cancellation -> better to deadlock than to wake up waiters incorrectly " is 123.
Long Statement,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Wait,The length of the statement  "					//update timeout (delays in wait commencement are due to spinning and/or spurious wakeups from other waits being canceled) " is 122.
Complex Conditional,System.Threading.Tasks,TaskScheduler,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskScheduler.cs,TryRunInline,The conditional expression  "(ets == null) || (task.m_action == null) || task.IsDelegateInvoked || task.IsCanceled"  is complex.
Complex Conditional,System.Threading,CancellationTokenRegistration,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenRegistration.cs,Dispose,The conditional expression  "m_tokenSource != null && m_tokenSource.IsCancellationRequested && //running callbacks has commenced.  !m_tokenSource.IsCancellationCompleted && //running callbacks hasn't finished  !deregisterOccured && //deregistration failed (ie the callback is missing from the list)  m_tokenSource.ThreadIDExecutingCallbacks != Thread.CurrentThread.ManagedThreadId"  is complex.
Empty Catch Block,System,LightupServices,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Lightup\Lightup.cs,CreateDelegate,The method has an empty catch block.
Empty Catch Block,System,LightupServices,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Lightup\Lightup.cs,CreateDelegate,The method has an empty catch block.
Empty Catch Block,System.Runtime.CompilerServices,AsyncVoidMethodBuilder,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Runtime\CompilerServices\AsyncVoidMethodBuilder.cs,AsyncVoidMethodBuilder,The method has an empty catch block.
Magic Number,System.Collections.Concurrent,ConcurrentDictionary,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: try {  	// The thread that first obtains m_locks[0] will be the one doing the resize operation  	AcquireLocks (0' 1' ref locksAcquired);  	// Make sure nobody resized the table while we were waiting for lock 0:  	if (buckets != m_buckets) {  		// We assume that since the table reference is different' it was already resized. If we ever  		// decide to do table shrinking' or replace the table for other reasons' we will have to revisit  		// this logic.  		return;  	}  	// Compute the new table size. We find the smallest integer larger than twice the previous table size' and not divisible by  	// 2'3'5 or 7. We can consider a different table-sizing policy in the future.  	int newLength;  	try {  		checked {  			// Double the size of the buckets table and add one' so that we have an odd integer.  			newLength = buckets.Length * 2 + 1;  			// Now' we only need to check odd integers' and find the first that is not divisible  			// by 3' 5 or 7.  			while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0) {  				newLength += 2;  			}  			Assert (newLength % 2 != 0);  		}  	}  	catch (OverflowException) {  		// If we were to resize the table' its new size will not fit into a 32-bit signed int. Just return.  		return;  	}  	Node[] newBuckets = new Node[newLength];  	int[] newCountPerLock = new int[m_locks.Length];  	// Now acquire all other locks for the table  	AcquireLocks (1' m_locks.Length' ref locksAcquired);  	// Copy all data into a new table' creating new nodes for all elements  	for (int i = 0; i < buckets.Length; i++) {  		Node current = buckets [i];  		while (current != null) {  			Node next = current.m_next;  			int newBucketNo' newLockNo;  			GetBucketAndLockNo (current.m_hashcode' out newBucketNo' out newLockNo' newBuckets.Length);  			newBuckets [newBucketNo] = new Node (current.m_key' current.m_value' current.m_hashcode' newBuckets [newBucketNo]);  			checked {  				newCountPerLock [newLockNo]++;  			}  			current = next;  		}  	}  	// And finally adjust m_buckets and m_countPerLock to point to data for the new table  	m_buckets = newBuckets;  	m_countPerLock = newCountPerLock;  }  finally {  	// Release all locks that we took earlier  	ReleaseLocks (0' locksAcquired);  }  
Magic Number,System.Collections.Concurrent,ConcurrentDictionary,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: try {  	// The thread that first obtains m_locks[0] will be the one doing the resize operation  	AcquireLocks (0' 1' ref locksAcquired);  	// Make sure nobody resized the table while we were waiting for lock 0:  	if (buckets != m_buckets) {  		// We assume that since the table reference is different' it was already resized. If we ever  		// decide to do table shrinking' or replace the table for other reasons' we will have to revisit  		// this logic.  		return;  	}  	// Compute the new table size. We find the smallest integer larger than twice the previous table size' and not divisible by  	// 2'3'5 or 7. We can consider a different table-sizing policy in the future.  	int newLength;  	try {  		checked {  			// Double the size of the buckets table and add one' so that we have an odd integer.  			newLength = buckets.Length * 2 + 1;  			// Now' we only need to check odd integers' and find the first that is not divisible  			// by 3' 5 or 7.  			while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0) {  				newLength += 2;  			}  			Assert (newLength % 2 != 0);  		}  	}  	catch (OverflowException) {  		// If we were to resize the table' its new size will not fit into a 32-bit signed int. Just return.  		return;  	}  	Node[] newBuckets = new Node[newLength];  	int[] newCountPerLock = new int[m_locks.Length];  	// Now acquire all other locks for the table  	AcquireLocks (1' m_locks.Length' ref locksAcquired);  	// Copy all data into a new table' creating new nodes for all elements  	for (int i = 0; i < buckets.Length; i++) {  		Node current = buckets [i];  		while (current != null) {  			Node next = current.m_next;  			int newBucketNo' newLockNo;  			GetBucketAndLockNo (current.m_hashcode' out newBucketNo' out newLockNo' newBuckets.Length);  			newBuckets [newBucketNo] = new Node (current.m_key' current.m_value' current.m_hashcode' newBuckets [newBucketNo]);  			checked {  				newCountPerLock [newLockNo]++;  			}  			current = next;  		}  	}  	// And finally adjust m_buckets and m_countPerLock to point to data for the new table  	m_buckets = newBuckets;  	m_countPerLock = newCountPerLock;  }  finally {  	// Release all locks that we took earlier  	ReleaseLocks (0' locksAcquired);  }  
Magic Number,System.Collections.Concurrent,ConcurrentDictionary,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: try {  	// The thread that first obtains m_locks[0] will be the one doing the resize operation  	AcquireLocks (0' 1' ref locksAcquired);  	// Make sure nobody resized the table while we were waiting for lock 0:  	if (buckets != m_buckets) {  		// We assume that since the table reference is different' it was already resized. If we ever  		// decide to do table shrinking' or replace the table for other reasons' we will have to revisit  		// this logic.  		return;  	}  	// Compute the new table size. We find the smallest integer larger than twice the previous table size' and not divisible by  	// 2'3'5 or 7. We can consider a different table-sizing policy in the future.  	int newLength;  	try {  		checked {  			// Double the size of the buckets table and add one' so that we have an odd integer.  			newLength = buckets.Length * 2 + 1;  			// Now' we only need to check odd integers' and find the first that is not divisible  			// by 3' 5 or 7.  			while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0) {  				newLength += 2;  			}  			Assert (newLength % 2 != 0);  		}  	}  	catch (OverflowException) {  		// If we were to resize the table' its new size will not fit into a 32-bit signed int. Just return.  		return;  	}  	Node[] newBuckets = new Node[newLength];  	int[] newCountPerLock = new int[m_locks.Length];  	// Now acquire all other locks for the table  	AcquireLocks (1' m_locks.Length' ref locksAcquired);  	// Copy all data into a new table' creating new nodes for all elements  	for (int i = 0; i < buckets.Length; i++) {  		Node current = buckets [i];  		while (current != null) {  			Node next = current.m_next;  			int newBucketNo' newLockNo;  			GetBucketAndLockNo (current.m_hashcode' out newBucketNo' out newLockNo' newBuckets.Length);  			newBuckets [newBucketNo] = new Node (current.m_key' current.m_value' current.m_hashcode' newBuckets [newBucketNo]);  			checked {  				newCountPerLock [newLockNo]++;  			}  			current = next;  		}  	}  	// And finally adjust m_buckets and m_countPerLock to point to data for the new table  	m_buckets = newBuckets;  	m_countPerLock = newCountPerLock;  }  finally {  	// Release all locks that we took earlier  	ReleaseLocks (0' locksAcquired);  }  
Magic Number,System.Collections.Concurrent,ConcurrentDictionary,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: try {  	// The thread that first obtains m_locks[0] will be the one doing the resize operation  	AcquireLocks (0' 1' ref locksAcquired);  	// Make sure nobody resized the table while we were waiting for lock 0:  	if (buckets != m_buckets) {  		// We assume that since the table reference is different' it was already resized. If we ever  		// decide to do table shrinking' or replace the table for other reasons' we will have to revisit  		// this logic.  		return;  	}  	// Compute the new table size. We find the smallest integer larger than twice the previous table size' and not divisible by  	// 2'3'5 or 7. We can consider a different table-sizing policy in the future.  	int newLength;  	try {  		checked {  			// Double the size of the buckets table and add one' so that we have an odd integer.  			newLength = buckets.Length * 2 + 1;  			// Now' we only need to check odd integers' and find the first that is not divisible  			// by 3' 5 or 7.  			while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0) {  				newLength += 2;  			}  			Assert (newLength % 2 != 0);  		}  	}  	catch (OverflowException) {  		// If we were to resize the table' its new size will not fit into a 32-bit signed int. Just return.  		return;  	}  	Node[] newBuckets = new Node[newLength];  	int[] newCountPerLock = new int[m_locks.Length];  	// Now acquire all other locks for the table  	AcquireLocks (1' m_locks.Length' ref locksAcquired);  	// Copy all data into a new table' creating new nodes for all elements  	for (int i = 0; i < buckets.Length; i++) {  		Node current = buckets [i];  		while (current != null) {  			Node next = current.m_next;  			int newBucketNo' newLockNo;  			GetBucketAndLockNo (current.m_hashcode' out newBucketNo' out newLockNo' newBuckets.Length);  			newBuckets [newBucketNo] = new Node (current.m_key' current.m_value' current.m_hashcode' newBuckets [newBucketNo]);  			checked {  				newCountPerLock [newLockNo]++;  			}  			current = next;  		}  	}  	// And finally adjust m_buckets and m_countPerLock to point to data for the new table  	m_buckets = newBuckets;  	m_countPerLock = newCountPerLock;  }  finally {  	// Release all locks that we took earlier  	ReleaseLocks (0' locksAcquired);  }  
Magic Number,System.Collections.Concurrent,ConcurrentDictionary,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: try {  	// The thread that first obtains m_locks[0] will be the one doing the resize operation  	AcquireLocks (0' 1' ref locksAcquired);  	// Make sure nobody resized the table while we were waiting for lock 0:  	if (buckets != m_buckets) {  		// We assume that since the table reference is different' it was already resized. If we ever  		// decide to do table shrinking' or replace the table for other reasons' we will have to revisit  		// this logic.  		return;  	}  	// Compute the new table size. We find the smallest integer larger than twice the previous table size' and not divisible by  	// 2'3'5 or 7. We can consider a different table-sizing policy in the future.  	int newLength;  	try {  		checked {  			// Double the size of the buckets table and add one' so that we have an odd integer.  			newLength = buckets.Length * 2 + 1;  			// Now' we only need to check odd integers' and find the first that is not divisible  			// by 3' 5 or 7.  			while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0) {  				newLength += 2;  			}  			Assert (newLength % 2 != 0);  		}  	}  	catch (OverflowException) {  		// If we were to resize the table' its new size will not fit into a 32-bit signed int. Just return.  		return;  	}  	Node[] newBuckets = new Node[newLength];  	int[] newCountPerLock = new int[m_locks.Length];  	// Now acquire all other locks for the table  	AcquireLocks (1' m_locks.Length' ref locksAcquired);  	// Copy all data into a new table' creating new nodes for all elements  	for (int i = 0; i < buckets.Length; i++) {  		Node current = buckets [i];  		while (current != null) {  			Node next = current.m_next;  			int newBucketNo' newLockNo;  			GetBucketAndLockNo (current.m_hashcode' out newBucketNo' out newLockNo' newBuckets.Length);  			newBuckets [newBucketNo] = new Node (current.m_key' current.m_value' current.m_hashcode' newBuckets [newBucketNo]);  			checked {  				newCountPerLock [newLockNo]++;  			}  			current = next;  		}  	}  	// And finally adjust m_buckets and m_countPerLock to point to data for the new table  	m_buckets = newBuckets;  	m_countPerLock = newCountPerLock;  }  finally {  	// Release all locks that we took earlier  	ReleaseLocks (0' locksAcquired);  }  
Magic Number,System.Collections.Concurrent,ConcurrentDictionary,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: try {  	// The thread that first obtains m_locks[0] will be the one doing the resize operation  	AcquireLocks (0' 1' ref locksAcquired);  	// Make sure nobody resized the table while we were waiting for lock 0:  	if (buckets != m_buckets) {  		// We assume that since the table reference is different' it was already resized. If we ever  		// decide to do table shrinking' or replace the table for other reasons' we will have to revisit  		// this logic.  		return;  	}  	// Compute the new table size. We find the smallest integer larger than twice the previous table size' and not divisible by  	// 2'3'5 or 7. We can consider a different table-sizing policy in the future.  	int newLength;  	try {  		checked {  			// Double the size of the buckets table and add one' so that we have an odd integer.  			newLength = buckets.Length * 2 + 1;  			// Now' we only need to check odd integers' and find the first that is not divisible  			// by 3' 5 or 7.  			while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0) {  				newLength += 2;  			}  			Assert (newLength % 2 != 0);  		}  	}  	catch (OverflowException) {  		// If we were to resize the table' its new size will not fit into a 32-bit signed int. Just return.  		return;  	}  	Node[] newBuckets = new Node[newLength];  	int[] newCountPerLock = new int[m_locks.Length];  	// Now acquire all other locks for the table  	AcquireLocks (1' m_locks.Length' ref locksAcquired);  	// Copy all data into a new table' creating new nodes for all elements  	for (int i = 0; i < buckets.Length; i++) {  		Node current = buckets [i];  		while (current != null) {  			Node next = current.m_next;  			int newBucketNo' newLockNo;  			GetBucketAndLockNo (current.m_hashcode' out newBucketNo' out newLockNo' newBuckets.Length);  			newBuckets [newBucketNo] = new Node (current.m_key' current.m_value' current.m_hashcode' newBuckets [newBucketNo]);  			checked {  				newCountPerLock [newLockNo]++;  			}  			current = next;  		}  	}  	// And finally adjust m_buckets and m_countPerLock to point to data for the new table  	m_buckets = newBuckets;  	m_countPerLock = newCountPerLock;  }  finally {  	// Release all locks that we took earlier  	ReleaseLocks (0' locksAcquired);  }  
Magic Number,System.Collections.Concurrent,ConcurrentDictionary,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: try {  	checked {  		// Double the size of the buckets table and add one' so that we have an odd integer.  		newLength = buckets.Length * 2 + 1;  		// Now' we only need to check odd integers' and find the first that is not divisible  		// by 3' 5 or 7.  		while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0) {  			newLength += 2;  		}  		Assert (newLength % 2 != 0);  	}  }  catch (OverflowException) {  	// If we were to resize the table' its new size will not fit into a 32-bit signed int. Just return.  	return;  }  
Magic Number,System.Collections.Concurrent,ConcurrentDictionary,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: try {  	checked {  		// Double the size of the buckets table and add one' so that we have an odd integer.  		newLength = buckets.Length * 2 + 1;  		// Now' we only need to check odd integers' and find the first that is not divisible  		// by 3' 5 or 7.  		while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0) {  			newLength += 2;  		}  		Assert (newLength % 2 != 0);  	}  }  catch (OverflowException) {  	// If we were to resize the table' its new size will not fit into a 32-bit signed int. Just return.  	return;  }  
Magic Number,System.Collections.Concurrent,ConcurrentDictionary,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: try {  	checked {  		// Double the size of the buckets table and add one' so that we have an odd integer.  		newLength = buckets.Length * 2 + 1;  		// Now' we only need to check odd integers' and find the first that is not divisible  		// by 3' 5 or 7.  		while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0) {  			newLength += 2;  		}  		Assert (newLength % 2 != 0);  	}  }  catch (OverflowException) {  	// If we were to resize the table' its new size will not fit into a 32-bit signed int. Just return.  	return;  }  
Magic Number,System.Collections.Concurrent,ConcurrentDictionary,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: try {  	checked {  		// Double the size of the buckets table and add one' so that we have an odd integer.  		newLength = buckets.Length * 2 + 1;  		// Now' we only need to check odd integers' and find the first that is not divisible  		// by 3' 5 or 7.  		while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0) {  			newLength += 2;  		}  		Assert (newLength % 2 != 0);  	}  }  catch (OverflowException) {  	// If we were to resize the table' its new size will not fit into a 32-bit signed int. Just return.  	return;  }  
Magic Number,System.Collections.Concurrent,ConcurrentDictionary,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: try {  	checked {  		// Double the size of the buckets table and add one' so that we have an odd integer.  		newLength = buckets.Length * 2 + 1;  		// Now' we only need to check odd integers' and find the first that is not divisible  		// by 3' 5 or 7.  		while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0) {  			newLength += 2;  		}  		Assert (newLength % 2 != 0);  	}  }  catch (OverflowException) {  	// If we were to resize the table' its new size will not fit into a 32-bit signed int. Just return.  	return;  }  
Magic Number,System.Collections.Concurrent,ConcurrentDictionary,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: try {  	checked {  		// Double the size of the buckets table and add one' so that we have an odd integer.  		newLength = buckets.Length * 2 + 1;  		// Now' we only need to check odd integers' and find the first that is not divisible  		// by 3' 5 or 7.  		while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0) {  			newLength += 2;  		}  		Assert (newLength % 2 != 0);  	}  }  catch (OverflowException) {  	// If we were to resize the table' its new size will not fit into a 32-bit signed int. Just return.  	return;  }  
Magic Number,System.Collections.Concurrent,ConcurrentDictionary,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: checked {  	// Double the size of the buckets table and add one' so that we have an odd integer.  	newLength = buckets.Length * 2 + 1;  	// Now' we only need to check odd integers' and find the first that is not divisible  	// by 3' 5 or 7.  	while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0) {  		newLength += 2;  	}  	Assert (newLength % 2 != 0);  }  
Magic Number,System.Collections.Concurrent,ConcurrentDictionary,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: checked {  	// Double the size of the buckets table and add one' so that we have an odd integer.  	newLength = buckets.Length * 2 + 1;  	// Now' we only need to check odd integers' and find the first that is not divisible  	// by 3' 5 or 7.  	while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0) {  		newLength += 2;  	}  	Assert (newLength % 2 != 0);  }  
Magic Number,System.Collections.Concurrent,ConcurrentDictionary,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: checked {  	// Double the size of the buckets table and add one' so that we have an odd integer.  	newLength = buckets.Length * 2 + 1;  	// Now' we only need to check odd integers' and find the first that is not divisible  	// by 3' 5 or 7.  	while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0) {  		newLength += 2;  	}  	Assert (newLength % 2 != 0);  }  
Magic Number,System.Collections.Concurrent,ConcurrentDictionary,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: checked {  	// Double the size of the buckets table and add one' so that we have an odd integer.  	newLength = buckets.Length * 2 + 1;  	// Now' we only need to check odd integers' and find the first that is not divisible  	// by 3' 5 or 7.  	while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0) {  		newLength += 2;  	}  	Assert (newLength % 2 != 0);  }  
Magic Number,System.Collections.Concurrent,ConcurrentDictionary,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: checked {  	// Double the size of the buckets table and add one' so that we have an odd integer.  	newLength = buckets.Length * 2 + 1;  	// Now' we only need to check odd integers' and find the first that is not divisible  	// by 3' 5 or 7.  	while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0) {  		newLength += 2;  	}  	Assert (newLength % 2 != 0);  }  
Magic Number,System.Collections.Concurrent,ConcurrentDictionary,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: checked {  	// Double the size of the buckets table and add one' so that we have an odd integer.  	newLength = buckets.Length * 2 + 1;  	// Now' we only need to check odd integers' and find the first that is not divisible  	// by 3' 5 or 7.  	while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0) {  		newLength += 2;  	}  	Assert (newLength % 2 != 0);  }  
Magic Number,System.Collections.Concurrent,ConcurrentDictionary,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: newLength = buckets.Length * 2 + 1;  
Magic Number,System.Collections.Concurrent,ConcurrentDictionary,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0) {  	newLength += 2;  }  
Magic Number,System.Collections.Concurrent,ConcurrentDictionary,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0) {  	newLength += 2;  }  
Magic Number,System.Collections.Concurrent,ConcurrentDictionary,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0) {  	newLength += 2;  }  
Magic Number,System.Collections.Concurrent,ConcurrentDictionary,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0) {  	newLength += 2;  }  
Magic Number,System.Collections.Concurrent,ConcurrentDictionary,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: newLength += 2;  
Magic Number,System.Collections.Concurrent,ConcurrentDictionary,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Collections\Concurrent\ConcurrentDictionary.cs,GrowTable,The following statement contains a magic number: Assert (newLength % 2 != 0);  
Magic Number,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,InternalRegister,The following statement contains a magic number: if (!IsCancellationRequested) {  	int myIndex = Thread.CurrentThread.ManagedThreadId % s_nLists;  	CancellationCallbackInfo callbackInfo = new CancellationCallbackInfo (callback' stateForCallback' targetSyncContext' this);  	//allocate the callback list array  	if (m_registeredCallbacksLists == null) {  		SparselyPopulatedArray<CancellationCallbackInfo>[] list = new SparselyPopulatedArray<CancellationCallbackInfo>[s_nLists];  		Interlocked.CompareExchange (ref m_registeredCallbacksLists' list' null);  	}  	//allocate the actual lists on-demand to save mem in low-use situations' and to avoid false-sharing.  	if (m_registeredCallbacksLists [myIndex] == null) {  		SparselyPopulatedArray<CancellationCallbackInfo> callBackArray = new SparselyPopulatedArray<CancellationCallbackInfo> (4);  		Interlocked.CompareExchange (ref (m_registeredCallbacksLists [myIndex])' callBackArray' null);  	}  	// Now add the registration to the list.  	SparselyPopulatedArray<CancellationCallbackInfo> callbacks = m_registeredCallbacksLists [myIndex];  	SparselyPopulatedArrayAddInfo<CancellationCallbackInfo> addInfo = callbacks.Add (callbackInfo);  	CancellationTokenRegistration registration = new CancellationTokenRegistration (this' callbackInfo' addInfo);  	if (!IsCancellationRequested)  		return registration;  	//If a cancellation has since come in' we will try to undo the registration and run the callback directly here.  	bool deregisterOccurred = registration.TryDeregister ();  	if (!deregisterOccurred) {  		// the callback execution process must have snagged the callback for execution' so   		// 1. wait for the callback to complete' then  		// 2. return a dummy registration.  		WaitForCallbackToComplete (callbackInfo);  		return new CancellationTokenRegistration ();  	}  }  
Magic Number,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,InternalRegister,The following statement contains a magic number: if (m_registeredCallbacksLists [myIndex] == null) {  	SparselyPopulatedArray<CancellationCallbackInfo> callBackArray = new SparselyPopulatedArray<CancellationCallbackInfo> (4);  	Interlocked.CompareExchange (ref (m_registeredCallbacksLists [myIndex])' callBackArray' null);  }  
Magic Number,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,ExecuteCallbackHandlers,The following statement contains a magic number: try {  	for (int index = 0; index < callbackLists.Length; index++) {  		SparselyPopulatedArray<CancellationCallbackInfo> list = callbackLists [index];  		if (list != null) {  			SparselyPopulatedArrayFragment<CancellationCallbackInfo> currArrayFragment = list.Tail;  			while (currArrayFragment != null) {  				for (int i = currArrayFragment.Length - 1; i >= 0; i--) {  					// 1a. publish the indended callback' to ensure ctr.Dipose can tell if a wait is necessary.  					// 1b. transition to the target syncContext and continue there..  					//  On the target SyncContext.  					//   2. actually remove the callback  					//   3. execute the callback  					// re:#2 we do the remove on the syncCtx so that we can be sure we have control of the syncCtx before  					//        grabbing the callback.  This prevents a deadlock if ctr.Dispose() might run on the syncCtx too.  					m_executingCallback = currArrayFragment [i];  					if (m_executingCallback != null) {  						//Transition to the target sync context (if necessary)' and continue our work there.  						CancellationCallbackCoreWorkArguments args = new CancellationCallbackCoreWorkArguments (currArrayFragment' i);  						// marshal exceptions: either aggregate or perform an immediate rethrow  						// We assume that syncCtx.Send() has forwarded on user exceptions when appropriate.  						try {  							if (m_executingCallback.TargetSyncContext != null) {  								#pragma  								/// This API isn't available in Metro' but we never run in metro.  								m_executingCallback.TargetSyncContext.Send (CancellationCallbackCoreWork_OnSyncContext' args);  								#pragma  								// CancellationCallbackCoreWork_OnSyncContext may have altered ThreadIDExecutingCallbacks' so reset it.   								ThreadIDExecutingCallbacks = Thread.CurrentThread.ManagedThreadId;  							}  							else {  								CancellationCallbackCoreWork_OnSyncContext (args);  							}  						}  						catch (Exception ex) {  							if (throwOnFirstException)  								throw;  							// Otherwise' log it and proceed.  							if (exceptionList == null)  								exceptionList = new List<Exception> ();  							exceptionList.Add (ex);  						}  					}  				}  				currArrayFragment = currArrayFragment.Prev;  			}  		}  	}  }  finally {  	m_state = NOTIFYINGCOMPLETE;  	m_executingCallback = null;  	Thread.MemoryBarrier ();  	// for safety' prevent reorderings crossing this point and seeing inconsistent state.  }  
Magic Number,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,ExecuteCallbackHandlers,The following statement contains a magic number: try {  	for (int index = 0; index < callbackLists.Length; index++) {  		SparselyPopulatedArray<CancellationCallbackInfo> list = callbackLists [index];  		if (list != null) {  			SparselyPopulatedArrayFragment<CancellationCallbackInfo> currArrayFragment = list.Tail;  			while (currArrayFragment != null) {  				for (int i = currArrayFragment.Length - 1; i >= 0; i--) {  					// 1a. publish the indended callback' to ensure ctr.Dipose can tell if a wait is necessary.  					// 1b. transition to the target syncContext and continue there..  					//  On the target SyncContext.  					//   2. actually remove the callback  					//   3. execute the callback  					// re:#2 we do the remove on the syncCtx so that we can be sure we have control of the syncCtx before  					//        grabbing the callback.  This prevents a deadlock if ctr.Dispose() might run on the syncCtx too.  					m_executingCallback = currArrayFragment [i];  					if (m_executingCallback != null) {  						//Transition to the target sync context (if necessary)' and continue our work there.  						CancellationCallbackCoreWorkArguments args = new CancellationCallbackCoreWorkArguments (currArrayFragment' i);  						// marshal exceptions: either aggregate or perform an immediate rethrow  						// We assume that syncCtx.Send() has forwarded on user exceptions when appropriate.  						try {  							if (m_executingCallback.TargetSyncContext != null) {  								#pragma  								/// This API isn't available in Metro' but we never run in metro.  								m_executingCallback.TargetSyncContext.Send (CancellationCallbackCoreWork_OnSyncContext' args);  								#pragma  								// CancellationCallbackCoreWork_OnSyncContext may have altered ThreadIDExecutingCallbacks' so reset it.   								ThreadIDExecutingCallbacks = Thread.CurrentThread.ManagedThreadId;  							}  							else {  								CancellationCallbackCoreWork_OnSyncContext (args);  							}  						}  						catch (Exception ex) {  							if (throwOnFirstException)  								throw;  							// Otherwise' log it and proceed.  							if (exceptionList == null)  								exceptionList = new List<Exception> ();  							exceptionList.Add (ex);  						}  					}  				}  				currArrayFragment = currArrayFragment.Prev;  			}  		}  	}  }  finally {  	m_state = NOTIFYINGCOMPLETE;  	m_executingCallback = null;  	Thread.MemoryBarrier ();  	// for safety' prevent reorderings crossing this point and seeing inconsistent state.  }  
Magic Number,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,ExecuteCallbackHandlers,The following statement contains a magic number: for (int index = 0; index < callbackLists.Length; index++) {  	SparselyPopulatedArray<CancellationCallbackInfo> list = callbackLists [index];  	if (list != null) {  		SparselyPopulatedArrayFragment<CancellationCallbackInfo> currArrayFragment = list.Tail;  		while (currArrayFragment != null) {  			for (int i = currArrayFragment.Length - 1; i >= 0; i--) {  				// 1a. publish the indended callback' to ensure ctr.Dipose can tell if a wait is necessary.  				// 1b. transition to the target syncContext and continue there..  				//  On the target SyncContext.  				//   2. actually remove the callback  				//   3. execute the callback  				// re:#2 we do the remove on the syncCtx so that we can be sure we have control of the syncCtx before  				//        grabbing the callback.  This prevents a deadlock if ctr.Dispose() might run on the syncCtx too.  				m_executingCallback = currArrayFragment [i];  				if (m_executingCallback != null) {  					//Transition to the target sync context (if necessary)' and continue our work there.  					CancellationCallbackCoreWorkArguments args = new CancellationCallbackCoreWorkArguments (currArrayFragment' i);  					// marshal exceptions: either aggregate or perform an immediate rethrow  					// We assume that syncCtx.Send() has forwarded on user exceptions when appropriate.  					try {  						if (m_executingCallback.TargetSyncContext != null) {  							#pragma  							/// This API isn't available in Metro' but we never run in metro.  							m_executingCallback.TargetSyncContext.Send (CancellationCallbackCoreWork_OnSyncContext' args);  							#pragma  							// CancellationCallbackCoreWork_OnSyncContext may have altered ThreadIDExecutingCallbacks' so reset it.   							ThreadIDExecutingCallbacks = Thread.CurrentThread.ManagedThreadId;  						}  						else {  							CancellationCallbackCoreWork_OnSyncContext (args);  						}  					}  					catch (Exception ex) {  						if (throwOnFirstException)  							throw;  						// Otherwise' log it and proceed.  						if (exceptionList == null)  							exceptionList = new List<Exception> ();  						exceptionList.Add (ex);  					}  				}  			}  			currArrayFragment = currArrayFragment.Prev;  		}  	}  }  
Magic Number,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,ExecuteCallbackHandlers,The following statement contains a magic number: for (int index = 0; index < callbackLists.Length; index++) {  	SparselyPopulatedArray<CancellationCallbackInfo> list = callbackLists [index];  	if (list != null) {  		SparselyPopulatedArrayFragment<CancellationCallbackInfo> currArrayFragment = list.Tail;  		while (currArrayFragment != null) {  			for (int i = currArrayFragment.Length - 1; i >= 0; i--) {  				// 1a. publish the indended callback' to ensure ctr.Dipose can tell if a wait is necessary.  				// 1b. transition to the target syncContext and continue there..  				//  On the target SyncContext.  				//   2. actually remove the callback  				//   3. execute the callback  				// re:#2 we do the remove on the syncCtx so that we can be sure we have control of the syncCtx before  				//        grabbing the callback.  This prevents a deadlock if ctr.Dispose() might run on the syncCtx too.  				m_executingCallback = currArrayFragment [i];  				if (m_executingCallback != null) {  					//Transition to the target sync context (if necessary)' and continue our work there.  					CancellationCallbackCoreWorkArguments args = new CancellationCallbackCoreWorkArguments (currArrayFragment' i);  					// marshal exceptions: either aggregate or perform an immediate rethrow  					// We assume that syncCtx.Send() has forwarded on user exceptions when appropriate.  					try {  						if (m_executingCallback.TargetSyncContext != null) {  							#pragma  							/// This API isn't available in Metro' but we never run in metro.  							m_executingCallback.TargetSyncContext.Send (CancellationCallbackCoreWork_OnSyncContext' args);  							#pragma  							// CancellationCallbackCoreWork_OnSyncContext may have altered ThreadIDExecutingCallbacks' so reset it.   							ThreadIDExecutingCallbacks = Thread.CurrentThread.ManagedThreadId;  						}  						else {  							CancellationCallbackCoreWork_OnSyncContext (args);  						}  					}  					catch (Exception ex) {  						if (throwOnFirstException)  							throw;  						// Otherwise' log it and proceed.  						if (exceptionList == null)  							exceptionList = new List<Exception> ();  						exceptionList.Add (ex);  					}  				}  			}  			currArrayFragment = currArrayFragment.Prev;  		}  	}  }  
Magic Number,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,ExecuteCallbackHandlers,The following statement contains a magic number: if (list != null) {  	SparselyPopulatedArrayFragment<CancellationCallbackInfo> currArrayFragment = list.Tail;  	while (currArrayFragment != null) {  		for (int i = currArrayFragment.Length - 1; i >= 0; i--) {  			// 1a. publish the indended callback' to ensure ctr.Dipose can tell if a wait is necessary.  			// 1b. transition to the target syncContext and continue there..  			//  On the target SyncContext.  			//   2. actually remove the callback  			//   3. execute the callback  			// re:#2 we do the remove on the syncCtx so that we can be sure we have control of the syncCtx before  			//        grabbing the callback.  This prevents a deadlock if ctr.Dispose() might run on the syncCtx too.  			m_executingCallback = currArrayFragment [i];  			if (m_executingCallback != null) {  				//Transition to the target sync context (if necessary)' and continue our work there.  				CancellationCallbackCoreWorkArguments args = new CancellationCallbackCoreWorkArguments (currArrayFragment' i);  				// marshal exceptions: either aggregate or perform an immediate rethrow  				// We assume that syncCtx.Send() has forwarded on user exceptions when appropriate.  				try {  					if (m_executingCallback.TargetSyncContext != null) {  						#pragma  						/// This API isn't available in Metro' but we never run in metro.  						m_executingCallback.TargetSyncContext.Send (CancellationCallbackCoreWork_OnSyncContext' args);  						#pragma  						// CancellationCallbackCoreWork_OnSyncContext may have altered ThreadIDExecutingCallbacks' so reset it.   						ThreadIDExecutingCallbacks = Thread.CurrentThread.ManagedThreadId;  					}  					else {  						CancellationCallbackCoreWork_OnSyncContext (args);  					}  				}  				catch (Exception ex) {  					if (throwOnFirstException)  						throw;  					// Otherwise' log it and proceed.  					if (exceptionList == null)  						exceptionList = new List<Exception> ();  					exceptionList.Add (ex);  				}  			}  		}  		currArrayFragment = currArrayFragment.Prev;  	}  }  
Magic Number,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,ExecuteCallbackHandlers,The following statement contains a magic number: if (list != null) {  	SparselyPopulatedArrayFragment<CancellationCallbackInfo> currArrayFragment = list.Tail;  	while (currArrayFragment != null) {  		for (int i = currArrayFragment.Length - 1; i >= 0; i--) {  			// 1a. publish the indended callback' to ensure ctr.Dipose can tell if a wait is necessary.  			// 1b. transition to the target syncContext and continue there..  			//  On the target SyncContext.  			//   2. actually remove the callback  			//   3. execute the callback  			// re:#2 we do the remove on the syncCtx so that we can be sure we have control of the syncCtx before  			//        grabbing the callback.  This prevents a deadlock if ctr.Dispose() might run on the syncCtx too.  			m_executingCallback = currArrayFragment [i];  			if (m_executingCallback != null) {  				//Transition to the target sync context (if necessary)' and continue our work there.  				CancellationCallbackCoreWorkArguments args = new CancellationCallbackCoreWorkArguments (currArrayFragment' i);  				// marshal exceptions: either aggregate or perform an immediate rethrow  				// We assume that syncCtx.Send() has forwarded on user exceptions when appropriate.  				try {  					if (m_executingCallback.TargetSyncContext != null) {  						#pragma  						/// This API isn't available in Metro' but we never run in metro.  						m_executingCallback.TargetSyncContext.Send (CancellationCallbackCoreWork_OnSyncContext' args);  						#pragma  						// CancellationCallbackCoreWork_OnSyncContext may have altered ThreadIDExecutingCallbacks' so reset it.   						ThreadIDExecutingCallbacks = Thread.CurrentThread.ManagedThreadId;  					}  					else {  						CancellationCallbackCoreWork_OnSyncContext (args);  					}  				}  				catch (Exception ex) {  					if (throwOnFirstException)  						throw;  					// Otherwise' log it and proceed.  					if (exceptionList == null)  						exceptionList = new List<Exception> ();  					exceptionList.Add (ex);  				}  			}  		}  		currArrayFragment = currArrayFragment.Prev;  	}  }  
Magic Number,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,ExecuteCallbackHandlers,The following statement contains a magic number: while (currArrayFragment != null) {  	for (int i = currArrayFragment.Length - 1; i >= 0; i--) {  		// 1a. publish the indended callback' to ensure ctr.Dipose can tell if a wait is necessary.  		// 1b. transition to the target syncContext and continue there..  		//  On the target SyncContext.  		//   2. actually remove the callback  		//   3. execute the callback  		// re:#2 we do the remove on the syncCtx so that we can be sure we have control of the syncCtx before  		//        grabbing the callback.  This prevents a deadlock if ctr.Dispose() might run on the syncCtx too.  		m_executingCallback = currArrayFragment [i];  		if (m_executingCallback != null) {  			//Transition to the target sync context (if necessary)' and continue our work there.  			CancellationCallbackCoreWorkArguments args = new CancellationCallbackCoreWorkArguments (currArrayFragment' i);  			// marshal exceptions: either aggregate or perform an immediate rethrow  			// We assume that syncCtx.Send() has forwarded on user exceptions when appropriate.  			try {  				if (m_executingCallback.TargetSyncContext != null) {  					#pragma  					/// This API isn't available in Metro' but we never run in metro.  					m_executingCallback.TargetSyncContext.Send (CancellationCallbackCoreWork_OnSyncContext' args);  					#pragma  					// CancellationCallbackCoreWork_OnSyncContext may have altered ThreadIDExecutingCallbacks' so reset it.   					ThreadIDExecutingCallbacks = Thread.CurrentThread.ManagedThreadId;  				}  				else {  					CancellationCallbackCoreWork_OnSyncContext (args);  				}  			}  			catch (Exception ex) {  				if (throwOnFirstException)  					throw;  				// Otherwise' log it and proceed.  				if (exceptionList == null)  					exceptionList = new List<Exception> ();  				exceptionList.Add (ex);  			}  		}  	}  	currArrayFragment = currArrayFragment.Prev;  }  
Magic Number,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,ExecuteCallbackHandlers,The following statement contains a magic number: while (currArrayFragment != null) {  	for (int i = currArrayFragment.Length - 1; i >= 0; i--) {  		// 1a. publish the indended callback' to ensure ctr.Dipose can tell if a wait is necessary.  		// 1b. transition to the target syncContext and continue there..  		//  On the target SyncContext.  		//   2. actually remove the callback  		//   3. execute the callback  		// re:#2 we do the remove on the syncCtx so that we can be sure we have control of the syncCtx before  		//        grabbing the callback.  This prevents a deadlock if ctr.Dispose() might run on the syncCtx too.  		m_executingCallback = currArrayFragment [i];  		if (m_executingCallback != null) {  			//Transition to the target sync context (if necessary)' and continue our work there.  			CancellationCallbackCoreWorkArguments args = new CancellationCallbackCoreWorkArguments (currArrayFragment' i);  			// marshal exceptions: either aggregate or perform an immediate rethrow  			// We assume that syncCtx.Send() has forwarded on user exceptions when appropriate.  			try {  				if (m_executingCallback.TargetSyncContext != null) {  					#pragma  					/// This API isn't available in Metro' but we never run in metro.  					m_executingCallback.TargetSyncContext.Send (CancellationCallbackCoreWork_OnSyncContext' args);  					#pragma  					// CancellationCallbackCoreWork_OnSyncContext may have altered ThreadIDExecutingCallbacks' so reset it.   					ThreadIDExecutingCallbacks = Thread.CurrentThread.ManagedThreadId;  				}  				else {  					CancellationCallbackCoreWork_OnSyncContext (args);  				}  			}  			catch (Exception ex) {  				if (throwOnFirstException)  					throw;  				// Otherwise' log it and proceed.  				if (exceptionList == null)  					exceptionList = new List<Exception> ();  				exceptionList.Add (ex);  			}  		}  	}  	currArrayFragment = currArrayFragment.Prev;  }  
Magic Number,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,ExecuteCallbackHandlers,The following statement contains a magic number: for (int i = currArrayFragment.Length - 1; i >= 0; i--) {  	// 1a. publish the indended callback' to ensure ctr.Dipose can tell if a wait is necessary.  	// 1b. transition to the target syncContext and continue there..  	//  On the target SyncContext.  	//   2. actually remove the callback  	//   3. execute the callback  	// re:#2 we do the remove on the syncCtx so that we can be sure we have control of the syncCtx before  	//        grabbing the callback.  This prevents a deadlock if ctr.Dispose() might run on the syncCtx too.  	m_executingCallback = currArrayFragment [i];  	if (m_executingCallback != null) {  		//Transition to the target sync context (if necessary)' and continue our work there.  		CancellationCallbackCoreWorkArguments args = new CancellationCallbackCoreWorkArguments (currArrayFragment' i);  		// marshal exceptions: either aggregate or perform an immediate rethrow  		// We assume that syncCtx.Send() has forwarded on user exceptions when appropriate.  		try {  			if (m_executingCallback.TargetSyncContext != null) {  				#pragma  				/// This API isn't available in Metro' but we never run in metro.  				m_executingCallback.TargetSyncContext.Send (CancellationCallbackCoreWork_OnSyncContext' args);  				#pragma  				// CancellationCallbackCoreWork_OnSyncContext may have altered ThreadIDExecutingCallbacks' so reset it.   				ThreadIDExecutingCallbacks = Thread.CurrentThread.ManagedThreadId;  			}  			else {  				CancellationCallbackCoreWork_OnSyncContext (args);  			}  		}  		catch (Exception ex) {  			if (throwOnFirstException)  				throw;  			// Otherwise' log it and proceed.  			if (exceptionList == null)  				exceptionList = new List<Exception> ();  			exceptionList.Add (ex);  		}  	}  }  
Magic Number,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,ExecuteCallbackHandlers,The following statement contains a magic number: for (int i = currArrayFragment.Length - 1; i >= 0; i--) {  	// 1a. publish the indended callback' to ensure ctr.Dipose can tell if a wait is necessary.  	// 1b. transition to the target syncContext and continue there..  	//  On the target SyncContext.  	//   2. actually remove the callback  	//   3. execute the callback  	// re:#2 we do the remove on the syncCtx so that we can be sure we have control of the syncCtx before  	//        grabbing the callback.  This prevents a deadlock if ctr.Dispose() might run on the syncCtx too.  	m_executingCallback = currArrayFragment [i];  	if (m_executingCallback != null) {  		//Transition to the target sync context (if necessary)' and continue our work there.  		CancellationCallbackCoreWorkArguments args = new CancellationCallbackCoreWorkArguments (currArrayFragment' i);  		// marshal exceptions: either aggregate or perform an immediate rethrow  		// We assume that syncCtx.Send() has forwarded on user exceptions when appropriate.  		try {  			if (m_executingCallback.TargetSyncContext != null) {  				#pragma  				/// This API isn't available in Metro' but we never run in metro.  				m_executingCallback.TargetSyncContext.Send (CancellationCallbackCoreWork_OnSyncContext' args);  				#pragma  				// CancellationCallbackCoreWork_OnSyncContext may have altered ThreadIDExecutingCallbacks' so reset it.   				ThreadIDExecutingCallbacks = Thread.CurrentThread.ManagedThreadId;  			}  			else {  				CancellationCallbackCoreWork_OnSyncContext (args);  			}  		}  		catch (Exception ex) {  			if (throwOnFirstException)  				throw;  			// Otherwise' log it and proceed.  			if (exceptionList == null)  				exceptionList = new List<Exception> ();  			exceptionList.Add (ex);  		}  	}  }  
Magic Number,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,ExecuteCallbackHandlers,The following statement contains a magic number: if (m_executingCallback != null) {  	//Transition to the target sync context (if necessary)' and continue our work there.  	CancellationCallbackCoreWorkArguments args = new CancellationCallbackCoreWorkArguments (currArrayFragment' i);  	// marshal exceptions: either aggregate or perform an immediate rethrow  	// We assume that syncCtx.Send() has forwarded on user exceptions when appropriate.  	try {  		if (m_executingCallback.TargetSyncContext != null) {  			#pragma  			/// This API isn't available in Metro' but we never run in metro.  			m_executingCallback.TargetSyncContext.Send (CancellationCallbackCoreWork_OnSyncContext' args);  			#pragma  			// CancellationCallbackCoreWork_OnSyncContext may have altered ThreadIDExecutingCallbacks' so reset it.   			ThreadIDExecutingCallbacks = Thread.CurrentThread.ManagedThreadId;  		}  		else {  			CancellationCallbackCoreWork_OnSyncContext (args);  		}  	}  	catch (Exception ex) {  		if (throwOnFirstException)  			throw;  		// Otherwise' log it and proceed.  		if (exceptionList == null)  			exceptionList = new List<Exception> ();  		exceptionList.Add (ex);  	}  }  
Magic Number,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,ExecuteCallbackHandlers,The following statement contains a magic number: if (m_executingCallback != null) {  	//Transition to the target sync context (if necessary)' and continue our work there.  	CancellationCallbackCoreWorkArguments args = new CancellationCallbackCoreWorkArguments (currArrayFragment' i);  	// marshal exceptions: either aggregate or perform an immediate rethrow  	// We assume that syncCtx.Send() has forwarded on user exceptions when appropriate.  	try {  		if (m_executingCallback.TargetSyncContext != null) {  			#pragma  			/// This API isn't available in Metro' but we never run in metro.  			m_executingCallback.TargetSyncContext.Send (CancellationCallbackCoreWork_OnSyncContext' args);  			#pragma  			// CancellationCallbackCoreWork_OnSyncContext may have altered ThreadIDExecutingCallbacks' so reset it.   			ThreadIDExecutingCallbacks = Thread.CurrentThread.ManagedThreadId;  		}  		else {  			CancellationCallbackCoreWork_OnSyncContext (args);  		}  	}  	catch (Exception ex) {  		if (throwOnFirstException)  			throw;  		// Otherwise' log it and proceed.  		if (exceptionList == null)  			exceptionList = new List<Exception> ();  		exceptionList.Add (ex);  	}  }  
Magic Number,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,ExecuteCallbackHandlers,The following statement contains a magic number: try {  	if (m_executingCallback.TargetSyncContext != null) {  		#pragma  		/// This API isn't available in Metro' but we never run in metro.  		m_executingCallback.TargetSyncContext.Send (CancellationCallbackCoreWork_OnSyncContext' args);  		#pragma  		// CancellationCallbackCoreWork_OnSyncContext may have altered ThreadIDExecutingCallbacks' so reset it.   		ThreadIDExecutingCallbacks = Thread.CurrentThread.ManagedThreadId;  	}  	else {  		CancellationCallbackCoreWork_OnSyncContext (args);  	}  }  catch (Exception ex) {  	if (throwOnFirstException)  		throw;  	// Otherwise' log it and proceed.  	if (exceptionList == null)  		exceptionList = new List<Exception> ();  	exceptionList.Add (ex);  }  
Magic Number,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,ExecuteCallbackHandlers,The following statement contains a magic number: try {  	if (m_executingCallback.TargetSyncContext != null) {  		#pragma  		/// This API isn't available in Metro' but we never run in metro.  		m_executingCallback.TargetSyncContext.Send (CancellationCallbackCoreWork_OnSyncContext' args);  		#pragma  		// CancellationCallbackCoreWork_OnSyncContext may have altered ThreadIDExecutingCallbacks' so reset it.   		ThreadIDExecutingCallbacks = Thread.CurrentThread.ManagedThreadId;  	}  	else {  		CancellationCallbackCoreWork_OnSyncContext (args);  	}  }  catch (Exception ex) {  	if (throwOnFirstException)  		throw;  	// Otherwise' log it and proceed.  	if (exceptionList == null)  		exceptionList = new List<Exception> ();  	exceptionList.Add (ex);  }  
Magic Number,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,ExecuteCallbackHandlers,The following statement contains a magic number: if (m_executingCallback.TargetSyncContext != null) {  	#pragma  	/// This API isn't available in Metro' but we never run in metro.  	m_executingCallback.TargetSyncContext.Send (CancellationCallbackCoreWork_OnSyncContext' args);  	#pragma  	// CancellationCallbackCoreWork_OnSyncContext may have altered ThreadIDExecutingCallbacks' so reset it.   	ThreadIDExecutingCallbacks = Thread.CurrentThread.ManagedThreadId;  }  else {  	CancellationCallbackCoreWork_OnSyncContext (args);  }  
Magic Number,System.Threading,CancellationTokenSource,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,ExecuteCallbackHandlers,The following statement contains a magic number: if (m_executingCallback.TargetSyncContext != null) {  	#pragma  	/// This API isn't available in Metro' but we never run in metro.  	m_executingCallback.TargetSyncContext.Send (CancellationCallbackCoreWork_OnSyncContext' args);  	#pragma  	// CancellationCallbackCoreWork_OnSyncContext may have altered ThreadIDExecutingCallbacks' so reset it.   	ThreadIDExecutingCallbacks = Thread.CurrentThread.ManagedThreadId;  }  else {  	CancellationCallbackCoreWork_OnSyncContext (args);  }  
Magic Number,System.Threading,SparselyPopulatedArray,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,Add,The following statement contains a magic number: while (true) {  	// Get the tail' and ensure it's up to date.  	SparselyPopulatedArrayFragment<T> tail = m_tail;  	while (tail.m_next != null)  		m_tail = (tail = tail.m_next);  	// Search for a free index' starting from the tail.  	SparselyPopulatedArrayFragment<T> curr = tail;  	while (curr != null) {  		const int RE_SEARCH_THRESHOLD = -10;  		// Every 10 skips' force a search.  		if (curr.m_freeCount < 1)  			--curr.m_freeCount;  		if (curr.m_freeCount > 0 || curr.m_freeCount < RE_SEARCH_THRESHOLD) {  			int c = curr.Length;  			// We'll compute a start offset based on how many free slots we think there  			// are.  This optimizes for ordinary the LIFO deregistration pattern' and is  			// far from perfect due to the non-threadsafe ++ and -- of the free counter.  			int start = ((c - curr.m_freeCount) % c);  			if (start < 0) {  				start = 0;  				curr.m_freeCount--;  				// Too many free elements; fix up.  			}  			Contract.Assert (start >= 0 && start < c' "start is outside of bounds");  			// Now walk the array until we find a free slot (or reach the end).  			for (int i = 0; i < c; i++) {  				// If the slot is null' try to CAS our element into it.  				int tryIndex = (start + i) % c;  				Contract.Assert (tryIndex >= 0 && tryIndex < curr.m_elements.Length' "tryIndex is outside of bounds");  				if (curr.m_elements [tryIndex] == null && Interlocked.CompareExchange (ref curr.m_elements [tryIndex]' element' null) == null) {  					// We adjust the free count by --. Note: if this drops to 0' we will skip  					// the fragment on the next search iteration.  Searching threads will -- the  					// count and force a search every so often' just in case fragmentation occurs.  					int newFreeCount = curr.m_freeCount - 1;  					curr.m_freeCount = newFreeCount > 0 ? newFreeCount : 0;  					return new SparselyPopulatedArrayAddInfo<T> (curr' tryIndex);  				}  			}  		}  		curr = curr.m_prev;  	}  	// If we got here' we need to add a new chunk to the tail and try again.  	SparselyPopulatedArrayFragment<T> newTail = new SparselyPopulatedArrayFragment<T> (tail.m_elements.Length == 4096 ? 4096 : tail.m_elements.Length * 2' tail);  	if (Interlocked.CompareExchange (ref tail.m_next' newTail' null) == null) {  		m_tail = newTail;  	}  }  
Magic Number,System.Threading,SparselyPopulatedArray,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,Add,The following statement contains a magic number: while (true) {  	// Get the tail' and ensure it's up to date.  	SparselyPopulatedArrayFragment<T> tail = m_tail;  	while (tail.m_next != null)  		m_tail = (tail = tail.m_next);  	// Search for a free index' starting from the tail.  	SparselyPopulatedArrayFragment<T> curr = tail;  	while (curr != null) {  		const int RE_SEARCH_THRESHOLD = -10;  		// Every 10 skips' force a search.  		if (curr.m_freeCount < 1)  			--curr.m_freeCount;  		if (curr.m_freeCount > 0 || curr.m_freeCount < RE_SEARCH_THRESHOLD) {  			int c = curr.Length;  			// We'll compute a start offset based on how many free slots we think there  			// are.  This optimizes for ordinary the LIFO deregistration pattern' and is  			// far from perfect due to the non-threadsafe ++ and -- of the free counter.  			int start = ((c - curr.m_freeCount) % c);  			if (start < 0) {  				start = 0;  				curr.m_freeCount--;  				// Too many free elements; fix up.  			}  			Contract.Assert (start >= 0 && start < c' "start is outside of bounds");  			// Now walk the array until we find a free slot (or reach the end).  			for (int i = 0; i < c; i++) {  				// If the slot is null' try to CAS our element into it.  				int tryIndex = (start + i) % c;  				Contract.Assert (tryIndex >= 0 && tryIndex < curr.m_elements.Length' "tryIndex is outside of bounds");  				if (curr.m_elements [tryIndex] == null && Interlocked.CompareExchange (ref curr.m_elements [tryIndex]' element' null) == null) {  					// We adjust the free count by --. Note: if this drops to 0' we will skip  					// the fragment on the next search iteration.  Searching threads will -- the  					// count and force a search every so often' just in case fragmentation occurs.  					int newFreeCount = curr.m_freeCount - 1;  					curr.m_freeCount = newFreeCount > 0 ? newFreeCount : 0;  					return new SparselyPopulatedArrayAddInfo<T> (curr' tryIndex);  				}  			}  		}  		curr = curr.m_prev;  	}  	// If we got here' we need to add a new chunk to the tail and try again.  	SparselyPopulatedArrayFragment<T> newTail = new SparselyPopulatedArrayFragment<T> (tail.m_elements.Length == 4096 ? 4096 : tail.m_elements.Length * 2' tail);  	if (Interlocked.CompareExchange (ref tail.m_next' newTail' null) == null) {  		m_tail = newTail;  	}  }  
Magic Number,System.Threading,SparselyPopulatedArray,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,Add,The following statement contains a magic number: while (true) {  	// Get the tail' and ensure it's up to date.  	SparselyPopulatedArrayFragment<T> tail = m_tail;  	while (tail.m_next != null)  		m_tail = (tail = tail.m_next);  	// Search for a free index' starting from the tail.  	SparselyPopulatedArrayFragment<T> curr = tail;  	while (curr != null) {  		const int RE_SEARCH_THRESHOLD = -10;  		// Every 10 skips' force a search.  		if (curr.m_freeCount < 1)  			--curr.m_freeCount;  		if (curr.m_freeCount > 0 || curr.m_freeCount < RE_SEARCH_THRESHOLD) {  			int c = curr.Length;  			// We'll compute a start offset based on how many free slots we think there  			// are.  This optimizes for ordinary the LIFO deregistration pattern' and is  			// far from perfect due to the non-threadsafe ++ and -- of the free counter.  			int start = ((c - curr.m_freeCount) % c);  			if (start < 0) {  				start = 0;  				curr.m_freeCount--;  				// Too many free elements; fix up.  			}  			Contract.Assert (start >= 0 && start < c' "start is outside of bounds");  			// Now walk the array until we find a free slot (or reach the end).  			for (int i = 0; i < c; i++) {  				// If the slot is null' try to CAS our element into it.  				int tryIndex = (start + i) % c;  				Contract.Assert (tryIndex >= 0 && tryIndex < curr.m_elements.Length' "tryIndex is outside of bounds");  				if (curr.m_elements [tryIndex] == null && Interlocked.CompareExchange (ref curr.m_elements [tryIndex]' element' null) == null) {  					// We adjust the free count by --. Note: if this drops to 0' we will skip  					// the fragment on the next search iteration.  Searching threads will -- the  					// count and force a search every so often' just in case fragmentation occurs.  					int newFreeCount = curr.m_freeCount - 1;  					curr.m_freeCount = newFreeCount > 0 ? newFreeCount : 0;  					return new SparselyPopulatedArrayAddInfo<T> (curr' tryIndex);  				}  			}  		}  		curr = curr.m_prev;  	}  	// If we got here' we need to add a new chunk to the tail and try again.  	SparselyPopulatedArrayFragment<T> newTail = new SparselyPopulatedArrayFragment<T> (tail.m_elements.Length == 4096 ? 4096 : tail.m_elements.Length * 2' tail);  	if (Interlocked.CompareExchange (ref tail.m_next' newTail' null) == null) {  		m_tail = newTail;  	}  }  
Magic Number,System.Threading,SparselyPopulatedArray,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,Add,The following statement contains a magic number: while (true) {  	// Get the tail' and ensure it's up to date.  	SparselyPopulatedArrayFragment<T> tail = m_tail;  	while (tail.m_next != null)  		m_tail = (tail = tail.m_next);  	// Search for a free index' starting from the tail.  	SparselyPopulatedArrayFragment<T> curr = tail;  	while (curr != null) {  		const int RE_SEARCH_THRESHOLD = -10;  		// Every 10 skips' force a search.  		if (curr.m_freeCount < 1)  			--curr.m_freeCount;  		if (curr.m_freeCount > 0 || curr.m_freeCount < RE_SEARCH_THRESHOLD) {  			int c = curr.Length;  			// We'll compute a start offset based on how many free slots we think there  			// are.  This optimizes for ordinary the LIFO deregistration pattern' and is  			// far from perfect due to the non-threadsafe ++ and -- of the free counter.  			int start = ((c - curr.m_freeCount) % c);  			if (start < 0) {  				start = 0;  				curr.m_freeCount--;  				// Too many free elements; fix up.  			}  			Contract.Assert (start >= 0 && start < c' "start is outside of bounds");  			// Now walk the array until we find a free slot (or reach the end).  			for (int i = 0; i < c; i++) {  				// If the slot is null' try to CAS our element into it.  				int tryIndex = (start + i) % c;  				Contract.Assert (tryIndex >= 0 && tryIndex < curr.m_elements.Length' "tryIndex is outside of bounds");  				if (curr.m_elements [tryIndex] == null && Interlocked.CompareExchange (ref curr.m_elements [tryIndex]' element' null) == null) {  					// We adjust the free count by --. Note: if this drops to 0' we will skip  					// the fragment on the next search iteration.  Searching threads will -- the  					// count and force a search every so often' just in case fragmentation occurs.  					int newFreeCount = curr.m_freeCount - 1;  					curr.m_freeCount = newFreeCount > 0 ? newFreeCount : 0;  					return new SparselyPopulatedArrayAddInfo<T> (curr' tryIndex);  				}  			}  		}  		curr = curr.m_prev;  	}  	// If we got here' we need to add a new chunk to the tail and try again.  	SparselyPopulatedArrayFragment<T> newTail = new SparselyPopulatedArrayFragment<T> (tail.m_elements.Length == 4096 ? 4096 : tail.m_elements.Length * 2' tail);  	if (Interlocked.CompareExchange (ref tail.m_next' newTail' null) == null) {  		m_tail = newTail;  	}  }  
Magic Number,System.Threading,SparselyPopulatedArray,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\CancellationTokenSource.cs,Add,The following statement contains a magic number: while (curr != null) {  	const int RE_SEARCH_THRESHOLD = -10;  	// Every 10 skips' force a search.  	if (curr.m_freeCount < 1)  		--curr.m_freeCount;  	if (curr.m_freeCount > 0 || curr.m_freeCount < RE_SEARCH_THRESHOLD) {  		int c = curr.Length;  		// We'll compute a start offset based on how many free slots we think there  		// are.  This optimizes for ordinary the LIFO deregistration pattern' and is  		// far from perfect due to the non-threadsafe ++ and -- of the free counter.  		int start = ((c - curr.m_freeCount) % c);  		if (start < 0) {  			start = 0;  			curr.m_freeCount--;  			// Too many free elements; fix up.  		}  		Contract.Assert (start >= 0 && start < c' "start is outside of bounds");  		// Now walk the array until we find a free slot (or reach the end).  		for (int i = 0; i < c; i++) {  			// If the slot is null' try to CAS our element into it.  			int tryIndex = (start + i) % c;  			Contract.Assert (tryIndex >= 0 && tryIndex < curr.m_elements.Length' "tryIndex is outside of bounds");  			if (curr.m_elements [tryIndex] == null && Interlocked.CompareExchange (ref curr.m_elements [tryIndex]' element' null) == null) {  				// We adjust the free count by --. Note: if this drops to 0' we will skip  				// the fragment on the next search iteration.  Searching threads will -- the  				// count and force a search every so often' just in case fragmentation occurs.  				int newFreeCount = curr.m_freeCount - 1;  				curr.m_freeCount = newFreeCount > 0 ? newFreeCount : 0;  				return new SparselyPopulatedArrayAddInfo<T> (curr' tryIndex);  			}  		}  	}  	curr = curr.m_prev;  }  
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Wait,The following statement contains a magic number: if (!IsSet) {  	if (millisecondsTimeout == 0) {  		// For 0-timeouts' we just return immediately.  		return false;  	}  	// We spin briefly before falling back to allocating and/or waiting on a true event.  	long startTimeTicks = 0;  	bool bNeedTimeoutAdjustment = false;  	int realMillisecondsTimeout = millisecondsTimeout;  	//this will be adjusted if necessary.  	if (millisecondsTimeout != Timeout.Infinite) {  		// We will account for time spent spinning' so that we can decrement it from our  		// timeout.  In most cases the time spent in this section will be negligible.  But  		// we can't discount the possibility of our thread being switched out for a lengthy  		// period of time.  The timeout adjustments only take effect when and if we actually  		// decide to block in the kernel below.  		startTimeTicks = DateTime.UtcNow.Ticks;  		bNeedTimeoutAdjustment = true;  	}  	//spin  	int HOW_MANY_SPIN_BEFORE_YIELD = 10;  	int HOW_MANY_YIELD_EVERY_SLEEP_0 = 5;  	int HOW_MANY_YIELD_EVERY_SLEEP_1 = 20;  	for (int i = 0; i < SpinCount; i++) {  		if (IsSet) {  			return true;  		}  		else if (i < HOW_MANY_SPIN_BEFORE_YIELD) {  			if (i == HOW_MANY_SPIN_BEFORE_YIELD / 2) {  				#if PFX_LEGACY_3_5  				                            Platform.Yield(); #else  				ThreadLightup.Current.Yield ();  				#endif  			}  			else {  				ThreadLightup.Current.SpinWait (PlatformHelper.ProcessorCount * (4 << i));  			}  		}  		else if (i % HOW_MANY_YIELD_EVERY_SLEEP_1 == 0) {  			ThreadLightup.Current.Sleep (1);  		}  		else if (i % HOW_MANY_YIELD_EVERY_SLEEP_0 == 0) {  			ThreadLightup.Current.Sleep (0);  		}  		else {  			#if PFX_LEGACY_3_5  			                        Platform.Yield(); #else  			ThreadLightup.Current.Yield ();  			#endif  		}  		if (i >= 100 && i % 10 == 0)  			// check the cancellation token if the user passed a very large spin count  			cancellationToken.ThrowIfCancellationRequested ();  	}  	// Now enter the lock and wait.  	EnsureLockObjectCreated ();  	// We must register and deregister the token outside of the lock' to avoid deadlocks.  	using (cancellationToken.Register (s_cancellationTokenCallback' this)) {  		lock (m_lock) {  			// Loop to cope with spurious wakeups from other waits being canceled  			while (!IsSet) {  				// If our token was canceled' we must throw and exit.  				cancellationToken.ThrowIfCancellationRequested ();  				//update timeout (delays in wait commencement are due to spinning and/or spurious wakeups from other waits being canceled)  				if (bNeedTimeoutAdjustment) {  					realMillisecondsTimeout = UpdateTimeOut (startTimeTicks' millisecondsTimeout);  					if (realMillisecondsTimeout <= 0)  						return false;  				}  				// There is a race that Set will fail to see that there are waiters as Set does not take the lock'   				// so after updating waiters' we must check IsSet again.  				// Also' we must ensure there cannot be any reordering of the assignment to Waiters and the  				// read from IsSet.  This is guaranteed as Waiters{set;} involves an Interlocked.CompareExchange  				// operation which provides a full memory barrier.  				// If we see IsSet=false' then we are guaranteed that Set() will see that we are  				// waiting and will pulse the monitor correctly.  				Waiters = Waiters + 1;  				if (IsSet)//This check must occur after updating Waiters.  				 {  					Waiters--;  					//revert the increment.  					return true;  				}  				// Now finally perform the wait.  				try {  					// ** the actual wait **  					if (!Monitor.Wait (m_lock' realMillisecondsTimeout))  						return false;  					//return immediately if the timeout has expired.  				}  				finally {  					// Clean up: we're done waiting.  					Waiters = Waiters - 1;  				}  				// Now just loop back around' and the right thing will happen.  Either:  				//     1. We had a spurious wake-up due to some other wait being canceled via a different cancellationToken (rewait)  				// or  2. the wait was successful. (the loop will break)  			}  		}  	}  }  
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Wait,The following statement contains a magic number: if (!IsSet) {  	if (millisecondsTimeout == 0) {  		// For 0-timeouts' we just return immediately.  		return false;  	}  	// We spin briefly before falling back to allocating and/or waiting on a true event.  	long startTimeTicks = 0;  	bool bNeedTimeoutAdjustment = false;  	int realMillisecondsTimeout = millisecondsTimeout;  	//this will be adjusted if necessary.  	if (millisecondsTimeout != Timeout.Infinite) {  		// We will account for time spent spinning' so that we can decrement it from our  		// timeout.  In most cases the time spent in this section will be negligible.  But  		// we can't discount the possibility of our thread being switched out for a lengthy  		// period of time.  The timeout adjustments only take effect when and if we actually  		// decide to block in the kernel below.  		startTimeTicks = DateTime.UtcNow.Ticks;  		bNeedTimeoutAdjustment = true;  	}  	//spin  	int HOW_MANY_SPIN_BEFORE_YIELD = 10;  	int HOW_MANY_YIELD_EVERY_SLEEP_0 = 5;  	int HOW_MANY_YIELD_EVERY_SLEEP_1 = 20;  	for (int i = 0; i < SpinCount; i++) {  		if (IsSet) {  			return true;  		}  		else if (i < HOW_MANY_SPIN_BEFORE_YIELD) {  			if (i == HOW_MANY_SPIN_BEFORE_YIELD / 2) {  				#if PFX_LEGACY_3_5  				                            Platform.Yield(); #else  				ThreadLightup.Current.Yield ();  				#endif  			}  			else {  				ThreadLightup.Current.SpinWait (PlatformHelper.ProcessorCount * (4 << i));  			}  		}  		else if (i % HOW_MANY_YIELD_EVERY_SLEEP_1 == 0) {  			ThreadLightup.Current.Sleep (1);  		}  		else if (i % HOW_MANY_YIELD_EVERY_SLEEP_0 == 0) {  			ThreadLightup.Current.Sleep (0);  		}  		else {  			#if PFX_LEGACY_3_5  			                        Platform.Yield(); #else  			ThreadLightup.Current.Yield ();  			#endif  		}  		if (i >= 100 && i % 10 == 0)  			// check the cancellation token if the user passed a very large spin count  			cancellationToken.ThrowIfCancellationRequested ();  	}  	// Now enter the lock and wait.  	EnsureLockObjectCreated ();  	// We must register and deregister the token outside of the lock' to avoid deadlocks.  	using (cancellationToken.Register (s_cancellationTokenCallback' this)) {  		lock (m_lock) {  			// Loop to cope with spurious wakeups from other waits being canceled  			while (!IsSet) {  				// If our token was canceled' we must throw and exit.  				cancellationToken.ThrowIfCancellationRequested ();  				//update timeout (delays in wait commencement are due to spinning and/or spurious wakeups from other waits being canceled)  				if (bNeedTimeoutAdjustment) {  					realMillisecondsTimeout = UpdateTimeOut (startTimeTicks' millisecondsTimeout);  					if (realMillisecondsTimeout <= 0)  						return false;  				}  				// There is a race that Set will fail to see that there are waiters as Set does not take the lock'   				// so after updating waiters' we must check IsSet again.  				// Also' we must ensure there cannot be any reordering of the assignment to Waiters and the  				// read from IsSet.  This is guaranteed as Waiters{set;} involves an Interlocked.CompareExchange  				// operation which provides a full memory barrier.  				// If we see IsSet=false' then we are guaranteed that Set() will see that we are  				// waiting and will pulse the monitor correctly.  				Waiters = Waiters + 1;  				if (IsSet)//This check must occur after updating Waiters.  				 {  					Waiters--;  					//revert the increment.  					return true;  				}  				// Now finally perform the wait.  				try {  					// ** the actual wait **  					if (!Monitor.Wait (m_lock' realMillisecondsTimeout))  						return false;  					//return immediately if the timeout has expired.  				}  				finally {  					// Clean up: we're done waiting.  					Waiters = Waiters - 1;  				}  				// Now just loop back around' and the right thing will happen.  Either:  				//     1. We had a spurious wake-up due to some other wait being canceled via a different cancellationToken (rewait)  				// or  2. the wait was successful. (the loop will break)  			}  		}  	}  }  
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Wait,The following statement contains a magic number: if (!IsSet) {  	if (millisecondsTimeout == 0) {  		// For 0-timeouts' we just return immediately.  		return false;  	}  	// We spin briefly before falling back to allocating and/or waiting on a true event.  	long startTimeTicks = 0;  	bool bNeedTimeoutAdjustment = false;  	int realMillisecondsTimeout = millisecondsTimeout;  	//this will be adjusted if necessary.  	if (millisecondsTimeout != Timeout.Infinite) {  		// We will account for time spent spinning' so that we can decrement it from our  		// timeout.  In most cases the time spent in this section will be negligible.  But  		// we can't discount the possibility of our thread being switched out for a lengthy  		// period of time.  The timeout adjustments only take effect when and if we actually  		// decide to block in the kernel below.  		startTimeTicks = DateTime.UtcNow.Ticks;  		bNeedTimeoutAdjustment = true;  	}  	//spin  	int HOW_MANY_SPIN_BEFORE_YIELD = 10;  	int HOW_MANY_YIELD_EVERY_SLEEP_0 = 5;  	int HOW_MANY_YIELD_EVERY_SLEEP_1 = 20;  	for (int i = 0; i < SpinCount; i++) {  		if (IsSet) {  			return true;  		}  		else if (i < HOW_MANY_SPIN_BEFORE_YIELD) {  			if (i == HOW_MANY_SPIN_BEFORE_YIELD / 2) {  				#if PFX_LEGACY_3_5  				                            Platform.Yield(); #else  				ThreadLightup.Current.Yield ();  				#endif  			}  			else {  				ThreadLightup.Current.SpinWait (PlatformHelper.ProcessorCount * (4 << i));  			}  		}  		else if (i % HOW_MANY_YIELD_EVERY_SLEEP_1 == 0) {  			ThreadLightup.Current.Sleep (1);  		}  		else if (i % HOW_MANY_YIELD_EVERY_SLEEP_0 == 0) {  			ThreadLightup.Current.Sleep (0);  		}  		else {  			#if PFX_LEGACY_3_5  			                        Platform.Yield(); #else  			ThreadLightup.Current.Yield ();  			#endif  		}  		if (i >= 100 && i % 10 == 0)  			// check the cancellation token if the user passed a very large spin count  			cancellationToken.ThrowIfCancellationRequested ();  	}  	// Now enter the lock and wait.  	EnsureLockObjectCreated ();  	// We must register and deregister the token outside of the lock' to avoid deadlocks.  	using (cancellationToken.Register (s_cancellationTokenCallback' this)) {  		lock (m_lock) {  			// Loop to cope with spurious wakeups from other waits being canceled  			while (!IsSet) {  				// If our token was canceled' we must throw and exit.  				cancellationToken.ThrowIfCancellationRequested ();  				//update timeout (delays in wait commencement are due to spinning and/or spurious wakeups from other waits being canceled)  				if (bNeedTimeoutAdjustment) {  					realMillisecondsTimeout = UpdateTimeOut (startTimeTicks' millisecondsTimeout);  					if (realMillisecondsTimeout <= 0)  						return false;  				}  				// There is a race that Set will fail to see that there are waiters as Set does not take the lock'   				// so after updating waiters' we must check IsSet again.  				// Also' we must ensure there cannot be any reordering of the assignment to Waiters and the  				// read from IsSet.  This is guaranteed as Waiters{set;} involves an Interlocked.CompareExchange  				// operation which provides a full memory barrier.  				// If we see IsSet=false' then we are guaranteed that Set() will see that we are  				// waiting and will pulse the monitor correctly.  				Waiters = Waiters + 1;  				if (IsSet)//This check must occur after updating Waiters.  				 {  					Waiters--;  					//revert the increment.  					return true;  				}  				// Now finally perform the wait.  				try {  					// ** the actual wait **  					if (!Monitor.Wait (m_lock' realMillisecondsTimeout))  						return false;  					//return immediately if the timeout has expired.  				}  				finally {  					// Clean up: we're done waiting.  					Waiters = Waiters - 1;  				}  				// Now just loop back around' and the right thing will happen.  Either:  				//     1. We had a spurious wake-up due to some other wait being canceled via a different cancellationToken (rewait)  				// or  2. the wait was successful. (the loop will break)  			}  		}  	}  }  
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Wait,The following statement contains a magic number: if (!IsSet) {  	if (millisecondsTimeout == 0) {  		// For 0-timeouts' we just return immediately.  		return false;  	}  	// We spin briefly before falling back to allocating and/or waiting on a true event.  	long startTimeTicks = 0;  	bool bNeedTimeoutAdjustment = false;  	int realMillisecondsTimeout = millisecondsTimeout;  	//this will be adjusted if necessary.  	if (millisecondsTimeout != Timeout.Infinite) {  		// We will account for time spent spinning' so that we can decrement it from our  		// timeout.  In most cases the time spent in this section will be negligible.  But  		// we can't discount the possibility of our thread being switched out for a lengthy  		// period of time.  The timeout adjustments only take effect when and if we actually  		// decide to block in the kernel below.  		startTimeTicks = DateTime.UtcNow.Ticks;  		bNeedTimeoutAdjustment = true;  	}  	//spin  	int HOW_MANY_SPIN_BEFORE_YIELD = 10;  	int HOW_MANY_YIELD_EVERY_SLEEP_0 = 5;  	int HOW_MANY_YIELD_EVERY_SLEEP_1 = 20;  	for (int i = 0; i < SpinCount; i++) {  		if (IsSet) {  			return true;  		}  		else if (i < HOW_MANY_SPIN_BEFORE_YIELD) {  			if (i == HOW_MANY_SPIN_BEFORE_YIELD / 2) {  				#if PFX_LEGACY_3_5  				                            Platform.Yield(); #else  				ThreadLightup.Current.Yield ();  				#endif  			}  			else {  				ThreadLightup.Current.SpinWait (PlatformHelper.ProcessorCount * (4 << i));  			}  		}  		else if (i % HOW_MANY_YIELD_EVERY_SLEEP_1 == 0) {  			ThreadLightup.Current.Sleep (1);  		}  		else if (i % HOW_MANY_YIELD_EVERY_SLEEP_0 == 0) {  			ThreadLightup.Current.Sleep (0);  		}  		else {  			#if PFX_LEGACY_3_5  			                        Platform.Yield(); #else  			ThreadLightup.Current.Yield ();  			#endif  		}  		if (i >= 100 && i % 10 == 0)  			// check the cancellation token if the user passed a very large spin count  			cancellationToken.ThrowIfCancellationRequested ();  	}  	// Now enter the lock and wait.  	EnsureLockObjectCreated ();  	// We must register and deregister the token outside of the lock' to avoid deadlocks.  	using (cancellationToken.Register (s_cancellationTokenCallback' this)) {  		lock (m_lock) {  			// Loop to cope with spurious wakeups from other waits being canceled  			while (!IsSet) {  				// If our token was canceled' we must throw and exit.  				cancellationToken.ThrowIfCancellationRequested ();  				//update timeout (delays in wait commencement are due to spinning and/or spurious wakeups from other waits being canceled)  				if (bNeedTimeoutAdjustment) {  					realMillisecondsTimeout = UpdateTimeOut (startTimeTicks' millisecondsTimeout);  					if (realMillisecondsTimeout <= 0)  						return false;  				}  				// There is a race that Set will fail to see that there are waiters as Set does not take the lock'   				// so after updating waiters' we must check IsSet again.  				// Also' we must ensure there cannot be any reordering of the assignment to Waiters and the  				// read from IsSet.  This is guaranteed as Waiters{set;} involves an Interlocked.CompareExchange  				// operation which provides a full memory barrier.  				// If we see IsSet=false' then we are guaranteed that Set() will see that we are  				// waiting and will pulse the monitor correctly.  				Waiters = Waiters + 1;  				if (IsSet)//This check must occur after updating Waiters.  				 {  					Waiters--;  					//revert the increment.  					return true;  				}  				// Now finally perform the wait.  				try {  					// ** the actual wait **  					if (!Monitor.Wait (m_lock' realMillisecondsTimeout))  						return false;  					//return immediately if the timeout has expired.  				}  				finally {  					// Clean up: we're done waiting.  					Waiters = Waiters - 1;  				}  				// Now just loop back around' and the right thing will happen.  Either:  				//     1. We had a spurious wake-up due to some other wait being canceled via a different cancellationToken (rewait)  				// or  2. the wait was successful. (the loop will break)  			}  		}  	}  }  
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Wait,The following statement contains a magic number: if (!IsSet) {  	if (millisecondsTimeout == 0) {  		// For 0-timeouts' we just return immediately.  		return false;  	}  	// We spin briefly before falling back to allocating and/or waiting on a true event.  	long startTimeTicks = 0;  	bool bNeedTimeoutAdjustment = false;  	int realMillisecondsTimeout = millisecondsTimeout;  	//this will be adjusted if necessary.  	if (millisecondsTimeout != Timeout.Infinite) {  		// We will account for time spent spinning' so that we can decrement it from our  		// timeout.  In most cases the time spent in this section will be negligible.  But  		// we can't discount the possibility of our thread being switched out for a lengthy  		// period of time.  The timeout adjustments only take effect when and if we actually  		// decide to block in the kernel below.  		startTimeTicks = DateTime.UtcNow.Ticks;  		bNeedTimeoutAdjustment = true;  	}  	//spin  	int HOW_MANY_SPIN_BEFORE_YIELD = 10;  	int HOW_MANY_YIELD_EVERY_SLEEP_0 = 5;  	int HOW_MANY_YIELD_EVERY_SLEEP_1 = 20;  	for (int i = 0; i < SpinCount; i++) {  		if (IsSet) {  			return true;  		}  		else if (i < HOW_MANY_SPIN_BEFORE_YIELD) {  			if (i == HOW_MANY_SPIN_BEFORE_YIELD / 2) {  				#if PFX_LEGACY_3_5  				                            Platform.Yield(); #else  				ThreadLightup.Current.Yield ();  				#endif  			}  			else {  				ThreadLightup.Current.SpinWait (PlatformHelper.ProcessorCount * (4 << i));  			}  		}  		else if (i % HOW_MANY_YIELD_EVERY_SLEEP_1 == 0) {  			ThreadLightup.Current.Sleep (1);  		}  		else if (i % HOW_MANY_YIELD_EVERY_SLEEP_0 == 0) {  			ThreadLightup.Current.Sleep (0);  		}  		else {  			#if PFX_LEGACY_3_5  			                        Platform.Yield(); #else  			ThreadLightup.Current.Yield ();  			#endif  		}  		if (i >= 100 && i % 10 == 0)  			// check the cancellation token if the user passed a very large spin count  			cancellationToken.ThrowIfCancellationRequested ();  	}  	// Now enter the lock and wait.  	EnsureLockObjectCreated ();  	// We must register and deregister the token outside of the lock' to avoid deadlocks.  	using (cancellationToken.Register (s_cancellationTokenCallback' this)) {  		lock (m_lock) {  			// Loop to cope with spurious wakeups from other waits being canceled  			while (!IsSet) {  				// If our token was canceled' we must throw and exit.  				cancellationToken.ThrowIfCancellationRequested ();  				//update timeout (delays in wait commencement are due to spinning and/or spurious wakeups from other waits being canceled)  				if (bNeedTimeoutAdjustment) {  					realMillisecondsTimeout = UpdateTimeOut (startTimeTicks' millisecondsTimeout);  					if (realMillisecondsTimeout <= 0)  						return false;  				}  				// There is a race that Set will fail to see that there are waiters as Set does not take the lock'   				// so after updating waiters' we must check IsSet again.  				// Also' we must ensure there cannot be any reordering of the assignment to Waiters and the  				// read from IsSet.  This is guaranteed as Waiters{set;} involves an Interlocked.CompareExchange  				// operation which provides a full memory barrier.  				// If we see IsSet=false' then we are guaranteed that Set() will see that we are  				// waiting and will pulse the monitor correctly.  				Waiters = Waiters + 1;  				if (IsSet)//This check must occur after updating Waiters.  				 {  					Waiters--;  					//revert the increment.  					return true;  				}  				// Now finally perform the wait.  				try {  					// ** the actual wait **  					if (!Monitor.Wait (m_lock' realMillisecondsTimeout))  						return false;  					//return immediately if the timeout has expired.  				}  				finally {  					// Clean up: we're done waiting.  					Waiters = Waiters - 1;  				}  				// Now just loop back around' and the right thing will happen.  Either:  				//     1. We had a spurious wake-up due to some other wait being canceled via a different cancellationToken (rewait)  				// or  2. the wait was successful. (the loop will break)  			}  		}  	}  }  
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Wait,The following statement contains a magic number: if (!IsSet) {  	if (millisecondsTimeout == 0) {  		// For 0-timeouts' we just return immediately.  		return false;  	}  	// We spin briefly before falling back to allocating and/or waiting on a true event.  	long startTimeTicks = 0;  	bool bNeedTimeoutAdjustment = false;  	int realMillisecondsTimeout = millisecondsTimeout;  	//this will be adjusted if necessary.  	if (millisecondsTimeout != Timeout.Infinite) {  		// We will account for time spent spinning' so that we can decrement it from our  		// timeout.  In most cases the time spent in this section will be negligible.  But  		// we can't discount the possibility of our thread being switched out for a lengthy  		// period of time.  The timeout adjustments only take effect when and if we actually  		// decide to block in the kernel below.  		startTimeTicks = DateTime.UtcNow.Ticks;  		bNeedTimeoutAdjustment = true;  	}  	//spin  	int HOW_MANY_SPIN_BEFORE_YIELD = 10;  	int HOW_MANY_YIELD_EVERY_SLEEP_0 = 5;  	int HOW_MANY_YIELD_EVERY_SLEEP_1 = 20;  	for (int i = 0; i < SpinCount; i++) {  		if (IsSet) {  			return true;  		}  		else if (i < HOW_MANY_SPIN_BEFORE_YIELD) {  			if (i == HOW_MANY_SPIN_BEFORE_YIELD / 2) {  				#if PFX_LEGACY_3_5  				                            Platform.Yield(); #else  				ThreadLightup.Current.Yield ();  				#endif  			}  			else {  				ThreadLightup.Current.SpinWait (PlatformHelper.ProcessorCount * (4 << i));  			}  		}  		else if (i % HOW_MANY_YIELD_EVERY_SLEEP_1 == 0) {  			ThreadLightup.Current.Sleep (1);  		}  		else if (i % HOW_MANY_YIELD_EVERY_SLEEP_0 == 0) {  			ThreadLightup.Current.Sleep (0);  		}  		else {  			#if PFX_LEGACY_3_5  			                        Platform.Yield(); #else  			ThreadLightup.Current.Yield ();  			#endif  		}  		if (i >= 100 && i % 10 == 0)  			// check the cancellation token if the user passed a very large spin count  			cancellationToken.ThrowIfCancellationRequested ();  	}  	// Now enter the lock and wait.  	EnsureLockObjectCreated ();  	// We must register and deregister the token outside of the lock' to avoid deadlocks.  	using (cancellationToken.Register (s_cancellationTokenCallback' this)) {  		lock (m_lock) {  			// Loop to cope with spurious wakeups from other waits being canceled  			while (!IsSet) {  				// If our token was canceled' we must throw and exit.  				cancellationToken.ThrowIfCancellationRequested ();  				//update timeout (delays in wait commencement are due to spinning and/or spurious wakeups from other waits being canceled)  				if (bNeedTimeoutAdjustment) {  					realMillisecondsTimeout = UpdateTimeOut (startTimeTicks' millisecondsTimeout);  					if (realMillisecondsTimeout <= 0)  						return false;  				}  				// There is a race that Set will fail to see that there are waiters as Set does not take the lock'   				// so after updating waiters' we must check IsSet again.  				// Also' we must ensure there cannot be any reordering of the assignment to Waiters and the  				// read from IsSet.  This is guaranteed as Waiters{set;} involves an Interlocked.CompareExchange  				// operation which provides a full memory barrier.  				// If we see IsSet=false' then we are guaranteed that Set() will see that we are  				// waiting and will pulse the monitor correctly.  				Waiters = Waiters + 1;  				if (IsSet)//This check must occur after updating Waiters.  				 {  					Waiters--;  					//revert the increment.  					return true;  				}  				// Now finally perform the wait.  				try {  					// ** the actual wait **  					if (!Monitor.Wait (m_lock' realMillisecondsTimeout))  						return false;  					//return immediately if the timeout has expired.  				}  				finally {  					// Clean up: we're done waiting.  					Waiters = Waiters - 1;  				}  				// Now just loop back around' and the right thing will happen.  Either:  				//     1. We had a spurious wake-up due to some other wait being canceled via a different cancellationToken (rewait)  				// or  2. the wait was successful. (the loop will break)  			}  		}  	}  }  
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Wait,The following statement contains a magic number: if (!IsSet) {  	if (millisecondsTimeout == 0) {  		// For 0-timeouts' we just return immediately.  		return false;  	}  	// We spin briefly before falling back to allocating and/or waiting on a true event.  	long startTimeTicks = 0;  	bool bNeedTimeoutAdjustment = false;  	int realMillisecondsTimeout = millisecondsTimeout;  	//this will be adjusted if necessary.  	if (millisecondsTimeout != Timeout.Infinite) {  		// We will account for time spent spinning' so that we can decrement it from our  		// timeout.  In most cases the time spent in this section will be negligible.  But  		// we can't discount the possibility of our thread being switched out for a lengthy  		// period of time.  The timeout adjustments only take effect when and if we actually  		// decide to block in the kernel below.  		startTimeTicks = DateTime.UtcNow.Ticks;  		bNeedTimeoutAdjustment = true;  	}  	//spin  	int HOW_MANY_SPIN_BEFORE_YIELD = 10;  	int HOW_MANY_YIELD_EVERY_SLEEP_0 = 5;  	int HOW_MANY_YIELD_EVERY_SLEEP_1 = 20;  	for (int i = 0; i < SpinCount; i++) {  		if (IsSet) {  			return true;  		}  		else if (i < HOW_MANY_SPIN_BEFORE_YIELD) {  			if (i == HOW_MANY_SPIN_BEFORE_YIELD / 2) {  				#if PFX_LEGACY_3_5  				                            Platform.Yield(); #else  				ThreadLightup.Current.Yield ();  				#endif  			}  			else {  				ThreadLightup.Current.SpinWait (PlatformHelper.ProcessorCount * (4 << i));  			}  		}  		else if (i % HOW_MANY_YIELD_EVERY_SLEEP_1 == 0) {  			ThreadLightup.Current.Sleep (1);  		}  		else if (i % HOW_MANY_YIELD_EVERY_SLEEP_0 == 0) {  			ThreadLightup.Current.Sleep (0);  		}  		else {  			#if PFX_LEGACY_3_5  			                        Platform.Yield(); #else  			ThreadLightup.Current.Yield ();  			#endif  		}  		if (i >= 100 && i % 10 == 0)  			// check the cancellation token if the user passed a very large spin count  			cancellationToken.ThrowIfCancellationRequested ();  	}  	// Now enter the lock and wait.  	EnsureLockObjectCreated ();  	// We must register and deregister the token outside of the lock' to avoid deadlocks.  	using (cancellationToken.Register (s_cancellationTokenCallback' this)) {  		lock (m_lock) {  			// Loop to cope with spurious wakeups from other waits being canceled  			while (!IsSet) {  				// If our token was canceled' we must throw and exit.  				cancellationToken.ThrowIfCancellationRequested ();  				//update timeout (delays in wait commencement are due to spinning and/or spurious wakeups from other waits being canceled)  				if (bNeedTimeoutAdjustment) {  					realMillisecondsTimeout = UpdateTimeOut (startTimeTicks' millisecondsTimeout);  					if (realMillisecondsTimeout <= 0)  						return false;  				}  				// There is a race that Set will fail to see that there are waiters as Set does not take the lock'   				// so after updating waiters' we must check IsSet again.  				// Also' we must ensure there cannot be any reordering of the assignment to Waiters and the  				// read from IsSet.  This is guaranteed as Waiters{set;} involves an Interlocked.CompareExchange  				// operation which provides a full memory barrier.  				// If we see IsSet=false' then we are guaranteed that Set() will see that we are  				// waiting and will pulse the monitor correctly.  				Waiters = Waiters + 1;  				if (IsSet)//This check must occur after updating Waiters.  				 {  					Waiters--;  					//revert the increment.  					return true;  				}  				// Now finally perform the wait.  				try {  					// ** the actual wait **  					if (!Monitor.Wait (m_lock' realMillisecondsTimeout))  						return false;  					//return immediately if the timeout has expired.  				}  				finally {  					// Clean up: we're done waiting.  					Waiters = Waiters - 1;  				}  				// Now just loop back around' and the right thing will happen.  Either:  				//     1. We had a spurious wake-up due to some other wait being canceled via a different cancellationToken (rewait)  				// or  2. the wait was successful. (the loop will break)  			}  		}  	}  }  
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Wait,The following statement contains a magic number: for (int i = 0; i < SpinCount; i++) {  	if (IsSet) {  		return true;  	}  	else if (i < HOW_MANY_SPIN_BEFORE_YIELD) {  		if (i == HOW_MANY_SPIN_BEFORE_YIELD / 2) {  			#if PFX_LEGACY_3_5  			                            Platform.Yield(); #else  			ThreadLightup.Current.Yield ();  			#endif  		}  		else {  			ThreadLightup.Current.SpinWait (PlatformHelper.ProcessorCount * (4 << i));  		}  	}  	else if (i % HOW_MANY_YIELD_EVERY_SLEEP_1 == 0) {  		ThreadLightup.Current.Sleep (1);  	}  	else if (i % HOW_MANY_YIELD_EVERY_SLEEP_0 == 0) {  		ThreadLightup.Current.Sleep (0);  	}  	else {  		#if PFX_LEGACY_3_5  		                        Platform.Yield(); #else  		ThreadLightup.Current.Yield ();  		#endif  	}  	if (i >= 100 && i % 10 == 0)  		// check the cancellation token if the user passed a very large spin count  		cancellationToken.ThrowIfCancellationRequested ();  }  
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Wait,The following statement contains a magic number: for (int i = 0; i < SpinCount; i++) {  	if (IsSet) {  		return true;  	}  	else if (i < HOW_MANY_SPIN_BEFORE_YIELD) {  		if (i == HOW_MANY_SPIN_BEFORE_YIELD / 2) {  			#if PFX_LEGACY_3_5  			                            Platform.Yield(); #else  			ThreadLightup.Current.Yield ();  			#endif  		}  		else {  			ThreadLightup.Current.SpinWait (PlatformHelper.ProcessorCount * (4 << i));  		}  	}  	else if (i % HOW_MANY_YIELD_EVERY_SLEEP_1 == 0) {  		ThreadLightup.Current.Sleep (1);  	}  	else if (i % HOW_MANY_YIELD_EVERY_SLEEP_0 == 0) {  		ThreadLightup.Current.Sleep (0);  	}  	else {  		#if PFX_LEGACY_3_5  		                        Platform.Yield(); #else  		ThreadLightup.Current.Yield ();  		#endif  	}  	if (i >= 100 && i % 10 == 0)  		// check the cancellation token if the user passed a very large spin count  		cancellationToken.ThrowIfCancellationRequested ();  }  
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Wait,The following statement contains a magic number: for (int i = 0; i < SpinCount; i++) {  	if (IsSet) {  		return true;  	}  	else if (i < HOW_MANY_SPIN_BEFORE_YIELD) {  		if (i == HOW_MANY_SPIN_BEFORE_YIELD / 2) {  			#if PFX_LEGACY_3_5  			                            Platform.Yield(); #else  			ThreadLightup.Current.Yield ();  			#endif  		}  		else {  			ThreadLightup.Current.SpinWait (PlatformHelper.ProcessorCount * (4 << i));  		}  	}  	else if (i % HOW_MANY_YIELD_EVERY_SLEEP_1 == 0) {  		ThreadLightup.Current.Sleep (1);  	}  	else if (i % HOW_MANY_YIELD_EVERY_SLEEP_0 == 0) {  		ThreadLightup.Current.Sleep (0);  	}  	else {  		#if PFX_LEGACY_3_5  		                        Platform.Yield(); #else  		ThreadLightup.Current.Yield ();  		#endif  	}  	if (i >= 100 && i % 10 == 0)  		// check the cancellation token if the user passed a very large spin count  		cancellationToken.ThrowIfCancellationRequested ();  }  
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Wait,The following statement contains a magic number: for (int i = 0; i < SpinCount; i++) {  	if (IsSet) {  		return true;  	}  	else if (i < HOW_MANY_SPIN_BEFORE_YIELD) {  		if (i == HOW_MANY_SPIN_BEFORE_YIELD / 2) {  			#if PFX_LEGACY_3_5  			                            Platform.Yield(); #else  			ThreadLightup.Current.Yield ();  			#endif  		}  		else {  			ThreadLightup.Current.SpinWait (PlatformHelper.ProcessorCount * (4 << i));  		}  	}  	else if (i % HOW_MANY_YIELD_EVERY_SLEEP_1 == 0) {  		ThreadLightup.Current.Sleep (1);  	}  	else if (i % HOW_MANY_YIELD_EVERY_SLEEP_0 == 0) {  		ThreadLightup.Current.Sleep (0);  	}  	else {  		#if PFX_LEGACY_3_5  		                        Platform.Yield(); #else  		ThreadLightup.Current.Yield ();  		#endif  	}  	if (i >= 100 && i % 10 == 0)  		// check the cancellation token if the user passed a very large spin count  		cancellationToken.ThrowIfCancellationRequested ();  }  
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Wait,The following statement contains a magic number: if (IsSet) {  	return true;  }  else if (i < HOW_MANY_SPIN_BEFORE_YIELD) {  	if (i == HOW_MANY_SPIN_BEFORE_YIELD / 2) {  		#if PFX_LEGACY_3_5  		                            Platform.Yield(); #else  		ThreadLightup.Current.Yield ();  		#endif  	}  	else {  		ThreadLightup.Current.SpinWait (PlatformHelper.ProcessorCount * (4 << i));  	}  }  else if (i % HOW_MANY_YIELD_EVERY_SLEEP_1 == 0) {  	ThreadLightup.Current.Sleep (1);  }  else if (i % HOW_MANY_YIELD_EVERY_SLEEP_0 == 0) {  	ThreadLightup.Current.Sleep (0);  }  else {  	#if PFX_LEGACY_3_5  	                        Platform.Yield(); #else  	ThreadLightup.Current.Yield ();  	#endif  }  
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Wait,The following statement contains a magic number: if (IsSet) {  	return true;  }  else if (i < HOW_MANY_SPIN_BEFORE_YIELD) {  	if (i == HOW_MANY_SPIN_BEFORE_YIELD / 2) {  		#if PFX_LEGACY_3_5  		                            Platform.Yield(); #else  		ThreadLightup.Current.Yield ();  		#endif  	}  	else {  		ThreadLightup.Current.SpinWait (PlatformHelper.ProcessorCount * (4 << i));  	}  }  else if (i % HOW_MANY_YIELD_EVERY_SLEEP_1 == 0) {  	ThreadLightup.Current.Sleep (1);  }  else if (i % HOW_MANY_YIELD_EVERY_SLEEP_0 == 0) {  	ThreadLightup.Current.Sleep (0);  }  else {  	#if PFX_LEGACY_3_5  	                        Platform.Yield(); #else  	ThreadLightup.Current.Yield ();  	#endif  }  
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Wait,The following statement contains a magic number: if (i < HOW_MANY_SPIN_BEFORE_YIELD) {  	if (i == HOW_MANY_SPIN_BEFORE_YIELD / 2) {  		#if PFX_LEGACY_3_5  		                            Platform.Yield(); #else  		ThreadLightup.Current.Yield ();  		#endif  	}  	else {  		ThreadLightup.Current.SpinWait (PlatformHelper.ProcessorCount * (4 << i));  	}  }  else if (i % HOW_MANY_YIELD_EVERY_SLEEP_1 == 0) {  	ThreadLightup.Current.Sleep (1);  }  else if (i % HOW_MANY_YIELD_EVERY_SLEEP_0 == 0) {  	ThreadLightup.Current.Sleep (0);  }  else {  	#if PFX_LEGACY_3_5  	                        Platform.Yield(); #else  	ThreadLightup.Current.Yield ();  	#endif  }  
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Wait,The following statement contains a magic number: if (i < HOW_MANY_SPIN_BEFORE_YIELD) {  	if (i == HOW_MANY_SPIN_BEFORE_YIELD / 2) {  		#if PFX_LEGACY_3_5  		                            Platform.Yield(); #else  		ThreadLightup.Current.Yield ();  		#endif  	}  	else {  		ThreadLightup.Current.SpinWait (PlatformHelper.ProcessorCount * (4 << i));  	}  }  else if (i % HOW_MANY_YIELD_EVERY_SLEEP_1 == 0) {  	ThreadLightup.Current.Sleep (1);  }  else if (i % HOW_MANY_YIELD_EVERY_SLEEP_0 == 0) {  	ThreadLightup.Current.Sleep (0);  }  else {  	#if PFX_LEGACY_3_5  	                        Platform.Yield(); #else  	ThreadLightup.Current.Yield ();  	#endif  }  
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Wait,The following statement contains a magic number: if (i == HOW_MANY_SPIN_BEFORE_YIELD / 2) {  	#if PFX_LEGACY_3_5  	                            Platform.Yield(); #else  	ThreadLightup.Current.Yield ();  	#endif  }  else {  	ThreadLightup.Current.SpinWait (PlatformHelper.ProcessorCount * (4 << i));  }  
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Wait,The following statement contains a magic number: if (i == HOW_MANY_SPIN_BEFORE_YIELD / 2) {  	#if PFX_LEGACY_3_5  	                            Platform.Yield(); #else  	ThreadLightup.Current.Yield ();  	#endif  }  else {  	ThreadLightup.Current.SpinWait (PlatformHelper.ProcessorCount * (4 << i));  }  
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Wait,The following statement contains a magic number: ThreadLightup.Current.SpinWait (PlatformHelper.ProcessorCount * (4 << i));  
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Wait,The following statement contains a magic number: if (i >= 100 && i % 10 == 0)  	// check the cancellation token if the user passed a very large spin count  	cancellationToken.ThrowIfCancellationRequested ();  
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,Wait,The following statement contains a magic number: if (i >= 100 && i % 10 == 0)  	// check the cancellation token if the user passed a very large spin count  	cancellationToken.ThrowIfCancellationRequested ();  
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,UpdateTimeOut,The following statement contains a magic number: if (elapsedMilliseconds > int.MaxValue) {  	return -2;  }  
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\ManualResetEventSlim.cs,UpdateTimeOut,The following statement contains a magic number: return -2;  
Magic Number,System.Threading,SpinWait,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\SpinWait.cs,SpinOnce,The following statement contains a magic number: if (NextSpinWillYield) {  	//  	// We must yield.  	//  	// We prefer to call Thread.Yield first' triggering a SwitchToThread. This  	// unfortunately doesn't consider all runnable threads on all OS SKUs. In  	// some cases' it may only consult the runnable threads whose ideal processor  	// is the one currently executing code. Thus we ocassionally issue a call to  	// Sleep(0)' which considers all runnable threads at equal priority. Even this  	// is insufficient since we may be spin waiting for lower priority threads to  	// execute; we therefore must call Sleep(1) once in a while too' which considers  	// all runnable threads' regardless of ideal processor and priority' but may  	// remove the thread from the scheduler's queue for 10+ms' if the system is  	// configured to use the (default) coarse-grained system timer.  	//  	#if ETW_EVENTING  	                CdsSyncEtwBCLProvider.Log.SpinWait_NextSpinWillYield(); #endif  	int yieldsSoFar = (m_count >= YIELD_THRESHOLD ? m_count - YIELD_THRESHOLD : m_count);  	if ((yieldsSoFar % SLEEP_1_EVERY_HOW_MANY_TIMES) == (SLEEP_1_EVERY_HOW_MANY_TIMES - 1)) {  		ThreadLightup.Current.Sleep (1);  	}  	else if ((yieldsSoFar % SLEEP_0_EVERY_HOW_MANY_TIMES) == (SLEEP_0_EVERY_HOW_MANY_TIMES - 1)) {  		ThreadLightup.Current.Sleep (0);  	}  	else {  		#if PFX_LEGACY_3_5  		                    Platform.Yield(); #else  		ThreadLightup.Current.Yield ();  		#endif  	}  }  else {  	//  	// Otherwise' we will spin.  	//  	// We do this using the CLR's SpinWait API' which is just a busy loop that  	// issues YIELD/PAUSE instructions to ensure multi-threaded CPUs can react  	// intelligently to avoid starving. (These are NOOPs on other CPUs.) We  	// choose a number for the loop iteration count such that each successive  	// call spins for longer' to reduce cache contention.  We cap the total  	// number of spins we are willing to tolerate to reduce delay to the caller'  	// since we expect most callers will eventually block anyway.  	//  	ThreadLightup.Current.SpinWait (4 << m_count);  }  
Magic Number,System.Threading,SpinWait,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\SpinWait.cs,SpinOnce,The following statement contains a magic number: ThreadLightup.Current.SpinWait (4 << m_count);  
Missing Default,System.Threading.Tasks,TaskExtensions,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskExtensions.cs,Unwrap,The following switch statement is missing a default case: switch (task.Status) {  // If task did not run to completion' then record the cancellation/fault information  // to tcs.Task.  case TaskStatus.Canceled:  case TaskStatus.Faulted:  	result = tcs.TrySetFromTask (task);  	Contract.Assert (result' "Unwrap(Task<Task>): Expected TrySetFromTask #1 to succeed");  	break;  case TaskStatus.RanToCompletion:  	// task.Result == null ==> proxy should be canceled.  	if (task.Result == null)  		tcs.TrySetCanceled ();  	// When task.Result completes' take some action to set the completion state of tcs.Task.  	else {  		task.Result.ContinueWith (_ =>  {  			// Copy completion/cancellation/exception info from task.Result to tcs.Task.  			result = tcs.TrySetFromTask (task.Result);  			Contract.Assert (result' "Unwrap(Task<Task>): Expected TrySetFromTask #2 to succeed");  		}' CancellationToken.None' TaskContinuationOptions.ExecuteSynchronously' TaskScheduler.Default);  	}  	break;  }  
Missing Default,System.Threading.Tasks,TaskExtensions,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskExtensions.cs,Unwrap,The following switch statement is missing a default case: switch (task.Status) {  // If task did not run to completion' then record the cancellation/fault information  // to tcs.Task.  case TaskStatus.Canceled:  case TaskStatus.Faulted:  	result = tcs.TrySetFromTask (task);  	Contract.Assert (result' "Unwrap(Task<Task<T>>): Expected TrySetFromTask #1 to succeed");  	break;  case TaskStatus.RanToCompletion:  	// task.Result == null ==> proxy should be canceled.  	if (task.Result == null)  		tcs.TrySetCanceled ();  	// When task.Result completes' take some action to set the completion state of tcs.Task.  	else {  		task.Result.ContinueWith (_ =>  {  			// Copy completion/cancellation/exception info from task.Result to tcs.Task.  			result = tcs.TrySetFromTask (task.Result);  			Contract.Assert (result' "Unwrap(Task<Task<T>>): Expected TrySetFromTask #2 to succeed");  		}' CancellationToken.None' TaskContinuationOptions.ExecuteSynchronously' TaskScheduler.Default);  	}  	break;  }  
Missing Default,System.Threading.Tasks,TaskExtensions,C:\repos\Microsoft_referencesource\Microsoft.Bcl\System.Threading.Tasks.v1.5\System\Threading\Tasks\TaskExtensions.cs,TrySetFromTask,The following switch statement is missing a default case: switch (source.Status) {  case TaskStatus.Canceled:  	rval = me.TrySetCanceled ();  	break;  case TaskStatus.Faulted:  	rval = me.TrySetException (source.Exception.InnerExceptions);  	break;  case TaskStatus.RanToCompletion:  	if (source is Task<TResult>)  		rval = me.TrySetResult (((Task<TResult>)source).Result);  	else  		rval = me.TrySetResult (default(TResult));  	break;  }  
