Implementation smell,Namespace,Class,File,Method,Description
Long Method,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The method has 89 lines of code.
Complex Method,CG.Web.MegaApiClient,Attributes,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\JsonSerialization.cs,ComputeCrc,Cyclomatic complexity of the method is 13
Complex Method,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,Read,Cyclomatic complexity of the method is 10
Complex Method,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,Cyclomatic complexity of the method is 18
Complex Method,CG.Web.MegaApiClient,Node,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Node.cs,OnDeserialized,Cyclomatic complexity of the method is 8
Complex Method,CG.Web.MegaApiClient,WebClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\WebClient_HttpWebRequest.cs,PostRequest,Cyclomatic complexity of the method is 9
Long Parameter List,CG.Web.MegaApiClient,ApiRequestFailedEventArgs,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\ApiRequestFailedEventArgs.cs,ApiRequestFailedEventArgs,The method has 5 parameters.
Long Parameter List,CG.Web.MegaApiClient,ApiRequestFailedEventArgs,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\ApiRequestFailedEventArgs.cs,ApiRequestFailedEventArgs,The method has 5 parameters.
Long Parameter List,CG.Web.MegaApiClient,ApiRequestFailedEventArgs,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\ApiRequestFailedEventArgs.cs,ApiRequestFailedEventArgs,The method has 6 parameters.
Long Parameter List,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,GetPartsFromDecryptedKey,The method has 4 parameters.
Long Parameter List,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,RsaDecrypt,The method has 4 parameters.
Long Parameter List,CG.Web.MegaApiClient,IMegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\IMegaApiClient.cs,Upload,The method has 4 parameters.
Long Parameter List,CG.Web.MegaApiClient,CreateNodeRequest,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\JsonSerialization.cs,CreateNodeRequest,The method has 6 parameters.
Long Parameter List,CG.Web.MegaApiClient,CreateNodeRequest,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\JsonSerialization.cs,CreateFileNodeRequest,The method has 5 parameters.
Long Parameter List,CG.Web.MegaApiClient,CreateNodeRequest,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\JsonSerialization.cs,CreateFolderNodeRequest,The method has 4 parameters.
Long Parameter List,CG.Web.MegaApiClient,ShareDataConverter,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\JsonSerialization.cs,ReadJson,The method has 4 parameters.
Long Parameter List,CG.Web.MegaApiClient,MegaAesCtrStreamDecrypter,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,MegaAesCtrStreamDecrypter,The method has 5 parameters.
Long Parameter List,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,MegaAesCtrStream,The method has 5 parameters.
Long Parameter List,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The method has 4 parameters.
Long Parameter List,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,GetPartsFromUri,The method has 5 parameters.
Long Parameter List,CG.Web.MegaApiClient,Options,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Options.cs,Options,The method has 7 parameters.
Long Parameter List,DamienG.Security.Cryptography,Crc32,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crc32.cs,CalculateHash,The method has 5 parameters.
Long Identifier,CG.Web.MegaApiClient,Options,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Options.cs,Options,The length of the parameter apiRequestDelayExponentialFactor is 32.
Long Statement,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,GetRsaPrivateKeyComponents,The length of the statement  "	encodedRsaPrivateKey = encodedRsaPrivateKey.CopySubArray (encodedRsaPrivateKey.Length + (16 - encodedRsaPrivateKey.Length % 16)); " is 129.
Long Statement,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Login,The length of the statement  "	byte[] sid = Crypto.RsaDecrypt (encryptedSid.FromMPINumber ()' rsaPrivateKeyComponents [0]' rsaPrivateKeyComponents [1]' rsaPrivateKeyComponents [2]); " is 150.
Long Statement,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,LoginAnonymous,The length of the statement  "	AnonymousLoginRequest request = new AnonymousLoginRequest (encryptedMasterKey.ToBase64 ()' encryptedSession.ToBase64 ()); " is 121.
Long Statement,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,CreateFolder,The length of the statement  "	CreateNodeRequest request = CreateNodeRequest.CreateFolderNodeRequest (parent' attributes.ToBase64 ()' encryptedKey.ToBase64 ()' key); " is 134.
Long Statement,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,GetDownloadLink,The length of the statement  "	return new Uri (BaseUri' string.Format ("/#{0}!{1}!{2}"' node.Type == NodeType.Directory ? "F" : string.Empty' response' node.Type == NodeType.Directory ? nodeCrypto.SharedKey.ToBase64 () : nodeCrypto.FullKey.ToBase64 ())); " is 223.
Long Statement,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Download,The length of the statement  "	Stream resultStream = new MegaAesCtrStreamDecrypter (dataStream' downloadResponse.Size' nodeCrypto.Key' nodeCrypto.Iv' nodeCrypto.MetaMac); " is 139.
Long Statement,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The length of the statement  "			var chunksSizesToUpload = this.ComputeChunksSizesToUpload (encryptedStream.ChunksPositions' encryptedStream.Length).ToArray (); " is 127.
Long Statement,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The length of the statement  "				this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' completionHandle)); " is 132.
Long Statement,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The length of the statement  "				if (apiResult == ApiResultCode.RequestFailedRetry || apiResult == ApiResultCode.RequestFailedPermanetly || apiResult == ApiResultCode.TooManyRequests) { " is 152.
Long Statement,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The length of the statement  "			byte[] cryptedAttributes = Crypto.EncryptAttributes (new Attributes (name' stream' modificationDate)' encryptedStream.FileKey); " is 127.
Long Statement,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The length of the statement  "			CreateNodeRequest createNodeRequest = CreateNodeRequest.CreateFileNodeRequest (parent' cryptedAttributes.ToBase64 ()' encryptedKey.ToBase64 ()' fileKey' completionHandle); " is 171.
Long Statement,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Rename,The length of the statement  "	byte[] encryptedAttributes = Crypto.EncryptAttributes (new Attributes (newName' ((Node)node).Attributes)' nodeCrypto.Key); " is 122.
Long Statement,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,RequestCore,The length of the statement  "		if (string.IsNullOrEmpty (dataResult) || (jsonData = JsonConvert.DeserializeObject (dataResult)) == null || jsonData is long || (jsonData is JArray && ((JArray)jsonData) [0].Type == JTokenType.Integer)) { " is 204.
Long Statement,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,RequestCore,The length of the statement  "			ApiResultCode apiCode = jsonData == null ? ApiResultCode.RequestFailedRetry : jsonData is long ? (ApiResultCode)Enum.ToObject (typeof(ApiResultCode)' jsonData) : (ApiResultCode)((JArray)jsonData) [0].Value<int> (); " is 214.
Long Statement,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,RequestCore,The length of the statement  "				this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' this.options.ApiRequestAttempts - remainingRetry' requestDelay' apiCode' dataResult)); " is 158.
Long Statement,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,RequestCore,The length of the statement  "	return (typeof(TResponse) == typeof(string)) ? data as TResponse : JsonConvert.DeserializeObject<TResponse> (data' settings); " is 125.
Long Statement,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,ComputeChunksSizesToUpload,The length of the statement  "		while (((int)(nextChunkPosition - currentChunkPosition) < this.options.ChunksPackSize || this.options.ChunksPackSize == -1) && i < chunksPositions.Length - 1) { " is 160.
Complex Conditional,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,RequestCore,The conditional expression  "string.IsNullOrEmpty (dataResult) || (jsonData = JsonConvert.DeserializeObject (dataResult)) == null || jsonData is long || (jsonData is JArray && ((JArray)jsonData) [0].Type == JTokenType.Integer)"  is complex.
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,DecryptKey,The following statement contains a magic number: for (int idx = 0; idx < data.Length; idx += 16) {  	byte[] block = data.CopySubArray (16' idx);  	byte[] decryptedBlock = DecryptAes (block' key);  	Array.Copy (decryptedBlock' 0' result' idx' 16);  }  
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,DecryptKey,The following statement contains a magic number: for (int idx = 0; idx < data.Length; idx += 16) {  	byte[] block = data.CopySubArray (16' idx);  	byte[] decryptedBlock = DecryptAes (block' key);  	Array.Copy (decryptedBlock' 0' result' idx' 16);  }  
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,DecryptKey,The following statement contains a magic number: for (int idx = 0; idx < data.Length; idx += 16) {  	byte[] block = data.CopySubArray (16' idx);  	byte[] decryptedBlock = DecryptAes (block' key);  	Array.Copy (decryptedBlock' 0' result' idx' 16);  }  
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,DecryptKey,The following statement contains a magic number: idx += 16
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,DecryptKey,The following statement contains a magic number: Array.Copy (decryptedBlock' 0' result' idx' 16);  
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,EncryptKey,The following statement contains a magic number: for (int idx = 0; idx < data.Length; idx += 16) {  	byte[] block = data.CopySubArray (16' idx);  	byte[] encryptedBlock = EncryptAes (block' key);  	Array.Copy (encryptedBlock' 0' result' idx' 16);  }  
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,EncryptKey,The following statement contains a magic number: for (int idx = 0; idx < data.Length; idx += 16) {  	byte[] block = data.CopySubArray (16' idx);  	byte[] encryptedBlock = EncryptAes (block' key);  	Array.Copy (encryptedBlock' 0' result' idx' 16);  }  
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,EncryptKey,The following statement contains a magic number: for (int idx = 0; idx < data.Length; idx += 16) {  	byte[] block = data.CopySubArray (16' idx);  	byte[] encryptedBlock = EncryptAes (block' key);  	Array.Copy (encryptedBlock' 0' result' idx' 16);  }  
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,EncryptKey,The following statement contains a magic number: idx += 16
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,EncryptKey,The following statement contains a magic number: Array.Copy (encryptedBlock' 0' result' idx' 16);  
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,GetPartsFromDecryptedKey,The following statement contains a magic number: iv = new byte[8];  
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,GetPartsFromDecryptedKey,The following statement contains a magic number: metaMac = new byte[8];  
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,GetPartsFromDecryptedKey,The following statement contains a magic number: Array.Copy (decryptedKey' 16' iv' 0' 8);  
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,GetPartsFromDecryptedKey,The following statement contains a magic number: Array.Copy (decryptedKey' 16' iv' 0' 8);  
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,GetPartsFromDecryptedKey,The following statement contains a magic number: Array.Copy (decryptedKey' 24' metaMac' 0' 8);  
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,GetPartsFromDecryptedKey,The following statement contains a magic number: Array.Copy (decryptedKey' 24' metaMac' 0' 8);  
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,GetPartsFromDecryptedKey,The following statement contains a magic number: fileKey = new byte[16];  
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,GetPartsFromDecryptedKey,The following statement contains a magic number: for (int idx = 0; idx < 16; idx++) {  	fileKey [idx] = (byte)(decryptedKey [idx] ^ decryptedKey [idx + 16]);  }  
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,GetPartsFromDecryptedKey,The following statement contains a magic number: for (int idx = 0; idx < 16; idx++) {  	fileKey [idx] = (byte)(decryptedKey [idx] ^ decryptedKey [idx + 16]);  }  
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,GetPartsFromDecryptedKey,The following statement contains a magic number: fileKey [idx] = (byte)(decryptedKey [idx] ^ decryptedKey [idx + 16]);  
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,CreateAesKey,The following statement contains a magic number: using (Rijndael rijndael = Rijndael.Create ()) {  	rijndael.Mode = CipherMode.CBC;  	rijndael.KeySize = 128;  	rijndael.Padding = PaddingMode.None;  	rijndael.GenerateKey ();  	return rijndael.Key;  }  
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,CreateAesKey,The following statement contains a magic number: rijndael.KeySize = 128;  
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,EncryptAttributes,The following statement contains a magic number: dataBytes = dataBytes.CopySubArray (dataBytes.Length + 16 - (dataBytes.Length % 16));  
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,EncryptAttributes,The following statement contains a magic number: dataBytes = dataBytes.CopySubArray (dataBytes.Length + 16 - (dataBytes.Length % 16));  
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,DecryptAttributes,The following statement contains a magic number: try {  	string json = decryptedAttributes.ToUTF8String ().Substring (4);  	int nullTerminationIndex = json.IndexOf ('\0');  	if (nullTerminationIndex != -1) {  		json = json.Substring (0' nullTerminationIndex);  	}  	return JsonConvert.DeserializeObject<Attributes> (json);  } catch (Exception ex) {  	return new Attributes (string.Format ("Attribute deserialization failed: {0}"' ex.Message));  }  
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,GetRsaPrivateKeyComponents,The following statement contains a magic number: encodedRsaPrivateKey = encodedRsaPrivateKey.CopySubArray (encodedRsaPrivateKey.Length + (16 - encodedRsaPrivateKey.Length % 16));  
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,GetRsaPrivateKeyComponents,The following statement contains a magic number: encodedRsaPrivateKey = encodedRsaPrivateKey.CopySubArray (encodedRsaPrivateKey.Length + (16 - encodedRsaPrivateKey.Length % 16));  
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,GetRsaPrivateKeyComponents,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	rsaPrivateKeyComponents [i] = rsaPrivateKey.FromMPINumber ();  	// Remove already retrieved part  	int dataLength = ((rsaPrivateKey [0] * 256 + rsaPrivateKey [1] + 7) / 8);  	rsaPrivateKey = rsaPrivateKey.CopySubArray (rsaPrivateKey.Length - dataLength - 2' dataLength + 2);  }  
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,GetRsaPrivateKeyComponents,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	rsaPrivateKeyComponents [i] = rsaPrivateKey.FromMPINumber ();  	// Remove already retrieved part  	int dataLength = ((rsaPrivateKey [0] * 256 + rsaPrivateKey [1] + 7) / 8);  	rsaPrivateKey = rsaPrivateKey.CopySubArray (rsaPrivateKey.Length - dataLength - 2' dataLength + 2);  }  
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,GetRsaPrivateKeyComponents,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	rsaPrivateKeyComponents [i] = rsaPrivateKey.FromMPINumber ();  	// Remove already retrieved part  	int dataLength = ((rsaPrivateKey [0] * 256 + rsaPrivateKey [1] + 7) / 8);  	rsaPrivateKey = rsaPrivateKey.CopySubArray (rsaPrivateKey.Length - dataLength - 2' dataLength + 2);  }  
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,GetRsaPrivateKeyComponents,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	rsaPrivateKeyComponents [i] = rsaPrivateKey.FromMPINumber ();  	// Remove already retrieved part  	int dataLength = ((rsaPrivateKey [0] * 256 + rsaPrivateKey [1] + 7) / 8);  	rsaPrivateKey = rsaPrivateKey.CopySubArray (rsaPrivateKey.Length - dataLength - 2' dataLength + 2);  }  
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,GetRsaPrivateKeyComponents,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	rsaPrivateKeyComponents [i] = rsaPrivateKey.FromMPINumber ();  	// Remove already retrieved part  	int dataLength = ((rsaPrivateKey [0] * 256 + rsaPrivateKey [1] + 7) / 8);  	rsaPrivateKey = rsaPrivateKey.CopySubArray (rsaPrivateKey.Length - dataLength - 2' dataLength + 2);  }  
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,GetRsaPrivateKeyComponents,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	rsaPrivateKeyComponents [i] = rsaPrivateKey.FromMPINumber ();  	// Remove already retrieved part  	int dataLength = ((rsaPrivateKey [0] * 256 + rsaPrivateKey [1] + 7) / 8);  	rsaPrivateKey = rsaPrivateKey.CopySubArray (rsaPrivateKey.Length - dataLength - 2' dataLength + 2);  }  
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,GetRsaPrivateKeyComponents,The following statement contains a magic number: rsaPrivateKey = rsaPrivateKey.CopySubArray (rsaPrivateKey.Length - dataLength - 2' dataLength + 2);  
Magic Number,CG.Web.MegaApiClient,Crypto,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crypto.cs,GetRsaPrivateKeyComponents,The following statement contains a magic number: rsaPrivateKey = rsaPrivateKey.CopySubArray (rsaPrivateKey.Length - dataLength - 2' dataLength + 2);  
Magic Number,CG.Web.MegaApiClient,Extensions,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Extensions.cs,FromBase64,The following statement contains a magic number: sb.Append (string.Empty.PadRight ((4 - data.Length % 4) % 4' '='));  
Magic Number,CG.Web.MegaApiClient,Extensions,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Extensions.cs,FromBase64,The following statement contains a magic number: sb.Append (string.Empty.PadRight ((4 - data.Length % 4) % 4' '='));  
Magic Number,CG.Web.MegaApiClient,Extensions,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Extensions.cs,FromBase64,The following statement contains a magic number: sb.Append (string.Empty.PadRight ((4 - data.Length % 4) % 4' '='));  
Magic Number,CG.Web.MegaApiClient,Extensions,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Extensions.cs,FromMPINumber,The following statement contains a magic number: Array.Copy (data' 2' result' 0' result.Length);  
Magic Number,CG.Web.MegaApiClient,Extensions,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Extensions.cs,DeserializeToLong,The following statement contains a magic number: while (p > 0) {  	result = (result << 8) + data [index + p--];  }  
Magic Number,CG.Web.MegaApiClient,Extensions,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Extensions.cs,DeserializeToLong,The following statement contains a magic number: result = (result << 8) + data [index + p--];  
Magic Number,CG.Web.MegaApiClient,Extensions,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Extensions.cs,SerializeToBytes,The following statement contains a magic number: while (data != 0) {  	result [++p] = (byte)data;  	data >>= 8;  }  
Magic Number,CG.Web.MegaApiClient,Extensions,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Extensions.cs,SerializeToBytes,The following statement contains a magic number: data >>= 8;  
Magic Number,CG.Web.MegaApiClient,Attributes,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\JsonSerialization.cs,ComputeCrc,The following statement contains a magic number: if (stream.Length <= CrcSize) {  	// tiny file: read verbatim' NUL pad  	if (0 != stream.Read (newCrcBuffer' 0' (int)stream.Length)) {  		Buffer.BlockCopy (newCrcBuffer' 0' crc' 0' newCrcBuffer.Length);  	}  } else if (stream.Length <= MAXFULL) {  	// small file: full coverage' four full CRC32s  	byte[] fileBuffer = new byte[stream.Length];  	int read = 0;  	while ((read += stream.Read (fileBuffer' read' (int)stream.Length - read)) < stream.Length)  		;  	for (int i = 0; i < crc.Length; i++) {  		int begin = (int)(i * stream.Length / crc.Length);  		int end = (int)((i + 1) * stream.Length / crc.Length);  		using (var crc32Hasher = new Crc32 (CryptoPPCRC32Polynomial' Crc32.DefaultSeed)) {  			crc32Hasher.TransformBlock (fileBuffer' begin' end - begin' null' 0);  			crc32Hasher.TransformFinalBlock (fileBuffer' 0' 0);  			var crcValBytes = crc32Hasher.Hash;  			crcVal = BitConverter.ToUInt32 (crcValBytes' 0);  		}  		crc [i] = crcVal;  	}  } else {  	// large file: sparse coverage' four sparse CRC32s  	byte[] block = new byte[4 * CrcSize];  	uint blocks = (uint)(MAXFULL / (block.Length * CrcArrayLength));  	long current = 0;  	for (uint i = 0; i < CrcArrayLength; i++) {  		using (var crc32Hasher = new Crc32 (CryptoPPCRC32Polynomial' Crc32.DefaultSeed)) {  			for (uint j = 0; j < blocks; j++) {  				long offset = (stream.Length - block.Length) * (i * blocks + j) / (CrcArrayLength * blocks - 1);  				stream.Seek (offset - current' SeekOrigin.Current);  				current += (offset - current);  				int blockWritten = stream.Read (block' 0' block.Length);  				current += blockWritten;  				crc32Hasher.TransformBlock (block' 0' blockWritten' null' 0);  			}  			crc32Hasher.TransformFinalBlock (block' 0' 0);  			var crc32ValBytes = crc32Hasher.Hash;  			crcVal = BitConverter.ToUInt32 (crc32ValBytes' 0);  		}  		crc [i] = crcVal;  	}  }  
Magic Number,CG.Web.MegaApiClient,Attributes,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\JsonSerialization.cs,ComputeCrc,The following statement contains a magic number: if (stream.Length <= MAXFULL) {  	// small file: full coverage' four full CRC32s  	byte[] fileBuffer = new byte[stream.Length];  	int read = 0;  	while ((read += stream.Read (fileBuffer' read' (int)stream.Length - read)) < stream.Length)  		;  	for (int i = 0; i < crc.Length; i++) {  		int begin = (int)(i * stream.Length / crc.Length);  		int end = (int)((i + 1) * stream.Length / crc.Length);  		using (var crc32Hasher = new Crc32 (CryptoPPCRC32Polynomial' Crc32.DefaultSeed)) {  			crc32Hasher.TransformBlock (fileBuffer' begin' end - begin' null' 0);  			crc32Hasher.TransformFinalBlock (fileBuffer' 0' 0);  			var crcValBytes = crc32Hasher.Hash;  			crcVal = BitConverter.ToUInt32 (crcValBytes' 0);  		}  		crc [i] = crcVal;  	}  } else {  	// large file: sparse coverage' four sparse CRC32s  	byte[] block = new byte[4 * CrcSize];  	uint blocks = (uint)(MAXFULL / (block.Length * CrcArrayLength));  	long current = 0;  	for (uint i = 0; i < CrcArrayLength; i++) {  		using (var crc32Hasher = new Crc32 (CryptoPPCRC32Polynomial' Crc32.DefaultSeed)) {  			for (uint j = 0; j < blocks; j++) {  				long offset = (stream.Length - block.Length) * (i * blocks + j) / (CrcArrayLength * blocks - 1);  				stream.Seek (offset - current' SeekOrigin.Current);  				current += (offset - current);  				int blockWritten = stream.Read (block' 0' block.Length);  				current += blockWritten;  				crc32Hasher.TransformBlock (block' 0' blockWritten' null' 0);  			}  			crc32Hasher.TransformFinalBlock (block' 0' 0);  			var crc32ValBytes = crc32Hasher.Hash;  			crcVal = BitConverter.ToUInt32 (crc32ValBytes' 0);  		}  		crc [i] = crcVal;  	}  }  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStreamDecrypter,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,MegaAesCtrStreamDecrypter,The following statement contains a magic number: if (expectedMetaMac == null || expectedMetaMac.Length != 8) {  	throw new ArgumentException ("Invalid expectedMetaMac");  }  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,MegaAesCtrStream,The following statement contains a magic number: if (fileKey == null || fileKey.Length != 16) {  	throw new ArgumentException ("Invalid fileKey");  }  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,MegaAesCtrStream,The following statement contains a magic number: if (iv == null || iv.Length != 8) {  	throw new ArgumentException ("Invalid Iv");  }  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,Read,The following statement contains a magic number: for (long pos = this.position; pos < Math.Min (this.position + count' this.streamLength); pos += 16) {  	// We are on a chunk bondary  	if (this.chunksPositions.Any (chunk => chunk == pos)) {  		if (pos != 0) {  			// Compute the current chunk mac data on each chunk bondary  			this.ComputeChunk ();  		}  		// Init chunk mac with Iv values  		for (int i = 0; i < 8; i++) {  			this.currentChunkMac [i] = this.iv [i];  			this.currentChunkMac [i + 8] = this.iv [i];  		}  	}  	this.IncrementCounter ();  	// Iterate each AES 16 bytes block  	byte[] input = new byte[16];  	byte[] output = new byte[input.Length];  	int inputLength = this.stream.Read (input' 0' input.Length);  	if (inputLength != input.Length) {  		// Sometimes' the stream is not finished but the read is not complete  		inputLength += this.stream.Read (input' inputLength' input.Length - inputLength);  	}  	// Merge Iv and counter  	byte[] ivCounter = new byte[16];  	Array.Copy (this.iv' ivCounter' 8);  	Array.Copy (this.counter' 0' ivCounter' 8' 8);  	byte[] encryptedIvCounter = Crypto.EncryptAes (ivCounter' this.fileKey);  	for (int inputPos = 0; inputPos < inputLength; inputPos++) {  		output [inputPos] = (byte)(encryptedIvCounter [inputPos] ^ input [inputPos]);  		this.currentChunkMac [inputPos] ^= (this.mode == Mode.Crypt) ? input [inputPos] : output [inputPos];  	}  	// Copy to buffer  	Array.Copy (output' 0' buffer' offset + pos - this.position' Math.Min (output.Length' this.streamLength - pos));  	// Crypt to current chunk mac  	this.currentChunkMac = Crypto.EncryptAes (this.currentChunkMac' this.fileKey);  }  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,Read,The following statement contains a magic number: for (long pos = this.position; pos < Math.Min (this.position + count' this.streamLength); pos += 16) {  	// We are on a chunk bondary  	if (this.chunksPositions.Any (chunk => chunk == pos)) {  		if (pos != 0) {  			// Compute the current chunk mac data on each chunk bondary  			this.ComputeChunk ();  		}  		// Init chunk mac with Iv values  		for (int i = 0; i < 8; i++) {  			this.currentChunkMac [i] = this.iv [i];  			this.currentChunkMac [i + 8] = this.iv [i];  		}  	}  	this.IncrementCounter ();  	// Iterate each AES 16 bytes block  	byte[] input = new byte[16];  	byte[] output = new byte[input.Length];  	int inputLength = this.stream.Read (input' 0' input.Length);  	if (inputLength != input.Length) {  		// Sometimes' the stream is not finished but the read is not complete  		inputLength += this.stream.Read (input' inputLength' input.Length - inputLength);  	}  	// Merge Iv and counter  	byte[] ivCounter = new byte[16];  	Array.Copy (this.iv' ivCounter' 8);  	Array.Copy (this.counter' 0' ivCounter' 8' 8);  	byte[] encryptedIvCounter = Crypto.EncryptAes (ivCounter' this.fileKey);  	for (int inputPos = 0; inputPos < inputLength; inputPos++) {  		output [inputPos] = (byte)(encryptedIvCounter [inputPos] ^ input [inputPos]);  		this.currentChunkMac [inputPos] ^= (this.mode == Mode.Crypt) ? input [inputPos] : output [inputPos];  	}  	// Copy to buffer  	Array.Copy (output' 0' buffer' offset + pos - this.position' Math.Min (output.Length' this.streamLength - pos));  	// Crypt to current chunk mac  	this.currentChunkMac = Crypto.EncryptAes (this.currentChunkMac' this.fileKey);  }  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,Read,The following statement contains a magic number: for (long pos = this.position; pos < Math.Min (this.position + count' this.streamLength); pos += 16) {  	// We are on a chunk bondary  	if (this.chunksPositions.Any (chunk => chunk == pos)) {  		if (pos != 0) {  			// Compute the current chunk mac data on each chunk bondary  			this.ComputeChunk ();  		}  		// Init chunk mac with Iv values  		for (int i = 0; i < 8; i++) {  			this.currentChunkMac [i] = this.iv [i];  			this.currentChunkMac [i + 8] = this.iv [i];  		}  	}  	this.IncrementCounter ();  	// Iterate each AES 16 bytes block  	byte[] input = new byte[16];  	byte[] output = new byte[input.Length];  	int inputLength = this.stream.Read (input' 0' input.Length);  	if (inputLength != input.Length) {  		// Sometimes' the stream is not finished but the read is not complete  		inputLength += this.stream.Read (input' inputLength' input.Length - inputLength);  	}  	// Merge Iv and counter  	byte[] ivCounter = new byte[16];  	Array.Copy (this.iv' ivCounter' 8);  	Array.Copy (this.counter' 0' ivCounter' 8' 8);  	byte[] encryptedIvCounter = Crypto.EncryptAes (ivCounter' this.fileKey);  	for (int inputPos = 0; inputPos < inputLength; inputPos++) {  		output [inputPos] = (byte)(encryptedIvCounter [inputPos] ^ input [inputPos]);  		this.currentChunkMac [inputPos] ^= (this.mode == Mode.Crypt) ? input [inputPos] : output [inputPos];  	}  	// Copy to buffer  	Array.Copy (output' 0' buffer' offset + pos - this.position' Math.Min (output.Length' this.streamLength - pos));  	// Crypt to current chunk mac  	this.currentChunkMac = Crypto.EncryptAes (this.currentChunkMac' this.fileKey);  }  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,Read,The following statement contains a magic number: for (long pos = this.position; pos < Math.Min (this.position + count' this.streamLength); pos += 16) {  	// We are on a chunk bondary  	if (this.chunksPositions.Any (chunk => chunk == pos)) {  		if (pos != 0) {  			// Compute the current chunk mac data on each chunk bondary  			this.ComputeChunk ();  		}  		// Init chunk mac with Iv values  		for (int i = 0; i < 8; i++) {  			this.currentChunkMac [i] = this.iv [i];  			this.currentChunkMac [i + 8] = this.iv [i];  		}  	}  	this.IncrementCounter ();  	// Iterate each AES 16 bytes block  	byte[] input = new byte[16];  	byte[] output = new byte[input.Length];  	int inputLength = this.stream.Read (input' 0' input.Length);  	if (inputLength != input.Length) {  		// Sometimes' the stream is not finished but the read is not complete  		inputLength += this.stream.Read (input' inputLength' input.Length - inputLength);  	}  	// Merge Iv and counter  	byte[] ivCounter = new byte[16];  	Array.Copy (this.iv' ivCounter' 8);  	Array.Copy (this.counter' 0' ivCounter' 8' 8);  	byte[] encryptedIvCounter = Crypto.EncryptAes (ivCounter' this.fileKey);  	for (int inputPos = 0; inputPos < inputLength; inputPos++) {  		output [inputPos] = (byte)(encryptedIvCounter [inputPos] ^ input [inputPos]);  		this.currentChunkMac [inputPos] ^= (this.mode == Mode.Crypt) ? input [inputPos] : output [inputPos];  	}  	// Copy to buffer  	Array.Copy (output' 0' buffer' offset + pos - this.position' Math.Min (output.Length' this.streamLength - pos));  	// Crypt to current chunk mac  	this.currentChunkMac = Crypto.EncryptAes (this.currentChunkMac' this.fileKey);  }  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,Read,The following statement contains a magic number: for (long pos = this.position; pos < Math.Min (this.position + count' this.streamLength); pos += 16) {  	// We are on a chunk bondary  	if (this.chunksPositions.Any (chunk => chunk == pos)) {  		if (pos != 0) {  			// Compute the current chunk mac data on each chunk bondary  			this.ComputeChunk ();  		}  		// Init chunk mac with Iv values  		for (int i = 0; i < 8; i++) {  			this.currentChunkMac [i] = this.iv [i];  			this.currentChunkMac [i + 8] = this.iv [i];  		}  	}  	this.IncrementCounter ();  	// Iterate each AES 16 bytes block  	byte[] input = new byte[16];  	byte[] output = new byte[input.Length];  	int inputLength = this.stream.Read (input' 0' input.Length);  	if (inputLength != input.Length) {  		// Sometimes' the stream is not finished but the read is not complete  		inputLength += this.stream.Read (input' inputLength' input.Length - inputLength);  	}  	// Merge Iv and counter  	byte[] ivCounter = new byte[16];  	Array.Copy (this.iv' ivCounter' 8);  	Array.Copy (this.counter' 0' ivCounter' 8' 8);  	byte[] encryptedIvCounter = Crypto.EncryptAes (ivCounter' this.fileKey);  	for (int inputPos = 0; inputPos < inputLength; inputPos++) {  		output [inputPos] = (byte)(encryptedIvCounter [inputPos] ^ input [inputPos]);  		this.currentChunkMac [inputPos] ^= (this.mode == Mode.Crypt) ? input [inputPos] : output [inputPos];  	}  	// Copy to buffer  	Array.Copy (output' 0' buffer' offset + pos - this.position' Math.Min (output.Length' this.streamLength - pos));  	// Crypt to current chunk mac  	this.currentChunkMac = Crypto.EncryptAes (this.currentChunkMac' this.fileKey);  }  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,Read,The following statement contains a magic number: for (long pos = this.position; pos < Math.Min (this.position + count' this.streamLength); pos += 16) {  	// We are on a chunk bondary  	if (this.chunksPositions.Any (chunk => chunk == pos)) {  		if (pos != 0) {  			// Compute the current chunk mac data on each chunk bondary  			this.ComputeChunk ();  		}  		// Init chunk mac with Iv values  		for (int i = 0; i < 8; i++) {  			this.currentChunkMac [i] = this.iv [i];  			this.currentChunkMac [i + 8] = this.iv [i];  		}  	}  	this.IncrementCounter ();  	// Iterate each AES 16 bytes block  	byte[] input = new byte[16];  	byte[] output = new byte[input.Length];  	int inputLength = this.stream.Read (input' 0' input.Length);  	if (inputLength != input.Length) {  		// Sometimes' the stream is not finished but the read is not complete  		inputLength += this.stream.Read (input' inputLength' input.Length - inputLength);  	}  	// Merge Iv and counter  	byte[] ivCounter = new byte[16];  	Array.Copy (this.iv' ivCounter' 8);  	Array.Copy (this.counter' 0' ivCounter' 8' 8);  	byte[] encryptedIvCounter = Crypto.EncryptAes (ivCounter' this.fileKey);  	for (int inputPos = 0; inputPos < inputLength; inputPos++) {  		output [inputPos] = (byte)(encryptedIvCounter [inputPos] ^ input [inputPos]);  		this.currentChunkMac [inputPos] ^= (this.mode == Mode.Crypt) ? input [inputPos] : output [inputPos];  	}  	// Copy to buffer  	Array.Copy (output' 0' buffer' offset + pos - this.position' Math.Min (output.Length' this.streamLength - pos));  	// Crypt to current chunk mac  	this.currentChunkMac = Crypto.EncryptAes (this.currentChunkMac' this.fileKey);  }  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,Read,The following statement contains a magic number: for (long pos = this.position; pos < Math.Min (this.position + count' this.streamLength); pos += 16) {  	// We are on a chunk bondary  	if (this.chunksPositions.Any (chunk => chunk == pos)) {  		if (pos != 0) {  			// Compute the current chunk mac data on each chunk bondary  			this.ComputeChunk ();  		}  		// Init chunk mac with Iv values  		for (int i = 0; i < 8; i++) {  			this.currentChunkMac [i] = this.iv [i];  			this.currentChunkMac [i + 8] = this.iv [i];  		}  	}  	this.IncrementCounter ();  	// Iterate each AES 16 bytes block  	byte[] input = new byte[16];  	byte[] output = new byte[input.Length];  	int inputLength = this.stream.Read (input' 0' input.Length);  	if (inputLength != input.Length) {  		// Sometimes' the stream is not finished but the read is not complete  		inputLength += this.stream.Read (input' inputLength' input.Length - inputLength);  	}  	// Merge Iv and counter  	byte[] ivCounter = new byte[16];  	Array.Copy (this.iv' ivCounter' 8);  	Array.Copy (this.counter' 0' ivCounter' 8' 8);  	byte[] encryptedIvCounter = Crypto.EncryptAes (ivCounter' this.fileKey);  	for (int inputPos = 0; inputPos < inputLength; inputPos++) {  		output [inputPos] = (byte)(encryptedIvCounter [inputPos] ^ input [inputPos]);  		this.currentChunkMac [inputPos] ^= (this.mode == Mode.Crypt) ? input [inputPos] : output [inputPos];  	}  	// Copy to buffer  	Array.Copy (output' 0' buffer' offset + pos - this.position' Math.Min (output.Length' this.streamLength - pos));  	// Crypt to current chunk mac  	this.currentChunkMac = Crypto.EncryptAes (this.currentChunkMac' this.fileKey);  }  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,Read,The following statement contains a magic number: for (long pos = this.position; pos < Math.Min (this.position + count' this.streamLength); pos += 16) {  	// We are on a chunk bondary  	if (this.chunksPositions.Any (chunk => chunk == pos)) {  		if (pos != 0) {  			// Compute the current chunk mac data on each chunk bondary  			this.ComputeChunk ();  		}  		// Init chunk mac with Iv values  		for (int i = 0; i < 8; i++) {  			this.currentChunkMac [i] = this.iv [i];  			this.currentChunkMac [i + 8] = this.iv [i];  		}  	}  	this.IncrementCounter ();  	// Iterate each AES 16 bytes block  	byte[] input = new byte[16];  	byte[] output = new byte[input.Length];  	int inputLength = this.stream.Read (input' 0' input.Length);  	if (inputLength != input.Length) {  		// Sometimes' the stream is not finished but the read is not complete  		inputLength += this.stream.Read (input' inputLength' input.Length - inputLength);  	}  	// Merge Iv and counter  	byte[] ivCounter = new byte[16];  	Array.Copy (this.iv' ivCounter' 8);  	Array.Copy (this.counter' 0' ivCounter' 8' 8);  	byte[] encryptedIvCounter = Crypto.EncryptAes (ivCounter' this.fileKey);  	for (int inputPos = 0; inputPos < inputLength; inputPos++) {  		output [inputPos] = (byte)(encryptedIvCounter [inputPos] ^ input [inputPos]);  		this.currentChunkMac [inputPos] ^= (this.mode == Mode.Crypt) ? input [inputPos] : output [inputPos];  	}  	// Copy to buffer  	Array.Copy (output' 0' buffer' offset + pos - this.position' Math.Min (output.Length' this.streamLength - pos));  	// Crypt to current chunk mac  	this.currentChunkMac = Crypto.EncryptAes (this.currentChunkMac' this.fileKey);  }  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,Read,The following statement contains a magic number: pos += 16
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,Read,The following statement contains a magic number: if (this.chunksPositions.Any (chunk => chunk == pos)) {  	if (pos != 0) {  		// Compute the current chunk mac data on each chunk bondary  		this.ComputeChunk ();  	}  	// Init chunk mac with Iv values  	for (int i = 0; i < 8; i++) {  		this.currentChunkMac [i] = this.iv [i];  		this.currentChunkMac [i + 8] = this.iv [i];  	}  }  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,Read,The following statement contains a magic number: if (this.chunksPositions.Any (chunk => chunk == pos)) {  	if (pos != 0) {  		// Compute the current chunk mac data on each chunk bondary  		this.ComputeChunk ();  	}  	// Init chunk mac with Iv values  	for (int i = 0; i < 8; i++) {  		this.currentChunkMac [i] = this.iv [i];  		this.currentChunkMac [i + 8] = this.iv [i];  	}  }  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,Read,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	this.currentChunkMac [i] = this.iv [i];  	this.currentChunkMac [i + 8] = this.iv [i];  }  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,Read,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	this.currentChunkMac [i] = this.iv [i];  	this.currentChunkMac [i + 8] = this.iv [i];  }  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,Read,The following statement contains a magic number: this.currentChunkMac [i + 8] = this.iv [i];  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,Read,The following statement contains a magic number: Array.Copy (this.iv' ivCounter' 8);  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,Read,The following statement contains a magic number: Array.Copy (this.counter' 0' ivCounter' 8' 8);  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,Read,The following statement contains a magic number: Array.Copy (this.counter' 0' ivCounter' 8' 8);  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,Read,The following statement contains a magic number: if (this.position == this.streamLength) {  	this.ComputeChunk ();  	// Compute Meta MAC  	for (int i = 0; i < 4; i++) {  		this.metaMac [i] = (byte)(this.fileMac [i] ^ this.fileMac [i + 4]);  		this.metaMac [i + 4] = (byte)(this.fileMac [i + 8] ^ this.fileMac [i + 12]);  	}  	this.OnStreamRead ();  }  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,Read,The following statement contains a magic number: if (this.position == this.streamLength) {  	this.ComputeChunk ();  	// Compute Meta MAC  	for (int i = 0; i < 4; i++) {  		this.metaMac [i] = (byte)(this.fileMac [i] ^ this.fileMac [i + 4]);  		this.metaMac [i + 4] = (byte)(this.fileMac [i + 8] ^ this.fileMac [i + 12]);  	}  	this.OnStreamRead ();  }  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,Read,The following statement contains a magic number: if (this.position == this.streamLength) {  	this.ComputeChunk ();  	// Compute Meta MAC  	for (int i = 0; i < 4; i++) {  		this.metaMac [i] = (byte)(this.fileMac [i] ^ this.fileMac [i + 4]);  		this.metaMac [i + 4] = (byte)(this.fileMac [i + 8] ^ this.fileMac [i + 12]);  	}  	this.OnStreamRead ();  }  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,Read,The following statement contains a magic number: if (this.position == this.streamLength) {  	this.ComputeChunk ();  	// Compute Meta MAC  	for (int i = 0; i < 4; i++) {  		this.metaMac [i] = (byte)(this.fileMac [i] ^ this.fileMac [i + 4]);  		this.metaMac [i + 4] = (byte)(this.fileMac [i + 8] ^ this.fileMac [i + 12]);  	}  	this.OnStreamRead ();  }  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,Read,The following statement contains a magic number: if (this.position == this.streamLength) {  	this.ComputeChunk ();  	// Compute Meta MAC  	for (int i = 0; i < 4; i++) {  		this.metaMac [i] = (byte)(this.fileMac [i] ^ this.fileMac [i + 4]);  		this.metaMac [i + 4] = (byte)(this.fileMac [i + 8] ^ this.fileMac [i + 12]);  	}  	this.OnStreamRead ();  }  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,Read,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	this.metaMac [i] = (byte)(this.fileMac [i] ^ this.fileMac [i + 4]);  	this.metaMac [i + 4] = (byte)(this.fileMac [i + 8] ^ this.fileMac [i + 12]);  }  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,Read,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	this.metaMac [i] = (byte)(this.fileMac [i] ^ this.fileMac [i + 4]);  	this.metaMac [i + 4] = (byte)(this.fileMac [i + 8] ^ this.fileMac [i + 12]);  }  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,Read,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	this.metaMac [i] = (byte)(this.fileMac [i] ^ this.fileMac [i + 4]);  	this.metaMac [i + 4] = (byte)(this.fileMac [i + 8] ^ this.fileMac [i + 12]);  }  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,Read,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	this.metaMac [i] = (byte)(this.fileMac [i] ^ this.fileMac [i + 4]);  	this.metaMac [i + 4] = (byte)(this.fileMac [i + 8] ^ this.fileMac [i + 12]);  }  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,Read,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	this.metaMac [i] = (byte)(this.fileMac [i] ^ this.fileMac [i + 4]);  	this.metaMac [i + 4] = (byte)(this.fileMac [i + 8] ^ this.fileMac [i + 12]);  }  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,Read,The following statement contains a magic number: this.metaMac [i] = (byte)(this.fileMac [i] ^ this.fileMac [i + 4]);  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,Read,The following statement contains a magic number: this.metaMac [i + 4] = (byte)(this.fileMac [i + 8] ^ this.fileMac [i + 12]);  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,Read,The following statement contains a magic number: this.metaMac [i + 4] = (byte)(this.fileMac [i + 8] ^ this.fileMac [i + 12]);  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,Read,The following statement contains a magic number: this.metaMac [i + 4] = (byte)(this.fileMac [i + 8] ^ this.fileMac [i + 12]);  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,IncrementCounter,The following statement contains a magic number: Array.Copy (counter' this.counter' 8);  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,ComputeChunk,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  	this.fileMac [i] ^= this.currentChunkMac [i];  }  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,GetChunksPositions,The following statement contains a magic number: for (int idx = 1; (idx <= 8) && (chunkStartPosition < (size - (idx * 131072))); idx++) {  	chunkStartPosition += idx * 131072;  	chunks.Add (chunkStartPosition);  }  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,GetChunksPositions,The following statement contains a magic number: for (int idx = 1; (idx <= 8) && (chunkStartPosition < (size - (idx * 131072))); idx++) {  	chunkStartPosition += idx * 131072;  	chunks.Add (chunkStartPosition);  }  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,GetChunksPositions,The following statement contains a magic number: for (int idx = 1; (idx <= 8) && (chunkStartPosition < (size - (idx * 131072))); idx++) {  	chunkStartPosition += idx * 131072;  	chunks.Add (chunkStartPosition);  }  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,GetChunksPositions,The following statement contains a magic number: chunkStartPosition += idx * 131072;  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,GetChunksPositions,The following statement contains a magic number: while ((chunkStartPosition + 1048576) < size) {  	chunkStartPosition += 1048576;  	chunks.Add (chunkStartPosition);  }  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,GetChunksPositions,The following statement contains a magic number: while ((chunkStartPosition + 1048576) < size) {  	chunkStartPosition += 1048576;  	chunks.Add (chunkStartPosition);  }  
Magic Number,CG.Web.MegaApiClient,MegaAesCtrStream,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaAesCtrStream.cs,GetChunksPositions,The following statement contains a magic number: chunkStartPosition += 1048576;  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Login,The following statement contains a magic number: this.sessionId = sid.ToBase64 ().Substring (0' 58);  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,LoginAnonymous,The following statement contains a magic number: this.masterKey = new byte[16];  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,LoginAnonymous,The following statement contains a magic number: Array.Copy (sessionChallenge' 0' encryptedSession' 0' 16);  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,LoginAnonymous,The following statement contains a magic number: Array.Copy (encryptedSessionChallenge' 0' encryptedSession' 16' encryptedSessionChallenge.Length);  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The following statement contains a magic number: while (remainingRetry-- > 0) {  	// Retrieve upload URL  	UploadUrlRequest uploadRequest = new UploadUrlRequest (stream.Length);  	UploadUrlResponse uploadResponse = this.Request<UploadUrlResponse> (uploadRequest);  	ApiResultCode apiResult = ApiResultCode.Ok;  	using (MegaAesCtrStreamCrypter encryptedStream = new MegaAesCtrStreamCrypter (stream)) {  		var chunkStartPosition = 0;  		var chunksSizesToUpload = this.ComputeChunksSizesToUpload (encryptedStream.ChunksPositions' encryptedStream.Length).ToArray ();  		Uri uri = null;  		for (int i = 0; i < chunksSizesToUpload.Length; i++) {  			completionHandle = string.Empty;  			int chunkSize = chunksSizesToUpload [i];  			byte[] chunkBuffer = new byte[chunkSize];  			encryptedStream.Read (chunkBuffer' 0' chunkSize);  			using (MemoryStream chunkStream = new MemoryStream (chunkBuffer)) {  				uri = new Uri (uploadResponse.Url + "/" + chunkStartPosition);  				chunkStartPosition += chunkSize;  				try {  					completionHandle = this.webClient.PostRequestRaw (uri' chunkStream);  					if (string.IsNullOrEmpty (completionHandle)) {  						apiResult = ApiResultCode.Ok;  						continue;  					}  					long retCode;  					if (completionHandle.FromBase64 ().Length != 27 && long.TryParse (completionHandle' out retCode)) {  						apiResult = (ApiResultCode)retCode;  						break;  					}  				} catch (Exception ex) {  					apiResult = ApiResultCode.RequestFailedRetry;  					this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' ex));  					break;  				}  			}  		}  		if (apiResult != ApiResultCode.Ok) {  			this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' completionHandle));  			if (apiResult == ApiResultCode.RequestFailedRetry || apiResult == ApiResultCode.RequestFailedPermanetly || apiResult == ApiResultCode.TooManyRequests) {  				// Restart upload from the beginning  				Thread.Sleep (requestDelay = (int)Math.Round (requestDelay * this.options.ApiRequestDelayExponentialFactor));  				// Reset steam position  				stream.Seek (0' SeekOrigin.Begin);  				continue;  			}  			throw new ApiException (apiResult);  		}  		// Encrypt attributes  		byte[] cryptedAttributes = Crypto.EncryptAttributes (new Attributes (name' stream' modificationDate)' encryptedStream.FileKey);  		// Compute the file key  		byte[] fileKey = new byte[32];  		for (int i = 0; i < 8; i++) {  			fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.Iv [i]);  			fileKey [i + 16] = encryptedStream.Iv [i];  		}  		for (int i = 8; i < 16; i++) {  			fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.MetaMac [i - 8]);  			fileKey [i + 16] = encryptedStream.MetaMac [i - 8];  		}  		byte[] encryptedKey = Crypto.EncryptKey (fileKey' this.masterKey);  		CreateNodeRequest createNodeRequest = CreateNodeRequest.CreateFileNodeRequest (parent' cryptedAttributes.ToBase64 ()' encryptedKey.ToBase64 ()' fileKey' completionHandle);  		GetNodesResponse createNodeResponse = this.Request<GetNodesResponse> (createNodeRequest' this.masterKey);  		return createNodeResponse.Nodes [0];  	}  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The following statement contains a magic number: while (remainingRetry-- > 0) {  	// Retrieve upload URL  	UploadUrlRequest uploadRequest = new UploadUrlRequest (stream.Length);  	UploadUrlResponse uploadResponse = this.Request<UploadUrlResponse> (uploadRequest);  	ApiResultCode apiResult = ApiResultCode.Ok;  	using (MegaAesCtrStreamCrypter encryptedStream = new MegaAesCtrStreamCrypter (stream)) {  		var chunkStartPosition = 0;  		var chunksSizesToUpload = this.ComputeChunksSizesToUpload (encryptedStream.ChunksPositions' encryptedStream.Length).ToArray ();  		Uri uri = null;  		for (int i = 0; i < chunksSizesToUpload.Length; i++) {  			completionHandle = string.Empty;  			int chunkSize = chunksSizesToUpload [i];  			byte[] chunkBuffer = new byte[chunkSize];  			encryptedStream.Read (chunkBuffer' 0' chunkSize);  			using (MemoryStream chunkStream = new MemoryStream (chunkBuffer)) {  				uri = new Uri (uploadResponse.Url + "/" + chunkStartPosition);  				chunkStartPosition += chunkSize;  				try {  					completionHandle = this.webClient.PostRequestRaw (uri' chunkStream);  					if (string.IsNullOrEmpty (completionHandle)) {  						apiResult = ApiResultCode.Ok;  						continue;  					}  					long retCode;  					if (completionHandle.FromBase64 ().Length != 27 && long.TryParse (completionHandle' out retCode)) {  						apiResult = (ApiResultCode)retCode;  						break;  					}  				} catch (Exception ex) {  					apiResult = ApiResultCode.RequestFailedRetry;  					this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' ex));  					break;  				}  			}  		}  		if (apiResult != ApiResultCode.Ok) {  			this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' completionHandle));  			if (apiResult == ApiResultCode.RequestFailedRetry || apiResult == ApiResultCode.RequestFailedPermanetly || apiResult == ApiResultCode.TooManyRequests) {  				// Restart upload from the beginning  				Thread.Sleep (requestDelay = (int)Math.Round (requestDelay * this.options.ApiRequestDelayExponentialFactor));  				// Reset steam position  				stream.Seek (0' SeekOrigin.Begin);  				continue;  			}  			throw new ApiException (apiResult);  		}  		// Encrypt attributes  		byte[] cryptedAttributes = Crypto.EncryptAttributes (new Attributes (name' stream' modificationDate)' encryptedStream.FileKey);  		// Compute the file key  		byte[] fileKey = new byte[32];  		for (int i = 0; i < 8; i++) {  			fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.Iv [i]);  			fileKey [i + 16] = encryptedStream.Iv [i];  		}  		for (int i = 8; i < 16; i++) {  			fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.MetaMac [i - 8]);  			fileKey [i + 16] = encryptedStream.MetaMac [i - 8];  		}  		byte[] encryptedKey = Crypto.EncryptKey (fileKey' this.masterKey);  		CreateNodeRequest createNodeRequest = CreateNodeRequest.CreateFileNodeRequest (parent' cryptedAttributes.ToBase64 ()' encryptedKey.ToBase64 ()' fileKey' completionHandle);  		GetNodesResponse createNodeResponse = this.Request<GetNodesResponse> (createNodeRequest' this.masterKey);  		return createNodeResponse.Nodes [0];  	}  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The following statement contains a magic number: while (remainingRetry-- > 0) {  	// Retrieve upload URL  	UploadUrlRequest uploadRequest = new UploadUrlRequest (stream.Length);  	UploadUrlResponse uploadResponse = this.Request<UploadUrlResponse> (uploadRequest);  	ApiResultCode apiResult = ApiResultCode.Ok;  	using (MegaAesCtrStreamCrypter encryptedStream = new MegaAesCtrStreamCrypter (stream)) {  		var chunkStartPosition = 0;  		var chunksSizesToUpload = this.ComputeChunksSizesToUpload (encryptedStream.ChunksPositions' encryptedStream.Length).ToArray ();  		Uri uri = null;  		for (int i = 0; i < chunksSizesToUpload.Length; i++) {  			completionHandle = string.Empty;  			int chunkSize = chunksSizesToUpload [i];  			byte[] chunkBuffer = new byte[chunkSize];  			encryptedStream.Read (chunkBuffer' 0' chunkSize);  			using (MemoryStream chunkStream = new MemoryStream (chunkBuffer)) {  				uri = new Uri (uploadResponse.Url + "/" + chunkStartPosition);  				chunkStartPosition += chunkSize;  				try {  					completionHandle = this.webClient.PostRequestRaw (uri' chunkStream);  					if (string.IsNullOrEmpty (completionHandle)) {  						apiResult = ApiResultCode.Ok;  						continue;  					}  					long retCode;  					if (completionHandle.FromBase64 ().Length != 27 && long.TryParse (completionHandle' out retCode)) {  						apiResult = (ApiResultCode)retCode;  						break;  					}  				} catch (Exception ex) {  					apiResult = ApiResultCode.RequestFailedRetry;  					this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' ex));  					break;  				}  			}  		}  		if (apiResult != ApiResultCode.Ok) {  			this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' completionHandle));  			if (apiResult == ApiResultCode.RequestFailedRetry || apiResult == ApiResultCode.RequestFailedPermanetly || apiResult == ApiResultCode.TooManyRequests) {  				// Restart upload from the beginning  				Thread.Sleep (requestDelay = (int)Math.Round (requestDelay * this.options.ApiRequestDelayExponentialFactor));  				// Reset steam position  				stream.Seek (0' SeekOrigin.Begin);  				continue;  			}  			throw new ApiException (apiResult);  		}  		// Encrypt attributes  		byte[] cryptedAttributes = Crypto.EncryptAttributes (new Attributes (name' stream' modificationDate)' encryptedStream.FileKey);  		// Compute the file key  		byte[] fileKey = new byte[32];  		for (int i = 0; i < 8; i++) {  			fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.Iv [i]);  			fileKey [i + 16] = encryptedStream.Iv [i];  		}  		for (int i = 8; i < 16; i++) {  			fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.MetaMac [i - 8]);  			fileKey [i + 16] = encryptedStream.MetaMac [i - 8];  		}  		byte[] encryptedKey = Crypto.EncryptKey (fileKey' this.masterKey);  		CreateNodeRequest createNodeRequest = CreateNodeRequest.CreateFileNodeRequest (parent' cryptedAttributes.ToBase64 ()' encryptedKey.ToBase64 ()' fileKey' completionHandle);  		GetNodesResponse createNodeResponse = this.Request<GetNodesResponse> (createNodeRequest' this.masterKey);  		return createNodeResponse.Nodes [0];  	}  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The following statement contains a magic number: while (remainingRetry-- > 0) {  	// Retrieve upload URL  	UploadUrlRequest uploadRequest = new UploadUrlRequest (stream.Length);  	UploadUrlResponse uploadResponse = this.Request<UploadUrlResponse> (uploadRequest);  	ApiResultCode apiResult = ApiResultCode.Ok;  	using (MegaAesCtrStreamCrypter encryptedStream = new MegaAesCtrStreamCrypter (stream)) {  		var chunkStartPosition = 0;  		var chunksSizesToUpload = this.ComputeChunksSizesToUpload (encryptedStream.ChunksPositions' encryptedStream.Length).ToArray ();  		Uri uri = null;  		for (int i = 0; i < chunksSizesToUpload.Length; i++) {  			completionHandle = string.Empty;  			int chunkSize = chunksSizesToUpload [i];  			byte[] chunkBuffer = new byte[chunkSize];  			encryptedStream.Read (chunkBuffer' 0' chunkSize);  			using (MemoryStream chunkStream = new MemoryStream (chunkBuffer)) {  				uri = new Uri (uploadResponse.Url + "/" + chunkStartPosition);  				chunkStartPosition += chunkSize;  				try {  					completionHandle = this.webClient.PostRequestRaw (uri' chunkStream);  					if (string.IsNullOrEmpty (completionHandle)) {  						apiResult = ApiResultCode.Ok;  						continue;  					}  					long retCode;  					if (completionHandle.FromBase64 ().Length != 27 && long.TryParse (completionHandle' out retCode)) {  						apiResult = (ApiResultCode)retCode;  						break;  					}  				} catch (Exception ex) {  					apiResult = ApiResultCode.RequestFailedRetry;  					this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' ex));  					break;  				}  			}  		}  		if (apiResult != ApiResultCode.Ok) {  			this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' completionHandle));  			if (apiResult == ApiResultCode.RequestFailedRetry || apiResult == ApiResultCode.RequestFailedPermanetly || apiResult == ApiResultCode.TooManyRequests) {  				// Restart upload from the beginning  				Thread.Sleep (requestDelay = (int)Math.Round (requestDelay * this.options.ApiRequestDelayExponentialFactor));  				// Reset steam position  				stream.Seek (0' SeekOrigin.Begin);  				continue;  			}  			throw new ApiException (apiResult);  		}  		// Encrypt attributes  		byte[] cryptedAttributes = Crypto.EncryptAttributes (new Attributes (name' stream' modificationDate)' encryptedStream.FileKey);  		// Compute the file key  		byte[] fileKey = new byte[32];  		for (int i = 0; i < 8; i++) {  			fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.Iv [i]);  			fileKey [i + 16] = encryptedStream.Iv [i];  		}  		for (int i = 8; i < 16; i++) {  			fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.MetaMac [i - 8]);  			fileKey [i + 16] = encryptedStream.MetaMac [i - 8];  		}  		byte[] encryptedKey = Crypto.EncryptKey (fileKey' this.masterKey);  		CreateNodeRequest createNodeRequest = CreateNodeRequest.CreateFileNodeRequest (parent' cryptedAttributes.ToBase64 ()' encryptedKey.ToBase64 ()' fileKey' completionHandle);  		GetNodesResponse createNodeResponse = this.Request<GetNodesResponse> (createNodeRequest' this.masterKey);  		return createNodeResponse.Nodes [0];  	}  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The following statement contains a magic number: while (remainingRetry-- > 0) {  	// Retrieve upload URL  	UploadUrlRequest uploadRequest = new UploadUrlRequest (stream.Length);  	UploadUrlResponse uploadResponse = this.Request<UploadUrlResponse> (uploadRequest);  	ApiResultCode apiResult = ApiResultCode.Ok;  	using (MegaAesCtrStreamCrypter encryptedStream = new MegaAesCtrStreamCrypter (stream)) {  		var chunkStartPosition = 0;  		var chunksSizesToUpload = this.ComputeChunksSizesToUpload (encryptedStream.ChunksPositions' encryptedStream.Length).ToArray ();  		Uri uri = null;  		for (int i = 0; i < chunksSizesToUpload.Length; i++) {  			completionHandle = string.Empty;  			int chunkSize = chunksSizesToUpload [i];  			byte[] chunkBuffer = new byte[chunkSize];  			encryptedStream.Read (chunkBuffer' 0' chunkSize);  			using (MemoryStream chunkStream = new MemoryStream (chunkBuffer)) {  				uri = new Uri (uploadResponse.Url + "/" + chunkStartPosition);  				chunkStartPosition += chunkSize;  				try {  					completionHandle = this.webClient.PostRequestRaw (uri' chunkStream);  					if (string.IsNullOrEmpty (completionHandle)) {  						apiResult = ApiResultCode.Ok;  						continue;  					}  					long retCode;  					if (completionHandle.FromBase64 ().Length != 27 && long.TryParse (completionHandle' out retCode)) {  						apiResult = (ApiResultCode)retCode;  						break;  					}  				} catch (Exception ex) {  					apiResult = ApiResultCode.RequestFailedRetry;  					this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' ex));  					break;  				}  			}  		}  		if (apiResult != ApiResultCode.Ok) {  			this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' completionHandle));  			if (apiResult == ApiResultCode.RequestFailedRetry || apiResult == ApiResultCode.RequestFailedPermanetly || apiResult == ApiResultCode.TooManyRequests) {  				// Restart upload from the beginning  				Thread.Sleep (requestDelay = (int)Math.Round (requestDelay * this.options.ApiRequestDelayExponentialFactor));  				// Reset steam position  				stream.Seek (0' SeekOrigin.Begin);  				continue;  			}  			throw new ApiException (apiResult);  		}  		// Encrypt attributes  		byte[] cryptedAttributes = Crypto.EncryptAttributes (new Attributes (name' stream' modificationDate)' encryptedStream.FileKey);  		// Compute the file key  		byte[] fileKey = new byte[32];  		for (int i = 0; i < 8; i++) {  			fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.Iv [i]);  			fileKey [i + 16] = encryptedStream.Iv [i];  		}  		for (int i = 8; i < 16; i++) {  			fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.MetaMac [i - 8]);  			fileKey [i + 16] = encryptedStream.MetaMac [i - 8];  		}  		byte[] encryptedKey = Crypto.EncryptKey (fileKey' this.masterKey);  		CreateNodeRequest createNodeRequest = CreateNodeRequest.CreateFileNodeRequest (parent' cryptedAttributes.ToBase64 ()' encryptedKey.ToBase64 ()' fileKey' completionHandle);  		GetNodesResponse createNodeResponse = this.Request<GetNodesResponse> (createNodeRequest' this.masterKey);  		return createNodeResponse.Nodes [0];  	}  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The following statement contains a magic number: while (remainingRetry-- > 0) {  	// Retrieve upload URL  	UploadUrlRequest uploadRequest = new UploadUrlRequest (stream.Length);  	UploadUrlResponse uploadResponse = this.Request<UploadUrlResponse> (uploadRequest);  	ApiResultCode apiResult = ApiResultCode.Ok;  	using (MegaAesCtrStreamCrypter encryptedStream = new MegaAesCtrStreamCrypter (stream)) {  		var chunkStartPosition = 0;  		var chunksSizesToUpload = this.ComputeChunksSizesToUpload (encryptedStream.ChunksPositions' encryptedStream.Length).ToArray ();  		Uri uri = null;  		for (int i = 0; i < chunksSizesToUpload.Length; i++) {  			completionHandle = string.Empty;  			int chunkSize = chunksSizesToUpload [i];  			byte[] chunkBuffer = new byte[chunkSize];  			encryptedStream.Read (chunkBuffer' 0' chunkSize);  			using (MemoryStream chunkStream = new MemoryStream (chunkBuffer)) {  				uri = new Uri (uploadResponse.Url + "/" + chunkStartPosition);  				chunkStartPosition += chunkSize;  				try {  					completionHandle = this.webClient.PostRequestRaw (uri' chunkStream);  					if (string.IsNullOrEmpty (completionHandle)) {  						apiResult = ApiResultCode.Ok;  						continue;  					}  					long retCode;  					if (completionHandle.FromBase64 ().Length != 27 && long.TryParse (completionHandle' out retCode)) {  						apiResult = (ApiResultCode)retCode;  						break;  					}  				} catch (Exception ex) {  					apiResult = ApiResultCode.RequestFailedRetry;  					this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' ex));  					break;  				}  			}  		}  		if (apiResult != ApiResultCode.Ok) {  			this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' completionHandle));  			if (apiResult == ApiResultCode.RequestFailedRetry || apiResult == ApiResultCode.RequestFailedPermanetly || apiResult == ApiResultCode.TooManyRequests) {  				// Restart upload from the beginning  				Thread.Sleep (requestDelay = (int)Math.Round (requestDelay * this.options.ApiRequestDelayExponentialFactor));  				// Reset steam position  				stream.Seek (0' SeekOrigin.Begin);  				continue;  			}  			throw new ApiException (apiResult);  		}  		// Encrypt attributes  		byte[] cryptedAttributes = Crypto.EncryptAttributes (new Attributes (name' stream' modificationDate)' encryptedStream.FileKey);  		// Compute the file key  		byte[] fileKey = new byte[32];  		for (int i = 0; i < 8; i++) {  			fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.Iv [i]);  			fileKey [i + 16] = encryptedStream.Iv [i];  		}  		for (int i = 8; i < 16; i++) {  			fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.MetaMac [i - 8]);  			fileKey [i + 16] = encryptedStream.MetaMac [i - 8];  		}  		byte[] encryptedKey = Crypto.EncryptKey (fileKey' this.masterKey);  		CreateNodeRequest createNodeRequest = CreateNodeRequest.CreateFileNodeRequest (parent' cryptedAttributes.ToBase64 ()' encryptedKey.ToBase64 ()' fileKey' completionHandle);  		GetNodesResponse createNodeResponse = this.Request<GetNodesResponse> (createNodeRequest' this.masterKey);  		return createNodeResponse.Nodes [0];  	}  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The following statement contains a magic number: while (remainingRetry-- > 0) {  	// Retrieve upload URL  	UploadUrlRequest uploadRequest = new UploadUrlRequest (stream.Length);  	UploadUrlResponse uploadResponse = this.Request<UploadUrlResponse> (uploadRequest);  	ApiResultCode apiResult = ApiResultCode.Ok;  	using (MegaAesCtrStreamCrypter encryptedStream = new MegaAesCtrStreamCrypter (stream)) {  		var chunkStartPosition = 0;  		var chunksSizesToUpload = this.ComputeChunksSizesToUpload (encryptedStream.ChunksPositions' encryptedStream.Length).ToArray ();  		Uri uri = null;  		for (int i = 0; i < chunksSizesToUpload.Length; i++) {  			completionHandle = string.Empty;  			int chunkSize = chunksSizesToUpload [i];  			byte[] chunkBuffer = new byte[chunkSize];  			encryptedStream.Read (chunkBuffer' 0' chunkSize);  			using (MemoryStream chunkStream = new MemoryStream (chunkBuffer)) {  				uri = new Uri (uploadResponse.Url + "/" + chunkStartPosition);  				chunkStartPosition += chunkSize;  				try {  					completionHandle = this.webClient.PostRequestRaw (uri' chunkStream);  					if (string.IsNullOrEmpty (completionHandle)) {  						apiResult = ApiResultCode.Ok;  						continue;  					}  					long retCode;  					if (completionHandle.FromBase64 ().Length != 27 && long.TryParse (completionHandle' out retCode)) {  						apiResult = (ApiResultCode)retCode;  						break;  					}  				} catch (Exception ex) {  					apiResult = ApiResultCode.RequestFailedRetry;  					this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' ex));  					break;  				}  			}  		}  		if (apiResult != ApiResultCode.Ok) {  			this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' completionHandle));  			if (apiResult == ApiResultCode.RequestFailedRetry || apiResult == ApiResultCode.RequestFailedPermanetly || apiResult == ApiResultCode.TooManyRequests) {  				// Restart upload from the beginning  				Thread.Sleep (requestDelay = (int)Math.Round (requestDelay * this.options.ApiRequestDelayExponentialFactor));  				// Reset steam position  				stream.Seek (0' SeekOrigin.Begin);  				continue;  			}  			throw new ApiException (apiResult);  		}  		// Encrypt attributes  		byte[] cryptedAttributes = Crypto.EncryptAttributes (new Attributes (name' stream' modificationDate)' encryptedStream.FileKey);  		// Compute the file key  		byte[] fileKey = new byte[32];  		for (int i = 0; i < 8; i++) {  			fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.Iv [i]);  			fileKey [i + 16] = encryptedStream.Iv [i];  		}  		for (int i = 8; i < 16; i++) {  			fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.MetaMac [i - 8]);  			fileKey [i + 16] = encryptedStream.MetaMac [i - 8];  		}  		byte[] encryptedKey = Crypto.EncryptKey (fileKey' this.masterKey);  		CreateNodeRequest createNodeRequest = CreateNodeRequest.CreateFileNodeRequest (parent' cryptedAttributes.ToBase64 ()' encryptedKey.ToBase64 ()' fileKey' completionHandle);  		GetNodesResponse createNodeResponse = this.Request<GetNodesResponse> (createNodeRequest' this.masterKey);  		return createNodeResponse.Nodes [0];  	}  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The following statement contains a magic number: while (remainingRetry-- > 0) {  	// Retrieve upload URL  	UploadUrlRequest uploadRequest = new UploadUrlRequest (stream.Length);  	UploadUrlResponse uploadResponse = this.Request<UploadUrlResponse> (uploadRequest);  	ApiResultCode apiResult = ApiResultCode.Ok;  	using (MegaAesCtrStreamCrypter encryptedStream = new MegaAesCtrStreamCrypter (stream)) {  		var chunkStartPosition = 0;  		var chunksSizesToUpload = this.ComputeChunksSizesToUpload (encryptedStream.ChunksPositions' encryptedStream.Length).ToArray ();  		Uri uri = null;  		for (int i = 0; i < chunksSizesToUpload.Length; i++) {  			completionHandle = string.Empty;  			int chunkSize = chunksSizesToUpload [i];  			byte[] chunkBuffer = new byte[chunkSize];  			encryptedStream.Read (chunkBuffer' 0' chunkSize);  			using (MemoryStream chunkStream = new MemoryStream (chunkBuffer)) {  				uri = new Uri (uploadResponse.Url + "/" + chunkStartPosition);  				chunkStartPosition += chunkSize;  				try {  					completionHandle = this.webClient.PostRequestRaw (uri' chunkStream);  					if (string.IsNullOrEmpty (completionHandle)) {  						apiResult = ApiResultCode.Ok;  						continue;  					}  					long retCode;  					if (completionHandle.FromBase64 ().Length != 27 && long.TryParse (completionHandle' out retCode)) {  						apiResult = (ApiResultCode)retCode;  						break;  					}  				} catch (Exception ex) {  					apiResult = ApiResultCode.RequestFailedRetry;  					this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' ex));  					break;  				}  			}  		}  		if (apiResult != ApiResultCode.Ok) {  			this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' completionHandle));  			if (apiResult == ApiResultCode.RequestFailedRetry || apiResult == ApiResultCode.RequestFailedPermanetly || apiResult == ApiResultCode.TooManyRequests) {  				// Restart upload from the beginning  				Thread.Sleep (requestDelay = (int)Math.Round (requestDelay * this.options.ApiRequestDelayExponentialFactor));  				// Reset steam position  				stream.Seek (0' SeekOrigin.Begin);  				continue;  			}  			throw new ApiException (apiResult);  		}  		// Encrypt attributes  		byte[] cryptedAttributes = Crypto.EncryptAttributes (new Attributes (name' stream' modificationDate)' encryptedStream.FileKey);  		// Compute the file key  		byte[] fileKey = new byte[32];  		for (int i = 0; i < 8; i++) {  			fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.Iv [i]);  			fileKey [i + 16] = encryptedStream.Iv [i];  		}  		for (int i = 8; i < 16; i++) {  			fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.MetaMac [i - 8]);  			fileKey [i + 16] = encryptedStream.MetaMac [i - 8];  		}  		byte[] encryptedKey = Crypto.EncryptKey (fileKey' this.masterKey);  		CreateNodeRequest createNodeRequest = CreateNodeRequest.CreateFileNodeRequest (parent' cryptedAttributes.ToBase64 ()' encryptedKey.ToBase64 ()' fileKey' completionHandle);  		GetNodesResponse createNodeResponse = this.Request<GetNodesResponse> (createNodeRequest' this.masterKey);  		return createNodeResponse.Nodes [0];  	}  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The following statement contains a magic number: while (remainingRetry-- > 0) {  	// Retrieve upload URL  	UploadUrlRequest uploadRequest = new UploadUrlRequest (stream.Length);  	UploadUrlResponse uploadResponse = this.Request<UploadUrlResponse> (uploadRequest);  	ApiResultCode apiResult = ApiResultCode.Ok;  	using (MegaAesCtrStreamCrypter encryptedStream = new MegaAesCtrStreamCrypter (stream)) {  		var chunkStartPosition = 0;  		var chunksSizesToUpload = this.ComputeChunksSizesToUpload (encryptedStream.ChunksPositions' encryptedStream.Length).ToArray ();  		Uri uri = null;  		for (int i = 0; i < chunksSizesToUpload.Length; i++) {  			completionHandle = string.Empty;  			int chunkSize = chunksSizesToUpload [i];  			byte[] chunkBuffer = new byte[chunkSize];  			encryptedStream.Read (chunkBuffer' 0' chunkSize);  			using (MemoryStream chunkStream = new MemoryStream (chunkBuffer)) {  				uri = new Uri (uploadResponse.Url + "/" + chunkStartPosition);  				chunkStartPosition += chunkSize;  				try {  					completionHandle = this.webClient.PostRequestRaw (uri' chunkStream);  					if (string.IsNullOrEmpty (completionHandle)) {  						apiResult = ApiResultCode.Ok;  						continue;  					}  					long retCode;  					if (completionHandle.FromBase64 ().Length != 27 && long.TryParse (completionHandle' out retCode)) {  						apiResult = (ApiResultCode)retCode;  						break;  					}  				} catch (Exception ex) {  					apiResult = ApiResultCode.RequestFailedRetry;  					this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' ex));  					break;  				}  			}  		}  		if (apiResult != ApiResultCode.Ok) {  			this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' completionHandle));  			if (apiResult == ApiResultCode.RequestFailedRetry || apiResult == ApiResultCode.RequestFailedPermanetly || apiResult == ApiResultCode.TooManyRequests) {  				// Restart upload from the beginning  				Thread.Sleep (requestDelay = (int)Math.Round (requestDelay * this.options.ApiRequestDelayExponentialFactor));  				// Reset steam position  				stream.Seek (0' SeekOrigin.Begin);  				continue;  			}  			throw new ApiException (apiResult);  		}  		// Encrypt attributes  		byte[] cryptedAttributes = Crypto.EncryptAttributes (new Attributes (name' stream' modificationDate)' encryptedStream.FileKey);  		// Compute the file key  		byte[] fileKey = new byte[32];  		for (int i = 0; i < 8; i++) {  			fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.Iv [i]);  			fileKey [i + 16] = encryptedStream.Iv [i];  		}  		for (int i = 8; i < 16; i++) {  			fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.MetaMac [i - 8]);  			fileKey [i + 16] = encryptedStream.MetaMac [i - 8];  		}  		byte[] encryptedKey = Crypto.EncryptKey (fileKey' this.masterKey);  		CreateNodeRequest createNodeRequest = CreateNodeRequest.CreateFileNodeRequest (parent' cryptedAttributes.ToBase64 ()' encryptedKey.ToBase64 ()' fileKey' completionHandle);  		GetNodesResponse createNodeResponse = this.Request<GetNodesResponse> (createNodeRequest' this.masterKey);  		return createNodeResponse.Nodes [0];  	}  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The following statement contains a magic number: using (MegaAesCtrStreamCrypter encryptedStream = new MegaAesCtrStreamCrypter (stream)) {  	var chunkStartPosition = 0;  	var chunksSizesToUpload = this.ComputeChunksSizesToUpload (encryptedStream.ChunksPositions' encryptedStream.Length).ToArray ();  	Uri uri = null;  	for (int i = 0; i < chunksSizesToUpload.Length; i++) {  		completionHandle = string.Empty;  		int chunkSize = chunksSizesToUpload [i];  		byte[] chunkBuffer = new byte[chunkSize];  		encryptedStream.Read (chunkBuffer' 0' chunkSize);  		using (MemoryStream chunkStream = new MemoryStream (chunkBuffer)) {  			uri = new Uri (uploadResponse.Url + "/" + chunkStartPosition);  			chunkStartPosition += chunkSize;  			try {  				completionHandle = this.webClient.PostRequestRaw (uri' chunkStream);  				if (string.IsNullOrEmpty (completionHandle)) {  					apiResult = ApiResultCode.Ok;  					continue;  				}  				long retCode;  				if (completionHandle.FromBase64 ().Length != 27 && long.TryParse (completionHandle' out retCode)) {  					apiResult = (ApiResultCode)retCode;  					break;  				}  			} catch (Exception ex) {  				apiResult = ApiResultCode.RequestFailedRetry;  				this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' ex));  				break;  			}  		}  	}  	if (apiResult != ApiResultCode.Ok) {  		this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' completionHandle));  		if (apiResult == ApiResultCode.RequestFailedRetry || apiResult == ApiResultCode.RequestFailedPermanetly || apiResult == ApiResultCode.TooManyRequests) {  			// Restart upload from the beginning  			Thread.Sleep (requestDelay = (int)Math.Round (requestDelay * this.options.ApiRequestDelayExponentialFactor));  			// Reset steam position  			stream.Seek (0' SeekOrigin.Begin);  			continue;  		}  		throw new ApiException (apiResult);  	}  	// Encrypt attributes  	byte[] cryptedAttributes = Crypto.EncryptAttributes (new Attributes (name' stream' modificationDate)' encryptedStream.FileKey);  	// Compute the file key  	byte[] fileKey = new byte[32];  	for (int i = 0; i < 8; i++) {  		fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.Iv [i]);  		fileKey [i + 16] = encryptedStream.Iv [i];  	}  	for (int i = 8; i < 16; i++) {  		fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.MetaMac [i - 8]);  		fileKey [i + 16] = encryptedStream.MetaMac [i - 8];  	}  	byte[] encryptedKey = Crypto.EncryptKey (fileKey' this.masterKey);  	CreateNodeRequest createNodeRequest = CreateNodeRequest.CreateFileNodeRequest (parent' cryptedAttributes.ToBase64 ()' encryptedKey.ToBase64 ()' fileKey' completionHandle);  	GetNodesResponse createNodeResponse = this.Request<GetNodesResponse> (createNodeRequest' this.masterKey);  	return createNodeResponse.Nodes [0];  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The following statement contains a magic number: using (MegaAesCtrStreamCrypter encryptedStream = new MegaAesCtrStreamCrypter (stream)) {  	var chunkStartPosition = 0;  	var chunksSizesToUpload = this.ComputeChunksSizesToUpload (encryptedStream.ChunksPositions' encryptedStream.Length).ToArray ();  	Uri uri = null;  	for (int i = 0; i < chunksSizesToUpload.Length; i++) {  		completionHandle = string.Empty;  		int chunkSize = chunksSizesToUpload [i];  		byte[] chunkBuffer = new byte[chunkSize];  		encryptedStream.Read (chunkBuffer' 0' chunkSize);  		using (MemoryStream chunkStream = new MemoryStream (chunkBuffer)) {  			uri = new Uri (uploadResponse.Url + "/" + chunkStartPosition);  			chunkStartPosition += chunkSize;  			try {  				completionHandle = this.webClient.PostRequestRaw (uri' chunkStream);  				if (string.IsNullOrEmpty (completionHandle)) {  					apiResult = ApiResultCode.Ok;  					continue;  				}  				long retCode;  				if (completionHandle.FromBase64 ().Length != 27 && long.TryParse (completionHandle' out retCode)) {  					apiResult = (ApiResultCode)retCode;  					break;  				}  			} catch (Exception ex) {  				apiResult = ApiResultCode.RequestFailedRetry;  				this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' ex));  				break;  			}  		}  	}  	if (apiResult != ApiResultCode.Ok) {  		this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' completionHandle));  		if (apiResult == ApiResultCode.RequestFailedRetry || apiResult == ApiResultCode.RequestFailedPermanetly || apiResult == ApiResultCode.TooManyRequests) {  			// Restart upload from the beginning  			Thread.Sleep (requestDelay = (int)Math.Round (requestDelay * this.options.ApiRequestDelayExponentialFactor));  			// Reset steam position  			stream.Seek (0' SeekOrigin.Begin);  			continue;  		}  		throw new ApiException (apiResult);  	}  	// Encrypt attributes  	byte[] cryptedAttributes = Crypto.EncryptAttributes (new Attributes (name' stream' modificationDate)' encryptedStream.FileKey);  	// Compute the file key  	byte[] fileKey = new byte[32];  	for (int i = 0; i < 8; i++) {  		fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.Iv [i]);  		fileKey [i + 16] = encryptedStream.Iv [i];  	}  	for (int i = 8; i < 16; i++) {  		fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.MetaMac [i - 8]);  		fileKey [i + 16] = encryptedStream.MetaMac [i - 8];  	}  	byte[] encryptedKey = Crypto.EncryptKey (fileKey' this.masterKey);  	CreateNodeRequest createNodeRequest = CreateNodeRequest.CreateFileNodeRequest (parent' cryptedAttributes.ToBase64 ()' encryptedKey.ToBase64 ()' fileKey' completionHandle);  	GetNodesResponse createNodeResponse = this.Request<GetNodesResponse> (createNodeRequest' this.masterKey);  	return createNodeResponse.Nodes [0];  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The following statement contains a magic number: using (MegaAesCtrStreamCrypter encryptedStream = new MegaAesCtrStreamCrypter (stream)) {  	var chunkStartPosition = 0;  	var chunksSizesToUpload = this.ComputeChunksSizesToUpload (encryptedStream.ChunksPositions' encryptedStream.Length).ToArray ();  	Uri uri = null;  	for (int i = 0; i < chunksSizesToUpload.Length; i++) {  		completionHandle = string.Empty;  		int chunkSize = chunksSizesToUpload [i];  		byte[] chunkBuffer = new byte[chunkSize];  		encryptedStream.Read (chunkBuffer' 0' chunkSize);  		using (MemoryStream chunkStream = new MemoryStream (chunkBuffer)) {  			uri = new Uri (uploadResponse.Url + "/" + chunkStartPosition);  			chunkStartPosition += chunkSize;  			try {  				completionHandle = this.webClient.PostRequestRaw (uri' chunkStream);  				if (string.IsNullOrEmpty (completionHandle)) {  					apiResult = ApiResultCode.Ok;  					continue;  				}  				long retCode;  				if (completionHandle.FromBase64 ().Length != 27 && long.TryParse (completionHandle' out retCode)) {  					apiResult = (ApiResultCode)retCode;  					break;  				}  			} catch (Exception ex) {  				apiResult = ApiResultCode.RequestFailedRetry;  				this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' ex));  				break;  			}  		}  	}  	if (apiResult != ApiResultCode.Ok) {  		this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' completionHandle));  		if (apiResult == ApiResultCode.RequestFailedRetry || apiResult == ApiResultCode.RequestFailedPermanetly || apiResult == ApiResultCode.TooManyRequests) {  			// Restart upload from the beginning  			Thread.Sleep (requestDelay = (int)Math.Round (requestDelay * this.options.ApiRequestDelayExponentialFactor));  			// Reset steam position  			stream.Seek (0' SeekOrigin.Begin);  			continue;  		}  		throw new ApiException (apiResult);  	}  	// Encrypt attributes  	byte[] cryptedAttributes = Crypto.EncryptAttributes (new Attributes (name' stream' modificationDate)' encryptedStream.FileKey);  	// Compute the file key  	byte[] fileKey = new byte[32];  	for (int i = 0; i < 8; i++) {  		fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.Iv [i]);  		fileKey [i + 16] = encryptedStream.Iv [i];  	}  	for (int i = 8; i < 16; i++) {  		fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.MetaMac [i - 8]);  		fileKey [i + 16] = encryptedStream.MetaMac [i - 8];  	}  	byte[] encryptedKey = Crypto.EncryptKey (fileKey' this.masterKey);  	CreateNodeRequest createNodeRequest = CreateNodeRequest.CreateFileNodeRequest (parent' cryptedAttributes.ToBase64 ()' encryptedKey.ToBase64 ()' fileKey' completionHandle);  	GetNodesResponse createNodeResponse = this.Request<GetNodesResponse> (createNodeRequest' this.masterKey);  	return createNodeResponse.Nodes [0];  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The following statement contains a magic number: using (MegaAesCtrStreamCrypter encryptedStream = new MegaAesCtrStreamCrypter (stream)) {  	var chunkStartPosition = 0;  	var chunksSizesToUpload = this.ComputeChunksSizesToUpload (encryptedStream.ChunksPositions' encryptedStream.Length).ToArray ();  	Uri uri = null;  	for (int i = 0; i < chunksSizesToUpload.Length; i++) {  		completionHandle = string.Empty;  		int chunkSize = chunksSizesToUpload [i];  		byte[] chunkBuffer = new byte[chunkSize];  		encryptedStream.Read (chunkBuffer' 0' chunkSize);  		using (MemoryStream chunkStream = new MemoryStream (chunkBuffer)) {  			uri = new Uri (uploadResponse.Url + "/" + chunkStartPosition);  			chunkStartPosition += chunkSize;  			try {  				completionHandle = this.webClient.PostRequestRaw (uri' chunkStream);  				if (string.IsNullOrEmpty (completionHandle)) {  					apiResult = ApiResultCode.Ok;  					continue;  				}  				long retCode;  				if (completionHandle.FromBase64 ().Length != 27 && long.TryParse (completionHandle' out retCode)) {  					apiResult = (ApiResultCode)retCode;  					break;  				}  			} catch (Exception ex) {  				apiResult = ApiResultCode.RequestFailedRetry;  				this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' ex));  				break;  			}  		}  	}  	if (apiResult != ApiResultCode.Ok) {  		this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' completionHandle));  		if (apiResult == ApiResultCode.RequestFailedRetry || apiResult == ApiResultCode.RequestFailedPermanetly || apiResult == ApiResultCode.TooManyRequests) {  			// Restart upload from the beginning  			Thread.Sleep (requestDelay = (int)Math.Round (requestDelay * this.options.ApiRequestDelayExponentialFactor));  			// Reset steam position  			stream.Seek (0' SeekOrigin.Begin);  			continue;  		}  		throw new ApiException (apiResult);  	}  	// Encrypt attributes  	byte[] cryptedAttributes = Crypto.EncryptAttributes (new Attributes (name' stream' modificationDate)' encryptedStream.FileKey);  	// Compute the file key  	byte[] fileKey = new byte[32];  	for (int i = 0; i < 8; i++) {  		fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.Iv [i]);  		fileKey [i + 16] = encryptedStream.Iv [i];  	}  	for (int i = 8; i < 16; i++) {  		fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.MetaMac [i - 8]);  		fileKey [i + 16] = encryptedStream.MetaMac [i - 8];  	}  	byte[] encryptedKey = Crypto.EncryptKey (fileKey' this.masterKey);  	CreateNodeRequest createNodeRequest = CreateNodeRequest.CreateFileNodeRequest (parent' cryptedAttributes.ToBase64 ()' encryptedKey.ToBase64 ()' fileKey' completionHandle);  	GetNodesResponse createNodeResponse = this.Request<GetNodesResponse> (createNodeRequest' this.masterKey);  	return createNodeResponse.Nodes [0];  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The following statement contains a magic number: using (MegaAesCtrStreamCrypter encryptedStream = new MegaAesCtrStreamCrypter (stream)) {  	var chunkStartPosition = 0;  	var chunksSizesToUpload = this.ComputeChunksSizesToUpload (encryptedStream.ChunksPositions' encryptedStream.Length).ToArray ();  	Uri uri = null;  	for (int i = 0; i < chunksSizesToUpload.Length; i++) {  		completionHandle = string.Empty;  		int chunkSize = chunksSizesToUpload [i];  		byte[] chunkBuffer = new byte[chunkSize];  		encryptedStream.Read (chunkBuffer' 0' chunkSize);  		using (MemoryStream chunkStream = new MemoryStream (chunkBuffer)) {  			uri = new Uri (uploadResponse.Url + "/" + chunkStartPosition);  			chunkStartPosition += chunkSize;  			try {  				completionHandle = this.webClient.PostRequestRaw (uri' chunkStream);  				if (string.IsNullOrEmpty (completionHandle)) {  					apiResult = ApiResultCode.Ok;  					continue;  				}  				long retCode;  				if (completionHandle.FromBase64 ().Length != 27 && long.TryParse (completionHandle' out retCode)) {  					apiResult = (ApiResultCode)retCode;  					break;  				}  			} catch (Exception ex) {  				apiResult = ApiResultCode.RequestFailedRetry;  				this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' ex));  				break;  			}  		}  	}  	if (apiResult != ApiResultCode.Ok) {  		this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' completionHandle));  		if (apiResult == ApiResultCode.RequestFailedRetry || apiResult == ApiResultCode.RequestFailedPermanetly || apiResult == ApiResultCode.TooManyRequests) {  			// Restart upload from the beginning  			Thread.Sleep (requestDelay = (int)Math.Round (requestDelay * this.options.ApiRequestDelayExponentialFactor));  			// Reset steam position  			stream.Seek (0' SeekOrigin.Begin);  			continue;  		}  		throw new ApiException (apiResult);  	}  	// Encrypt attributes  	byte[] cryptedAttributes = Crypto.EncryptAttributes (new Attributes (name' stream' modificationDate)' encryptedStream.FileKey);  	// Compute the file key  	byte[] fileKey = new byte[32];  	for (int i = 0; i < 8; i++) {  		fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.Iv [i]);  		fileKey [i + 16] = encryptedStream.Iv [i];  	}  	for (int i = 8; i < 16; i++) {  		fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.MetaMac [i - 8]);  		fileKey [i + 16] = encryptedStream.MetaMac [i - 8];  	}  	byte[] encryptedKey = Crypto.EncryptKey (fileKey' this.masterKey);  	CreateNodeRequest createNodeRequest = CreateNodeRequest.CreateFileNodeRequest (parent' cryptedAttributes.ToBase64 ()' encryptedKey.ToBase64 ()' fileKey' completionHandle);  	GetNodesResponse createNodeResponse = this.Request<GetNodesResponse> (createNodeRequest' this.masterKey);  	return createNodeResponse.Nodes [0];  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The following statement contains a magic number: using (MegaAesCtrStreamCrypter encryptedStream = new MegaAesCtrStreamCrypter (stream)) {  	var chunkStartPosition = 0;  	var chunksSizesToUpload = this.ComputeChunksSizesToUpload (encryptedStream.ChunksPositions' encryptedStream.Length).ToArray ();  	Uri uri = null;  	for (int i = 0; i < chunksSizesToUpload.Length; i++) {  		completionHandle = string.Empty;  		int chunkSize = chunksSizesToUpload [i];  		byte[] chunkBuffer = new byte[chunkSize];  		encryptedStream.Read (chunkBuffer' 0' chunkSize);  		using (MemoryStream chunkStream = new MemoryStream (chunkBuffer)) {  			uri = new Uri (uploadResponse.Url + "/" + chunkStartPosition);  			chunkStartPosition += chunkSize;  			try {  				completionHandle = this.webClient.PostRequestRaw (uri' chunkStream);  				if (string.IsNullOrEmpty (completionHandle)) {  					apiResult = ApiResultCode.Ok;  					continue;  				}  				long retCode;  				if (completionHandle.FromBase64 ().Length != 27 && long.TryParse (completionHandle' out retCode)) {  					apiResult = (ApiResultCode)retCode;  					break;  				}  			} catch (Exception ex) {  				apiResult = ApiResultCode.RequestFailedRetry;  				this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' ex));  				break;  			}  		}  	}  	if (apiResult != ApiResultCode.Ok) {  		this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' completionHandle));  		if (apiResult == ApiResultCode.RequestFailedRetry || apiResult == ApiResultCode.RequestFailedPermanetly || apiResult == ApiResultCode.TooManyRequests) {  			// Restart upload from the beginning  			Thread.Sleep (requestDelay = (int)Math.Round (requestDelay * this.options.ApiRequestDelayExponentialFactor));  			// Reset steam position  			stream.Seek (0' SeekOrigin.Begin);  			continue;  		}  		throw new ApiException (apiResult);  	}  	// Encrypt attributes  	byte[] cryptedAttributes = Crypto.EncryptAttributes (new Attributes (name' stream' modificationDate)' encryptedStream.FileKey);  	// Compute the file key  	byte[] fileKey = new byte[32];  	for (int i = 0; i < 8; i++) {  		fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.Iv [i]);  		fileKey [i + 16] = encryptedStream.Iv [i];  	}  	for (int i = 8; i < 16; i++) {  		fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.MetaMac [i - 8]);  		fileKey [i + 16] = encryptedStream.MetaMac [i - 8];  	}  	byte[] encryptedKey = Crypto.EncryptKey (fileKey' this.masterKey);  	CreateNodeRequest createNodeRequest = CreateNodeRequest.CreateFileNodeRequest (parent' cryptedAttributes.ToBase64 ()' encryptedKey.ToBase64 ()' fileKey' completionHandle);  	GetNodesResponse createNodeResponse = this.Request<GetNodesResponse> (createNodeRequest' this.masterKey);  	return createNodeResponse.Nodes [0];  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The following statement contains a magic number: using (MegaAesCtrStreamCrypter encryptedStream = new MegaAesCtrStreamCrypter (stream)) {  	var chunkStartPosition = 0;  	var chunksSizesToUpload = this.ComputeChunksSizesToUpload (encryptedStream.ChunksPositions' encryptedStream.Length).ToArray ();  	Uri uri = null;  	for (int i = 0; i < chunksSizesToUpload.Length; i++) {  		completionHandle = string.Empty;  		int chunkSize = chunksSizesToUpload [i];  		byte[] chunkBuffer = new byte[chunkSize];  		encryptedStream.Read (chunkBuffer' 0' chunkSize);  		using (MemoryStream chunkStream = new MemoryStream (chunkBuffer)) {  			uri = new Uri (uploadResponse.Url + "/" + chunkStartPosition);  			chunkStartPosition += chunkSize;  			try {  				completionHandle = this.webClient.PostRequestRaw (uri' chunkStream);  				if (string.IsNullOrEmpty (completionHandle)) {  					apiResult = ApiResultCode.Ok;  					continue;  				}  				long retCode;  				if (completionHandle.FromBase64 ().Length != 27 && long.TryParse (completionHandle' out retCode)) {  					apiResult = (ApiResultCode)retCode;  					break;  				}  			} catch (Exception ex) {  				apiResult = ApiResultCode.RequestFailedRetry;  				this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' ex));  				break;  			}  		}  	}  	if (apiResult != ApiResultCode.Ok) {  		this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' completionHandle));  		if (apiResult == ApiResultCode.RequestFailedRetry || apiResult == ApiResultCode.RequestFailedPermanetly || apiResult == ApiResultCode.TooManyRequests) {  			// Restart upload from the beginning  			Thread.Sleep (requestDelay = (int)Math.Round (requestDelay * this.options.ApiRequestDelayExponentialFactor));  			// Reset steam position  			stream.Seek (0' SeekOrigin.Begin);  			continue;  		}  		throw new ApiException (apiResult);  	}  	// Encrypt attributes  	byte[] cryptedAttributes = Crypto.EncryptAttributes (new Attributes (name' stream' modificationDate)' encryptedStream.FileKey);  	// Compute the file key  	byte[] fileKey = new byte[32];  	for (int i = 0; i < 8; i++) {  		fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.Iv [i]);  		fileKey [i + 16] = encryptedStream.Iv [i];  	}  	for (int i = 8; i < 16; i++) {  		fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.MetaMac [i - 8]);  		fileKey [i + 16] = encryptedStream.MetaMac [i - 8];  	}  	byte[] encryptedKey = Crypto.EncryptKey (fileKey' this.masterKey);  	CreateNodeRequest createNodeRequest = CreateNodeRequest.CreateFileNodeRequest (parent' cryptedAttributes.ToBase64 ()' encryptedKey.ToBase64 ()' fileKey' completionHandle);  	GetNodesResponse createNodeResponse = this.Request<GetNodesResponse> (createNodeRequest' this.masterKey);  	return createNodeResponse.Nodes [0];  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The following statement contains a magic number: using (MegaAesCtrStreamCrypter encryptedStream = new MegaAesCtrStreamCrypter (stream)) {  	var chunkStartPosition = 0;  	var chunksSizesToUpload = this.ComputeChunksSizesToUpload (encryptedStream.ChunksPositions' encryptedStream.Length).ToArray ();  	Uri uri = null;  	for (int i = 0; i < chunksSizesToUpload.Length; i++) {  		completionHandle = string.Empty;  		int chunkSize = chunksSizesToUpload [i];  		byte[] chunkBuffer = new byte[chunkSize];  		encryptedStream.Read (chunkBuffer' 0' chunkSize);  		using (MemoryStream chunkStream = new MemoryStream (chunkBuffer)) {  			uri = new Uri (uploadResponse.Url + "/" + chunkStartPosition);  			chunkStartPosition += chunkSize;  			try {  				completionHandle = this.webClient.PostRequestRaw (uri' chunkStream);  				if (string.IsNullOrEmpty (completionHandle)) {  					apiResult = ApiResultCode.Ok;  					continue;  				}  				long retCode;  				if (completionHandle.FromBase64 ().Length != 27 && long.TryParse (completionHandle' out retCode)) {  					apiResult = (ApiResultCode)retCode;  					break;  				}  			} catch (Exception ex) {  				apiResult = ApiResultCode.RequestFailedRetry;  				this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' ex));  				break;  			}  		}  	}  	if (apiResult != ApiResultCode.Ok) {  		this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' completionHandle));  		if (apiResult == ApiResultCode.RequestFailedRetry || apiResult == ApiResultCode.RequestFailedPermanetly || apiResult == ApiResultCode.TooManyRequests) {  			// Restart upload from the beginning  			Thread.Sleep (requestDelay = (int)Math.Round (requestDelay * this.options.ApiRequestDelayExponentialFactor));  			// Reset steam position  			stream.Seek (0' SeekOrigin.Begin);  			continue;  		}  		throw new ApiException (apiResult);  	}  	// Encrypt attributes  	byte[] cryptedAttributes = Crypto.EncryptAttributes (new Attributes (name' stream' modificationDate)' encryptedStream.FileKey);  	// Compute the file key  	byte[] fileKey = new byte[32];  	for (int i = 0; i < 8; i++) {  		fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.Iv [i]);  		fileKey [i + 16] = encryptedStream.Iv [i];  	}  	for (int i = 8; i < 16; i++) {  		fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.MetaMac [i - 8]);  		fileKey [i + 16] = encryptedStream.MetaMac [i - 8];  	}  	byte[] encryptedKey = Crypto.EncryptKey (fileKey' this.masterKey);  	CreateNodeRequest createNodeRequest = CreateNodeRequest.CreateFileNodeRequest (parent' cryptedAttributes.ToBase64 ()' encryptedKey.ToBase64 ()' fileKey' completionHandle);  	GetNodesResponse createNodeResponse = this.Request<GetNodesResponse> (createNodeRequest' this.masterKey);  	return createNodeResponse.Nodes [0];  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The following statement contains a magic number: using (MegaAesCtrStreamCrypter encryptedStream = new MegaAesCtrStreamCrypter (stream)) {  	var chunkStartPosition = 0;  	var chunksSizesToUpload = this.ComputeChunksSizesToUpload (encryptedStream.ChunksPositions' encryptedStream.Length).ToArray ();  	Uri uri = null;  	for (int i = 0; i < chunksSizesToUpload.Length; i++) {  		completionHandle = string.Empty;  		int chunkSize = chunksSizesToUpload [i];  		byte[] chunkBuffer = new byte[chunkSize];  		encryptedStream.Read (chunkBuffer' 0' chunkSize);  		using (MemoryStream chunkStream = new MemoryStream (chunkBuffer)) {  			uri = new Uri (uploadResponse.Url + "/" + chunkStartPosition);  			chunkStartPosition += chunkSize;  			try {  				completionHandle = this.webClient.PostRequestRaw (uri' chunkStream);  				if (string.IsNullOrEmpty (completionHandle)) {  					apiResult = ApiResultCode.Ok;  					continue;  				}  				long retCode;  				if (completionHandle.FromBase64 ().Length != 27 && long.TryParse (completionHandle' out retCode)) {  					apiResult = (ApiResultCode)retCode;  					break;  				}  			} catch (Exception ex) {  				apiResult = ApiResultCode.RequestFailedRetry;  				this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' ex));  				break;  			}  		}  	}  	if (apiResult != ApiResultCode.Ok) {  		this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' completionHandle));  		if (apiResult == ApiResultCode.RequestFailedRetry || apiResult == ApiResultCode.RequestFailedPermanetly || apiResult == ApiResultCode.TooManyRequests) {  			// Restart upload from the beginning  			Thread.Sleep (requestDelay = (int)Math.Round (requestDelay * this.options.ApiRequestDelayExponentialFactor));  			// Reset steam position  			stream.Seek (0' SeekOrigin.Begin);  			continue;  		}  		throw new ApiException (apiResult);  	}  	// Encrypt attributes  	byte[] cryptedAttributes = Crypto.EncryptAttributes (new Attributes (name' stream' modificationDate)' encryptedStream.FileKey);  	// Compute the file key  	byte[] fileKey = new byte[32];  	for (int i = 0; i < 8; i++) {  		fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.Iv [i]);  		fileKey [i + 16] = encryptedStream.Iv [i];  	}  	for (int i = 8; i < 16; i++) {  		fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.MetaMac [i - 8]);  		fileKey [i + 16] = encryptedStream.MetaMac [i - 8];  	}  	byte[] encryptedKey = Crypto.EncryptKey (fileKey' this.masterKey);  	CreateNodeRequest createNodeRequest = CreateNodeRequest.CreateFileNodeRequest (parent' cryptedAttributes.ToBase64 ()' encryptedKey.ToBase64 ()' fileKey' completionHandle);  	GetNodesResponse createNodeResponse = this.Request<GetNodesResponse> (createNodeRequest' this.masterKey);  	return createNodeResponse.Nodes [0];  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The following statement contains a magic number: for (int i = 0; i < chunksSizesToUpload.Length; i++) {  	completionHandle = string.Empty;  	int chunkSize = chunksSizesToUpload [i];  	byte[] chunkBuffer = new byte[chunkSize];  	encryptedStream.Read (chunkBuffer' 0' chunkSize);  	using (MemoryStream chunkStream = new MemoryStream (chunkBuffer)) {  		uri = new Uri (uploadResponse.Url + "/" + chunkStartPosition);  		chunkStartPosition += chunkSize;  		try {  			completionHandle = this.webClient.PostRequestRaw (uri' chunkStream);  			if (string.IsNullOrEmpty (completionHandle)) {  				apiResult = ApiResultCode.Ok;  				continue;  			}  			long retCode;  			if (completionHandle.FromBase64 ().Length != 27 && long.TryParse (completionHandle' out retCode)) {  				apiResult = (ApiResultCode)retCode;  				break;  			}  		} catch (Exception ex) {  			apiResult = ApiResultCode.RequestFailedRetry;  			this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' ex));  			break;  		}  	}  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The following statement contains a magic number: using (MemoryStream chunkStream = new MemoryStream (chunkBuffer)) {  	uri = new Uri (uploadResponse.Url + "/" + chunkStartPosition);  	chunkStartPosition += chunkSize;  	try {  		completionHandle = this.webClient.PostRequestRaw (uri' chunkStream);  		if (string.IsNullOrEmpty (completionHandle)) {  			apiResult = ApiResultCode.Ok;  			continue;  		}  		long retCode;  		if (completionHandle.FromBase64 ().Length != 27 && long.TryParse (completionHandle' out retCode)) {  			apiResult = (ApiResultCode)retCode;  			break;  		}  	} catch (Exception ex) {  		apiResult = ApiResultCode.RequestFailedRetry;  		this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' ex));  		break;  	}  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The following statement contains a magic number: try {  	completionHandle = this.webClient.PostRequestRaw (uri' chunkStream);  	if (string.IsNullOrEmpty (completionHandle)) {  		apiResult = ApiResultCode.Ok;  		continue;  	}  	long retCode;  	if (completionHandle.FromBase64 ().Length != 27 && long.TryParse (completionHandle' out retCode)) {  		apiResult = (ApiResultCode)retCode;  		break;  	}  } catch (Exception ex) {  	apiResult = ApiResultCode.RequestFailedRetry;  	this.ApiRequestFailed.Invoke (this' new ApiRequestFailedEventArgs (uri' remainingRetry' requestDelay' apiResult' ex));  	break;  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The following statement contains a magic number: if (completionHandle.FromBase64 ().Length != 27 && long.TryParse (completionHandle' out retCode)) {  	apiResult = (ApiResultCode)retCode;  	break;  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.Iv [i]);  	fileKey [i + 16] = encryptedStream.Iv [i];  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.Iv [i]);  	fileKey [i + 16] = encryptedStream.Iv [i];  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The following statement contains a magic number: fileKey [i + 16] = encryptedStream.Iv [i];  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The following statement contains a magic number: for (int i = 8; i < 16; i++) {  	fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.MetaMac [i - 8]);  	fileKey [i + 16] = encryptedStream.MetaMac [i - 8];  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The following statement contains a magic number: for (int i = 8; i < 16; i++) {  	fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.MetaMac [i - 8]);  	fileKey [i + 16] = encryptedStream.MetaMac [i - 8];  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The following statement contains a magic number: for (int i = 8; i < 16; i++) {  	fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.MetaMac [i - 8]);  	fileKey [i + 16] = encryptedStream.MetaMac [i - 8];  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The following statement contains a magic number: for (int i = 8; i < 16; i++) {  	fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.MetaMac [i - 8]);  	fileKey [i + 16] = encryptedStream.MetaMac [i - 8];  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The following statement contains a magic number: for (int i = 8; i < 16; i++) {  	fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.MetaMac [i - 8]);  	fileKey [i + 16] = encryptedStream.MetaMac [i - 8];  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The following statement contains a magic number: fileKey [i] = (byte)(encryptedStream.FileKey [i] ^ encryptedStream.MetaMac [i - 8]);  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The following statement contains a magic number: fileKey [i + 16] = encryptedStream.MetaMac [i - 8];  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,Upload,The following statement contains a magic number: fileKey [i + 16] = encryptedStream.MetaMac [i - 8];  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,GenerateHash,The following statement contains a magic number: for (int i = 0; i < emailBytes.Length; i++) {  	hash [i % 16] ^= emailBytes [i];  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,GenerateHash,The following statement contains a magic number: hash [i % 16] ^= emailBytes [i];  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,GenerateHash,The following statement contains a magic number: for (int it = 0; it < 16384; it++) {  	hash = Crypto.EncryptAes (hash' passwordAesKey);  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,GenerateHash,The following statement contains a magic number: Array.Copy (hash' 0' result' 0' 4);  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,GenerateHash,The following statement contains a magic number: Array.Copy (hash' 8' result' 4' 4);  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,GenerateHash,The following statement contains a magic number: Array.Copy (hash' 8' result' 4' 4);  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,GenerateHash,The following statement contains a magic number: Array.Copy (hash' 8' result' 4' 4);  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,PrepareKey,The following statement contains a magic number: for (int it = 0; it < 65536; it++) {  	for (int idx = 0; idx < data.Length; idx += 16) {  		// Pad the data to 16 bytes blocks  		byte[] key = data.CopySubArray (16' idx);  		pkey = Crypto.EncryptAes (pkey' key);  	}  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,PrepareKey,The following statement contains a magic number: for (int it = 0; it < 65536; it++) {  	for (int idx = 0; idx < data.Length; idx += 16) {  		// Pad the data to 16 bytes blocks  		byte[] key = data.CopySubArray (16' idx);  		pkey = Crypto.EncryptAes (pkey' key);  	}  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,PrepareKey,The following statement contains a magic number: for (int it = 0; it < 65536; it++) {  	for (int idx = 0; idx < data.Length; idx += 16) {  		// Pad the data to 16 bytes blocks  		byte[] key = data.CopySubArray (16' idx);  		pkey = Crypto.EncryptAes (pkey' key);  	}  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,PrepareKey,The following statement contains a magic number: for (int idx = 0; idx < data.Length; idx += 16) {  	// Pad the data to 16 bytes blocks  	byte[] key = data.CopySubArray (16' idx);  	pkey = Crypto.EncryptAes (pkey' key);  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,PrepareKey,The following statement contains a magic number: for (int idx = 0; idx < data.Length; idx += 16) {  	// Pad the data to 16 bytes blocks  	byte[] key = data.CopySubArray (16' idx);  	pkey = Crypto.EncryptAes (pkey' key);  }  
Magic Number,CG.Web.MegaApiClient,MegaApiClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\MegaApiClient.cs,PrepareKey,The following statement contains a magic number: idx += 16
Magic Number,CG.Web.MegaApiClient,WebClient,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\WebClient_HttpWebRequest.cs,GenerateUserAgent,The following statement contains a magic number: return string.Format ("{0} v{1}"' assemblyName.Name' assemblyName.Version.ToString (2));  
Magic Number,DamienG.Security.Cryptography,Crc32,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crc32.cs,InitializeTable,The following statement contains a magic number: for (var i = 0; i < 256; i++) {  	var entry = (UInt32)i;  	for (var j = 0; j < 8; j++)  		if ((entry & 1) == 1)  			entry = (entry >> 1) ^ polynomial;  		else  			entry = entry >> 1;  	createTable [i] = entry;  }  
Magic Number,DamienG.Security.Cryptography,Crc32,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crc32.cs,InitializeTable,The following statement contains a magic number: for (var i = 0; i < 256; i++) {  	var entry = (UInt32)i;  	for (var j = 0; j < 8; j++)  		if ((entry & 1) == 1)  			entry = (entry >> 1) ^ polynomial;  		else  			entry = entry >> 1;  	createTable [i] = entry;  }  
Magic Number,DamienG.Security.Cryptography,Crc32,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crc32.cs,InitializeTable,The following statement contains a magic number: for (var j = 0; j < 8; j++)  	if ((entry & 1) == 1)  		entry = (entry >> 1) ^ polynomial;  	else  		entry = entry >> 1;  
Magic Number,DamienG.Security.Cryptography,Crc32,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crc32.cs,CalculateHash,The following statement contains a magic number: for (var i = start; i < start + size; i++)  	hash = (hash >> 8) ^ table [buffer [i] ^ hash & 0xff];  
Magic Number,DamienG.Security.Cryptography,Crc32,D:\newReposJune17\gpailler_MegaApiClient\MegaApiClient-3.5\..\MegaApiClient\Cryptography\Crc32.cs,CalculateHash,The following statement contains a magic number: hash = (hash >> 8) ^ table [buffer [i] ^ hash & 0xff];  
