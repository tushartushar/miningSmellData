Implementation smell,Namespace,Class,File,Method,Description
Long Method,Effort.Internal.Csv,CsvReader,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Csv\CsvReader.cs,ReadField,The method has 347 lines of code.
Long Method,Effort.Internal.Csv,CsvReader,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Csv\CsvReader.cs,ReadNextRecord,The method has 158 lines of code.
Long Method,Effort.Internal.DbCommandTreeTransformation,TransformVisitor,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbCommandTreeTransformation\TransformVisitor.In.cs,Visit,The method has 104 lines of code.
Long Method,Effort.Internal.DbCommandTreeTransformation,CanonicalFunctionMapper,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbCommandTreeTransformation\CanonicalFunctions.cs,AddDateTimeMappings,The method has 124 lines of code.
Long Method,Effort.Internal.TypeGeneration,DataRowFactory,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\TypeGeneration\DataRowFactory.cs,CreateRowType,The method has 104 lines of code.
Complex Method,Effort.Internal.Common,MetadataWorkspaceHelper,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Common\MetadataWorkspaceHelper.cs,ParseResources,Cyclomatic complexity of the method is 8
Complex Method,Effort.Internal.Csv,CsvReader,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Csv\CsvReader.cs,ReadField,Cyclomatic complexity of the method is 11
Complex Method,Effort.Internal.Csv,CsvReader,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Csv\CsvReader.cs,ReadNextRecord,Cyclomatic complexity of the method is 14
Complex Method,Effort.Internal.DbManagement.Engine.Services,DataRowKeyInfoHelper,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbManagement\Engine\Services\DataRowKeyInfoHelper.cs,TryParseKeySelectorExpression,Cyclomatic complexity of the method is 10
Complex Method,Effort.Internal.StorageSchema,CommonPropertyElementModifier,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\StorageSchema\CommonPropertyElementModifier.cs,Modify,Cyclomatic complexity of the method is 8
Complex Method,Effort.Internal.TypeConversion,DefaultTypeConverter,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\TypeConversion\DefaultTypeConverter.cs,ConvertClrObject,Cyclomatic complexity of the method is 8
Complex Method,Effort.Internal.TypeConversion,EdmTypeConverter,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\TypeConversion\EdmTypeConverter.cs,GetTypeFacets,Cyclomatic complexity of the method is 8
Long Parameter List,Effort.Internal.Common,DatabaseReflectionHelper,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Common\DatabaseReflectionHelper.cs,CreateTable,The method has 5 parameters. Parameters: database' entityType' primaryKeyInfo' identityField' constraintFactories
Long Parameter List,Effort.Internal.Common,WrapperMethods,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Common\DatabaseReflectionHelper.cs,CreateRelation,The method has 6 parameters. Parameters: database' primaryIndex' foreignIndex' foreignToPrimary' primaryToForeign' options
Long Parameter List,Effort.Internal.Csv,CsvReader,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Csv\CsvReader.cs,CsvReader,The method has 7 parameters. Parameters: reader' hasHeaders' delimiter' quote' escape' comment' trimmingOptions
Long Parameter List,Effort.Internal.Csv,CsvReader,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Csv\CsvReader.cs,CsvReader,The method has 8 parameters. Parameters: reader' hasHeaders' delimiter' quote' escape' comment' trimmingOptions' bufferSize
Long Parameter List,Effort.Internal.Csv,CsvReader,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Csv\CsvReader.cs,CopyFieldToArray,The method has 5 parameters. Parameters: field' fieldOffset' destinationArray' destinationOffset' length
Long Parameter List,Effort.Internal.Csv,CsvReader,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Csv\CsvReader.cs,GetBytes,The method has 5 parameters. Parameters: i' fieldOffset' buffer' bufferoffset' length
Long Parameter List,Effort.Internal.Csv,CsvReader,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Csv\CsvReader.cs,GetChars,The method has 5 parameters. Parameters: i' fieldoffset' buffer' bufferoffset' length
Long Parameter List,Effort.Internal.Csv,MalformedCsvException,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Csv\MalformedCsvException.cs,MalformedCsvException,The method has 5 parameters. Parameters: rawData' currentPosition' currentRecordIndex' currentFieldIndex' innerException
Long Parameter List,Effort.Internal.Csv,MissingFieldCsvException,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Csv\MissingFieldCsvException.cs,MissingFieldCsvException,The method has 5 parameters. Parameters: rawData' currentPosition' currentRecordIndex' currentFieldIndex' innerException
Long Parameter List,Effort.Internal.DbCommandTreeTransformation,DbFunctions,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbCommandTreeTransformation\DbFunctions.cs,CreateDateTime,The method has 6 parameters. Parameters: year' month' day' hour' minute' second
Long Parameter List,Effort.Internal.DbCommandTreeTransformation,DbFunctions,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbCommandTreeTransformation\DbFunctions.cs,CreateDateTimeOffset,The method has 7 parameters. Parameters: year' month' day' hour' minute' second' offsetMinutes
Long Parameter List,Effort.Internal.DbCommandTreeTransformation,TransformVisitor,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbCommandTreeTransformation\TransformVisitor.In.cs,CreateAggregateFunction,The method has 5 parameters. Parameters: functionAggregate' sourceVariableName' sourceType' sourceGroup' resultType
Long Parameter List,Effort.Internal.DbManagement.Schema,DbRelationInfo,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbManagement\Schema\DbRelationInfo.cs,DbRelationInfo,The method has 7 parameters. Parameters: primaryTable' foreignTable' primaryKeyInfo' foreignKeyInfo' primaryToForeignConverter' foreignToPrimaryConverter' cascadedDelete
Long Parameter List,Effort.Internal.DbManagement.Schema,DbTableInfo,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbManagement\Schema\DbTableInfo.cs,DbTableInfo,The method has 8 parameters. Parameters: tableName' entityType' identityField' properties' primaryKeyInfo' uniqueKeys' foreignKeys' constraintFactories
Long Parameter List,Effort.Provider,EffortDataReader,C:\repos\tamasflamich_effort\Main\Source\Effort\Provider\EffortDataReader.cs,GetBytes,The method has 5 parameters. Parameters: ordinal' dataOffset' buffer' bufferOffset' length
Long Parameter List,Effort.Provider,EffortDataReader,C:\repos\tamasflamich_effort\Main\Source\Effort\Provider\EffortDataReader.cs,GetChars,The method has 5 parameters. Parameters: ordinal' dataOffset' buffer' bufferOffset' length
Long Identifier,Effort.Exceptions,ExceptionMessages,C:\repos\tamasflamich_effort\Main\Source\Effort\Exceptions\ExceptionMessages.cs,,The length of the parameter AutomaticRegistationFailedResolveCode is 37.
Long Identifier,Effort.Exceptions,ExceptionMessages,C:\repos\tamasflamich_effort\Main\Source\Effort\Exceptions\ExceptionMessages.cs,,The length of the parameter AutomaticRegistationFailedResolveConfig is 39.
Long Identifier,Effort.Exceptions,ExceptionMessages,C:\repos\tamasflamich_effort\Main\Source\Effort\Exceptions\ExceptionMessages.cs,,The length of the parameter DbExpressionTransformationNotImplemented is 40.
Long Identifier,Effort.Internal.Caching,ObjectContextTypeStore,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Caching\ObjectContextTypeStore.cs,GetObjectContextType,The length of the parameter objectContextTypeFactoryMethod is 30.
Long Identifier,Effort.Internal.DbCommandTreeTransformation,TransformVisitor,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbCommandTreeTransformation\TransformVisitor.In.cs,Visit,The length of the parameter parameterPlaceholderConstructor is 31.
Long Identifier,Effort.Internal.DbManagement.Schema.Configuration,RelationConfiguration,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbManagement\Schema\Configuration\RelationConfiguration.cs,,The length of the parameter PrimaryToForeignConverterMethod is 31.
Long Identifier,Effort.Internal.DbManagement.Schema.Configuration,RelationConfiguration,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbManagement\Schema\Configuration\RelationConfiguration.cs,,The length of the parameter ForeignToPrimaryConverterMethod is 31.
Long Statement,Effort.Internal.CommandActions,DeleteCommandAction,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\CommandActions\DeleteCommandAction.cs,ExecuteNonQuery,The length of the statement  "            Expression expr = DbCommandActionHelper.GetEnumeratorExpression(this.commandTree.Predicate' this.commandTree' context.DbContainer' out table); " is 142.
Long Statement,Effort.Internal.CommandActions,InsertCommandAction,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\CommandActions\InsertCommandAction.cs,ExecuteDataReader,The length of the statement  "            IDictionary<string' DbExpression> setClauses = DbCommandActionHelper.GetSetClauseExpressions(this.commandTree.SetClauses); " is 122.
Long Statement,Effort.Internal.CommandActions,InsertCommandAction,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\CommandActions\InsertCommandAction.cs,ExecuteDataReader,The length of the statement  "            Dictionary<string' object> entityReturningValues = DbCommandActionHelper.CreateReturningEntity(context' returningFields' entity); " is 129.
Long Statement,Effort.Internal.CommandActions,UpdateCommandAction,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\CommandActions\UpdateCommandAction.cs,ExecuteDataReader,The length of the statement  "            Expression expr = DbCommandActionHelper.GetEnumeratorExpression(this.commandTree.Predicate' this.commandTree' context.DbContainer' out table); " is 142.
Long Statement,Effort.Internal.CommandActions,UpdateCommandAction,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\CommandActions\UpdateCommandAction.cs,ExecuteDataReader,The length of the statement  "            IDictionary<string' DbExpression> setClauses = DbCommandActionHelper.GetSetClauseExpressions(this.commandTree.SetClauses); " is 122.
Long Statement,Effort.Internal.CommandActions,UpdateCommandAction,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\CommandActions\UpdateCommandAction.cs,ExecuteDataReader,The length of the statement  "            IEnumerable<object> updatedEntities = DatabaseReflectionHelper.UpdateEntities(entitiesToUpdate' updater' context.Transaction); " is 126.
Long Statement,Effort.Internal.CommandActions,UpdateCommandAction,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\CommandActions\UpdateCommandAction.cs,ExecuteNonQuery,The length of the statement  "            Expression expr = DbCommandActionHelper.GetEnumeratorExpression(this.commandTree.Predicate' this.commandTree' context.DbContainer' out table); " is 142.
Long Statement,Effort.Internal.CommandActions,UpdateCommandAction,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\CommandActions\UpdateCommandAction.cs,ExecuteNonQuery,The length of the statement  "            IDictionary<string' DbExpression> setClauses = DbCommandActionHelper.GetSetClauseExpressions(this.commandTree.SetClauses); " is 122.
Long Statement,Effort.Internal.Common,MetadataWorkspaceHelper,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Common\MetadataWorkspaceHelper.cs,Rewrite,The length of the statement  "                UniversalStorageSchemaModifier.Instance.Modify(ssdlFile' new ProviderInformation(providerInvariantName' providerManifestToken)); " is 128.
Long Statement,Effort.Internal.Common,MetadataWorkspaceHelper,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Common\MetadataWorkspaceHelper.cs,Rewrite,The length of the statement  "                new ModificationFunctionMappingModifier().Modify(mslFile' new Effort.Internal.Common.XmlProcessing.ModificationContext()); " is 122.
Long Statement,Effort.Internal.Common,MetadataWorkspaceHelper,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Common\MetadataWorkspaceHelper.cs,ParseMetadata,The length of the statement  "            foreach (string component in metadata.Split(new char[] { '|' }' StringSplitOptions.RemoveEmptyEntries).Select(c => c.Trim())) " is 125.
Long Statement,Effort.Internal.Csv,CsvReader,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Csv\CsvReader.cs,ReadField,The length of the statement  "                                else if (c == this.escape && (this.escape != this.quote || (pos + 1 < this.bufferLength && this.buffer[pos + 1] == this.quote) || (pos + 1 == this.bufferLength && this.reader.Peek() == this.quote))) " is 198.
Long Statement,Effort.Internal.Csv,CsvReader,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Csv\CsvReader.cs,ReadField,The length of the statement  "                                    HandleParseError(new MalformedCsvException(GetCurrentRawData()' this.nextFieldStart' Math.Max(0' this.currentRecordIndex)' index)' ref this.nextFieldStart); " is 156.
Long Statement,Effort.Internal.Csv,CsvReader,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Csv\CsvReader.cs,ReadField,The length of the statement  "                                HandleParseError(new MalformedCsvException(GetCurrentRawData()' this.nextFieldStart' Math.Max(0' this.currentRecordIndex)' index)' ref this.nextFieldStart); " is 156.
Long Statement,Effort.Internal.Csv,CsvReader,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Csv\CsvReader.cs,ReadField,The length of the statement  "            HandleParseError(new MalformedCsvException(GetCurrentRawData()' this.nextFieldStart' Math.Max(0' this.currentRecordIndex)' index)' ref this.nextFieldStart); " is 156.
Long Statement,Effort.Internal.Csv,CsvReader,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Csv\CsvReader.cs,HandleParseError,The length of the statement  "                            throw new NotSupportedException(string.Format(CultureInfo.InvariantCulture' ExceptionMessages.ParseErrorActionNotSupported' e.Action)' e.Error); " is 144.
Long Statement,Effort.Internal.Csv,CsvReader,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Csv\CsvReader.cs,HandleParseError,The length of the statement  "                    throw new NotSupportedException(string.Format(CultureInfo.InvariantCulture' ExceptionMessages.ParseErrorActionNotSupported' this.defaultParseErrorAction)' error); " is 162.
Long Statement,Effort.Internal.Csv,CsvReader,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Csv\CsvReader.cs,CopyFieldToArray,The length of the statement  "                throw new ArgumentOutOfRangeException("field"' field' string.Format(CultureInfo.InvariantCulture' ExceptionMessages.FieldIndexOutOfRange' field)); " is 146.
Long Statement,Effort.Internal.Csv,CsvReader,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Csv\CsvReader.cs,GetOrdinal,The length of the statement  "                throw new ArgumentException(string.Format(CultureInfo.InvariantCulture' ExceptionMessages.FieldHeaderNotFound' name)' "name"); " is 126.
Complex Conditional,Effort.Internal.Csv,CsvReader,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Csv\CsvReader.cs,ReadField,The conditional expression  "c == this.escape && (this.escape != this.quote || (pos + 1 < this.bufferLength && this.buffer[pos + 1] == this.quote) || (pos + 1 == this.bufferLength && this.reader.Peek() == this.quote))"  is complex.
Complex Conditional,Effort.Internal.Csv,CsvReader,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Csv\CsvReader.cs,ReadField,The conditional expression  "!this.eof && !delimiterSkipped && (initializing || index == this.fieldCount - 1)"  is complex.
Complex Conditional,Effort.Internal.Csv,CsvReader,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Csv\CsvReader.cs,ReadField,The conditional expression  "!delimiterSkipped && !this.eof && !(this.eol || IsNewLine(this.nextFieldStart))"  is complex.
Complex Conditional,Effort.Internal.Csv,CsvReader,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Csv\CsvReader.cs,SkipToNextLine,The conditional expression  "(pos < this.bufferLength || (ReadBuffer() && ((pos = 0) == 0))) && !ParseNewLine(ref pos)"  is complex.
Complex Conditional,Effort.Internal.DbCommandTreeTransformation,DbFunctions,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbCommandTreeTransformation\DbFunctions.cs,CreateDateTime,The conditional expression  "!year.HasValue ||                   !month.HasValue ||                   !day.HasValue ||                  !hour.HasValue ||                   !minute.HasValue ||                   !second.HasValue"  is complex.
Complex Conditional,Effort.Internal.DbCommandTreeTransformation,DbFunctions,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbCommandTreeTransformation\DbFunctions.cs,CreateDateTimeOffset,The conditional expression  "!year.HasValue ||                  !month.HasValue ||                  !day.HasValue ||                  !hour.HasValue ||                  !minute.HasValue ||                  !second.HasValue ||                  !offsetMinutes.HasValue"  is complex.
Empty Catch Block,Effort.Internal.Common,MetadataWorkspaceHelper,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Common\MetadataWorkspaceHelper.cs,ParseResources,The method has an empty catch block.
Magic Number,Effort.Internal.Common,TupleTypeHelper,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Common\TupleTypeHelper.cs,GetTupleType,The following statement contains a magic number: switch (memberTypes.Length)              {                  case 1:                      generic = typeof(Tuple<>);                      break;                  case 2:                      generic = typeof(Tuple<'>);                      break;                  case 3:                      generic = typeof(Tuple<''>);                      break;                  case 4:                      generic = typeof(Tuple<'''>);                      break;                  case 5:                      generic = typeof(Tuple<''''>);                      break;                  case 6:                      generic = typeof(Tuple<'''''>);                      break;                  case 7:                      generic = typeof(Tuple<''''''>);                      break;                  case 8:                      generic = typeof(Tuple<'''''''>);                      break;                  default:                      throw new ArgumentException("Too many members"' "memberTypes");              }
Magic Number,Effort.Internal.Common,TupleTypeHelper,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Common\TupleTypeHelper.cs,GetTupleType,The following statement contains a magic number: switch (memberTypes.Length)              {                  case 1:                      generic = typeof(Tuple<>);                      break;                  case 2:                      generic = typeof(Tuple<'>);                      break;                  case 3:                      generic = typeof(Tuple<''>);                      break;                  case 4:                      generic = typeof(Tuple<'''>);                      break;                  case 5:                      generic = typeof(Tuple<''''>);                      break;                  case 6:                      generic = typeof(Tuple<'''''>);                      break;                  case 7:                      generic = typeof(Tuple<''''''>);                      break;                  case 8:                      generic = typeof(Tuple<'''''''>);                      break;                  default:                      throw new ArgumentException("Too many members"' "memberTypes");              }
Magic Number,Effort.Internal.Common,TupleTypeHelper,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Common\TupleTypeHelper.cs,GetTupleType,The following statement contains a magic number: switch (memberTypes.Length)              {                  case 1:                      generic = typeof(Tuple<>);                      break;                  case 2:                      generic = typeof(Tuple<'>);                      break;                  case 3:                      generic = typeof(Tuple<''>);                      break;                  case 4:                      generic = typeof(Tuple<'''>);                      break;                  case 5:                      generic = typeof(Tuple<''''>);                      break;                  case 6:                      generic = typeof(Tuple<'''''>);                      break;                  case 7:                      generic = typeof(Tuple<''''''>);                      break;                  case 8:                      generic = typeof(Tuple<'''''''>);                      break;                  default:                      throw new ArgumentException("Too many members"' "memberTypes");              }
Magic Number,Effort.Internal.Common,TupleTypeHelper,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Common\TupleTypeHelper.cs,GetTupleType,The following statement contains a magic number: switch (memberTypes.Length)              {                  case 1:                      generic = typeof(Tuple<>);                      break;                  case 2:                      generic = typeof(Tuple<'>);                      break;                  case 3:                      generic = typeof(Tuple<''>);                      break;                  case 4:                      generic = typeof(Tuple<'''>);                      break;                  case 5:                      generic = typeof(Tuple<''''>);                      break;                  case 6:                      generic = typeof(Tuple<'''''>);                      break;                  case 7:                      generic = typeof(Tuple<''''''>);                      break;                  case 8:                      generic = typeof(Tuple<'''''''>);                      break;                  default:                      throw new ArgumentException("Too many members"' "memberTypes");              }
Magic Number,Effort.Internal.Common,TupleTypeHelper,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Common\TupleTypeHelper.cs,GetTupleType,The following statement contains a magic number: switch (memberTypes.Length)              {                  case 1:                      generic = typeof(Tuple<>);                      break;                  case 2:                      generic = typeof(Tuple<'>);                      break;                  case 3:                      generic = typeof(Tuple<''>);                      break;                  case 4:                      generic = typeof(Tuple<'''>);                      break;                  case 5:                      generic = typeof(Tuple<''''>);                      break;                  case 6:                      generic = typeof(Tuple<'''''>);                      break;                  case 7:                      generic = typeof(Tuple<''''''>);                      break;                  case 8:                      generic = typeof(Tuple<'''''''>);                      break;                  default:                      throw new ArgumentException("Too many members"' "memberTypes");              }
Magic Number,Effort.Internal.Common,TupleTypeHelper,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Common\TupleTypeHelper.cs,GetTupleType,The following statement contains a magic number: switch (memberTypes.Length)              {                  case 1:                      generic = typeof(Tuple<>);                      break;                  case 2:                      generic = typeof(Tuple<'>);                      break;                  case 3:                      generic = typeof(Tuple<''>);                      break;                  case 4:                      generic = typeof(Tuple<'''>);                      break;                  case 5:                      generic = typeof(Tuple<''''>);                      break;                  case 6:                      generic = typeof(Tuple<'''''>);                      break;                  case 7:                      generic = typeof(Tuple<''''''>);                      break;                  case 8:                      generic = typeof(Tuple<'''''''>);                      break;                  default:                      throw new ArgumentException("Too many members"' "memberTypes");              }
Magic Number,Effort.Internal.Common,TupleTypeHelper,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Common\TupleTypeHelper.cs,GetTupleType,The following statement contains a magic number: switch (memberTypes.Length)              {                  case 1:                      generic = typeof(Tuple<>);                      break;                  case 2:                      generic = typeof(Tuple<'>);                      break;                  case 3:                      generic = typeof(Tuple<''>);                      break;                  case 4:                      generic = typeof(Tuple<'''>);                      break;                  case 5:                      generic = typeof(Tuple<''''>);                      break;                  case 6:                      generic = typeof(Tuple<'''''>);                      break;                  case 7:                      generic = typeof(Tuple<''''''>);                      break;                  case 8:                      generic = typeof(Tuple<'''''''>);                      break;                  default:                      throw new ArgumentException("Too many members"' "memberTypes");              }
Magic Number,Effort.Internal.Common,MetadataWorkspaceHelper,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Common\MetadataWorkspaceHelper.cs,IsEcmaAssembly,The following statement contains a magic number: if (publicKey != null && publicKey.Length == 16 && publicKey[8] == 0x4)              {                  return true;              }              else              {                  return false;              }
Magic Number,Effort.Internal.Common,MetadataWorkspaceHelper,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Common\MetadataWorkspaceHelper.cs,IsEcmaAssembly,The following statement contains a magic number: if (publicKey != null && publicKey.Length == 16 && publicKey[8] == 0x4)              {                  return true;              }              else              {                  return false;              }
Magic Number,Effort.Internal.Csv,CsvReader,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Csv\CsvReader.cs,ReadNextRecord,The following statement contains a magic number: if (!this.initialized)              {                  this.buffer = new char[this.bufferSize];                    // will be replaced if and when headers are read                  this.fieldHeaders = new string[0];                    if (!ReadBuffer())                  {                      return false;                  }                    if (!SkipEmptyAndCommentedLines(ref this.nextFieldStart))                  {                      return false;                  }                    // Keep growing this.fields array until the last field has been found                  // and then resize it to its final correct size                    this.fieldCount = 0;                  this.fields = new FieldValue[16];                    while (!ReadField(this.fieldCount' true' false).IsMissing)                  {                      if (this.parseErrorFlag)                      {                          this.fieldCount = 0;                          Array.Clear(this.fields' 0' this.fields.Length);                          this.parseErrorFlag = false;                          this.nextFieldIndex = 0;                      }                      else                      {                          this.fieldCount++;                            if (this.fieldCount == this.fields.Length)                          {                              Array.Resize<FieldValue>(ref this.fields' (this.fieldCount + 1) * 2);                          }                      }                  }                    // fieldCount contains the last field index' but it must contains the field count'                  // so increment by 1                  this.fieldCount++;                    if (this.fields.Length != this.fieldCount)                  {                      Array.Resize<FieldValue>(ref this.fields' this.fieldCount);                  }                    this.initialized = true;                    // If headers are present' call ReadNextRecord again                  if (this.hasHeaders)                  {                      // Don't count first record as it was the headers                      this.currentRecordIndex = -1;                        this.firstRecordInCache = false;                        this.fieldHeaders = new string[this.fieldCount];                      this.fieldHeaderIndexes = new Dictionary<string' int>(this.fieldCount' fieldHeaderComparer);                        for (int i = 0; i < this.fields.Length; i++)                      {                          string headerName = this.fields[i].Value;                          if (string.IsNullOrEmpty(headerName) || headerName.Trim().Length == 0)                          {                              headerName = this.DefaultHeaderName + i.ToString();                          }                            this.fieldHeaders[i] = headerName;                          this.fieldHeaderIndexes.Add(headerName' i);                      }                        // Proceed to first record                      if (!onlyReadHeaders)                      {                          // Calling again ReadNextRecord() seems to be simpler'                           // but in fact would probably cause many subtle bugs because a derived                           // class does not expect a recursive behavior so simply do what is                           // needed here and no more.                            if (!SkipEmptyAndCommentedLines(ref this.nextFieldStart))                          {                              return false;                          }                            Array.Clear(this.fields' 0' this.fields.Length);                          this.nextFieldIndex = 0;                          this.eol = false;                            this.currentRecordIndex++;                          return true;                      }                  }                  else                  {                      if (onlyReadHeaders)                      {                          this.firstRecordInCache = true;                          this.currentRecordIndex = -1;                      }                      else                      {                          this.firstRecordInCache = false;                          this.currentRecordIndex = 0;                      }                  }              }              else              {                  if (skipToNextLine)                  {                      SkipToNextLine(ref this.nextFieldStart);                  }                  else if (this.currentRecordIndex > -1 && !this.missingFieldFlag)                  {                      // If not already at end of record' move there                      if (!this.eol && !this.eof)                      {                          if (!this.supportsMultiline)                          {                              SkipToNextLine(ref this.nextFieldStart);                          }                          else                          {                              // a dirty trick to handle the case where extra fields are present                              while (!ReadField(this.nextFieldIndex' true' true).IsMissing)                              {                              }                          }                      }                  }                    if (!this.firstRecordInCache && !SkipEmptyAndCommentedLines(ref this.nextFieldStart))                  {                      return false;                  }                    if (this.hasHeaders || !this.firstRecordInCache)                  {                      this.eol = false;                  }                    // Check to see if the first record is in cache.                  // This can happen when initializing a reader with no headers                  // because one record must be read to get the field count automatically                  if (this.firstRecordInCache)                  {                      this.firstRecordInCache = false;                  }                  else                  {                      Array.Clear(this.fields' 0' this.fields.Length);                      this.nextFieldIndex = 0;                  }                    this.missingFieldFlag = false;                  this.parseErrorFlag = false;                  this.currentRecordIndex++;              }
Magic Number,Effort.Internal.Csv,CsvReader,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Csv\CsvReader.cs,ReadNextRecord,The following statement contains a magic number: if (!this.initialized)              {                  this.buffer = new char[this.bufferSize];                    // will be replaced if and when headers are read                  this.fieldHeaders = new string[0];                    if (!ReadBuffer())                  {                      return false;                  }                    if (!SkipEmptyAndCommentedLines(ref this.nextFieldStart))                  {                      return false;                  }                    // Keep growing this.fields array until the last field has been found                  // and then resize it to its final correct size                    this.fieldCount = 0;                  this.fields = new FieldValue[16];                    while (!ReadField(this.fieldCount' true' false).IsMissing)                  {                      if (this.parseErrorFlag)                      {                          this.fieldCount = 0;                          Array.Clear(this.fields' 0' this.fields.Length);                          this.parseErrorFlag = false;                          this.nextFieldIndex = 0;                      }                      else                      {                          this.fieldCount++;                            if (this.fieldCount == this.fields.Length)                          {                              Array.Resize<FieldValue>(ref this.fields' (this.fieldCount + 1) * 2);                          }                      }                  }                    // fieldCount contains the last field index' but it must contains the field count'                  // so increment by 1                  this.fieldCount++;                    if (this.fields.Length != this.fieldCount)                  {                      Array.Resize<FieldValue>(ref this.fields' this.fieldCount);                  }                    this.initialized = true;                    // If headers are present' call ReadNextRecord again                  if (this.hasHeaders)                  {                      // Don't count first record as it was the headers                      this.currentRecordIndex = -1;                        this.firstRecordInCache = false;                        this.fieldHeaders = new string[this.fieldCount];                      this.fieldHeaderIndexes = new Dictionary<string' int>(this.fieldCount' fieldHeaderComparer);                        for (int i = 0; i < this.fields.Length; i++)                      {                          string headerName = this.fields[i].Value;                          if (string.IsNullOrEmpty(headerName) || headerName.Trim().Length == 0)                          {                              headerName = this.DefaultHeaderName + i.ToString();                          }                            this.fieldHeaders[i] = headerName;                          this.fieldHeaderIndexes.Add(headerName' i);                      }                        // Proceed to first record                      if (!onlyReadHeaders)                      {                          // Calling again ReadNextRecord() seems to be simpler'                           // but in fact would probably cause many subtle bugs because a derived                           // class does not expect a recursive behavior so simply do what is                           // needed here and no more.                            if (!SkipEmptyAndCommentedLines(ref this.nextFieldStart))                          {                              return false;                          }                            Array.Clear(this.fields' 0' this.fields.Length);                          this.nextFieldIndex = 0;                          this.eol = false;                            this.currentRecordIndex++;                          return true;                      }                  }                  else                  {                      if (onlyReadHeaders)                      {                          this.firstRecordInCache = true;                          this.currentRecordIndex = -1;                      }                      else                      {                          this.firstRecordInCache = false;                          this.currentRecordIndex = 0;                      }                  }              }              else              {                  if (skipToNextLine)                  {                      SkipToNextLine(ref this.nextFieldStart);                  }                  else if (this.currentRecordIndex > -1 && !this.missingFieldFlag)                  {                      // If not already at end of record' move there                      if (!this.eol && !this.eof)                      {                          if (!this.supportsMultiline)                          {                              SkipToNextLine(ref this.nextFieldStart);                          }                          else                          {                              // a dirty trick to handle the case where extra fields are present                              while (!ReadField(this.nextFieldIndex' true' true).IsMissing)                              {                              }                          }                      }                  }                    if (!this.firstRecordInCache && !SkipEmptyAndCommentedLines(ref this.nextFieldStart))                  {                      return false;                  }                    if (this.hasHeaders || !this.firstRecordInCache)                  {                      this.eol = false;                  }                    // Check to see if the first record is in cache.                  // This can happen when initializing a reader with no headers                  // because one record must be read to get the field count automatically                  if (this.firstRecordInCache)                  {                      this.firstRecordInCache = false;                  }                  else                  {                      Array.Clear(this.fields' 0' this.fields.Length);                      this.nextFieldIndex = 0;                  }                    this.missingFieldFlag = false;                  this.parseErrorFlag = false;                  this.currentRecordIndex++;              }
Magic Number,Effort.Internal.Csv,CsvReader,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Csv\CsvReader.cs,GetSchemaTable,The following statement contains a magic number: for (int i = 0; i < columnNames.Length; i++)              {                  schemaRow[1] = columnNames[i]; // Base column name                  schemaRow[4] = columnNames[i]; // Column name                  schemaRow[5] = i; // Column ordinal                    schema.Rows.Add(schemaRow);              }
Magic Number,Effort.Internal.Csv,CsvReader,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\Csv\CsvReader.cs,GetSchemaTable,The following statement contains a magic number: for (int i = 0; i < columnNames.Length; i++)              {                  schemaRow[1] = columnNames[i]; // Base column name                  schemaRow[4] = columnNames[i]; // Column name                  schemaRow[5] = i; // Column ordinal                    schema.Rows.Add(schemaRow);              }
Magic Number,Effort.Internal.DbCommandTreeTransformation,DbFunctions,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbCommandTreeTransformation\DbFunctions.cs,AddMicroseconds,The following statement contains a magic number: return date.Value.AddTicks(value.Value * 10);
Magic Number,Effort.Internal.DbCommandTreeTransformation,DbFunctions,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbCommandTreeTransformation\DbFunctions.cs,AddNanoseconds,The following statement contains a magic number: return date.Value.AddTicks(value.Value / 100);
Magic Number,Effort.Internal.DbCommandTreeTransformation,DbFunctions,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbCommandTreeTransformation\DbFunctions.cs,DiffMonths,The following statement contains a magic number: return                   (val2.Value.Year - val1.Value.Year) * 12 +                   (val2.Value.Month - val1.Value.Month);
Magic Number,Effort.Internal.DbCommandTreeTransformation,DbFunctions,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbCommandTreeTransformation\DbFunctions.cs,DiffMicroseconds,The following statement contains a magic number: return (int)((val2.Value - val1.Value).Ticks / 10);
Magic Number,Effort.Internal.DbCommandTreeTransformation,DbFunctions,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbCommandTreeTransformation\DbFunctions.cs,DiffNanoseconds,The following statement contains a magic number: return (int)((val2.Value - val1.Value).Ticks * 100);
Magic Number,Effort.Internal.DbCommandTreeTransformation,DbFunctions,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbCommandTreeTransformation\DbFunctions.cs,AddMicroseconds,The following statement contains a magic number: return date.Value.AddTicks(value.Value * 10);
Magic Number,Effort.Internal.DbCommandTreeTransformation,DbFunctions,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbCommandTreeTransformation\DbFunctions.cs,AddNanoseconds,The following statement contains a magic number: return date.Value.AddTicks(value.Value / 100);
Magic Number,Effort.Internal.DbCommandTreeTransformation,DbFunctions,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbCommandTreeTransformation\DbFunctions.cs,DiffMonths,The following statement contains a magic number: return                  (val2.Value.Year - val1.Value.Year) * 12 +                  (val2.Value.Month - val1.Value.Month);
Magic Number,Effort.Internal.DbCommandTreeTransformation,DbFunctions,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbCommandTreeTransformation\DbFunctions.cs,DiffMicroseconds,The following statement contains a magic number: return (int)((val2.Value - val1.Value).Ticks / 10);
Magic Number,Effort.Internal.DbCommandTreeTransformation,DbFunctions,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbCommandTreeTransformation\DbFunctions.cs,DiffNanoseconds,The following statement contains a magic number: return (int)((val2.Value - val1.Value).Ticks * 100);
Magic Number,Effort.Internal.DbCommandTreeTransformation,DbFunctions,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbCommandTreeTransformation\DbFunctions.cs,AddMicroseconds,The following statement contains a magic number: return date.Value.Add(TimeSpan.FromTicks(value.Value * 10));
Magic Number,Effort.Internal.DbCommandTreeTransformation,DbFunctions,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbCommandTreeTransformation\DbFunctions.cs,AddNanoseconds,The following statement contains a magic number: return date.Value.Add(TimeSpan.FromTicks(value.Value / 100));
Magic Number,Effort.Internal.DbCommandTreeTransformation,DbFunctions,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbCommandTreeTransformation\DbFunctions.cs,DiffMicroseconds,The following statement contains a magic number: return (int)((val2.Value - val1.Value).Ticks / 10);
Magic Number,Effort.Internal.DbCommandTreeTransformation,DbFunctions,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbCommandTreeTransformation\DbFunctions.cs,DiffNanoseconds,The following statement contains a magic number: return (int)((val2.Value - val1.Value).Ticks * 100);
Magic Number,Effort.Internal.DbCommandTreeTransformation,TransformVisitor,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbCommandTreeTransformation\TransformVisitor.In.cs,Visit,The following statement contains a magic number: if (args.Length == 2)              {                  ExpressionHelper.TryUnifyValueTypes(ref args[0]' ref args[1]);              }
Magic Number,Effort.Internal.DbCommandTreeTransformation,CanonicalFunctionMapper,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbCommandTreeTransformation\CanonicalFunctions.cs,MapRound,The following statement contains a magic number: switch(args.Length)              {                  case 1:                      method = IsDecimal(f.Parameters[0]) ?                          DecimalFunctions.Round :                          DoubleFunctions.Round;                      break;                  case 2:                      method = IsDecimal(f.Parameters[0]) ?                          DecimalFunctions.RoundDigits :                          DoubleFunctions.RoundDigits;                      break;              }
Magic Number,Effort.Internal.DbCommandTreeTransformation,CanonicalFunctionMapper,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbCommandTreeTransformation\CanonicalFunctions.cs,SelectDateTimeMethod,The following statement contains a magic number: if (firstArg == typeof(DateTime))              {                  return 0;              }              else if (firstArg == typeof(DateTimeOffset))              {                  return 1;              }              else if (firstArg == typeof(TimeSpan))              {                  return 2;              }
Magic Number,Effort.Internal.DbManagement.Schema.Constraints,ConstraintFactories,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbManagement\Schema\Constraints\ConstraintFactories.cs,CreateFactory,The following statement contains a magic number: switch (generics)              {                  case 1:                      factoryType = factoryType.MakeGenericType(member.EntityType);                      break;                  case 2:                      factoryType = factoryType.MakeGenericType(member.EntityType' member.MemberType);                      break;                  default:                      throw new InvalidOperationException("Invalid factory type");              }
Magic Number,Effort.Internal.TypeGeneration,DataRowFactory,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\TypeGeneration\DataRowFactory.cs,GenerateGetHashcodeIL,The following statement contains a magic number: for (int i = 0; i < fields.Length; i++)              {                  Type type = fields[i].FieldType;                    Type equalityComparerType = typeof(EqualityComparer<>).MakeGenericType(type);                    MethodInfo defaultEqualityComparerGetter = equalityComparerType                      .GetProperty("Default")                      .GetGetMethod();                    MethodInfo getHashCodeMethod = equalityComparerType                      .GetMethod("GetHashCode"' new Type[] { type });                    // s[1] = const                  gen.Emit(OpCodes.Ldc_I4' -1521134295);                  // s[0] = s[0] * s[1]                  gen.Emit(OpCodes.Mul);                    // s[1] = EqualityComparer<T>.Default                  gen.Emit(OpCodes.Call' defaultEqualityComparerGetter);                    // s[2] = this.field                  gen.Emit(OpCodes.Ldarg_0);                  gen.Emit(OpCodes.Ldfld' fields[i]);                    // s[1] = s[1].GetHashCode(s[2])                  gen.Emit(OpCodes.Callvirt' getHashCodeMethod);                    // s[0] = s[0] + s[1]                  gen.Emit(OpCodes.Add);              }
Magic Number,Effort.Internal.TypeGeneration,DataRowFactory,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\TypeGeneration\DataRowFactory.cs,GenerateLdArg,The following statement contains a magic number: switch (i)              {                  case 0:                      gen.Emit(OpCodes.Ldarg_0);                      break;                  case 1:                      gen.Emit(OpCodes.Ldarg_1);                      break;                  case 2:                      gen.Emit(OpCodes.Ldarg_2);                      break;                  case 3:                      gen.Emit(OpCodes.Ldarg_3);                      break;                  default:                      if (i <= 127)                      {                          gen.Emit(OpCodes.Ldarg_S' i);                      }                      else                      {                          gen.Emit(OpCodes.Ldarg' i);                      }                      break;              }
Magic Number,Effort.Internal.TypeGeneration,DataRowFactory,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\TypeGeneration\DataRowFactory.cs,GenerateLdArg,The following statement contains a magic number: switch (i)              {                  case 0:                      gen.Emit(OpCodes.Ldarg_0);                      break;                  case 1:                      gen.Emit(OpCodes.Ldarg_1);                      break;                  case 2:                      gen.Emit(OpCodes.Ldarg_2);                      break;                  case 3:                      gen.Emit(OpCodes.Ldarg_3);                      break;                  default:                      if (i <= 127)                      {                          gen.Emit(OpCodes.Ldarg_S' i);                      }                      else                      {                          gen.Emit(OpCodes.Ldarg' i);                      }                      break;              }
Magic Number,Effort.Internal.TypeGeneration,DataRowFactory,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\TypeGeneration\DataRowFactory.cs,GenerateLdArg,The following statement contains a magic number: switch (i)              {                  case 0:                      gen.Emit(OpCodes.Ldarg_0);                      break;                  case 1:                      gen.Emit(OpCodes.Ldarg_1);                      break;                  case 2:                      gen.Emit(OpCodes.Ldarg_2);                      break;                  case 3:                      gen.Emit(OpCodes.Ldarg_3);                      break;                  default:                      if (i <= 127)                      {                          gen.Emit(OpCodes.Ldarg_S' i);                      }                      else                      {                          gen.Emit(OpCodes.Ldarg' i);                      }                      break;              }
Magic Number,Effort.Internal.TypeGeneration,DataRowFactory,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\TypeGeneration\DataRowFactory.cs,GenerateLdc_I4,The following statement contains a magic number: switch (constant)              {                  case 0:                      gen.Emit(OpCodes.Ldc_I4_0);                      break;                  case 1:                      gen.Emit(OpCodes.Ldc_I4_1);                      break;                  case 2:                      gen.Emit(OpCodes.Ldc_I4_2);                      break;                  case 3:                      gen.Emit(OpCodes.Ldc_I4_3);                      break;                  case 4:                      gen.Emit(OpCodes.Ldc_I4_4);                      break;                  case 5:                      gen.Emit(OpCodes.Ldc_I4_5);                      break;                  case 6:                      gen.Emit(OpCodes.Ldc_I4_6);                      break;                  case 7:                      gen.Emit(OpCodes.Ldc_I4_7);                      break;                  case 8:                      gen.Emit(OpCodes.Ldc_I4_8);                      break;                  default:                      if (constant <= 127)                      {                          gen.Emit(OpCodes.Ldc_I4_S' constant);                      }                      else                      {                          gen.Emit(OpCodes.Ldc_I4' constant);                      }                      break;              }
Magic Number,Effort.Internal.TypeGeneration,DataRowFactory,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\TypeGeneration\DataRowFactory.cs,GenerateLdc_I4,The following statement contains a magic number: switch (constant)              {                  case 0:                      gen.Emit(OpCodes.Ldc_I4_0);                      break;                  case 1:                      gen.Emit(OpCodes.Ldc_I4_1);                      break;                  case 2:                      gen.Emit(OpCodes.Ldc_I4_2);                      break;                  case 3:                      gen.Emit(OpCodes.Ldc_I4_3);                      break;                  case 4:                      gen.Emit(OpCodes.Ldc_I4_4);                      break;                  case 5:                      gen.Emit(OpCodes.Ldc_I4_5);                      break;                  case 6:                      gen.Emit(OpCodes.Ldc_I4_6);                      break;                  case 7:                      gen.Emit(OpCodes.Ldc_I4_7);                      break;                  case 8:                      gen.Emit(OpCodes.Ldc_I4_8);                      break;                  default:                      if (constant <= 127)                      {                          gen.Emit(OpCodes.Ldc_I4_S' constant);                      }                      else                      {                          gen.Emit(OpCodes.Ldc_I4' constant);                      }                      break;              }
Magic Number,Effort.Internal.TypeGeneration,DataRowFactory,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\TypeGeneration\DataRowFactory.cs,GenerateLdc_I4,The following statement contains a magic number: switch (constant)              {                  case 0:                      gen.Emit(OpCodes.Ldc_I4_0);                      break;                  case 1:                      gen.Emit(OpCodes.Ldc_I4_1);                      break;                  case 2:                      gen.Emit(OpCodes.Ldc_I4_2);                      break;                  case 3:                      gen.Emit(OpCodes.Ldc_I4_3);                      break;                  case 4:                      gen.Emit(OpCodes.Ldc_I4_4);                      break;                  case 5:                      gen.Emit(OpCodes.Ldc_I4_5);                      break;                  case 6:                      gen.Emit(OpCodes.Ldc_I4_6);                      break;                  case 7:                      gen.Emit(OpCodes.Ldc_I4_7);                      break;                  case 8:                      gen.Emit(OpCodes.Ldc_I4_8);                      break;                  default:                      if (constant <= 127)                      {                          gen.Emit(OpCodes.Ldc_I4_S' constant);                      }                      else                      {                          gen.Emit(OpCodes.Ldc_I4' constant);                      }                      break;              }
Magic Number,Effort.Internal.TypeGeneration,DataRowFactory,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\TypeGeneration\DataRowFactory.cs,GenerateLdc_I4,The following statement contains a magic number: switch (constant)              {                  case 0:                      gen.Emit(OpCodes.Ldc_I4_0);                      break;                  case 1:                      gen.Emit(OpCodes.Ldc_I4_1);                      break;                  case 2:                      gen.Emit(OpCodes.Ldc_I4_2);                      break;                  case 3:                      gen.Emit(OpCodes.Ldc_I4_3);                      break;                  case 4:                      gen.Emit(OpCodes.Ldc_I4_4);                      break;                  case 5:                      gen.Emit(OpCodes.Ldc_I4_5);                      break;                  case 6:                      gen.Emit(OpCodes.Ldc_I4_6);                      break;                  case 7:                      gen.Emit(OpCodes.Ldc_I4_7);                      break;                  case 8:                      gen.Emit(OpCodes.Ldc_I4_8);                      break;                  default:                      if (constant <= 127)                      {                          gen.Emit(OpCodes.Ldc_I4_S' constant);                      }                      else                      {                          gen.Emit(OpCodes.Ldc_I4' constant);                      }                      break;              }
Magic Number,Effort.Internal.TypeGeneration,DataRowFactory,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\TypeGeneration\DataRowFactory.cs,GenerateLdc_I4,The following statement contains a magic number: switch (constant)              {                  case 0:                      gen.Emit(OpCodes.Ldc_I4_0);                      break;                  case 1:                      gen.Emit(OpCodes.Ldc_I4_1);                      break;                  case 2:                      gen.Emit(OpCodes.Ldc_I4_2);                      break;                  case 3:                      gen.Emit(OpCodes.Ldc_I4_3);                      break;                  case 4:                      gen.Emit(OpCodes.Ldc_I4_4);                      break;                  case 5:                      gen.Emit(OpCodes.Ldc_I4_5);                      break;                  case 6:                      gen.Emit(OpCodes.Ldc_I4_6);                      break;                  case 7:                      gen.Emit(OpCodes.Ldc_I4_7);                      break;                  case 8:                      gen.Emit(OpCodes.Ldc_I4_8);                      break;                  default:                      if (constant <= 127)                      {                          gen.Emit(OpCodes.Ldc_I4_S' constant);                      }                      else                      {                          gen.Emit(OpCodes.Ldc_I4' constant);                      }                      break;              }
Magic Number,Effort.Internal.TypeGeneration,DataRowFactory,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\TypeGeneration\DataRowFactory.cs,GenerateLdc_I4,The following statement contains a magic number: switch (constant)              {                  case 0:                      gen.Emit(OpCodes.Ldc_I4_0);                      break;                  case 1:                      gen.Emit(OpCodes.Ldc_I4_1);                      break;                  case 2:                      gen.Emit(OpCodes.Ldc_I4_2);                      break;                  case 3:                      gen.Emit(OpCodes.Ldc_I4_3);                      break;                  case 4:                      gen.Emit(OpCodes.Ldc_I4_4);                      break;                  case 5:                      gen.Emit(OpCodes.Ldc_I4_5);                      break;                  case 6:                      gen.Emit(OpCodes.Ldc_I4_6);                      break;                  case 7:                      gen.Emit(OpCodes.Ldc_I4_7);                      break;                  case 8:                      gen.Emit(OpCodes.Ldc_I4_8);                      break;                  default:                      if (constant <= 127)                      {                          gen.Emit(OpCodes.Ldc_I4_S' constant);                      }                      else                      {                          gen.Emit(OpCodes.Ldc_I4' constant);                      }                      break;              }
Magic Number,Effort.Internal.TypeGeneration,DataRowFactory,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\TypeGeneration\DataRowFactory.cs,GenerateLdc_I4,The following statement contains a magic number: switch (constant)              {                  case 0:                      gen.Emit(OpCodes.Ldc_I4_0);                      break;                  case 1:                      gen.Emit(OpCodes.Ldc_I4_1);                      break;                  case 2:                      gen.Emit(OpCodes.Ldc_I4_2);                      break;                  case 3:                      gen.Emit(OpCodes.Ldc_I4_3);                      break;                  case 4:                      gen.Emit(OpCodes.Ldc_I4_4);                      break;                  case 5:                      gen.Emit(OpCodes.Ldc_I4_5);                      break;                  case 6:                      gen.Emit(OpCodes.Ldc_I4_6);                      break;                  case 7:                      gen.Emit(OpCodes.Ldc_I4_7);                      break;                  case 8:                      gen.Emit(OpCodes.Ldc_I4_8);                      break;                  default:                      if (constant <= 127)                      {                          gen.Emit(OpCodes.Ldc_I4_S' constant);                      }                      else                      {                          gen.Emit(OpCodes.Ldc_I4' constant);                      }                      break;              }
Magic Number,Effort.Internal.TypeGeneration,DataRowFactory,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\TypeGeneration\DataRowFactory.cs,GenerateLdc_I4,The following statement contains a magic number: switch (constant)              {                  case 0:                      gen.Emit(OpCodes.Ldc_I4_0);                      break;                  case 1:                      gen.Emit(OpCodes.Ldc_I4_1);                      break;                  case 2:                      gen.Emit(OpCodes.Ldc_I4_2);                      break;                  case 3:                      gen.Emit(OpCodes.Ldc_I4_3);                      break;                  case 4:                      gen.Emit(OpCodes.Ldc_I4_4);                      break;                  case 5:                      gen.Emit(OpCodes.Ldc_I4_5);                      break;                  case 6:                      gen.Emit(OpCodes.Ldc_I4_6);                      break;                  case 7:                      gen.Emit(OpCodes.Ldc_I4_7);                      break;                  case 8:                      gen.Emit(OpCodes.Ldc_I4_8);                      break;                  default:                      if (constant <= 127)                      {                          gen.Emit(OpCodes.Ldc_I4_S' constant);                      }                      else                      {                          gen.Emit(OpCodes.Ldc_I4' constant);                      }                      break;              }
Magic Number,Effort.Internal.TypeGeneration,TypeCacheEntryKey,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\TypeGeneration\DataRowFactory.cs,GetHashCode,The following statement contains a magic number: for (int i = 0; i < this.names.Length; i++)                  {                      hash = this.names[i].GetHashCode() ^ this.types[i].GetHashCode();                        // Rotate and mod2 addition                      result = result ^ ((hash << (i % 32)) | (hash >> (32 - (i % 32))));                  }
Magic Number,Effort.Internal.TypeGeneration,TypeCacheEntryKey,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\TypeGeneration\DataRowFactory.cs,GetHashCode,The following statement contains a magic number: for (int i = 0; i < this.names.Length; i++)                  {                      hash = this.names[i].GetHashCode() ^ this.types[i].GetHashCode();                        // Rotate and mod2 addition                      result = result ^ ((hash << (i % 32)) | (hash >> (32 - (i % 32))));                  }
Magic Number,Effort.Internal.TypeGeneration,TypeCacheEntryKey,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\TypeGeneration\DataRowFactory.cs,GetHashCode,The following statement contains a magic number: for (int i = 0; i < this.names.Length; i++)                  {                      hash = this.names[i].GetHashCode() ^ this.types[i].GetHashCode();                        // Rotate and mod2 addition                      result = result ^ ((hash << (i % 32)) | (hash >> (32 - (i % 32))));                  }
Magic Number,Effort.Provider,EffortProviderManifest,C:\repos\tamasflamich_effort\Main\Source\Effort\Provider\EffortProviderManifest.cs,ConvertTypeUsage,The following statement contains a magic number: switch (goal.PrimitiveTypeKind)              {                  case PrimitiveTypeKind.DateTime:                        if (!TypeUsageHelper.TryGetPrecision(original' out precision))                      {                          precision = 7;                      }                        return TypeUsage.CreateDateTimeTypeUsage(goal' precision);                    case PrimitiveTypeKind.DateTimeOffset:                        if (!TypeUsageHelper.TryGetPrecision(original' out precision))                      {                          precision = 7;                      }                        return TypeUsage.CreateDateTimeOffsetTypeUsage(goal' precision);                    case PrimitiveTypeKind.Time:                        if (!TypeUsageHelper.TryGetPrecision(original' out precision))                      {                          precision = 7;                      }                        return TypeUsage.CreateTimeTypeUsage(goal' precision);                    case PrimitiveTypeKind.Decimal:                        if (!TypeUsageHelper.TryGetPrecision(original' out precision))                      {                          precision = 18;                      }                        if (!TypeUsageHelper.TryGetScale(original' out scale))                      {                          scale = 0;                      }                        return TypeUsage.CreateDecimalTypeUsage(goal' precision' scale);                    case PrimitiveTypeKind.Binary:                        if (!TypeUsageHelper.TryGetIsFixedLength(original' out isFixed))                      {                          isFixed = false;                      }                        if (TypeUsageHelper.TryGetMaxLength(original' out maxLength))                      {                          return TypeUsage.CreateBinaryTypeUsage(goal' isFixed' maxLength);                      }                      else                      {                          return TypeUsage.CreateBinaryTypeUsage(goal' isFixed);                      }                    case PrimitiveTypeKind.String:                        if (!TypeUsageHelper.TryGetIsFixedLength(original' out isFixed))                      {                          isFixed = false;                      }                        if (!TypeUsageHelper.TryGetIsUnicode(original' out isUnicode))                      {                          isUnicode = true;                      }                        if (TypeUsageHelper.TryGetMaxLength(original' out maxLength))                      {                          return                              TypeUsage.CreateStringTypeUsage(                                  goal'                                  isUnicode'                                  isFixed'                                  maxLength);                      }                      else                      {                          return                              TypeUsage.CreateStringTypeUsage(                                  goal'                                  isUnicode'                                  isFixed);                      }              }
Magic Number,Effort.Provider,EffortProviderManifest,C:\repos\tamasflamich_effort\Main\Source\Effort\Provider\EffortProviderManifest.cs,ConvertTypeUsage,The following statement contains a magic number: switch (goal.PrimitiveTypeKind)              {                  case PrimitiveTypeKind.DateTime:                        if (!TypeUsageHelper.TryGetPrecision(original' out precision))                      {                          precision = 7;                      }                        return TypeUsage.CreateDateTimeTypeUsage(goal' precision);                    case PrimitiveTypeKind.DateTimeOffset:                        if (!TypeUsageHelper.TryGetPrecision(original' out precision))                      {                          precision = 7;                      }                        return TypeUsage.CreateDateTimeOffsetTypeUsage(goal' precision);                    case PrimitiveTypeKind.Time:                        if (!TypeUsageHelper.TryGetPrecision(original' out precision))                      {                          precision = 7;                      }                        return TypeUsage.CreateTimeTypeUsage(goal' precision);                    case PrimitiveTypeKind.Decimal:                        if (!TypeUsageHelper.TryGetPrecision(original' out precision))                      {                          precision = 18;                      }                        if (!TypeUsageHelper.TryGetScale(original' out scale))                      {                          scale = 0;                      }                        return TypeUsage.CreateDecimalTypeUsage(goal' precision' scale);                    case PrimitiveTypeKind.Binary:                        if (!TypeUsageHelper.TryGetIsFixedLength(original' out isFixed))                      {                          isFixed = false;                      }                        if (TypeUsageHelper.TryGetMaxLength(original' out maxLength))                      {                          return TypeUsage.CreateBinaryTypeUsage(goal' isFixed' maxLength);                      }                      else                      {                          return TypeUsage.CreateBinaryTypeUsage(goal' isFixed);                      }                    case PrimitiveTypeKind.String:                        if (!TypeUsageHelper.TryGetIsFixedLength(original' out isFixed))                      {                          isFixed = false;                      }                        if (!TypeUsageHelper.TryGetIsUnicode(original' out isUnicode))                      {                          isUnicode = true;                      }                        if (TypeUsageHelper.TryGetMaxLength(original' out maxLength))                      {                          return                              TypeUsage.CreateStringTypeUsage(                                  goal'                                  isUnicode'                                  isFixed'                                  maxLength);                      }                      else                      {                          return                              TypeUsage.CreateStringTypeUsage(                                  goal'                                  isUnicode'                                  isFixed);                      }              }
Magic Number,Effort.Provider,EffortProviderManifest,C:\repos\tamasflamich_effort\Main\Source\Effort\Provider\EffortProviderManifest.cs,ConvertTypeUsage,The following statement contains a magic number: switch (goal.PrimitiveTypeKind)              {                  case PrimitiveTypeKind.DateTime:                        if (!TypeUsageHelper.TryGetPrecision(original' out precision))                      {                          precision = 7;                      }                        return TypeUsage.CreateDateTimeTypeUsage(goal' precision);                    case PrimitiveTypeKind.DateTimeOffset:                        if (!TypeUsageHelper.TryGetPrecision(original' out precision))                      {                          precision = 7;                      }                        return TypeUsage.CreateDateTimeOffsetTypeUsage(goal' precision);                    case PrimitiveTypeKind.Time:                        if (!TypeUsageHelper.TryGetPrecision(original' out precision))                      {                          precision = 7;                      }                        return TypeUsage.CreateTimeTypeUsage(goal' precision);                    case PrimitiveTypeKind.Decimal:                        if (!TypeUsageHelper.TryGetPrecision(original' out precision))                      {                          precision = 18;                      }                        if (!TypeUsageHelper.TryGetScale(original' out scale))                      {                          scale = 0;                      }                        return TypeUsage.CreateDecimalTypeUsage(goal' precision' scale);                    case PrimitiveTypeKind.Binary:                        if (!TypeUsageHelper.TryGetIsFixedLength(original' out isFixed))                      {                          isFixed = false;                      }                        if (TypeUsageHelper.TryGetMaxLength(original' out maxLength))                      {                          return TypeUsage.CreateBinaryTypeUsage(goal' isFixed' maxLength);                      }                      else                      {                          return TypeUsage.CreateBinaryTypeUsage(goal' isFixed);                      }                    case PrimitiveTypeKind.String:                        if (!TypeUsageHelper.TryGetIsFixedLength(original' out isFixed))                      {                          isFixed = false;                      }                        if (!TypeUsageHelper.TryGetIsUnicode(original' out isUnicode))                      {                          isUnicode = true;                      }                        if (TypeUsageHelper.TryGetMaxLength(original' out maxLength))                      {                          return                              TypeUsage.CreateStringTypeUsage(                                  goal'                                  isUnicode'                                  isFixed'                                  maxLength);                      }                      else                      {                          return                              TypeUsage.CreateStringTypeUsage(                                  goal'                                  isUnicode'                                  isFixed);                      }              }
Magic Number,Effort.Provider,EffortProviderManifest,C:\repos\tamasflamich_effort\Main\Source\Effort\Provider\EffortProviderManifest.cs,ConvertTypeUsage,The following statement contains a magic number: switch (goal.PrimitiveTypeKind)              {                  case PrimitiveTypeKind.DateTime:                        if (!TypeUsageHelper.TryGetPrecision(original' out precision))                      {                          precision = 7;                      }                        return TypeUsage.CreateDateTimeTypeUsage(goal' precision);                    case PrimitiveTypeKind.DateTimeOffset:                        if (!TypeUsageHelper.TryGetPrecision(original' out precision))                      {                          precision = 7;                      }                        return TypeUsage.CreateDateTimeOffsetTypeUsage(goal' precision);                    case PrimitiveTypeKind.Time:                        if (!TypeUsageHelper.TryGetPrecision(original' out precision))                      {                          precision = 7;                      }                        return TypeUsage.CreateTimeTypeUsage(goal' precision);                    case PrimitiveTypeKind.Decimal:                        if (!TypeUsageHelper.TryGetPrecision(original' out precision))                      {                          precision = 18;                      }                        if (!TypeUsageHelper.TryGetScale(original' out scale))                      {                          scale = 0;                      }                        return TypeUsage.CreateDecimalTypeUsage(goal' precision' scale);                    case PrimitiveTypeKind.Binary:                        if (!TypeUsageHelper.TryGetIsFixedLength(original' out isFixed))                      {                          isFixed = false;                      }                        if (TypeUsageHelper.TryGetMaxLength(original' out maxLength))                      {                          return TypeUsage.CreateBinaryTypeUsage(goal' isFixed' maxLength);                      }                      else                      {                          return TypeUsage.CreateBinaryTypeUsage(goal' isFixed);                      }                    case PrimitiveTypeKind.String:                        if (!TypeUsageHelper.TryGetIsFixedLength(original' out isFixed))                      {                          isFixed = false;                      }                        if (!TypeUsageHelper.TryGetIsUnicode(original' out isUnicode))                      {                          isUnicode = true;                      }                        if (TypeUsageHelper.TryGetMaxLength(original' out maxLength))                      {                          return                              TypeUsage.CreateStringTypeUsage(                                  goal'                                  isUnicode'                                  isFixed'                                  maxLength);                      }                      else                      {                          return                              TypeUsage.CreateStringTypeUsage(                                  goal'                                  isUnicode'                                  isFixed);                      }              }
Missing Default,Effort.Internal.DbCommandTreeTransformation,TransformVisitor,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbCommandTreeTransformation\TransformVisitor.In.cs,Visit,The following switch statement is missing a default case: switch (expression.ExpressionKind)              {                  case DbExpressionKind.Plus:                      return Expression.Add(args[0]' args[1]);                    case DbExpressionKind.Minus:                      return Expression.Subtract(args[0]' args[1]);                    case DbExpressionKind.Multiply:                      return Expression.Multiply(args[0]' args[1]);                    case DbExpressionKind.Divide:                      return Expression.Divide(args[0]' args[1]);                    case DbExpressionKind.Modulo:                      return Expression.Modulo(args[0]' args[1]);                    case DbExpressionKind.UnaryMinus:                      return Expression.Negate(args[0]);              }
Missing Default,Effort.Internal.DbCommandTreeTransformation,TransformVisitor,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbCommandTreeTransformation\TransformVisitor.In.cs,GetCompareMode,The following switch statement is missing a default case: switch (kind)              {                  case DbExpressionKind.Equals:                      return Tuple.Create(0' true);                  case DbExpressionKind.NotEquals:                      return Tuple.Create(0' false);                  case DbExpressionKind.GreaterThan:                      return Tuple.Create(1' true);                  case DbExpressionKind.GreaterThanOrEquals:                      return Tuple.Create(-1' false);                  case DbExpressionKind.LessThan:                      return Tuple.Create(-1' true);                  case DbExpressionKind.LessThanOrEquals:                      return Tuple.Create(1' false);              }
Missing Default,Effort.Internal.DbCommandTreeTransformation,CanonicalFunctionMapper,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\DbCommandTreeTransformation\CanonicalFunctions.cs,MapRound,The following switch statement is missing a default case: switch(args.Length)              {                  case 1:                      method = IsDecimal(f.Parameters[0]) ?                          DecimalFunctions.Round :                          DoubleFunctions.Round;                      break;                  case 2:                      method = IsDecimal(f.Parameters[0]) ?                          DecimalFunctions.RoundDigits :                          DoubleFunctions.RoundDigits;                      break;              }
Missing Default,Effort.Internal.TypeConversion,EdmTypeConverter,C:\repos\tamasflamich_effort\Main\Source\Effort\Internal\TypeConversion\EdmTypeConverter.cs,GetTypeFacets,The following switch statement is missing a default case: switch ((StoreGeneratedPattern)facet.Value)                  {                      case StoreGeneratedPattern.Computed:                          facets.Computed = true;                          break;                      case StoreGeneratedPattern.Identity:                          facets.Identity = true;                          break;                  }
Missing Default,Effort.Provider,EffortProviderManifest,C:\repos\tamasflamich_effort\Main\Source\Effort\Provider\EffortProviderManifest.cs,ConvertTypeUsage,The following switch statement is missing a default case: switch (goal.PrimitiveTypeKind)              {                  case PrimitiveTypeKind.DateTime:                        if (!TypeUsageHelper.TryGetPrecision(original' out precision))                      {                          precision = 7;                      }                        return TypeUsage.CreateDateTimeTypeUsage(goal' precision);                    case PrimitiveTypeKind.DateTimeOffset:                        if (!TypeUsageHelper.TryGetPrecision(original' out precision))                      {                          precision = 7;                      }                        return TypeUsage.CreateDateTimeOffsetTypeUsage(goal' precision);                    case PrimitiveTypeKind.Time:                        if (!TypeUsageHelper.TryGetPrecision(original' out precision))                      {                          precision = 7;                      }                        return TypeUsage.CreateTimeTypeUsage(goal' precision);                    case PrimitiveTypeKind.Decimal:                        if (!TypeUsageHelper.TryGetPrecision(original' out precision))                      {                          precision = 18;                      }                        if (!TypeUsageHelper.TryGetScale(original' out scale))                      {                          scale = 0;                      }                        return TypeUsage.CreateDecimalTypeUsage(goal' precision' scale);                    case PrimitiveTypeKind.Binary:                        if (!TypeUsageHelper.TryGetIsFixedLength(original' out isFixed))                      {                          isFixed = false;                      }                        if (TypeUsageHelper.TryGetMaxLength(original' out maxLength))                      {                          return TypeUsage.CreateBinaryTypeUsage(goal' isFixed' maxLength);                      }                      else                      {                          return TypeUsage.CreateBinaryTypeUsage(goal' isFixed);                      }                    case PrimitiveTypeKind.String:                        if (!TypeUsageHelper.TryGetIsFixedLength(original' out isFixed))                      {                          isFixed = false;                      }                        if (!TypeUsageHelper.TryGetIsUnicode(original' out isUnicode))                      {                          isUnicode = true;                      }                        if (TypeUsageHelper.TryGetMaxLength(original' out maxLength))                      {                          return                              TypeUsage.CreateStringTypeUsage(                                  goal'                                  isUnicode'                                  isFixed'                                  maxLength);                      }                      else                      {                          return                              TypeUsage.CreateStringTypeUsage(                                  goal'                                  isUnicode'                                  isFixed);                      }              }
