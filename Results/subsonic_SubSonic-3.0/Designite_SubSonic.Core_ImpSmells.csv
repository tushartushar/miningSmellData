Implementation smell,Namespace,Class,File,Method,Description
Long Method,SubSonic.Linq.Structure,TSqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\TSqlFormatter.cs,VisitMethodCall,The method has 381 lines of code.
Long Method,SubSonic.Linq.Structure,TSqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\TSqlFormatter.cs,VisitBinary,The method has 155 lines of code.
Long Method,SubSonic.DataProviders.MySQL,MySqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\MySQL\MySqlFormatter.cs,VisitMethodCall,The method has 252 lines of code.
Long Method,SubSonic.DataProviders.SQLite,SQLiteFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\SQLite\SQLiteFormatter.cs,VisitMethodCall,The method has 233 lines of code.
Long Method,SubSonic.Linq.Translation,QueryBinder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\QueryBinder.cs,VisitMethodCall,The method has 156 lines of code.
Long Method,SubSonic.Extensions,Objects,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Objects.cs,ToSchemaTable,The method has 102 lines of code.
Long Method,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The method has 254 lines of code.
Long Method,SubSonic.SqlGeneration,ANSISqlGenerator,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\SQLGeneration\ANSISqlGenerator.cs,GenerateConstraints,The method has 143 lines of code.
Complex Method,SubSonic.DataProviders,DbDataProvider,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\DbDataProvider.cs,AddParams,Cyclomatic complexity of the method is 8
Complex Method,SubSonic.Linq.Structure,DbExpressionComparer,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\DbExpressionComparer.cs,Compare,Cyclomatic complexity of the method is 17
Complex Method,SubSonic.Linq.Structure,DbExpressionVisitor,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\DbExpressionVisitor.cs,Visit,Cyclomatic complexity of the method is 16
Complex Method,SubSonic.Linq.Structure,DbExpressionWriter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\DbExpressionWriter.cs,Visit,Cyclomatic complexity of the method is 8
Complex Method,SubSonic.Linq.Structure,QueryMapping,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\QueryMapping.cs,GetAggregator,Cyclomatic complexity of the method is 8
Complex Method,SubSonic.Linq.Structure,TSqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\TSqlFormatter.cs,VisitMemberAccess,Cyclomatic complexity of the method is 11
Complex Method,SubSonic.Linq.Structure,TSqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\TSqlFormatter.cs,VisitMethodCall,Cyclomatic complexity of the method is 61
Complex Method,SubSonic.Linq.Structure,TSqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\TSqlFormatter.cs,VisitBinary,Cyclomatic complexity of the method is 24
Complex Method,SubSonic.Linq.Structure,TSqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\TSqlFormatter.cs,GetOperator,Cyclomatic complexity of the method is 15
Complex Method,SubSonic.Linq.Structure,TSqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\TSqlFormatter.cs,WriteValue,Cyclomatic complexity of the method is 15
Complex Method,SubSonic.Linq.Structure,TSqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\TSqlFormatter.cs,VisitSelect,Cyclomatic complexity of the method is 17
Complex Method,SubSonic.Linq.Structure,ExpressionComparer,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\ExpressionComparer.cs,Compare,Cyclomatic complexity of the method is 19
Complex Method,SubSonic.Linq.Structure,ExpressionComparer,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\ExpressionComparer.cs,CompareBinding,Cyclomatic complexity of the method is 8
Complex Method,SubSonic.Linq.Structure,ExpressionVisitor,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\ExpressionVisitor.cs,Visit,Cyclomatic complexity of the method is 16
Complex Method,SubSonic.Linq.Structure,ExpressionWriter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\ExpressionWriter.cs,GetOperator,Cyclomatic complexity of the method is 21
Complex Method,SubSonic.Linq.Structure,TypeHelper,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\TypeHelper.cs,FindIEnumerable,Cyclomatic complexity of the method is 10
Complex Method,SubSonic.DataProviders.MySQL,MySqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\MySQL\MySqlFormatter.cs,VisitMemberAccess,Cyclomatic complexity of the method is 11
Complex Method,SubSonic.DataProviders.MySQL,MySqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\MySQL\MySqlFormatter.cs,VisitMethodCall,Cyclomatic complexity of the method is 38
Complex Method,SubSonic.DataProviders.MySQL,MySqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\MySQL\MySqlFormatter.cs,VisitSelect,Cyclomatic complexity of the method is 17
Complex Method,SubSonic.DataProviders.MySQL,MySqlGenerator,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\MySQL\MySqlGenerator.cs,GetNativeType,Cyclomatic complexity of the method is 14
Complex Method,SubSonic.DataProviders.MySQL,MySqlSchema,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\MySQL\MySqlSchema.cs,GetNativeType,Cyclomatic complexity of the method is 13
Complex Method,SubSonic.DataProviders.MySQL,MySqlSchema,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\MySQL\MySqlSchema.cs,GenerateColumnAttributes,Cyclomatic complexity of the method is 9
Complex Method,SubSonic.DataProviders.MySQL,MySqlSchema,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\MySQL\MySqlSchema.cs,GetDbType,Cyclomatic complexity of the method is 15
Complex Method,SubSonic.DataProviders.SqlServer,Sql2005Schema,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\SqlServer\Sql2005Schema.cs,GetNativeType,Cyclomatic complexity of the method is 13
Complex Method,SubSonic.DataProviders.SqlServer,Sql2005Schema,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\SqlServer\Sql2005Schema.cs,GenerateColumnAttributes,Cyclomatic complexity of the method is 10
Complex Method,SubSonic.DataProviders.SqlServer,Sql2005Schema,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\SqlServer\Sql2005Schema.cs,GetDbType,Cyclomatic complexity of the method is 27
Complex Method,SubSonic.DataProviders.SQLite,SQLiteFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\SQLite\SQLiteFormatter.cs,VisitMethodCall,Cyclomatic complexity of the method is 38
Complex Method,SubSonic.DataProviders.SQLite,SQLiteFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\SQLite\SQLiteFormatter.cs,VisitMemberAccess,Cyclomatic complexity of the method is 11
Complex Method,SubSonic.DataProviders.SQLite,SQLiteFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\SQLite\SQLiteFormatter.cs,VisitSelect,Cyclomatic complexity of the method is 17
Complex Method,SubSonic.DataProviders.SQLite,SQLiteSchema,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\SQLite\SQLiteSchema.cs,GetNativeType,Cyclomatic complexity of the method is 15
Complex Method,SubSonic.DataProviders.SQLite,SQLiteSchema,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\SQLite\SQLiteSchema.cs,GenerateColumnAttributes,Cyclomatic complexity of the method is 9
Complex Method,SubSonic.DataProviders.SQLite,SQLiteSchema,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\SQLite\SQLiteSchema.cs,GetDbType,Cyclomatic complexity of the method is 15
Complex Method,SubSonic.Linq.Translation,QueryBinder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\QueryBinder.cs,VisitMethodCall,Cyclomatic complexity of the method is 36
Complex Method,SubSonic.Linq.Translation,QueryBinder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\QueryBinder.cs,BindAggregate,Cyclomatic complexity of the method is 11
Complex Method,SubSonic.Linq.Translation,QueryBinder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\QueryBinder.cs,BindAnyAll,Cyclomatic complexity of the method is 9
Complex Method,SubSonic.Linq.Translation,QueryBinder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\QueryBinder.cs,BindMember,Cyclomatic complexity of the method is 15
Complex Method,SubSonic.Linq.Translation,RedundantColumnRemover,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\RedundantColumnRemover.cs,VisitSelect,Cyclomatic complexity of the method is 8
Complex Method,SubSonic.Linq.Translation,SubqueryMerger,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\RedundantSubqueryRemover.cs,CanMergeWithFrom,Cyclomatic complexity of the method is 10
Complex Method,SubSonic.Linq.Translation,UnusedColumnRemover,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\UnusedColumnRemover.cs,VisitSelect,Cyclomatic complexity of the method is 9
Complex Method,SubSonic.Schema,Migrator,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Schema\Migrator.cs,CreateColumnMigrationSql,Cyclomatic complexity of the method is 8
Complex Method,SubSonic.Extensions,Database,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Database.cs,GetSqlDBType,Cyclomatic complexity of the method is 25
Complex Method,SubSonic.Extensions,Database,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Database.cs,GetDbType,Cyclomatic complexity of the method is 11
Complex Method,SubSonic.Extensions,Database,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Database.cs,Load,Cyclomatic complexity of the method is 16
Complex Method,SubSonic.Extensions,Dates,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Dates.cs,ReadableDiff,Cyclomatic complexity of the method is 15
Complex Method,SubSonic.Extensions,ExpressionParser,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\ExpressionParser.cs,ProcessExpression,Cyclomatic complexity of the method is 10
Complex Method,SubSonic.Extensions,ExpressionParser,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\ExpressionParser.cs,BuildFromBinary,Cyclomatic complexity of the method is 11
Complex Method,SubSonic.Extensions,ExpressionParser,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\ExpressionParser.cs,ProcessMethodCall,Cyclomatic complexity of the method is 8
Complex Method,SubSonic.Extensions,Objects,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Objects.cs,ToSchemaTable,Cyclomatic complexity of the method is 19
Complex Method,SubSonic.Extensions,QueryVisitor,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\QueryVisitor.cs,VisitBinary,Cyclomatic complexity of the method is 23
Complex Method,SubSonic.Query,Constraint,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Query\Constraint.cs,GetComparisonOperator,Cyclomatic complexity of the method is 17
Complex Method,SubSonic.Query,SqlQuery,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Query\SqlQuery.cs,CreateJoin,Cyclomatic complexity of the method is 11
Complex Method,SubSonic.Query,TypeSystem,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Query\TypeSystem.cs,FindIEnumerable,Cyclomatic complexity of the method is 10
Complex Method,SubSonic.SqlGeneration,ANSISqlGenerator,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\SQLGeneration\ANSISqlGenerator.cs,GenerateCommandLine,Cyclomatic complexity of the method is 8
Complex Method,SubSonic.SqlGeneration,ANSISqlGenerator,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\SQLGeneration\ANSISqlGenerator.cs,GenerateConstraints,Cyclomatic complexity of the method is 24
Long Parameter List,SubSonic.Linq.Structure,SelectExpression,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\DbExpressions.cs,SelectExpression,The method has 9 parameters. Parameters: alias' columns' from' where' orderBy' groupBy' isDistinct' skip' take
Long Parameter List,SubSonic.Linq.Structure,SelectExpression,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\DbExpressions.cs,SelectExpression,The method has 6 parameters. Parameters: alias' columns' from' where' orderBy' groupBy
Long Parameter List,SubSonic.Linq.Translation,ColumnProjector,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\ColumnProjector.cs,ColumnProjector,The method has 5 parameters. Parameters: fnCanBeColumn' expression' existingColumns' newAlias' existingAliases
Long Parameter List,SubSonic.Linq.Translation,ColumnProjector,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\ColumnProjector.cs,ProjectColumns,The method has 5 parameters. Parameters: fnCanBeColumn' expression' existingColumns' newAlias' existingAliases
Long Parameter List,SubSonic.Linq.Translation,ColumnProjector,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\ColumnProjector.cs,ProjectColumns,The method has 5 parameters. Parameters: fnCanBeColumn' expression' existingColumns' newAlias' existingAliases
Long Parameter List,SubSonic.Linq.Translation,QueryBinder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\QueryBinder.cs,BindJoin,The method has 6 parameters. Parameters: resultType' outerSource' innerSource' outerKey' innerKey' resultSelector
Long Parameter List,SubSonic.Query,Constraint,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Query\Constraint.cs,Constraint,The method has 5 parameters. Parameters: condition' constraintColumnName' constraintQualifiedColumnName' constraintConstructionFragment' sqlQuery
Long Parameter List,SubSonic.Query,Join,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Query\Join.cs,Join,The method has 5 parameters. Parameters: fromTableName' fromColumnName' toTableName' toColumnName' joinType
Long Parameter List,SubSonic.Query,QueryCommand,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Query\QueryCommand.cs,AddParameter,The method has 5 parameters. Parameters: parameterName' parameterValue' maxSize' dbType' direction
Long Identifier,SubSonic.Extensions,RegexPattern,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\RegexPattern.cs,,The length of the parameter EMBEDDED_CLASS_NAME_UNDERSCORE_MATCH is 36.
Long Identifier,SubSonic.Extensions,RegexPattern,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\RegexPattern.cs,,The length of the parameter EMBEDDED_CLASS_NAME_UNDERSCORE_REPLACE is 38.
Long Identifier,SubSonic.Query,Constraint,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Query\Constraint.cs,Constraint,The length of the parameter constraintConstructionFragment is 30.
Long Identifier,SubSonic.Query,Constraint,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Query\Constraint.cs,Constraint,The length of the parameter constraintConstructionFragment is 30.
Long Statement,SubSonic.DataProviders,DynamicProxyInterceptionStrategy,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\IInterceptionStrategy.cs,Intercept,The length of the statement  "            return Generator.CreateClassProxyWithTarget(objectToIntercept.GetType()' objectToIntercept' ProxyGenerationOptions.Default' interceptor); " is 137.
Long Statement,SubSonic.DataProviders,DbDataProvider,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\DbDataProvider.cs,FindTable,The length of the statement  "            //    throw new InvalidOperationException("The schema hasn't been loaded by this provider. This is usually done by the constructor of the 'QuerySurface' or 'DataContext' provided by " + " is 185.
Long Statement,SubSonic.DataProviders,DbDataProvider,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\DbDataProvider.cs,FindTable,The length of the statement  "            var result = Schema.Tables.FirstOrDefault(x => x.Name.Equals(tableName' StringComparison.InvariantCultureIgnoreCase)) ?? " is 120.
Long Statement,SubSonic.DataProviders,ProviderFactory,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\ProviderFactory.cs,GetProvider,The length of the statement  "            string connString = ConfigurationManager.ConnectionStrings[ConfigurationManager.ConnectionStrings.Count - 1].ConnectionString; " is 126.
Long Statement,SubSonic.DataProviders,ProviderFactory,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\ProviderFactory.cs,GetProvider,The length of the statement  "            string providerName = ConfigurationManager.ConnectionStrings[ConfigurationManager.ConnectionStrings.Count - 1].ProviderName; " is 124.
Long Statement,SubSonic.DataProviders,ProviderFactory,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\ProviderFactory.cs,LoadProvider,The length of the statement  "                throw new InvalidOperationException(String.Format("Could not create a IDataProvider for providerName {0}"' providerName)); " is 122.
Long Statement,SubSonic.Linq.Structure,DbExpressionExtensions,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\DbExpressions.cs,SetColumns,The length of the statement  "            return new SelectExpression(select.Alias' columns.OrderBy(c => c.Name)' select.From' select.Where' select.OrderBy' select.GroupBy' select.IsDistinct' select.Skip' select.Take); " is 176.
Long Statement,SubSonic.Linq.Structure,DbExpressionExtensions,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\DbExpressions.cs,AddOuterJoinTest,The length of the statement  "            SelectExpression newSource = proj.Source.AddColumn(new ColumnDeclaration(colName' Expression.Constant(1' typeof(int?)))); " is 121.
Long Statement,SubSonic.Linq.Structure,DbExpressionExtensions,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\DbExpressions.cs,SetDistinct,The length of the statement  "                return new SelectExpression(select.Alias' select.Columns' select.From' select.Where' select.OrderBy' select.GroupBy' isDistinct' select.Skip' select.Take); " is 155.
Long Statement,SubSonic.Linq.Structure,DbExpressionExtensions,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\DbExpressions.cs,SetWhere,The length of the statement  "                return new SelectExpression(select.Alias' select.Columns' select.From' where' select.OrderBy' select.GroupBy' select.IsDistinct' select.Skip' select.Take); " is 155.
Long Statement,SubSonic.Linq.Structure,DbExpressionExtensions,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\DbExpressions.cs,SetOrderBy,The length of the statement  "            return new SelectExpression(select.Alias' select.Columns' select.From' select.Where' orderBy' select.GroupBy' select.IsDistinct' select.Skip' select.Take); " is 155.
Long Statement,SubSonic.Linq.Structure,DbExpressionExtensions,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\DbExpressions.cs,SetGroupBy,The length of the statement  "            return new SelectExpression(select.Alias' select.Columns' select.From' select.Where' select.OrderBy' groupBy' select.IsDistinct' select.Skip' select.Take); " is 155.
Long Statement,SubSonic.Linq.Structure,DbExpressionExtensions,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\DbExpressions.cs,SetSkip,The length of the statement  "                return new SelectExpression(select.Alias' select.Columns' select.From' select.Where' select.OrderBy' select.GroupBy' select.IsDistinct' skip' select.Take); " is 155.
Long Statement,SubSonic.Linq.Structure,DbExpressionExtensions,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\DbExpressions.cs,SetTake,The length of the statement  "                return new SelectExpression(select.Alias' select.Columns' select.From' select.Where' select.OrderBy' select.GroupBy' select.IsDistinct' select.Skip' take); " is 155.
Long Statement,SubSonic.Linq.Structure,DbExpressionExtensions,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\DbExpressions.cs,AddRedundantSelect,The length of the statement  "            var newColumns = select.Columns.Select(d => new ColumnDeclaration(d.Name' new ColumnExpression(d.Expression.Type' newAlias' d.Name))); " is 134.
Long Statement,SubSonic.Linq.Structure,DbExpressionExtensions,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\DbExpressions.cs,AddRedundantSelect,The length of the statement  "            var newFrom = new SelectExpression(newAlias' select.Columns' select.From' select.Where' select.OrderBy' select.GroupBy' select.IsDistinct' select.Skip' select.Take); " is 165.
Long Statement,SubSonic.Linq.Structure,DbExpressionExtensions,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\DbExpressions.cs,SetFrom,The length of the statement  "                return new SelectExpression(select.Alias' select.Columns' from' select.Where' select.OrderBy' select.GroupBy' select.IsDistinct' select.Skip' select.Take); " is 155.
Long Statement,SubSonic.Linq.Structure,ImplicitMapping,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\ImplicitMapping.cs,IsIdentity,The length of the statement  "                return member.Name.EndsWith("ID") && member.DeclaringType.Name.StartsWith(member.Name.Substring(0' member.Name.Length - 2));  " is 124.
Long Statement,SubSonic.Linq.Structure,QueryMapping,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\QueryMapping.cs,GetMappedMembers,The length of the statement  "            HashSet<MemberInfo> members = new HashSet<MemberInfo>(rowType.GetProperties().Cast<MemberInfo>().Where(m => this.IsMapped(m))); " is 127.
Long Statement,SubSonic.Linq.Structure,QueryMapping,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\QueryMapping.cs,GetMemberExpression,The length of the statement  "                var pc = ColumnProjector.ProjectColumns(this.Language.CanBeColumn' projection.Projector' null' newAlias' projection.Source.Alias); " is 130.
Long Statement,SubSonic.Linq.Structure,QueryMapping,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\QueryMapping.cs,GetMemberExpression,The length of the statement  "                LambdaExpression aggregator = this.GetAggregator(TypeHelper.GetMemberType(member)' typeof(IEnumerable<>).MakeGenericType(pc.Projector.Type)); " is 141.
Long Statement,SubSonic.Linq.Structure,QueryMapping,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\QueryMapping.cs,GetAggregator,The length of the statement  "                    body = Expression.Call(typeof(Queryable)' "AsQueryable"' new Type[] { expectedElementType }' CoerceElement(expectedElementType' p)); " is 132.
Long Statement,SubSonic.Linq.Structure,QueryMapping,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\QueryMapping.cs,GetAggregator,The length of the statement  "                    body = Expression.Call(typeof(Enumerable)' "ToArray"' new Type[] { expectedElementType }' CoerceElement(expectedElementType' p)); " is 129.
Long Statement,SubSonic.Linq.Structure,QueryMapping,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\QueryMapping.cs,GetAggregator,The length of the statement  "                    body = Expression.Call(typeof(Enumerable)' "ToList"' new Type[] { expectedElementType }' CoerceElement(expectedElementType' p)); " is 128.
Long Statement,SubSonic.Linq.Structure,QueryMapping,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\QueryMapping.cs,CoerceElement,The length of the statement  "            if (expectedElementType != elementType && (expectedElementType.IsAssignableFrom(elementType) || elementType.IsAssignableFrom(expectedElementType))) " is 147.
Long Statement,SubSonic.Linq.Structure,QueryCompiler,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\QueryCompiler.cs,Compile,The length of the statement  "            var args = Expression.NewArrayInit(typeof(object)' pexprs.Select(p => Expression.Convert(p' typeof(object))).ToArray()); " is 120.
Long Statement,SubSonic.Linq.Structure,QueryCompiler,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\QueryCompiler.cs,Compile,The length of the statement  "            Expression body = Expression.Convert(Expression.Call(Expression.Constant(cq)' "Invoke"' Type.EmptyTypes' args)' method.ReturnType); " is 131.
Long Statement,SubSonic.Linq.Structure,QueryProvider,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\QueryProvider.cs,CreateQuery,The length of the statement  "                return (IQueryable)Activator.CreateInstance(typeof(Query<>).MakeGenericType(elementType)' new object[] { this' expression }); " is 125.
Long Statement,SubSonic.DataProviders.SQLite,SQLiteSchema,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\SQLite\SQLiteSchema.cs,BuildDropColumnStatement,The length of the statement  "            Console.WriteLine("Can't drop a column from SQLite - you have to do this manually: http://grass.osgeo.org/wiki/Sqlite_Drop_Column"); " is 132.
Long Statement,SubSonic.Linq.Translation,AggregateRewriter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\AggregateRewriter.cs,VisitSelect,The length of the statement  "                return new SelectExpression(select.Alias' aggColumns' select.From' select.Where' select.OrderBy' select.GroupBy' select.IsDistinct' select.Skip' select.Take); " is 158.
Long Statement,SubSonic.Linq.Translation,ClientJoinedProjectionRewriter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\ClientJoinedProjectionRewriter.cs,VisitProjection,The length of the statement  "                        var pc = ColumnProjector.ProjectColumns(this.language.CanBeColumn' newProjector' newOuterSelect.Columns' newAlias' newOuterSelect.Alias' newInnerSelect.Alias); " is 159.
Long Statement,SubSonic.Linq.Translation,ClientJoinedProjectionRewriter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\ClientJoinedProjectionRewriter.cs,VisitProjection,The length of the statement  "                        SelectExpression joinedSelect = new SelectExpression(newAlias' pc.Columns' join' null' null' null' proj.IsSingleton' null' null); " is 129.
Long Statement,SubSonic.Linq.Translation,CrossApplyRewriter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\CrossApplyRewriter.cs,VisitJoin,The length of the statement  "                    //   3) and has no behavior that would change semantics if the where clause is removed (like groups' aggregates' take' skip' etc). " is 130.
Long Statement,SubSonic.Linq.Translation,CrossApplyRewriter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\CrossApplyRewriter.cs,VisitJoin,The length of the statement  "                            var pc = ColumnProjector.ProjectColumns(this.CanBeColumn' where' select.Columns' select.Alias' DeclaredAliasGatherer.Gather(select.From)); " is 138.
Long Statement,SubSonic.Linq.Translation,CrossApplyRewriter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\CrossApplyRewriter.cs,VisitJoin,The length of the statement  "                            JoinType jt = (where == null) ? JoinType.CrossJoin : (join.Join == JoinType.CrossApply ? JoinType.InnerJoin : JoinType.LeftOuter); " is 130.
Long Statement,SubSonic.Linq.Translation,OrderByRewriter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\OrderByRewriter.cs,VisitSelect,The length of the statement  "                    select = new SelectExpression(select.Alias' columns' select.From' select.Where' orderings' select.GroupBy' select.IsDistinct' select.Skip' select.Take); " is 152.
Long Statement,SubSonic.Linq.Translation,QueryBinder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\QueryBinder.cs,BindAggregate,The length of the statement  "                // check for easy to optimize case.  If the projection that our aggregate is based on is really the 'group' argument from " is 121.
Long Statement,SubSonic.Linq.Translation,QueryDuplicator,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\QueryDuplicator.cs,VisitSelect,The length of the statement  "            return new SelectExpression(newAlias' select.Columns' select.From' select.Where' select.OrderBy' select.GroupBy' select.IsDistinct' select.Skip' select.Take); " is 158.
Long Statement,SubSonic.Linq.Translation,SubqueryMerger,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\RedundantSubqueryRemover.cs,VisitSelect,The length of the statement  "                        select = new SelectExpression(select.Alias' select.Columns' select.From' where' orderBy' groupBy' isDistinct' skip' take); " is 122.
Long Statement,SubSonic.Linq.Translation,SubqueryMerger,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\RedundantSubqueryRemover.cs,CanMergeWithFrom,The length of the statement  "                if (frmHasGroupBy /*&& (select.Where != null)*/) // need to assert projection is the same in order to move group-by forward " is 123.
Long Statement,SubSonic.Linq.Translation,SubqueryMerger,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\RedundantSubqueryRemover.cs,CanMergeWithFrom,The length of the statement  "                if (fromSelect.Take != null && (select.Take != null || select.Skip != null || select.IsDistinct || selHasAggregates || selHasGroupBy)) " is 134.
Long Statement,SubSonic.Linq.Translation,SubqueryMerger,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\RedundantSubqueryRemover.cs,CanMergeWithFrom,The length of the statement  "                if (fromSelect.IsDistinct && (select.Take != null || select.Skip != null || !selHasNameMapProjection || selHasGroupBy || selHasAggregates || (selHasOrderBy && !isTopLevel))) " is 173.
Long Statement,SubSonic.Linq.Translation,RelationshipBinder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\RelationshipBinder.cs,VisitSelect,The length of the statement  "                    return new SelectExpression(select.Alias' columns' this.currentFrom' where' orderBy' groupBy' select.IsDistinct' skip' take); " is 125.
Long Statement,SubSonic.Linq.Translation,RelationshipIncluder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\RelationshipIncluder.cs,VisitMemberInit,The length of the statement  "                            throw new NotSupportedException(string.Format("Cannot include '{0}.{1}' recursively."' mi.DeclaringType.Name' mi.Name)); " is 120.
Long Statement,SubSonic.Linq.Translation,SkipRewriter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\SkipRewriter.cs,VisitSelect,The length of the statement  "                    where = new BetweenExpression(rnCol' Expression.Add(select.Skip' Expression.Constant(1))' Expression.Add(select.Skip' select.Take)); " is 132.
Long Statement,SubSonic.Extensions,Database,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Database.cs,ToEnumerable,The length of the statement  "							//http://stackoverflow.com/questions/478013/how-do-i-create-and-access-a-new-instance-of-an-anonymous-class-passed-as-a-param " is 125.
Long Statement,SubSonic.Extensions,Objects,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Objects.cs,ChangeTypeTo,The length of the statement  "                throw  new InvalidOperationException("Can't convert an Int64 (long) to Int32(int). If you're using SQLite - this is probably due to your PK being an INTEGER' which is 64bit. You'll need to set your key to long."); " is 213.
Long Statement,SubSonic.Extensions,Objects,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Objects.cs,ToSchemaTable,The length of the statement  "                            "Property {0} of type {1} marked as relation must be declared virtual to allow dynamic proxy mechanisms work correctly!"' " is 121.
Long Statement,SubSonic.Extensions,Objects,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Objects.cs,ToSchemaTable,The length of the statement  "                throw new InvalidOperationException("Can't decide which property to consider the Key - you can create one called 'ID' or mark one with SubSonicPrimaryKey attribute"); " is 166.
Long Statement,SubSonic.Extensions,QueryVisitor,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\QueryVisitor.cs,AddConstraint,The length of the statement  "            if (!query.Constraints.Any(x => x.ParameterName == current.ParameterName && x.ParameterValue == current.ParameterValue)) " is 120.
Long Statement,SubSonic.Extensions,QueryVisitor,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\QueryVisitor.cs,VisitMethodCall,The length of the statement  "            // TODO: Here we only support member expressions -> Extend to solve http://github.com/subsonic/SubSonic-3.0/issues#issue/59 " is 123.
Long Statement,SubSonic.Query,BatchQuery,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Query\BatchQuery.cs,ResetCommands,The length of the statement  "                    commandText = System.Text.RegularExpressions.Regex.Replace(commandText' oldParamName + @"\b"' _provider.ParameterPrefix + "p" + indexer); " is 137.
Long Statement,SubSonic.Query,Constraint,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Query\Constraint.cs,In,The length of the statement  "                throw new InvalidOperationException("You must specify a column to return for the IN to be valid. Use Select(\"column\") to do this"); " is 133.
Long Statement,SubSonic.Query,Constraint,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Query\Constraint.cs,NotIn,The length of the statement  "                throw new InvalidOperationException("You must specify a column to return for the IN to be valid. Use Select(\"column\") to do this"); " is 133.
Long Statement,SubSonic.Query,CodingHorror,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Query\InlineQuery.cs,LoadCommandParams,The length of the statement  "					"The parameter count doesn't match up with the values entered - this could be our fault with our parser; please check the list to make sure the count adds up' and if it does' please add some spacing around the parameters in the list"); " is 235.
Long Statement,SubSonic.Query,Insert,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Query\Insert.cs,AddValues,The length of the statement  "                throw new InvalidOperationException("The Select list and value list don't match - they need to match exactly if you're creating an INSERT VALUES query"); " is 153.
Long Statement,SubSonic.Query,Update,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Query\Update.cs,GetCommand,The length of the statement  "                    // EK: The line below is intentional. See: http://weblogs.asp.net/fbouma/archive/2009/06/25/linq-beware-of-the-access-to-modified-closure-demon.aspx " is 148.
Long Statement,SubSonic.Query,Update,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Query\Update.cs,GetCommand,The length of the statement  "                    var col = table.Columns.SingleOrDefault(x => x.Name.Equals(setting.ColumnName' StringComparison.InvariantCultureIgnoreCase)); " is 125.
Long Statement,SubSonic.Query,QueryCommand,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Query\QueryCommand.cs,AddParameter,The length of the statement  "            AddParameter(parameterName' parameterValue' QueryParameter.DefaultSize' dataType' QueryParameter.DefaultParameterDirection); " is 124.
Long Statement,SubSonic.Query,QueryCommand,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Query\QueryCommand.cs,AddParameter,The length of the statement  "            AddParameter(parameterName' parameterValue' QueryParameter.DefaultSize' DbType.Object' QueryParameter.DefaultParameterDirection); " is 129.
Long Statement,SubSonic.Query,QueryCommand,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Query\QueryCommand.cs,GetOutputParameters,The length of the statement  "                    if(p.Mode == ParameterDirection.InputOutput || p.Mode == ParameterDirection.Output || p.Mode == ParameterDirection.ReturnValue) " is 127.
Long Statement,SubSonic.Query,SqlQuery,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Query\SqlQuery.cs,GenerateException,The length of the statement  "                        "You're trying to connect to a database in your App_Data directory' and your SQL Server installation does not support User Instances."' " is 135.
Long Statement,SubSonic.Query,SqlQuery,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Query\SqlQuery.cs,GenerateException,The length of the statement  "                        "The joins on your query are not ordered properly - make sure you're not repeating a table in the first (or 'from') position on a join that's also specified in FROM. Also - a JOIN can't have two of the same table in the 'from' first position. Check the SQL output to see how to order this properly"' " is 299.
Long Statement,SubSonic.Query,SqlQuery,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Query\SqlQuery.cs,From,The length of the statement  "                throw new InvalidOperationException("Can't find the table " + tableName + "; suggest you use the Generics <T> to pass the From (From<T>())"); " is 141.
Long Statement,SubSonic.Query,SqlQuery,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Query\SqlQuery.cs,CreateJoin,The length of the statement  "                throw new InvalidOperationException("Can't join if there's no table to join to - make sure to use From() before InnerJoin"); " is 124.
Long Statement,SubSonic.Query,SqlQuery,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Query\SqlQuery.cs,CreateJoin,The length of the statement  "                throw new InvalidOperationException("Don't know which column to join to - can't find column " + fromColumnName + " in table " + FromTables[0].Name); " is 148.
Long Statement,SubSonic.Query,SqlQuery,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Query\SqlQuery.cs,CreateJoin,The length of the statement  "                throw new InvalidOperationException("Don't know which column to join to - can't find column " + toColumnName + " in table " + toTable.Name); " is 140.
Long Statement,SubSonic.Query,SqlQuery,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Query\SqlQuery.cs,CreateJoin,The length of the statement  "                throw new InvalidOperationException("Can't join if there's no table to join to - make sure to use From() before InnerJoin"); " is 124.
Long Statement,SubSonic.Query,SqlQuery,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Query\SqlQuery.cs,CreateJoin,The length of the statement  "                throw new InvalidOperationException("Don't know which column to join to - tried to join based on Primary Key (" + fromColumn.Name + ") but couldn't find a match"); " is 163.
Long Statement,SubSonic.SqlGeneration.Schema,SubSonicToManyRelationAttribute,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\SQLGeneration\Schema\RelationAttributes.cs,GetRelationType,The length of the statement  "                throw new InvalidOperationException("Expecting a collection type that is assignable from List<T> to use this propery as one to many collection"); " is 145.
Long Statement,SubSonic.SqlGeneration,ANSISqlGenerator,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\SQLGeneration\ANSISqlGenerator.cs,GenerateFromList,The length of the statement  "				// EK: The line below is intentional. See: http://weblogs.asp.net/fbouma/archive/2009/06/25/linq-beware-of-the-access-to-modified-closure-demon.aspx " is 148.
Complex Conditional,SubSonic.Linq.Structure,DbExpressionVisitor,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\DbExpressionVisitor.cs,VisitSelect,The conditional expression  "from != select.From                  || where != select.Where                  || orderBy != select.OrderBy                  || groupBy != select.GroupBy                  || take != select.Take                  || skip != select.Skip                  || columns != select.Columns"  is complex.
Complex Conditional,SubSonic.Linq.Structure,TSqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\TSqlFormatter.cs,VisitBinary,The conditional expression  "(mc.Method.DeclaringType == typeof(string) || mc.Method.DeclaringType == typeof(decimal))                                        && mc.Method.Name == "Compare" && mc.Method.IsStatic && mc.Arguments.Count == 2"  is complex.
Complex Conditional,SubSonic.DataProviders.SQLite,SQLiteSchema,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\SQLite\SQLiteSchema.cs,GenerateColumnAttributes,The conditional expression  "column.IsPrimaryKey && column.DataType == DbType.Int32                  || column.IsPrimaryKey && column.DataType == DbType.Int16                  || column.IsPrimaryKey && column.DataType == DbType.Int64"  is complex.
Complex Conditional,SubSonic.Linq.Translation,CrossApplyRewriter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\CrossApplyRewriter.cs,VisitJoin,The conditional expression  "select != null                          && select.Take == null                          && select.Skip == null                          && !AggregateChecker.HasAggregates(select)                          && (select.GroupBy == null || select.GroupBy.Count == 0)"  is complex.
Complex Conditional,SubSonic.Linq.Translation,OrderByRewriter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\OrderByRewriter.cs,RebindOrderings,The conditional expression  "decl.Expression == ordering.Expression ||                              (column != null && declColumn != null && column.Alias == declColumn.Alias && column.Name == declColumn.Name)"  is complex.
Complex Conditional,SubSonic.Linq.Translation,QueryBinder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\QueryBinder.cs,BindSelectMany,The conditional expression  "mcs != null && mcs.Method.Name == "DefaultIfEmpty" && mcs.Arguments.Count == 1 &&                  (mcs.Method.DeclaringType == typeof (Queryable) || mcs.Method.DeclaringType == typeof (Enumerable))"  is complex.
Complex Conditional,SubSonic.Linq.Translation,QueryBinder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\QueryBinder.cs,BindAggregate,The conditional expression  "mcs.Method.Name == "Distinct" && mcs.Arguments.Count == 1 &&                      (mcs.Method.DeclaringType == typeof (Queryable) || mcs.Method.DeclaringType == typeof (Enumerable))"  is complex.
Complex Conditional,SubSonic.Linq.Translation,SubqueryMerger,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\RedundantSubqueryRemover.cs,VisitSelect,The conditional expression  "where != select.Where                          || orderBy != select.OrderBy                          || groupBy != select.GroupBy                          || isDistinct != select.IsDistinct                          || skip != select.Skip                          || take != select.Take"  is complex.
Complex Conditional,SubSonic.Linq.Translation,SubqueryMerger,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\RedundantSubqueryRemover.cs,CanMergeWithFrom,The conditional expression  "frmHasOrderBy && (selHasGroupBy || selHasAggregates || select.IsDistinct)"  is complex.
Complex Conditional,SubSonic.Linq.Translation,SubqueryMerger,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\RedundantSubqueryRemover.cs,CanMergeWithFrom,The conditional expression  "fromSelect.Take != null && (select.Take != null || select.Skip != null || select.IsDistinct || selHasAggregates || selHasGroupBy)"  is complex.
Complex Conditional,SubSonic.Linq.Translation,SubqueryMerger,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\RedundantSubqueryRemover.cs,CanMergeWithFrom,The conditional expression  "fromSelect.Skip != null && (select.Skip != null || select.IsDistinct || selHasAggregates || selHasGroupBy)"  is complex.
Complex Conditional,SubSonic.Linq.Translation,SubqueryMerger,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\RedundantSubqueryRemover.cs,CanMergeWithFrom,The conditional expression  "fromSelect.IsDistinct && (select.Take != null || select.Skip != null || !selHasNameMapProjection || selHasGroupBy || selHasAggregates || (selHasOrderBy && !isTopLevel))"  is complex.
Complex Conditional,SubSonic.Linq.Translation,RelationshipBinder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\RelationshipBinder.cs,VisitSelect,The conditional expression  "this.currentFrom != select.From                      || where != select.Where                      || orderBy != select.OrderBy                      || groupBy != select.GroupBy                      || take != select.Take                      || skip != select.Skip                      || columns != select.Columns"  is complex.
Complex Conditional,SubSonic.Linq.Translation,UnusedColumnRemover,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\UnusedColumnRemover.cs,VisitSelect,The conditional expression  "columns != select.Columns                   || take != select.Take                   || skip != select.Skip                  || orderbys != select.OrderBy                   || groupbys != select.GroupBy                  || where != select.Where                   || from != select.From"  is complex.
Complex Conditional,SubSonic.Extensions,Database,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Database.cs,ToInsertQuery,The conditional expression  "!col.AutoIncrement && !col.IsReadOnly && !(col.DefaultSetting != null && hashed[key] == null)"  is complex.
Empty Catch Block,SubSonic.Linq.Structure,ImplicitMapping,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\ImplicitMapping.cs,GetColumnName,The method has an empty catch block.
Empty Catch Block,SubSonic.Linq.Structure,QueryMapping,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\QueryMapping.cs,GetTypeProjection,The method has an empty catch block.
Empty Catch Block,SubSonic.Repository,SimpleRepository,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Repository\SimpleRepository.cs,Add,The method has an empty catch block.
Empty Catch Block,SubSonic.Repository,SubSonicRepository<T>,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Repository\SubSonicRepository.cs,Add,The method has an empty catch block.
Empty Catch Block,SubSonic.Extensions,Objects,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Objects.cs,ToDictionary,The method has an empty catch block.
Magic Number,SubSonic.DataProviders,LazyLoadInterceptor,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\LazyLoadInterceptor.cs,GetPropertyName,The following statement contains a magic number: return method.Name.Substring(4' method.Name.Length - 4);
Magic Number,SubSonic.DataProviders,LazyLoadInterceptor,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\LazyLoadInterceptor.cs,GetPropertyName,The following statement contains a magic number: return method.Name.Substring(4' method.Name.Length - 4);
Magic Number,SubSonic.Linq.Structure,DbExpressionTypeExtensions,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\DbExpressions.cs,IsDbExpression,The following statement contains a magic number: return ((int)et) >= 1000;
Magic Number,SubSonic.Linq.Structure,ImplicitMapping,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\ImplicitMapping.cs,IsIdentity,The following statement contains a magic number: return member.Name.EndsWith("ID") && member.DeclaringType.Name.StartsWith(member.Name.Substring(0' member.Name.Length - 2));
Magic Number,SubSonic.Linq.Structure,ImplicitMapping,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\ImplicitMapping.cs,Singular,The following statement contains a magic number: string rest = name.Substring(0' name.Length - 2);
Magic Number,SubSonic.Linq.Structure,ImplicitMapping,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\ImplicitMapping.cs,Singular,The following statement contains a magic number: return name.Substring(0' name.Length - 3) + "y";
Magic Number,SubSonic.Linq.Structure,TSqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\TSqlFormatter.cs,VisitMethodCall,The following statement contains a magic number: switch (m.Method.Name)                  {                      case "StartsWith":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE ");                          this.Visit(m.Arguments[0]);                          sb.Append(" + '%')");                          return m;                      case "EndsWith":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE '%' + ");                          this.Visit(m.Arguments[0]);                          sb.Append(")");                          return m;                      case "Contains":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE '%' + ");                          this.Visit(m.Arguments[0]);                          sb.Append(" + '%')");                          return m;                      case "Concat":                          IList<Expression> args = m.Arguments;                          if (args.Count == 1 && args[0].NodeType == ExpressionType.NewArrayInit)                          {                              args = ((NewArrayExpression)args[0]).Expressions;                          }                          for (int i = 0' n = args.Count; i < n; i++)                          {                              if (i > 0) sb.Append(" + ");                              this.Visit(args[i]);                          }                          return m;                      case "IsNullOrEmpty":                          sb.Append("(");                          this.Visit(m.Arguments[0]);                          sb.Append(" IS NULL OR ");                          this.Visit(m.Arguments[0]);                          sb.Append(" = '')");                          return m;                      case "ToUpper":                          sb.Append("UPPER(");                          this.Visit(m.Object);                          sb.Append(")");                          return m;                      case "ToLower":                          sb.Append("LOWER(");                          this.Visit(m.Object);                          sb.Append(")");                          return m;                      case "Replace":                          sb.Append("REPLACE(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append("' ");                          this.Visit(m.Arguments[1]);                          sb.Append(")");                          return m;                      case "Substring":                          sb.Append("SUBSTRING(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append(" + 1' ");                          if (m.Arguments.Count == 2)                          {                              this.Visit(m.Arguments[1]);                          }                          else                          {                              sb.Append("8000");                          }                          sb.Append(")");                          return m;                      case "Remove":                          sb.Append("STUFF(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append(" + 1' ");                          if (m.Arguments.Count == 2)                          {                              this.Visit(m.Arguments[1]);                          }                          else                          {                              sb.Append("8000");                          }                          sb.Append("' '')");                          return m;                      case "IndexOf":                          sb.Append("(CHARINDEX(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          if (m.Arguments.Count == 2 && m.Arguments[1].Type == typeof(int))                          {                              sb.Append("' ");                              this.Visit(m.Arguments[1]);                          }                          sb.Append(") - 1)");                          return m;                      case "Trim":                          sb.Append("RTRIM(LTRIM(");                          this.Visit(m.Object);                          sb.Append("))");                          return m;                  }
Magic Number,SubSonic.Linq.Structure,TSqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\TSqlFormatter.cs,VisitMethodCall,The following statement contains a magic number: switch (m.Method.Name)                  {                      case "StartsWith":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE ");                          this.Visit(m.Arguments[0]);                          sb.Append(" + '%')");                          return m;                      case "EndsWith":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE '%' + ");                          this.Visit(m.Arguments[0]);                          sb.Append(")");                          return m;                      case "Contains":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE '%' + ");                          this.Visit(m.Arguments[0]);                          sb.Append(" + '%')");                          return m;                      case "Concat":                          IList<Expression> args = m.Arguments;                          if (args.Count == 1 && args[0].NodeType == ExpressionType.NewArrayInit)                          {                              args = ((NewArrayExpression)args[0]).Expressions;                          }                          for (int i = 0' n = args.Count; i < n; i++)                          {                              if (i > 0) sb.Append(" + ");                              this.Visit(args[i]);                          }                          return m;                      case "IsNullOrEmpty":                          sb.Append("(");                          this.Visit(m.Arguments[0]);                          sb.Append(" IS NULL OR ");                          this.Visit(m.Arguments[0]);                          sb.Append(" = '')");                          return m;                      case "ToUpper":                          sb.Append("UPPER(");                          this.Visit(m.Object);                          sb.Append(")");                          return m;                      case "ToLower":                          sb.Append("LOWER(");                          this.Visit(m.Object);                          sb.Append(")");                          return m;                      case "Replace":                          sb.Append("REPLACE(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append("' ");                          this.Visit(m.Arguments[1]);                          sb.Append(")");                          return m;                      case "Substring":                          sb.Append("SUBSTRING(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append(" + 1' ");                          if (m.Arguments.Count == 2)                          {                              this.Visit(m.Arguments[1]);                          }                          else                          {                              sb.Append("8000");                          }                          sb.Append(")");                          return m;                      case "Remove":                          sb.Append("STUFF(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append(" + 1' ");                          if (m.Arguments.Count == 2)                          {                              this.Visit(m.Arguments[1]);                          }                          else                          {                              sb.Append("8000");                          }                          sb.Append("' '')");                          return m;                      case "IndexOf":                          sb.Append("(CHARINDEX(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          if (m.Arguments.Count == 2 && m.Arguments[1].Type == typeof(int))                          {                              sb.Append("' ");                              this.Visit(m.Arguments[1]);                          }                          sb.Append(") - 1)");                          return m;                      case "Trim":                          sb.Append("RTRIM(LTRIM(");                          this.Visit(m.Object);                          sb.Append("))");                          return m;                  }
Magic Number,SubSonic.Linq.Structure,TSqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\TSqlFormatter.cs,VisitMethodCall,The following statement contains a magic number: switch (m.Method.Name)                  {                      case "StartsWith":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE ");                          this.Visit(m.Arguments[0]);                          sb.Append(" + '%')");                          return m;                      case "EndsWith":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE '%' + ");                          this.Visit(m.Arguments[0]);                          sb.Append(")");                          return m;                      case "Contains":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE '%' + ");                          this.Visit(m.Arguments[0]);                          sb.Append(" + '%')");                          return m;                      case "Concat":                          IList<Expression> args = m.Arguments;                          if (args.Count == 1 && args[0].NodeType == ExpressionType.NewArrayInit)                          {                              args = ((NewArrayExpression)args[0]).Expressions;                          }                          for (int i = 0' n = args.Count; i < n; i++)                          {                              if (i > 0) sb.Append(" + ");                              this.Visit(args[i]);                          }                          return m;                      case "IsNullOrEmpty":                          sb.Append("(");                          this.Visit(m.Arguments[0]);                          sb.Append(" IS NULL OR ");                          this.Visit(m.Arguments[0]);                          sb.Append(" = '')");                          return m;                      case "ToUpper":                          sb.Append("UPPER(");                          this.Visit(m.Object);                          sb.Append(")");                          return m;                      case "ToLower":                          sb.Append("LOWER(");                          this.Visit(m.Object);                          sb.Append(")");                          return m;                      case "Replace":                          sb.Append("REPLACE(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append("' ");                          this.Visit(m.Arguments[1]);                          sb.Append(")");                          return m;                      case "Substring":                          sb.Append("SUBSTRING(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append(" + 1' ");                          if (m.Arguments.Count == 2)                          {                              this.Visit(m.Arguments[1]);                          }                          else                          {                              sb.Append("8000");                          }                          sb.Append(")");                          return m;                      case "Remove":                          sb.Append("STUFF(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append(" + 1' ");                          if (m.Arguments.Count == 2)                          {                              this.Visit(m.Arguments[1]);                          }                          else                          {                              sb.Append("8000");                          }                          sb.Append("' '')");                          return m;                      case "IndexOf":                          sb.Append("(CHARINDEX(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          if (m.Arguments.Count == 2 && m.Arguments[1].Type == typeof(int))                          {                              sb.Append("' ");                              this.Visit(m.Arguments[1]);                          }                          sb.Append(") - 1)");                          return m;                      case "Trim":                          sb.Append("RTRIM(LTRIM(");                          this.Visit(m.Object);                          sb.Append("))");                          return m;                  }
Magic Number,SubSonic.Linq.Structure,TSqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\TSqlFormatter.cs,VisitNew,The following statement contains a magic number: this.Visit(nex.Arguments[2]);
Magic Number,SubSonic.Linq.Structure,TSqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\TSqlFormatter.cs,VisitNew,The following statement contains a magic number: nex.Arguments.Count == 3
Magic Number,SubSonic.DataProviders.MySQL,MySqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\MySQL\MySqlFormatter.cs,VisitMethodCall,The following statement contains a magic number: switch (m.Method.Name) {                      case "StartsWith":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE CONCAT(");                          this.Visit(m.Arguments[0]);                          sb.Append("''%'))");                          return m;                      case "EndsWith":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE CONCAT('%''");                          this.Visit(m.Arguments[0]);                          sb.Append("))");                          return m;                      case "Contains":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE CONCAT('%''");                          this.Visit(m.Arguments[0]);                          sb.Append("''%'))");                          return m;                      case "Concat":                          IList<Expression> args = m.Arguments;                          if (args.Count == 1 && args[0].NodeType == ExpressionType.NewArrayInit) {                              args = ((NewArrayExpression)args[0]).Expressions;                          }                          for (int i = 0' n = args.Count; i < n; i++) {                              if (i > 0) sb.Append(" + ");                              this.Visit(args[i]);                          }                          return m;                      case "IsNullOrEmpty":                          sb.Append("(");                          this.Visit(m.Arguments[0]);                          sb.Append(" IS NULL OR ");                          this.Visit(m.Arguments[0]);                          sb.Append(" = '')");                          return m;                      case "ToUpper":                          sb.Append("UPPER(");                          this.Visit(m.Object);                          sb.Append(")");                          return m;                      case "ToLower":                          sb.Append("LOWER(");                          this.Visit(m.Object);                          sb.Append(")");                          return m;                      case "Replace":                          sb.Append("REPLACE(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append("' ");                          this.Visit(m.Arguments[1]);                          sb.Append(")");                          return m;                      case "Substring":                          sb.Append("SUBSTRING(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append(" + 1' ");                          if (m.Arguments.Count == 2) {                              this.Visit(m.Arguments[1]);                          } else {                              sb.Append("8000");                          }                          sb.Append(")");                          return m;                      case "Remove":                          sb.Append("STUFF(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append(" + 1' ");                          if (m.Arguments.Count == 2) {                              this.Visit(m.Arguments[1]);                          } else {                              sb.Append("8000");                          }                          sb.Append("' '')");                          return m;                      case "IndexOf":                          sb.Append("(LOCATE(");                          this.Visit(m.Arguments[0]);                          sb.Append("' ");                          this.Visit(m.Object);                          if (m.Arguments.Count == 2 && m.Arguments[1].Type == typeof(int)) {                              sb.Append("' ");                              this.Visit(m.Arguments[1]);                          }                          sb.Append(") - 1)");                          return m;                      case "Trim":                          sb.Append("RTRIM(LTRIM(");                          this.Visit(m.Object);                          sb.Append("))");                          return m;                  }
Magic Number,SubSonic.DataProviders.MySQL,MySqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\MySQL\MySqlFormatter.cs,VisitMethodCall,The following statement contains a magic number: switch (m.Method.Name) {                      case "StartsWith":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE CONCAT(");                          this.Visit(m.Arguments[0]);                          sb.Append("''%'))");                          return m;                      case "EndsWith":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE CONCAT('%''");                          this.Visit(m.Arguments[0]);                          sb.Append("))");                          return m;                      case "Contains":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE CONCAT('%''");                          this.Visit(m.Arguments[0]);                          sb.Append("''%'))");                          return m;                      case "Concat":                          IList<Expression> args = m.Arguments;                          if (args.Count == 1 && args[0].NodeType == ExpressionType.NewArrayInit) {                              args = ((NewArrayExpression)args[0]).Expressions;                          }                          for (int i = 0' n = args.Count; i < n; i++) {                              if (i > 0) sb.Append(" + ");                              this.Visit(args[i]);                          }                          return m;                      case "IsNullOrEmpty":                          sb.Append("(");                          this.Visit(m.Arguments[0]);                          sb.Append(" IS NULL OR ");                          this.Visit(m.Arguments[0]);                          sb.Append(" = '')");                          return m;                      case "ToUpper":                          sb.Append("UPPER(");                          this.Visit(m.Object);                          sb.Append(")");                          return m;                      case "ToLower":                          sb.Append("LOWER(");                          this.Visit(m.Object);                          sb.Append(")");                          return m;                      case "Replace":                          sb.Append("REPLACE(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append("' ");                          this.Visit(m.Arguments[1]);                          sb.Append(")");                          return m;                      case "Substring":                          sb.Append("SUBSTRING(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append(" + 1' ");                          if (m.Arguments.Count == 2) {                              this.Visit(m.Arguments[1]);                          } else {                              sb.Append("8000");                          }                          sb.Append(")");                          return m;                      case "Remove":                          sb.Append("STUFF(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append(" + 1' ");                          if (m.Arguments.Count == 2) {                              this.Visit(m.Arguments[1]);                          } else {                              sb.Append("8000");                          }                          sb.Append("' '')");                          return m;                      case "IndexOf":                          sb.Append("(LOCATE(");                          this.Visit(m.Arguments[0]);                          sb.Append("' ");                          this.Visit(m.Object);                          if (m.Arguments.Count == 2 && m.Arguments[1].Type == typeof(int)) {                              sb.Append("' ");                              this.Visit(m.Arguments[1]);                          }                          sb.Append(") - 1)");                          return m;                      case "Trim":                          sb.Append("RTRIM(LTRIM(");                          this.Visit(m.Object);                          sb.Append("))");                          return m;                  }
Magic Number,SubSonic.DataProviders.MySQL,MySqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\MySQL\MySqlFormatter.cs,VisitMethodCall,The following statement contains a magic number: switch (m.Method.Name) {                      case "StartsWith":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE CONCAT(");                          this.Visit(m.Arguments[0]);                          sb.Append("''%'))");                          return m;                      case "EndsWith":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE CONCAT('%''");                          this.Visit(m.Arguments[0]);                          sb.Append("))");                          return m;                      case "Contains":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE CONCAT('%''");                          this.Visit(m.Arguments[0]);                          sb.Append("''%'))");                          return m;                      case "Concat":                          IList<Expression> args = m.Arguments;                          if (args.Count == 1 && args[0].NodeType == ExpressionType.NewArrayInit) {                              args = ((NewArrayExpression)args[0]).Expressions;                          }                          for (int i = 0' n = args.Count; i < n; i++) {                              if (i > 0) sb.Append(" + ");                              this.Visit(args[i]);                          }                          return m;                      case "IsNullOrEmpty":                          sb.Append("(");                          this.Visit(m.Arguments[0]);                          sb.Append(" IS NULL OR ");                          this.Visit(m.Arguments[0]);                          sb.Append(" = '')");                          return m;                      case "ToUpper":                          sb.Append("UPPER(");                          this.Visit(m.Object);                          sb.Append(")");                          return m;                      case "ToLower":                          sb.Append("LOWER(");                          this.Visit(m.Object);                          sb.Append(")");                          return m;                      case "Replace":                          sb.Append("REPLACE(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append("' ");                          this.Visit(m.Arguments[1]);                          sb.Append(")");                          return m;                      case "Substring":                          sb.Append("SUBSTRING(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append(" + 1' ");                          if (m.Arguments.Count == 2) {                              this.Visit(m.Arguments[1]);                          } else {                              sb.Append("8000");                          }                          sb.Append(")");                          return m;                      case "Remove":                          sb.Append("STUFF(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append(" + 1' ");                          if (m.Arguments.Count == 2) {                              this.Visit(m.Arguments[1]);                          } else {                              sb.Append("8000");                          }                          sb.Append("' '')");                          return m;                      case "IndexOf":                          sb.Append("(LOCATE(");                          this.Visit(m.Arguments[0]);                          sb.Append("' ");                          this.Visit(m.Object);                          if (m.Arguments.Count == 2 && m.Arguments[1].Type == typeof(int)) {                              sb.Append("' ");                              this.Visit(m.Arguments[1]);                          }                          sb.Append(") - 1)");                          return m;                      case "Trim":                          sb.Append("RTRIM(LTRIM(");                          this.Visit(m.Object);                          sb.Append("))");                          return m;                  }
Magic Number,SubSonic.DataProviders.MySQL,MySqlSchema,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\MySQL\MySqlSchema.cs,GenerateColumnAttributes,The following statement contains a magic number: column.MaxLength = 16;
Magic Number,SubSonic.DataProviders.MySQL,MySqlSchema,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\MySQL\MySqlSchema.cs,GenerateColumnAttributes,The following statement contains a magic number: column.DataType == DbType.String && column.MaxLength > 8000
Magic Number,SubSonic.DataProviders.SqlServer,Sql2005Schema,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\SqlServer\Sql2005Schema.cs,GenerateColumnAttributes,The following statement contains a magic number: column.DataType == DbType.String && column.MaxLength > 8000
Magic Number,SubSonic.DataProviders.SQLite,SQLiteFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\SQLite\SQLiteFormatter.cs,VisitMethodCall,The following statement contains a magic number: switch (m.Method.Name) {                      case "StartsWith":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE ");                          this.Visit(m.Arguments[0]);                          sb.Append(" || '%')");                          return m;                      case "EndsWith":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE '%' || ");                          this.Visit(m.Arguments[0]);                          sb.Append(")");                          return m;                      case "Contains":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE '%' || ");                          this.Visit(m.Arguments[0]);                          sb.Append(" || '%')");                          return m;                      case "Concat":                          IList<Expression> args = m.Arguments;                          if (args.Count == 1 && args[0].NodeType == ExpressionType.NewArrayInit) {                              args = ((NewArrayExpression)args[0]).Expressions;                          }                          for (int i = 0' n = args.Count; i < n; i++) {                              if (i > 0) sb.Append(" + ");                              this.Visit(args[i]);                          }                          return m;                      case "IsNullOrEmpty":                          sb.Append("(");                          this.Visit(m.Arguments[0]);                          sb.Append(" IS NULL OR ");                          this.Visit(m.Arguments[0]);                          sb.Append(" = '')");                          return m;                      case "ToUpper":                          sb.Append("UPPER(");                          this.Visit(m.Object);                          sb.Append(")");                          return m;                      case "ToLower":                          sb.Append("LOWER(");                          this.Visit(m.Object);                          sb.Append(")");                          return m;                      case "Replace":                          sb.Append("REPLACE(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append("' ");                          this.Visit(m.Arguments[1]);                          sb.Append(")");                          return m;                      case "Substring":                          sb.Append("SUBSTR(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append(" + 1' ");                          if (m.Arguments.Count == 2) {                              this.Visit(m.Arguments[1]);                          } else {                              sb.Append("8000");                          }                          sb.Append(")");                          return m;                      case "Remove":                          sb.Append("STUFF(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append(" + 1' ");                          if (m.Arguments.Count == 2) {                              this.Visit(m.Arguments[1]);                          } else {                              sb.Append("8000");                          }                          sb.Append("' '')");                          return m;                      case "IndexOf":                          sb.Append("(CHARINDEX(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          if (m.Arguments.Count == 2 && m.Arguments[1].Type == typeof(int)) {                              sb.Append("' ");                              this.Visit(m.Arguments[1]);                          }                          sb.Append(") - 1)");                          return m;                      case "Trim":                          sb.Append("RTRIM(LTRIM(");                          this.Visit(m.Object);                          sb.Append("))");                          return m;                  }
Magic Number,SubSonic.DataProviders.SQLite,SQLiteFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\SQLite\SQLiteFormatter.cs,VisitMethodCall,The following statement contains a magic number: switch (m.Method.Name) {                      case "StartsWith":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE ");                          this.Visit(m.Arguments[0]);                          sb.Append(" || '%')");                          return m;                      case "EndsWith":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE '%' || ");                          this.Visit(m.Arguments[0]);                          sb.Append(")");                          return m;                      case "Contains":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE '%' || ");                          this.Visit(m.Arguments[0]);                          sb.Append(" || '%')");                          return m;                      case "Concat":                          IList<Expression> args = m.Arguments;                          if (args.Count == 1 && args[0].NodeType == ExpressionType.NewArrayInit) {                              args = ((NewArrayExpression)args[0]).Expressions;                          }                          for (int i = 0' n = args.Count; i < n; i++) {                              if (i > 0) sb.Append(" + ");                              this.Visit(args[i]);                          }                          return m;                      case "IsNullOrEmpty":                          sb.Append("(");                          this.Visit(m.Arguments[0]);                          sb.Append(" IS NULL OR ");                          this.Visit(m.Arguments[0]);                          sb.Append(" = '')");                          return m;                      case "ToUpper":                          sb.Append("UPPER(");                          this.Visit(m.Object);                          sb.Append(")");                          return m;                      case "ToLower":                          sb.Append("LOWER(");                          this.Visit(m.Object);                          sb.Append(")");                          return m;                      case "Replace":                          sb.Append("REPLACE(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append("' ");                          this.Visit(m.Arguments[1]);                          sb.Append(")");                          return m;                      case "Substring":                          sb.Append("SUBSTR(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append(" + 1' ");                          if (m.Arguments.Count == 2) {                              this.Visit(m.Arguments[1]);                          } else {                              sb.Append("8000");                          }                          sb.Append(")");                          return m;                      case "Remove":                          sb.Append("STUFF(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append(" + 1' ");                          if (m.Arguments.Count == 2) {                              this.Visit(m.Arguments[1]);                          } else {                              sb.Append("8000");                          }                          sb.Append("' '')");                          return m;                      case "IndexOf":                          sb.Append("(CHARINDEX(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          if (m.Arguments.Count == 2 && m.Arguments[1].Type == typeof(int)) {                              sb.Append("' ");                              this.Visit(m.Arguments[1]);                          }                          sb.Append(") - 1)");                          return m;                      case "Trim":                          sb.Append("RTRIM(LTRIM(");                          this.Visit(m.Object);                          sb.Append("))");                          return m;                  }
Magic Number,SubSonic.DataProviders.SQLite,SQLiteFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\SQLite\SQLiteFormatter.cs,VisitMethodCall,The following statement contains a magic number: switch (m.Method.Name) {                      case "StartsWith":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE ");                          this.Visit(m.Arguments[0]);                          sb.Append(" || '%')");                          return m;                      case "EndsWith":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE '%' || ");                          this.Visit(m.Arguments[0]);                          sb.Append(")");                          return m;                      case "Contains":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE '%' || ");                          this.Visit(m.Arguments[0]);                          sb.Append(" || '%')");                          return m;                      case "Concat":                          IList<Expression> args = m.Arguments;                          if (args.Count == 1 && args[0].NodeType == ExpressionType.NewArrayInit) {                              args = ((NewArrayExpression)args[0]).Expressions;                          }                          for (int i = 0' n = args.Count; i < n; i++) {                              if (i > 0) sb.Append(" + ");                              this.Visit(args[i]);                          }                          return m;                      case "IsNullOrEmpty":                          sb.Append("(");                          this.Visit(m.Arguments[0]);                          sb.Append(" IS NULL OR ");                          this.Visit(m.Arguments[0]);                          sb.Append(" = '')");                          return m;                      case "ToUpper":                          sb.Append("UPPER(");                          this.Visit(m.Object);                          sb.Append(")");                          return m;                      case "ToLower":                          sb.Append("LOWER(");                          this.Visit(m.Object);                          sb.Append(")");                          return m;                      case "Replace":                          sb.Append("REPLACE(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append("' ");                          this.Visit(m.Arguments[1]);                          sb.Append(")");                          return m;                      case "Substring":                          sb.Append("SUBSTR(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append(" + 1' ");                          if (m.Arguments.Count == 2) {                              this.Visit(m.Arguments[1]);                          } else {                              sb.Append("8000");                          }                          sb.Append(")");                          return m;                      case "Remove":                          sb.Append("STUFF(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append(" + 1' ");                          if (m.Arguments.Count == 2) {                              this.Visit(m.Arguments[1]);                          } else {                              sb.Append("8000");                          }                          sb.Append("' '')");                          return m;                      case "IndexOf":                          sb.Append("(CHARINDEX(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          if (m.Arguments.Count == 2 && m.Arguments[1].Type == typeof(int)) {                              sb.Append("' ");                              this.Visit(m.Arguments[1]);                          }                          sb.Append(") - 1)");                          return m;                      case "Trim":                          sb.Append("RTRIM(LTRIM(");                          this.Visit(m.Object);                          sb.Append("))");                          return m;                  }
Magic Number,SubSonic.DataProviders.SQLite,SQLiteSchema,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\SQLite\SQLiteSchema.cs,GenerateColumnAttributes,The following statement contains a magic number: column.DataType == DbType.String && column.MaxLength > 8000
Magic Number,SubSonic.DataProviders.SQLite,SQLiteSchema,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\SQLite\SQLiteSchema.cs,GenerateColumnAttributes,The following statement contains a magic number: column.IsString && column.MaxLength < 8000
Magic Number,SubSonic.Linq.Translation,QueryBinder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\QueryBinder.cs,VisitMethodCall,The following statement contains a magic number: switch (m.Method.Name)                  {                      case "Where":                          return BindWhere(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "Select":                          return BindSelect(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "SelectMany":                          if (m.Arguments.Count == 2)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])                                  );                          }                          break;                      case "Join":                          return BindJoin(                              m.Type' m.Arguments[0]' m.Arguments[1]'                              (LambdaExpression) StripQuotes(m.Arguments[2])'                              (LambdaExpression) StripQuotes(m.Arguments[3])'                              (LambdaExpression) StripQuotes(m.Arguments[4])                              );                      case "OrderBy":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Ascending);                      case "OrderByDescending":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Descending);                      case "ThenBy":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Ascending);                      case "ThenByDescending":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Descending);                      case "GroupBy":                          if (m.Arguments.Count == 2)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              LambdaExpression lambda1 = (LambdaExpression) StripQuotes(m.Arguments[1]);                              LambdaExpression lambda2 = (LambdaExpression) StripQuotes(m.Arguments[2]);                              if (lambda2.Parameters.Count == 1)                              {                                  // second lambda is element selector                                  return BindGroupBy(m.Arguments[0]' lambda1' lambda2' null);                              }                              else if (lambda2.Parameters.Count == 2)                              {                                  // second lambda is result selector                                  return BindGroupBy(m.Arguments[0]' lambda1' null' lambda2);                              }                          }                          else if (m.Arguments.Count == 4)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])'                                  (LambdaExpression) StripQuotes(m.Arguments[3])                                  );                          }                          break;                      case "Count":                      case "Min":                      case "Max":                      case "Sum":                      case "Average":                          if (m.Arguments.Count == 1)                          {                              return BindAggregate(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression selector = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAggregate(m.Arguments[0]' m.Method' selector' m == root);                          }                          break;                      case "Distinct":                          if (m.Arguments.Count == 1)                          {                              return BindDistinct(m.Arguments[0]);                          }                          break;                      case "Skip":                          if (m.Arguments.Count == 2)                          {                              return BindSkip(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "Take":                          if (m.Arguments.Count == 2)                          {                              return BindTake(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "First":                      case "FirstOrDefault":                      case "Single":                      case "SingleOrDefault":                          if (m.Arguments.Count == 1)                          {                              return BindFirst(m.Arguments[0]' null' m.Method.Name' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindFirst(m.Arguments[0]' predicate' m.Method.Name' m == root);                          }                          break;                      case "Any":                          if (m.Arguments.Count == 1)                          {                              return BindAnyAll(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "All":                          if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "Contains":                          if (m.Arguments.Count == 2)                          {                              return BindContains(m.Arguments[0]' m.Arguments[1]' m == root);                          }                          break;                  }
Magic Number,SubSonic.Linq.Translation,QueryBinder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\QueryBinder.cs,VisitMethodCall,The following statement contains a magic number: switch (m.Method.Name)                  {                      case "Where":                          return BindWhere(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "Select":                          return BindSelect(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "SelectMany":                          if (m.Arguments.Count == 2)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])                                  );                          }                          break;                      case "Join":                          return BindJoin(                              m.Type' m.Arguments[0]' m.Arguments[1]'                              (LambdaExpression) StripQuotes(m.Arguments[2])'                              (LambdaExpression) StripQuotes(m.Arguments[3])'                              (LambdaExpression) StripQuotes(m.Arguments[4])                              );                      case "OrderBy":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Ascending);                      case "OrderByDescending":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Descending);                      case "ThenBy":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Ascending);                      case "ThenByDescending":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Descending);                      case "GroupBy":                          if (m.Arguments.Count == 2)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              LambdaExpression lambda1 = (LambdaExpression) StripQuotes(m.Arguments[1]);                              LambdaExpression lambda2 = (LambdaExpression) StripQuotes(m.Arguments[2]);                              if (lambda2.Parameters.Count == 1)                              {                                  // second lambda is element selector                                  return BindGroupBy(m.Arguments[0]' lambda1' lambda2' null);                              }                              else if (lambda2.Parameters.Count == 2)                              {                                  // second lambda is result selector                                  return BindGroupBy(m.Arguments[0]' lambda1' null' lambda2);                              }                          }                          else if (m.Arguments.Count == 4)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])'                                  (LambdaExpression) StripQuotes(m.Arguments[3])                                  );                          }                          break;                      case "Count":                      case "Min":                      case "Max":                      case "Sum":                      case "Average":                          if (m.Arguments.Count == 1)                          {                              return BindAggregate(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression selector = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAggregate(m.Arguments[0]' m.Method' selector' m == root);                          }                          break;                      case "Distinct":                          if (m.Arguments.Count == 1)                          {                              return BindDistinct(m.Arguments[0]);                          }                          break;                      case "Skip":                          if (m.Arguments.Count == 2)                          {                              return BindSkip(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "Take":                          if (m.Arguments.Count == 2)                          {                              return BindTake(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "First":                      case "FirstOrDefault":                      case "Single":                      case "SingleOrDefault":                          if (m.Arguments.Count == 1)                          {                              return BindFirst(m.Arguments[0]' null' m.Method.Name' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindFirst(m.Arguments[0]' predicate' m.Method.Name' m == root);                          }                          break;                      case "Any":                          if (m.Arguments.Count == 1)                          {                              return BindAnyAll(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "All":                          if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "Contains":                          if (m.Arguments.Count == 2)                          {                              return BindContains(m.Arguments[0]' m.Arguments[1]' m == root);                          }                          break;                  }
Magic Number,SubSonic.Linq.Translation,QueryBinder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\QueryBinder.cs,VisitMethodCall,The following statement contains a magic number: switch (m.Method.Name)                  {                      case "Where":                          return BindWhere(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "Select":                          return BindSelect(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "SelectMany":                          if (m.Arguments.Count == 2)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])                                  );                          }                          break;                      case "Join":                          return BindJoin(                              m.Type' m.Arguments[0]' m.Arguments[1]'                              (LambdaExpression) StripQuotes(m.Arguments[2])'                              (LambdaExpression) StripQuotes(m.Arguments[3])'                              (LambdaExpression) StripQuotes(m.Arguments[4])                              );                      case "OrderBy":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Ascending);                      case "OrderByDescending":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Descending);                      case "ThenBy":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Ascending);                      case "ThenByDescending":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Descending);                      case "GroupBy":                          if (m.Arguments.Count == 2)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              LambdaExpression lambda1 = (LambdaExpression) StripQuotes(m.Arguments[1]);                              LambdaExpression lambda2 = (LambdaExpression) StripQuotes(m.Arguments[2]);                              if (lambda2.Parameters.Count == 1)                              {                                  // second lambda is element selector                                  return BindGroupBy(m.Arguments[0]' lambda1' lambda2' null);                              }                              else if (lambda2.Parameters.Count == 2)                              {                                  // second lambda is result selector                                  return BindGroupBy(m.Arguments[0]' lambda1' null' lambda2);                              }                          }                          else if (m.Arguments.Count == 4)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])'                                  (LambdaExpression) StripQuotes(m.Arguments[3])                                  );                          }                          break;                      case "Count":                      case "Min":                      case "Max":                      case "Sum":                      case "Average":                          if (m.Arguments.Count == 1)                          {                              return BindAggregate(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression selector = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAggregate(m.Arguments[0]' m.Method' selector' m == root);                          }                          break;                      case "Distinct":                          if (m.Arguments.Count == 1)                          {                              return BindDistinct(m.Arguments[0]);                          }                          break;                      case "Skip":                          if (m.Arguments.Count == 2)                          {                              return BindSkip(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "Take":                          if (m.Arguments.Count == 2)                          {                              return BindTake(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "First":                      case "FirstOrDefault":                      case "Single":                      case "SingleOrDefault":                          if (m.Arguments.Count == 1)                          {                              return BindFirst(m.Arguments[0]' null' m.Method.Name' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindFirst(m.Arguments[0]' predicate' m.Method.Name' m == root);                          }                          break;                      case "Any":                          if (m.Arguments.Count == 1)                          {                              return BindAnyAll(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "All":                          if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "Contains":                          if (m.Arguments.Count == 2)                          {                              return BindContains(m.Arguments[0]' m.Arguments[1]' m == root);                          }                          break;                  }
Magic Number,SubSonic.Linq.Translation,QueryBinder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\QueryBinder.cs,VisitMethodCall,The following statement contains a magic number: switch (m.Method.Name)                  {                      case "Where":                          return BindWhere(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "Select":                          return BindSelect(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "SelectMany":                          if (m.Arguments.Count == 2)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])                                  );                          }                          break;                      case "Join":                          return BindJoin(                              m.Type' m.Arguments[0]' m.Arguments[1]'                              (LambdaExpression) StripQuotes(m.Arguments[2])'                              (LambdaExpression) StripQuotes(m.Arguments[3])'                              (LambdaExpression) StripQuotes(m.Arguments[4])                              );                      case "OrderBy":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Ascending);                      case "OrderByDescending":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Descending);                      case "ThenBy":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Ascending);                      case "ThenByDescending":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Descending);                      case "GroupBy":                          if (m.Arguments.Count == 2)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              LambdaExpression lambda1 = (LambdaExpression) StripQuotes(m.Arguments[1]);                              LambdaExpression lambda2 = (LambdaExpression) StripQuotes(m.Arguments[2]);                              if (lambda2.Parameters.Count == 1)                              {                                  // second lambda is element selector                                  return BindGroupBy(m.Arguments[0]' lambda1' lambda2' null);                              }                              else if (lambda2.Parameters.Count == 2)                              {                                  // second lambda is result selector                                  return BindGroupBy(m.Arguments[0]' lambda1' null' lambda2);                              }                          }                          else if (m.Arguments.Count == 4)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])'                                  (LambdaExpression) StripQuotes(m.Arguments[3])                                  );                          }                          break;                      case "Count":                      case "Min":                      case "Max":                      case "Sum":                      case "Average":                          if (m.Arguments.Count == 1)                          {                              return BindAggregate(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression selector = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAggregate(m.Arguments[0]' m.Method' selector' m == root);                          }                          break;                      case "Distinct":                          if (m.Arguments.Count == 1)                          {                              return BindDistinct(m.Arguments[0]);                          }                          break;                      case "Skip":                          if (m.Arguments.Count == 2)                          {                              return BindSkip(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "Take":                          if (m.Arguments.Count == 2)                          {                              return BindTake(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "First":                      case "FirstOrDefault":                      case "Single":                      case "SingleOrDefault":                          if (m.Arguments.Count == 1)                          {                              return BindFirst(m.Arguments[0]' null' m.Method.Name' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindFirst(m.Arguments[0]' predicate' m.Method.Name' m == root);                          }                          break;                      case "Any":                          if (m.Arguments.Count == 1)                          {                              return BindAnyAll(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "All":                          if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "Contains":                          if (m.Arguments.Count == 2)                          {                              return BindContains(m.Arguments[0]' m.Arguments[1]' m == root);                          }                          break;                  }
Magic Number,SubSonic.Linq.Translation,QueryBinder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\QueryBinder.cs,VisitMethodCall,The following statement contains a magic number: switch (m.Method.Name)                  {                      case "Where":                          return BindWhere(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "Select":                          return BindSelect(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "SelectMany":                          if (m.Arguments.Count == 2)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])                                  );                          }                          break;                      case "Join":                          return BindJoin(                              m.Type' m.Arguments[0]' m.Arguments[1]'                              (LambdaExpression) StripQuotes(m.Arguments[2])'                              (LambdaExpression) StripQuotes(m.Arguments[3])'                              (LambdaExpression) StripQuotes(m.Arguments[4])                              );                      case "OrderBy":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Ascending);                      case "OrderByDescending":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Descending);                      case "ThenBy":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Ascending);                      case "ThenByDescending":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Descending);                      case "GroupBy":                          if (m.Arguments.Count == 2)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              LambdaExpression lambda1 = (LambdaExpression) StripQuotes(m.Arguments[1]);                              LambdaExpression lambda2 = (LambdaExpression) StripQuotes(m.Arguments[2]);                              if (lambda2.Parameters.Count == 1)                              {                                  // second lambda is element selector                                  return BindGroupBy(m.Arguments[0]' lambda1' lambda2' null);                              }                              else if (lambda2.Parameters.Count == 2)                              {                                  // second lambda is result selector                                  return BindGroupBy(m.Arguments[0]' lambda1' null' lambda2);                              }                          }                          else if (m.Arguments.Count == 4)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])'                                  (LambdaExpression) StripQuotes(m.Arguments[3])                                  );                          }                          break;                      case "Count":                      case "Min":                      case "Max":                      case "Sum":                      case "Average":                          if (m.Arguments.Count == 1)                          {                              return BindAggregate(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression selector = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAggregate(m.Arguments[0]' m.Method' selector' m == root);                          }                          break;                      case "Distinct":                          if (m.Arguments.Count == 1)                          {                              return BindDistinct(m.Arguments[0]);                          }                          break;                      case "Skip":                          if (m.Arguments.Count == 2)                          {                              return BindSkip(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "Take":                          if (m.Arguments.Count == 2)                          {                              return BindTake(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "First":                      case "FirstOrDefault":                      case "Single":                      case "SingleOrDefault":                          if (m.Arguments.Count == 1)                          {                              return BindFirst(m.Arguments[0]' null' m.Method.Name' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindFirst(m.Arguments[0]' predicate' m.Method.Name' m == root);                          }                          break;                      case "Any":                          if (m.Arguments.Count == 1)                          {                              return BindAnyAll(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "All":                          if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "Contains":                          if (m.Arguments.Count == 2)                          {                              return BindContains(m.Arguments[0]' m.Arguments[1]' m == root);                          }                          break;                  }
Magic Number,SubSonic.Linq.Translation,QueryBinder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\QueryBinder.cs,VisitMethodCall,The following statement contains a magic number: switch (m.Method.Name)                  {                      case "Where":                          return BindWhere(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "Select":                          return BindSelect(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "SelectMany":                          if (m.Arguments.Count == 2)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])                                  );                          }                          break;                      case "Join":                          return BindJoin(                              m.Type' m.Arguments[0]' m.Arguments[1]'                              (LambdaExpression) StripQuotes(m.Arguments[2])'                              (LambdaExpression) StripQuotes(m.Arguments[3])'                              (LambdaExpression) StripQuotes(m.Arguments[4])                              );                      case "OrderBy":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Ascending);                      case "OrderByDescending":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Descending);                      case "ThenBy":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Ascending);                      case "ThenByDescending":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Descending);                      case "GroupBy":                          if (m.Arguments.Count == 2)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              LambdaExpression lambda1 = (LambdaExpression) StripQuotes(m.Arguments[1]);                              LambdaExpression lambda2 = (LambdaExpression) StripQuotes(m.Arguments[2]);                              if (lambda2.Parameters.Count == 1)                              {                                  // second lambda is element selector                                  return BindGroupBy(m.Arguments[0]' lambda1' lambda2' null);                              }                              else if (lambda2.Parameters.Count == 2)                              {                                  // second lambda is result selector                                  return BindGroupBy(m.Arguments[0]' lambda1' null' lambda2);                              }                          }                          else if (m.Arguments.Count == 4)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])'                                  (LambdaExpression) StripQuotes(m.Arguments[3])                                  );                          }                          break;                      case "Count":                      case "Min":                      case "Max":                      case "Sum":                      case "Average":                          if (m.Arguments.Count == 1)                          {                              return BindAggregate(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression selector = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAggregate(m.Arguments[0]' m.Method' selector' m == root);                          }                          break;                      case "Distinct":                          if (m.Arguments.Count == 1)                          {                              return BindDistinct(m.Arguments[0]);                          }                          break;                      case "Skip":                          if (m.Arguments.Count == 2)                          {                              return BindSkip(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "Take":                          if (m.Arguments.Count == 2)                          {                              return BindTake(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "First":                      case "FirstOrDefault":                      case "Single":                      case "SingleOrDefault":                          if (m.Arguments.Count == 1)                          {                              return BindFirst(m.Arguments[0]' null' m.Method.Name' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindFirst(m.Arguments[0]' predicate' m.Method.Name' m == root);                          }                          break;                      case "Any":                          if (m.Arguments.Count == 1)                          {                              return BindAnyAll(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "All":                          if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "Contains":                          if (m.Arguments.Count == 2)                          {                              return BindContains(m.Arguments[0]' m.Arguments[1]' m == root);                          }                          break;                  }
Magic Number,SubSonic.Linq.Translation,QueryBinder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\QueryBinder.cs,VisitMethodCall,The following statement contains a magic number: switch (m.Method.Name)                  {                      case "Where":                          return BindWhere(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "Select":                          return BindSelect(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "SelectMany":                          if (m.Arguments.Count == 2)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])                                  );                          }                          break;                      case "Join":                          return BindJoin(                              m.Type' m.Arguments[0]' m.Arguments[1]'                              (LambdaExpression) StripQuotes(m.Arguments[2])'                              (LambdaExpression) StripQuotes(m.Arguments[3])'                              (LambdaExpression) StripQuotes(m.Arguments[4])                              );                      case "OrderBy":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Ascending);                      case "OrderByDescending":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Descending);                      case "ThenBy":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Ascending);                      case "ThenByDescending":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Descending);                      case "GroupBy":                          if (m.Arguments.Count == 2)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              LambdaExpression lambda1 = (LambdaExpression) StripQuotes(m.Arguments[1]);                              LambdaExpression lambda2 = (LambdaExpression) StripQuotes(m.Arguments[2]);                              if (lambda2.Parameters.Count == 1)                              {                                  // second lambda is element selector                                  return BindGroupBy(m.Arguments[0]' lambda1' lambda2' null);                              }                              else if (lambda2.Parameters.Count == 2)                              {                                  // second lambda is result selector                                  return BindGroupBy(m.Arguments[0]' lambda1' null' lambda2);                              }                          }                          else if (m.Arguments.Count == 4)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])'                                  (LambdaExpression) StripQuotes(m.Arguments[3])                                  );                          }                          break;                      case "Count":                      case "Min":                      case "Max":                      case "Sum":                      case "Average":                          if (m.Arguments.Count == 1)                          {                              return BindAggregate(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression selector = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAggregate(m.Arguments[0]' m.Method' selector' m == root);                          }                          break;                      case "Distinct":                          if (m.Arguments.Count == 1)                          {                              return BindDistinct(m.Arguments[0]);                          }                          break;                      case "Skip":                          if (m.Arguments.Count == 2)                          {                              return BindSkip(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "Take":                          if (m.Arguments.Count == 2)                          {                              return BindTake(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "First":                      case "FirstOrDefault":                      case "Single":                      case "SingleOrDefault":                          if (m.Arguments.Count == 1)                          {                              return BindFirst(m.Arguments[0]' null' m.Method.Name' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindFirst(m.Arguments[0]' predicate' m.Method.Name' m == root);                          }                          break;                      case "Any":                          if (m.Arguments.Count == 1)                          {                              return BindAnyAll(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "All":                          if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "Contains":                          if (m.Arguments.Count == 2)                          {                              return BindContains(m.Arguments[0]' m.Arguments[1]' m == root);                          }                          break;                  }
Magic Number,SubSonic.Linq.Translation,QueryBinder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\QueryBinder.cs,VisitMethodCall,The following statement contains a magic number: switch (m.Method.Name)                  {                      case "Where":                          return BindWhere(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "Select":                          return BindSelect(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "SelectMany":                          if (m.Arguments.Count == 2)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])                                  );                          }                          break;                      case "Join":                          return BindJoin(                              m.Type' m.Arguments[0]' m.Arguments[1]'                              (LambdaExpression) StripQuotes(m.Arguments[2])'                              (LambdaExpression) StripQuotes(m.Arguments[3])'                              (LambdaExpression) StripQuotes(m.Arguments[4])                              );                      case "OrderBy":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Ascending);                      case "OrderByDescending":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Descending);                      case "ThenBy":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Ascending);                      case "ThenByDescending":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Descending);                      case "GroupBy":                          if (m.Arguments.Count == 2)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              LambdaExpression lambda1 = (LambdaExpression) StripQuotes(m.Arguments[1]);                              LambdaExpression lambda2 = (LambdaExpression) StripQuotes(m.Arguments[2]);                              if (lambda2.Parameters.Count == 1)                              {                                  // second lambda is element selector                                  return BindGroupBy(m.Arguments[0]' lambda1' lambda2' null);                              }                              else if (lambda2.Parameters.Count == 2)                              {                                  // second lambda is result selector                                  return BindGroupBy(m.Arguments[0]' lambda1' null' lambda2);                              }                          }                          else if (m.Arguments.Count == 4)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])'                                  (LambdaExpression) StripQuotes(m.Arguments[3])                                  );                          }                          break;                      case "Count":                      case "Min":                      case "Max":                      case "Sum":                      case "Average":                          if (m.Arguments.Count == 1)                          {                              return BindAggregate(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression selector = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAggregate(m.Arguments[0]' m.Method' selector' m == root);                          }                          break;                      case "Distinct":                          if (m.Arguments.Count == 1)                          {                              return BindDistinct(m.Arguments[0]);                          }                          break;                      case "Skip":                          if (m.Arguments.Count == 2)                          {                              return BindSkip(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "Take":                          if (m.Arguments.Count == 2)                          {                              return BindTake(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "First":                      case "FirstOrDefault":                      case "Single":                      case "SingleOrDefault":                          if (m.Arguments.Count == 1)                          {                              return BindFirst(m.Arguments[0]' null' m.Method.Name' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindFirst(m.Arguments[0]' predicate' m.Method.Name' m == root);                          }                          break;                      case "Any":                          if (m.Arguments.Count == 1)                          {                              return BindAnyAll(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "All":                          if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "Contains":                          if (m.Arguments.Count == 2)                          {                              return BindContains(m.Arguments[0]' m.Arguments[1]' m == root);                          }                          break;                  }
Magic Number,SubSonic.Linq.Translation,QueryBinder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\QueryBinder.cs,VisitMethodCall,The following statement contains a magic number: switch (m.Method.Name)                  {                      case "Where":                          return BindWhere(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "Select":                          return BindSelect(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "SelectMany":                          if (m.Arguments.Count == 2)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])                                  );                          }                          break;                      case "Join":                          return BindJoin(                              m.Type' m.Arguments[0]' m.Arguments[1]'                              (LambdaExpression) StripQuotes(m.Arguments[2])'                              (LambdaExpression) StripQuotes(m.Arguments[3])'                              (LambdaExpression) StripQuotes(m.Arguments[4])                              );                      case "OrderBy":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Ascending);                      case "OrderByDescending":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Descending);                      case "ThenBy":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Ascending);                      case "ThenByDescending":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Descending);                      case "GroupBy":                          if (m.Arguments.Count == 2)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              LambdaExpression lambda1 = (LambdaExpression) StripQuotes(m.Arguments[1]);                              LambdaExpression lambda2 = (LambdaExpression) StripQuotes(m.Arguments[2]);                              if (lambda2.Parameters.Count == 1)                              {                                  // second lambda is element selector                                  return BindGroupBy(m.Arguments[0]' lambda1' lambda2' null);                              }                              else if (lambda2.Parameters.Count == 2)                              {                                  // second lambda is result selector                                  return BindGroupBy(m.Arguments[0]' lambda1' null' lambda2);                              }                          }                          else if (m.Arguments.Count == 4)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])'                                  (LambdaExpression) StripQuotes(m.Arguments[3])                                  );                          }                          break;                      case "Count":                      case "Min":                      case "Max":                      case "Sum":                      case "Average":                          if (m.Arguments.Count == 1)                          {                              return BindAggregate(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression selector = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAggregate(m.Arguments[0]' m.Method' selector' m == root);                          }                          break;                      case "Distinct":                          if (m.Arguments.Count == 1)                          {                              return BindDistinct(m.Arguments[0]);                          }                          break;                      case "Skip":                          if (m.Arguments.Count == 2)                          {                              return BindSkip(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "Take":                          if (m.Arguments.Count == 2)                          {                              return BindTake(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "First":                      case "FirstOrDefault":                      case "Single":                      case "SingleOrDefault":                          if (m.Arguments.Count == 1)                          {                              return BindFirst(m.Arguments[0]' null' m.Method.Name' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindFirst(m.Arguments[0]' predicate' m.Method.Name' m == root);                          }                          break;                      case "Any":                          if (m.Arguments.Count == 1)                          {                              return BindAnyAll(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "All":                          if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "Contains":                          if (m.Arguments.Count == 2)                          {                              return BindContains(m.Arguments[0]' m.Arguments[1]' m == root);                          }                          break;                  }
Magic Number,SubSonic.Linq.Translation,QueryBinder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\QueryBinder.cs,VisitMethodCall,The following statement contains a magic number: switch (m.Method.Name)                  {                      case "Where":                          return BindWhere(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "Select":                          return BindSelect(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "SelectMany":                          if (m.Arguments.Count == 2)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])                                  );                          }                          break;                      case "Join":                          return BindJoin(                              m.Type' m.Arguments[0]' m.Arguments[1]'                              (LambdaExpression) StripQuotes(m.Arguments[2])'                              (LambdaExpression) StripQuotes(m.Arguments[3])'                              (LambdaExpression) StripQuotes(m.Arguments[4])                              );                      case "OrderBy":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Ascending);                      case "OrderByDescending":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Descending);                      case "ThenBy":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Ascending);                      case "ThenByDescending":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Descending);                      case "GroupBy":                          if (m.Arguments.Count == 2)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              LambdaExpression lambda1 = (LambdaExpression) StripQuotes(m.Arguments[1]);                              LambdaExpression lambda2 = (LambdaExpression) StripQuotes(m.Arguments[2]);                              if (lambda2.Parameters.Count == 1)                              {                                  // second lambda is element selector                                  return BindGroupBy(m.Arguments[0]' lambda1' lambda2' null);                              }                              else if (lambda2.Parameters.Count == 2)                              {                                  // second lambda is result selector                                  return BindGroupBy(m.Arguments[0]' lambda1' null' lambda2);                              }                          }                          else if (m.Arguments.Count == 4)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])'                                  (LambdaExpression) StripQuotes(m.Arguments[3])                                  );                          }                          break;                      case "Count":                      case "Min":                      case "Max":                      case "Sum":                      case "Average":                          if (m.Arguments.Count == 1)                          {                              return BindAggregate(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression selector = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAggregate(m.Arguments[0]' m.Method' selector' m == root);                          }                          break;                      case "Distinct":                          if (m.Arguments.Count == 1)                          {                              return BindDistinct(m.Arguments[0]);                          }                          break;                      case "Skip":                          if (m.Arguments.Count == 2)                          {                              return BindSkip(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "Take":                          if (m.Arguments.Count == 2)                          {                              return BindTake(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "First":                      case "FirstOrDefault":                      case "Single":                      case "SingleOrDefault":                          if (m.Arguments.Count == 1)                          {                              return BindFirst(m.Arguments[0]' null' m.Method.Name' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindFirst(m.Arguments[0]' predicate' m.Method.Name' m == root);                          }                          break;                      case "Any":                          if (m.Arguments.Count == 1)                          {                              return BindAnyAll(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "All":                          if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "Contains":                          if (m.Arguments.Count == 2)                          {                              return BindContains(m.Arguments[0]' m.Arguments[1]' m == root);                          }                          break;                  }
Magic Number,SubSonic.Linq.Translation,QueryBinder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\QueryBinder.cs,VisitMethodCall,The following statement contains a magic number: switch (m.Method.Name)                  {                      case "Where":                          return BindWhere(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "Select":                          return BindSelect(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "SelectMany":                          if (m.Arguments.Count == 2)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])                                  );                          }                          break;                      case "Join":                          return BindJoin(                              m.Type' m.Arguments[0]' m.Arguments[1]'                              (LambdaExpression) StripQuotes(m.Arguments[2])'                              (LambdaExpression) StripQuotes(m.Arguments[3])'                              (LambdaExpression) StripQuotes(m.Arguments[4])                              );                      case "OrderBy":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Ascending);                      case "OrderByDescending":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Descending);                      case "ThenBy":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Ascending);                      case "ThenByDescending":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Descending);                      case "GroupBy":                          if (m.Arguments.Count == 2)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              LambdaExpression lambda1 = (LambdaExpression) StripQuotes(m.Arguments[1]);                              LambdaExpression lambda2 = (LambdaExpression) StripQuotes(m.Arguments[2]);                              if (lambda2.Parameters.Count == 1)                              {                                  // second lambda is element selector                                  return BindGroupBy(m.Arguments[0]' lambda1' lambda2' null);                              }                              else if (lambda2.Parameters.Count == 2)                              {                                  // second lambda is result selector                                  return BindGroupBy(m.Arguments[0]' lambda1' null' lambda2);                              }                          }                          else if (m.Arguments.Count == 4)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])'                                  (LambdaExpression) StripQuotes(m.Arguments[3])                                  );                          }                          break;                      case "Count":                      case "Min":                      case "Max":                      case "Sum":                      case "Average":                          if (m.Arguments.Count == 1)                          {                              return BindAggregate(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression selector = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAggregate(m.Arguments[0]' m.Method' selector' m == root);                          }                          break;                      case "Distinct":                          if (m.Arguments.Count == 1)                          {                              return BindDistinct(m.Arguments[0]);                          }                          break;                      case "Skip":                          if (m.Arguments.Count == 2)                          {                              return BindSkip(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "Take":                          if (m.Arguments.Count == 2)                          {                              return BindTake(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "First":                      case "FirstOrDefault":                      case "Single":                      case "SingleOrDefault":                          if (m.Arguments.Count == 1)                          {                              return BindFirst(m.Arguments[0]' null' m.Method.Name' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindFirst(m.Arguments[0]' predicate' m.Method.Name' m == root);                          }                          break;                      case "Any":                          if (m.Arguments.Count == 1)                          {                              return BindAnyAll(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "All":                          if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "Contains":                          if (m.Arguments.Count == 2)                          {                              return BindContains(m.Arguments[0]' m.Arguments[1]' m == root);                          }                          break;                  }
Magic Number,SubSonic.Linq.Translation,QueryBinder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\QueryBinder.cs,VisitMethodCall,The following statement contains a magic number: switch (m.Method.Name)                  {                      case "Where":                          return BindWhere(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "Select":                          return BindSelect(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "SelectMany":                          if (m.Arguments.Count == 2)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])                                  );                          }                          break;                      case "Join":                          return BindJoin(                              m.Type' m.Arguments[0]' m.Arguments[1]'                              (LambdaExpression) StripQuotes(m.Arguments[2])'                              (LambdaExpression) StripQuotes(m.Arguments[3])'                              (LambdaExpression) StripQuotes(m.Arguments[4])                              );                      case "OrderBy":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Ascending);                      case "OrderByDescending":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Descending);                      case "ThenBy":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Ascending);                      case "ThenByDescending":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Descending);                      case "GroupBy":                          if (m.Arguments.Count == 2)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              LambdaExpression lambda1 = (LambdaExpression) StripQuotes(m.Arguments[1]);                              LambdaExpression lambda2 = (LambdaExpression) StripQuotes(m.Arguments[2]);                              if (lambda2.Parameters.Count == 1)                              {                                  // second lambda is element selector                                  return BindGroupBy(m.Arguments[0]' lambda1' lambda2' null);                              }                              else if (lambda2.Parameters.Count == 2)                              {                                  // second lambda is result selector                                  return BindGroupBy(m.Arguments[0]' lambda1' null' lambda2);                              }                          }                          else if (m.Arguments.Count == 4)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])'                                  (LambdaExpression) StripQuotes(m.Arguments[3])                                  );                          }                          break;                      case "Count":                      case "Min":                      case "Max":                      case "Sum":                      case "Average":                          if (m.Arguments.Count == 1)                          {                              return BindAggregate(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression selector = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAggregate(m.Arguments[0]' m.Method' selector' m == root);                          }                          break;                      case "Distinct":                          if (m.Arguments.Count == 1)                          {                              return BindDistinct(m.Arguments[0]);                          }                          break;                      case "Skip":                          if (m.Arguments.Count == 2)                          {                              return BindSkip(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "Take":                          if (m.Arguments.Count == 2)                          {                              return BindTake(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "First":                      case "FirstOrDefault":                      case "Single":                      case "SingleOrDefault":                          if (m.Arguments.Count == 1)                          {                              return BindFirst(m.Arguments[0]' null' m.Method.Name' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindFirst(m.Arguments[0]' predicate' m.Method.Name' m == root);                          }                          break;                      case "Any":                          if (m.Arguments.Count == 1)                          {                              return BindAnyAll(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "All":                          if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "Contains":                          if (m.Arguments.Count == 2)                          {                              return BindContains(m.Arguments[0]' m.Arguments[1]' m == root);                          }                          break;                  }
Magic Number,SubSonic.Linq.Translation,QueryBinder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\QueryBinder.cs,VisitMethodCall,The following statement contains a magic number: switch (m.Method.Name)                  {                      case "Where":                          return BindWhere(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "Select":                          return BindSelect(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "SelectMany":                          if (m.Arguments.Count == 2)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])                                  );                          }                          break;                      case "Join":                          return BindJoin(                              m.Type' m.Arguments[0]' m.Arguments[1]'                              (LambdaExpression) StripQuotes(m.Arguments[2])'                              (LambdaExpression) StripQuotes(m.Arguments[3])'                              (LambdaExpression) StripQuotes(m.Arguments[4])                              );                      case "OrderBy":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Ascending);                      case "OrderByDescending":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Descending);                      case "ThenBy":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Ascending);                      case "ThenByDescending":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Descending);                      case "GroupBy":                          if (m.Arguments.Count == 2)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              LambdaExpression lambda1 = (LambdaExpression) StripQuotes(m.Arguments[1]);                              LambdaExpression lambda2 = (LambdaExpression) StripQuotes(m.Arguments[2]);                              if (lambda2.Parameters.Count == 1)                              {                                  // second lambda is element selector                                  return BindGroupBy(m.Arguments[0]' lambda1' lambda2' null);                              }                              else if (lambda2.Parameters.Count == 2)                              {                                  // second lambda is result selector                                  return BindGroupBy(m.Arguments[0]' lambda1' null' lambda2);                              }                          }                          else if (m.Arguments.Count == 4)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])'                                  (LambdaExpression) StripQuotes(m.Arguments[3])                                  );                          }                          break;                      case "Count":                      case "Min":                      case "Max":                      case "Sum":                      case "Average":                          if (m.Arguments.Count == 1)                          {                              return BindAggregate(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression selector = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAggregate(m.Arguments[0]' m.Method' selector' m == root);                          }                          break;                      case "Distinct":                          if (m.Arguments.Count == 1)                          {                              return BindDistinct(m.Arguments[0]);                          }                          break;                      case "Skip":                          if (m.Arguments.Count == 2)                          {                              return BindSkip(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "Take":                          if (m.Arguments.Count == 2)                          {                              return BindTake(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "First":                      case "FirstOrDefault":                      case "Single":                      case "SingleOrDefault":                          if (m.Arguments.Count == 1)                          {                              return BindFirst(m.Arguments[0]' null' m.Method.Name' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindFirst(m.Arguments[0]' predicate' m.Method.Name' m == root);                          }                          break;                      case "Any":                          if (m.Arguments.Count == 1)                          {                              return BindAnyAll(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "All":                          if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "Contains":                          if (m.Arguments.Count == 2)                          {                              return BindContains(m.Arguments[0]' m.Arguments[1]' m == root);                          }                          break;                  }
Magic Number,SubSonic.Linq.Translation,QueryBinder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\QueryBinder.cs,VisitMethodCall,The following statement contains a magic number: switch (m.Method.Name)                  {                      case "Where":                          return BindWhere(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "Select":                          return BindSelect(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "SelectMany":                          if (m.Arguments.Count == 2)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])                                  );                          }                          break;                      case "Join":                          return BindJoin(                              m.Type' m.Arguments[0]' m.Arguments[1]'                              (LambdaExpression) StripQuotes(m.Arguments[2])'                              (LambdaExpression) StripQuotes(m.Arguments[3])'                              (LambdaExpression) StripQuotes(m.Arguments[4])                              );                      case "OrderBy":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Ascending);                      case "OrderByDescending":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Descending);                      case "ThenBy":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Ascending);                      case "ThenByDescending":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Descending);                      case "GroupBy":                          if (m.Arguments.Count == 2)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              LambdaExpression lambda1 = (LambdaExpression) StripQuotes(m.Arguments[1]);                              LambdaExpression lambda2 = (LambdaExpression) StripQuotes(m.Arguments[2]);                              if (lambda2.Parameters.Count == 1)                              {                                  // second lambda is element selector                                  return BindGroupBy(m.Arguments[0]' lambda1' lambda2' null);                              }                              else if (lambda2.Parameters.Count == 2)                              {                                  // second lambda is result selector                                  return BindGroupBy(m.Arguments[0]' lambda1' null' lambda2);                              }                          }                          else if (m.Arguments.Count == 4)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])'                                  (LambdaExpression) StripQuotes(m.Arguments[3])                                  );                          }                          break;                      case "Count":                      case "Min":                      case "Max":                      case "Sum":                      case "Average":                          if (m.Arguments.Count == 1)                          {                              return BindAggregate(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression selector = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAggregate(m.Arguments[0]' m.Method' selector' m == root);                          }                          break;                      case "Distinct":                          if (m.Arguments.Count == 1)                          {                              return BindDistinct(m.Arguments[0]);                          }                          break;                      case "Skip":                          if (m.Arguments.Count == 2)                          {                              return BindSkip(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "Take":                          if (m.Arguments.Count == 2)                          {                              return BindTake(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "First":                      case "FirstOrDefault":                      case "Single":                      case "SingleOrDefault":                          if (m.Arguments.Count == 1)                          {                              return BindFirst(m.Arguments[0]' null' m.Method.Name' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindFirst(m.Arguments[0]' predicate' m.Method.Name' m == root);                          }                          break;                      case "Any":                          if (m.Arguments.Count == 1)                          {                              return BindAnyAll(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "All":                          if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "Contains":                          if (m.Arguments.Count == 2)                          {                              return BindContains(m.Arguments[0]' m.Arguments[1]' m == root);                          }                          break;                  }
Magic Number,SubSonic.Linq.Translation,QueryBinder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\QueryBinder.cs,VisitMethodCall,The following statement contains a magic number: switch (m.Method.Name)                  {                      case "Where":                          return BindWhere(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "Select":                          return BindSelect(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "SelectMany":                          if (m.Arguments.Count == 2)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])                                  );                          }                          break;                      case "Join":                          return BindJoin(                              m.Type' m.Arguments[0]' m.Arguments[1]'                              (LambdaExpression) StripQuotes(m.Arguments[2])'                              (LambdaExpression) StripQuotes(m.Arguments[3])'                              (LambdaExpression) StripQuotes(m.Arguments[4])                              );                      case "OrderBy":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Ascending);                      case "OrderByDescending":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Descending);                      case "ThenBy":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Ascending);                      case "ThenByDescending":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Descending);                      case "GroupBy":                          if (m.Arguments.Count == 2)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              LambdaExpression lambda1 = (LambdaExpression) StripQuotes(m.Arguments[1]);                              LambdaExpression lambda2 = (LambdaExpression) StripQuotes(m.Arguments[2]);                              if (lambda2.Parameters.Count == 1)                              {                                  // second lambda is element selector                                  return BindGroupBy(m.Arguments[0]' lambda1' lambda2' null);                              }                              else if (lambda2.Parameters.Count == 2)                              {                                  // second lambda is result selector                                  return BindGroupBy(m.Arguments[0]' lambda1' null' lambda2);                              }                          }                          else if (m.Arguments.Count == 4)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])'                                  (LambdaExpression) StripQuotes(m.Arguments[3])                                  );                          }                          break;                      case "Count":                      case "Min":                      case "Max":                      case "Sum":                      case "Average":                          if (m.Arguments.Count == 1)                          {                              return BindAggregate(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression selector = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAggregate(m.Arguments[0]' m.Method' selector' m == root);                          }                          break;                      case "Distinct":                          if (m.Arguments.Count == 1)                          {                              return BindDistinct(m.Arguments[0]);                          }                          break;                      case "Skip":                          if (m.Arguments.Count == 2)                          {                              return BindSkip(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "Take":                          if (m.Arguments.Count == 2)                          {                              return BindTake(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "First":                      case "FirstOrDefault":                      case "Single":                      case "SingleOrDefault":                          if (m.Arguments.Count == 1)                          {                              return BindFirst(m.Arguments[0]' null' m.Method.Name' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindFirst(m.Arguments[0]' predicate' m.Method.Name' m == root);                          }                          break;                      case "Any":                          if (m.Arguments.Count == 1)                          {                              return BindAnyAll(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "All":                          if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "Contains":                          if (m.Arguments.Count == 2)                          {                              return BindContains(m.Arguments[0]' m.Arguments[1]' m == root);                          }                          break;                  }
Magic Number,SubSonic.Linq.Translation,QueryBinder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\QueryBinder.cs,VisitMethodCall,The following statement contains a magic number: switch (m.Method.Name)                  {                      case "Where":                          return BindWhere(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "Select":                          return BindSelect(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "SelectMany":                          if (m.Arguments.Count == 2)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])                                  );                          }                          break;                      case "Join":                          return BindJoin(                              m.Type' m.Arguments[0]' m.Arguments[1]'                              (LambdaExpression) StripQuotes(m.Arguments[2])'                              (LambdaExpression) StripQuotes(m.Arguments[3])'                              (LambdaExpression) StripQuotes(m.Arguments[4])                              );                      case "OrderBy":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Ascending);                      case "OrderByDescending":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Descending);                      case "ThenBy":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Ascending);                      case "ThenByDescending":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Descending);                      case "GroupBy":                          if (m.Arguments.Count == 2)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              LambdaExpression lambda1 = (LambdaExpression) StripQuotes(m.Arguments[1]);                              LambdaExpression lambda2 = (LambdaExpression) StripQuotes(m.Arguments[2]);                              if (lambda2.Parameters.Count == 1)                              {                                  // second lambda is element selector                                  return BindGroupBy(m.Arguments[0]' lambda1' lambda2' null);                              }                              else if (lambda2.Parameters.Count == 2)                              {                                  // second lambda is result selector                                  return BindGroupBy(m.Arguments[0]' lambda1' null' lambda2);                              }                          }                          else if (m.Arguments.Count == 4)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])'                                  (LambdaExpression) StripQuotes(m.Arguments[3])                                  );                          }                          break;                      case "Count":                      case "Min":                      case "Max":                      case "Sum":                      case "Average":                          if (m.Arguments.Count == 1)                          {                              return BindAggregate(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression selector = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAggregate(m.Arguments[0]' m.Method' selector' m == root);                          }                          break;                      case "Distinct":                          if (m.Arguments.Count == 1)                          {                              return BindDistinct(m.Arguments[0]);                          }                          break;                      case "Skip":                          if (m.Arguments.Count == 2)                          {                              return BindSkip(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "Take":                          if (m.Arguments.Count == 2)                          {                              return BindTake(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "First":                      case "FirstOrDefault":                      case "Single":                      case "SingleOrDefault":                          if (m.Arguments.Count == 1)                          {                              return BindFirst(m.Arguments[0]' null' m.Method.Name' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindFirst(m.Arguments[0]' predicate' m.Method.Name' m == root);                          }                          break;                      case "Any":                          if (m.Arguments.Count == 1)                          {                              return BindAnyAll(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "All":                          if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "Contains":                          if (m.Arguments.Count == 2)                          {                              return BindContains(m.Arguments[0]' m.Arguments[1]' m == root);                          }                          break;                  }
Magic Number,SubSonic.Linq.Translation,QueryBinder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\QueryBinder.cs,VisitMethodCall,The following statement contains a magic number: switch (m.Method.Name)                  {                      case "Where":                          return BindWhere(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "Select":                          return BindSelect(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "SelectMany":                          if (m.Arguments.Count == 2)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])                                  );                          }                          break;                      case "Join":                          return BindJoin(                              m.Type' m.Arguments[0]' m.Arguments[1]'                              (LambdaExpression) StripQuotes(m.Arguments[2])'                              (LambdaExpression) StripQuotes(m.Arguments[3])'                              (LambdaExpression) StripQuotes(m.Arguments[4])                              );                      case "OrderBy":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Ascending);                      case "OrderByDescending":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Descending);                      case "ThenBy":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Ascending);                      case "ThenByDescending":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Descending);                      case "GroupBy":                          if (m.Arguments.Count == 2)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              LambdaExpression lambda1 = (LambdaExpression) StripQuotes(m.Arguments[1]);                              LambdaExpression lambda2 = (LambdaExpression) StripQuotes(m.Arguments[2]);                              if (lambda2.Parameters.Count == 1)                              {                                  // second lambda is element selector                                  return BindGroupBy(m.Arguments[0]' lambda1' lambda2' null);                              }                              else if (lambda2.Parameters.Count == 2)                              {                                  // second lambda is result selector                                  return BindGroupBy(m.Arguments[0]' lambda1' null' lambda2);                              }                          }                          else if (m.Arguments.Count == 4)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])'                                  (LambdaExpression) StripQuotes(m.Arguments[3])                                  );                          }                          break;                      case "Count":                      case "Min":                      case "Max":                      case "Sum":                      case "Average":                          if (m.Arguments.Count == 1)                          {                              return BindAggregate(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression selector = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAggregate(m.Arguments[0]' m.Method' selector' m == root);                          }                          break;                      case "Distinct":                          if (m.Arguments.Count == 1)                          {                              return BindDistinct(m.Arguments[0]);                          }                          break;                      case "Skip":                          if (m.Arguments.Count == 2)                          {                              return BindSkip(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "Take":                          if (m.Arguments.Count == 2)                          {                              return BindTake(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "First":                      case "FirstOrDefault":                      case "Single":                      case "SingleOrDefault":                          if (m.Arguments.Count == 1)                          {                              return BindFirst(m.Arguments[0]' null' m.Method.Name' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindFirst(m.Arguments[0]' predicate' m.Method.Name' m == root);                          }                          break;                      case "Any":                          if (m.Arguments.Count == 1)                          {                              return BindAnyAll(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "All":                          if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "Contains":                          if (m.Arguments.Count == 2)                          {                              return BindContains(m.Arguments[0]' m.Arguments[1]' m == root);                          }                          break;                  }
Magic Number,SubSonic.Linq.Translation,QueryBinder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\QueryBinder.cs,VisitMethodCall,The following statement contains a magic number: switch (m.Method.Name)                  {                      case "Where":                          return BindWhere(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "Select":                          return BindSelect(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "SelectMany":                          if (m.Arguments.Count == 2)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])                                  );                          }                          break;                      case "Join":                          return BindJoin(                              m.Type' m.Arguments[0]' m.Arguments[1]'                              (LambdaExpression) StripQuotes(m.Arguments[2])'                              (LambdaExpression) StripQuotes(m.Arguments[3])'                              (LambdaExpression) StripQuotes(m.Arguments[4])                              );                      case "OrderBy":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Ascending);                      case "OrderByDescending":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Descending);                      case "ThenBy":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Ascending);                      case "ThenByDescending":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Descending);                      case "GroupBy":                          if (m.Arguments.Count == 2)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              LambdaExpression lambda1 = (LambdaExpression) StripQuotes(m.Arguments[1]);                              LambdaExpression lambda2 = (LambdaExpression) StripQuotes(m.Arguments[2]);                              if (lambda2.Parameters.Count == 1)                              {                                  // second lambda is element selector                                  return BindGroupBy(m.Arguments[0]' lambda1' lambda2' null);                              }                              else if (lambda2.Parameters.Count == 2)                              {                                  // second lambda is result selector                                  return BindGroupBy(m.Arguments[0]' lambda1' null' lambda2);                              }                          }                          else if (m.Arguments.Count == 4)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])'                                  (LambdaExpression) StripQuotes(m.Arguments[3])                                  );                          }                          break;                      case "Count":                      case "Min":                      case "Max":                      case "Sum":                      case "Average":                          if (m.Arguments.Count == 1)                          {                              return BindAggregate(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression selector = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAggregate(m.Arguments[0]' m.Method' selector' m == root);                          }                          break;                      case "Distinct":                          if (m.Arguments.Count == 1)                          {                              return BindDistinct(m.Arguments[0]);                          }                          break;                      case "Skip":                          if (m.Arguments.Count == 2)                          {                              return BindSkip(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "Take":                          if (m.Arguments.Count == 2)                          {                              return BindTake(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "First":                      case "FirstOrDefault":                      case "Single":                      case "SingleOrDefault":                          if (m.Arguments.Count == 1)                          {                              return BindFirst(m.Arguments[0]' null' m.Method.Name' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindFirst(m.Arguments[0]' predicate' m.Method.Name' m == root);                          }                          break;                      case "Any":                          if (m.Arguments.Count == 1)                          {                              return BindAnyAll(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "All":                          if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "Contains":                          if (m.Arguments.Count == 2)                          {                              return BindContains(m.Arguments[0]' m.Arguments[1]' m == root);                          }                          break;                  }
Magic Number,SubSonic.Linq.Translation,QueryBinder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\QueryBinder.cs,VisitMethodCall,The following statement contains a magic number: switch (m.Method.Name)                  {                      case "Where":                          return BindWhere(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "Select":                          return BindSelect(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "SelectMany":                          if (m.Arguments.Count == 2)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])                                  );                          }                          break;                      case "Join":                          return BindJoin(                              m.Type' m.Arguments[0]' m.Arguments[1]'                              (LambdaExpression) StripQuotes(m.Arguments[2])'                              (LambdaExpression) StripQuotes(m.Arguments[3])'                              (LambdaExpression) StripQuotes(m.Arguments[4])                              );                      case "OrderBy":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Ascending);                      case "OrderByDescending":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Descending);                      case "ThenBy":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Ascending);                      case "ThenByDescending":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Descending);                      case "GroupBy":                          if (m.Arguments.Count == 2)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              LambdaExpression lambda1 = (LambdaExpression) StripQuotes(m.Arguments[1]);                              LambdaExpression lambda2 = (LambdaExpression) StripQuotes(m.Arguments[2]);                              if (lambda2.Parameters.Count == 1)                              {                                  // second lambda is element selector                                  return BindGroupBy(m.Arguments[0]' lambda1' lambda2' null);                              }                              else if (lambda2.Parameters.Count == 2)                              {                                  // second lambda is result selector                                  return BindGroupBy(m.Arguments[0]' lambda1' null' lambda2);                              }                          }                          else if (m.Arguments.Count == 4)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])'                                  (LambdaExpression) StripQuotes(m.Arguments[3])                                  );                          }                          break;                      case "Count":                      case "Min":                      case "Max":                      case "Sum":                      case "Average":                          if (m.Arguments.Count == 1)                          {                              return BindAggregate(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression selector = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAggregate(m.Arguments[0]' m.Method' selector' m == root);                          }                          break;                      case "Distinct":                          if (m.Arguments.Count == 1)                          {                              return BindDistinct(m.Arguments[0]);                          }                          break;                      case "Skip":                          if (m.Arguments.Count == 2)                          {                              return BindSkip(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "Take":                          if (m.Arguments.Count == 2)                          {                              return BindTake(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "First":                      case "FirstOrDefault":                      case "Single":                      case "SingleOrDefault":                          if (m.Arguments.Count == 1)                          {                              return BindFirst(m.Arguments[0]' null' m.Method.Name' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindFirst(m.Arguments[0]' predicate' m.Method.Name' m == root);                          }                          break;                      case "Any":                          if (m.Arguments.Count == 1)                          {                              return BindAnyAll(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "All":                          if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "Contains":                          if (m.Arguments.Count == 2)                          {                              return BindContains(m.Arguments[0]' m.Arguments[1]' m == root);                          }                          break;                  }
Magic Number,SubSonic.Linq.Translation,QueryBinder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\QueryBinder.cs,VisitMethodCall,The following statement contains a magic number: switch (m.Method.Name)                  {                      case "Where":                          return BindWhere(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "Select":                          return BindSelect(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "SelectMany":                          if (m.Arguments.Count == 2)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])                                  );                          }                          break;                      case "Join":                          return BindJoin(                              m.Type' m.Arguments[0]' m.Arguments[1]'                              (LambdaExpression) StripQuotes(m.Arguments[2])'                              (LambdaExpression) StripQuotes(m.Arguments[3])'                              (LambdaExpression) StripQuotes(m.Arguments[4])                              );                      case "OrderBy":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Ascending);                      case "OrderByDescending":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Descending);                      case "ThenBy":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Ascending);                      case "ThenByDescending":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Descending);                      case "GroupBy":                          if (m.Arguments.Count == 2)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              LambdaExpression lambda1 = (LambdaExpression) StripQuotes(m.Arguments[1]);                              LambdaExpression lambda2 = (LambdaExpression) StripQuotes(m.Arguments[2]);                              if (lambda2.Parameters.Count == 1)                              {                                  // second lambda is element selector                                  return BindGroupBy(m.Arguments[0]' lambda1' lambda2' null);                              }                              else if (lambda2.Parameters.Count == 2)                              {                                  // second lambda is result selector                                  return BindGroupBy(m.Arguments[0]' lambda1' null' lambda2);                              }                          }                          else if (m.Arguments.Count == 4)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])'                                  (LambdaExpression) StripQuotes(m.Arguments[3])                                  );                          }                          break;                      case "Count":                      case "Min":                      case "Max":                      case "Sum":                      case "Average":                          if (m.Arguments.Count == 1)                          {                              return BindAggregate(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression selector = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAggregate(m.Arguments[0]' m.Method' selector' m == root);                          }                          break;                      case "Distinct":                          if (m.Arguments.Count == 1)                          {                              return BindDistinct(m.Arguments[0]);                          }                          break;                      case "Skip":                          if (m.Arguments.Count == 2)                          {                              return BindSkip(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "Take":                          if (m.Arguments.Count == 2)                          {                              return BindTake(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "First":                      case "FirstOrDefault":                      case "Single":                      case "SingleOrDefault":                          if (m.Arguments.Count == 1)                          {                              return BindFirst(m.Arguments[0]' null' m.Method.Name' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindFirst(m.Arguments[0]' predicate' m.Method.Name' m == root);                          }                          break;                      case "Any":                          if (m.Arguments.Count == 1)                          {                              return BindAnyAll(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "All":                          if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "Contains":                          if (m.Arguments.Count == 2)                          {                              return BindContains(m.Arguments[0]' m.Arguments[1]' m == root);                          }                          break;                  }
Magic Number,SubSonic.Schema,Pagination,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Schema\PagedList.cs,ToPagedList,The following statement contains a magic number: return new PagedList<T>(source' index' 10);
Magic Number,SubSonic.Extensions,Dates,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Dates.cs,ReadableDiff,The following statement contains a magic number: seconds += 60;
Magic Number,SubSonic.Extensions,Dates,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Dates.cs,ReadableDiff,The following statement contains a magic number: minutes += 60;
Magic Number,SubSonic.Extensions,Dates,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Dates.cs,ReadableDiff,The following statement contains a magic number: hours += 24;
Magic Number,SubSonic.Extensions,Dates,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Dates.cs,ReadableDiff,The following statement contains a magic number: int previousMonth = (endTime.Month == 1) ? 12 : endTime.Month - 1;
Magic Number,SubSonic.Extensions,Dates,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Dates.cs,ReadableDiff,The following statement contains a magic number: int year = (previousMonth == 12) ? endTime.Year - 1 : endTime.Year;
Magic Number,SubSonic.Extensions,Dates,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Dates.cs,ReadableDiff,The following statement contains a magic number: months += 12;
Magic Number,SubSonic.Extensions,Dates,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Dates.cs,TimeDiff,The following statement contains a magic number: seconds += 60;
Magic Number,SubSonic.Extensions,Dates,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Dates.cs,TimeDiff,The following statement contains a magic number: minutes += 60;
Magic Number,SubSonic.Extensions,Dates,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Dates.cs,TimeDiff,The following statement contains a magic number: hours += 24;
Magic Number,SubSonic.Extensions,Dates,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Dates.cs,TimeDiff,The following statement contains a magic number: int previousMonth = (endTime.Month == 1) ? 12 : endTime.Month - 1;
Magic Number,SubSonic.Extensions,Dates,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Dates.cs,TimeDiff,The following statement contains a magic number: int year = (previousMonth == 12) ? endTime.Year - 1 : endTime.Year;
Magic Number,SubSonic.Extensions,Dates,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Dates.cs,TimeDiff,The following statement contains a magic number: months += 12;
Magic Number,SubSonic.Extensions,Dates,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Dates.cs,GetDateDayWithSuffix,The following statement contains a magic number: dayNumber == 1 || dayNumber == 21 || dayNumber == 31
Magic Number,SubSonic.Extensions,Dates,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Dates.cs,GetDateDayWithSuffix,The following statement contains a magic number: dayNumber == 1 || dayNumber == 21 || dayNumber == 31
Magic Number,SubSonic.Extensions,Inflector,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Inflector.cs,AddOrdinalSuffix,The following statement contains a magic number: int nMod100 = n % 100;
Magic Number,SubSonic.Extensions,Inflector,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Inflector.cs,AddOrdinalSuffix,The following statement contains a magic number: nMod100 >= 11 && nMod100 <= 13
Magic Number,SubSonic.Extensions,Inflector,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Inflector.cs,AddOrdinalSuffix,The following statement contains a magic number: nMod100 >= 11 && nMod100 <= 13
Magic Number,SubSonic.Extensions,Inflector,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Inflector.cs,AddOrdinalSuffix,The following statement contains a magic number: switch(n % 10)                  {                      case 1:                          return String.Concat(number' "st");                      case 2:                          return String.Concat(number' "nd");                      case 3:                          return String.Concat(number' "rd");                      default:                          return String.Concat(number' "th");                  }
Magic Number,SubSonic.Extensions,Inflector,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Inflector.cs,AddOrdinalSuffix,The following statement contains a magic number: switch(n % 10)                  {                      case 1:                          return String.Concat(number' "st");                      case 2:                          return String.Concat(number' "nd");                      case 3:                          return String.Concat(number' "rd");                      default:                          return String.Concat(number' "th");                  }
Magic Number,SubSonic.Extensions,Inflector,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Inflector.cs,AddOrdinalSuffix,The following statement contains a magic number: switch(n % 10)                  {                      case 1:                          return String.Concat(number' "st");                      case 2:                          return String.Concat(number' "nd");                      case 3:                          return String.Concat(number' "rd");                      default:                          return String.Concat(number' "th");                  }
Magic Number,SubSonic.Extensions,Numeric,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Numeric.cs,Random,The following statement contains a magic number: byte[] random = new Byte[4];
Magic Number,SubSonic.Extensions,Objects,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Objects.cs,ToSchemaTable,The following statement contains a magic number: column.NumberScale = 2;
Magic Number,SubSonic.Extensions,Objects,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Objects.cs,ToSchemaTable,The following statement contains a magic number: column.NumericPrecision = 10;
Magic Number,SubSonic.Extensions,QueryVisitor,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\QueryVisitor.cs,BuildCollectionConstraint,The following statement contains a magic number: methodCallExpression.Arguments.Count == 2
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,TextToEntity,The following statement contains a magic number: return textString.Replace(AsciiToUnicode(38)' "&amp;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(160' "&nbsp;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(161' "&iexcl;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(162' "&cent;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(163' "&pound;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(164' "&curren;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(165' "&yen;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(166' "&brvbar;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(167' "&sect;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(168' "&uml;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(169' "&copy;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(170' "&ordf;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(171' "&laquo;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(172' "&not;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(173' "&shy;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(174' "&reg;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(175' "&macr;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(176' "&deg;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(177' "&plusmn;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(178' "&sup2;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(179' "&sup3;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(180' "&acute;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(181' "&micro;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(182' "&para;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(183' "&middot;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(184' "&cedil;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(185' "&sup1;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(186' "&ordm;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(187' "&raquo;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(188' "&frac14;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(189' "&frac12;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(190' "&frac34;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(191' "&iquest;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(192' "&Agrave;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(193' "&Aacute;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(194' "&Acirc;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(195' "&Atilde;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(196' "&Auml;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(197' "&Aring;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(198' "&AElig;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(199' "&Ccedil;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(200' "&Egrave;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(201' "&Eacute;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(202' "&Ecirc;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(203' "&Euml;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(204' "&Igrave;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(205' "&Iacute;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(206' "&Icirc;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(207' "&Iuml;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(208' "&ETH;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(209' "&Ntilde;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(210' "&Ograve;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(211' "&Oacute;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(212' "&Ocirc;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(213' "&Otilde;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(214' "&Ouml;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(215' "&times;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(216' "&Oslash;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(217' "&Ugrave;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(218' "&Uacute;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(219' "&Ucirc;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(220' "&Uuml;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(221' "&Yacute;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(222' "&THORN;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(223' "&szlig;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(224' "&agrave;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(225' "&aacute;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(226' "&acirc;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(227' "&atilde;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(228' "&auml;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(229' "&aring;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(230' "&aelig;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(231' "&ccedil;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(232' "&egrave;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(233' "&eacute;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(234' "&ecirc;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(235' "&euml;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(236' "&igrave;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(237' "&iacute;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(238' "&icirc;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(239' "&iuml;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(240' "&eth;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(241' "&ntilde;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(242' "&ograve;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(243' "&oacute;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(244' "&ocirc;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(245' "&otilde;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(246' "&ouml;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(247' "&divide;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(248' "&oslash;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(249' "&ugrave;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(250' "&uacute;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(251' "&ucirc;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(252' "&uuml;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(253' "&yacute;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(254' "&thorn;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(255' "&yuml;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(402' "&fnof;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(913' "&Alpha;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(914' "&Beta;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(915' "&Gamma;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(916' "&Delta;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(917' "&Epsilon;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(918' "&Zeta;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(919' "&Eta;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(920' "&Theta;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(921' "&Iota;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(922' "&Kappa;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(923' "&Lambda;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(924' "&Mu;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(925' "&Nu;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(926' "&Xi;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(927' "&Omicron;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(928' "&Pi;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(929' "&Rho;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(931' "&Sigma;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(932' "&Tau;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(933' "&Upsilon;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(934' "&Phi;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(935' "&Chi;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(936' "&Psi;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(937' "&Omega;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(945' "&alpha;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(946' "&beta;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(947' "&gamma;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(948' "&delta;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(949' "&epsilon;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(950' "&zeta;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(951' "&eta;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(952' "&theta;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(953' "&iota;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(954' "&kappa;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(955' "&lambda;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(956' "&mu;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(957' "&nu;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(958' "&xi;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(959' "&omicron;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(960' "&pi;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(961' "&rho;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(962' "&sigmaf;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(963' "&sigma;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(964' "&tau;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(965' "&upsilon;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(966' "&phi;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(967' "&chi;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(968' "&psi;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(969' "&omega;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(977' "&thetasym;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(978' "&upsih;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(982' "&piv;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8226' "&bull;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8230' "&hellip;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8242' "&prime;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8243' "&Prime;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8254' "&oline;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8260' "&frasl;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8472' "&weierp;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8465' "&image;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8476' "&real;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8482' "&trade;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8501' "&alefsym;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8592' "&larr;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8593' "&uarr;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8594' "&rarr;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8595' "&darr;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8596' "&harr;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8629' "&crarr;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8656' "&lArr;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8657' "&uArr;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8658' "&rArr;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8659' "&dArr;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8660' "&hArr;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8704' "&forall;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8706' "&part;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8707' "&exist;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8709' "&empty;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8711' "&nabla;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8712' "&isin;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8713' "&notin;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8715' "&ni;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8719' "&prod;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8721' "&sum;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8722' "&minus;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8727' "&lowast;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8730' "&radic;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8733' "&prop;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8734' "&infin;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8736' "&ang;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8743' "&and;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8744' "&or;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8745' "&cap;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8746' "&cup;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8747' "&int;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8756' "&there4;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8764' "&sim;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8773' "&cong;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8776' "&asymp;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8800' "&ne;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8801' "&equiv;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8804' "&le;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8805' "&ge;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8834' "&sub;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8835' "&sup;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8836' "&nsub;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8838' "&sube;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8839' "&supe;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8853' "&oplus;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8855' "&otimes;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8869' "&perp;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8901' "&sdot;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8968' "&lceil;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8969' "&rceil;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8970' "&lfloor;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8971' "&rfloor;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(9001' "&lang;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(9002' "&rang;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(9674' "&loz;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(9824' "&spades;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(9827' "&clubs;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(9829' "&hearts;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(9830' "&diams;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(34' "&quot;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(60' "&lt;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(62' "&gt;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(338' "&OElig;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(339' "&oelig;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(352' "&Scaron;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(353' "&scaron;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(376' "&Yuml;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(710' "&circ;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(732' "&tilde;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8194' "&ensp;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8195' "&emsp;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8201' "&thinsp;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8204' "&zwnj;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8205' "&zwj;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8206' "&lrm;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8207' "&rlm;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8211' "&ndash;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8212' "&mdash;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8216' "&lsquo;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8217' "&rsquo;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8218' "&sbquo;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8220' "&ldquo;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8221' "&rdquo;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8222' "&bdquo;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8224' "&dagger;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8225' "&Dagger;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8240' "&permil;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8249' "&lsaquo;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8250' "&rsaquo;");
Magic Number,SubSonic.Extensions,Strings,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Strings.cs,FillEntities,The following statement contains a magic number: _entityTable.Add(8364' "&euro;");
Magic Number,SubSonic.Extensions,Validation,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Validation.cs,IsValidLuhn,The following statement contains a magic number: digits[i] *= 2;
Magic Number,SubSonic.Extensions,Validation,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Validation.cs,IsValidLuhn,The following statement contains a magic number: digits[i] -= 9;
Magic Number,SubSonic.Extensions,Validation,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Validation.cs,IsValidLuhn,The following statement contains a magic number: digits[i] > 9
Magic Number,SubSonic.Extensions,Validation,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\Validation.cs,IsValidLuhn,The following statement contains a magic number: return sum % 10 == 0;
Magic Number,SubSonic.SqlGeneration.Schema,ANSISchemaGenerator,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\SQLGeneration\Schema\ANSISchemaGenerator.cs,GetTableFromDB,The following statement contains a magic number: var restrictions = new string[4] {null' null' tableName' null};
Magic Number,SubSonic.SqlGeneration.Schema,SubSonicLongStringAttribute,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\SQLGeneration\Schema\SchemaAttributes.cs,Apply,The following statement contains a magic number: column.MaxLength = 8001;
Duplicate Code,SubSonic.Linq.Structure,TSqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\TSqlFormatter.cs,VisitMethodCall,The method contains a code clone-set at the following line numbers (starting from the method definition): ((251' 273)' (311' 333))
Missing Default,SubSonic.Linq.Structure,DbExpressionComparer,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\DbExpressionComparer.cs,CompareSubquery,The following switch statement is missing a default case: switch ((DbExpressionType) a.NodeType)              {                  case DbExpressionType.Scalar:                      return CompareScalar((ScalarExpression) a' (ScalarExpression) b);                  case DbExpressionType.Exists:                      return CompareExists((ExistsExpression) a' (ExistsExpression) b);                  case DbExpressionType.In:                      return CompareIn((InExpression) a' (InExpression) b);              }
Missing Default,SubSonic.Linq.Structure,DbExpressionVisitor,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\DbExpressionVisitor.cs,VisitSubquery,The following switch statement is missing a default case: switch ((DbExpressionType)subquery.NodeType)              {                  case DbExpressionType.Scalar:                      return this.VisitScalar((ScalarExpression)subquery);                  case DbExpressionType.Exists:                      return this.VisitExists((ExistsExpression)subquery);                  case DbExpressionType.In:                      return this.VisitIn((InExpression)subquery);              }
Missing Default,SubSonic.Linq.Structure,TSqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\TSqlFormatter.cs,VisitMemberAccess,The following switch statement is missing a default case: switch (m.Member.Name)                  {                      case "Length":                          sb.Append("LEN(");                          this.Visit(m.Expression);                          sb.Append(")");                          return m;                  }
Missing Default,SubSonic.Linq.Structure,TSqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\TSqlFormatter.cs,VisitMemberAccess,The following switch statement is missing a default case: switch (m.Member.Name)                  {                      case "Day":                          sb.Append("DAY(");                          this.Visit(m.Expression);                          sb.Append(")");                          return m;                      case "Month":                          sb.Append("MONTH(");                          this.Visit(m.Expression);                          sb.Append(")");                          return m;                      case "Year":                          sb.Append("YEAR(");                          this.Visit(m.Expression);                          sb.Append(")");                          return m;                      case "Hour":                          sb.Append("DATEPART(hour' ");                          this.Visit(m.Expression);                          sb.Append(")");                          return m;                      case "Minute":                          sb.Append("DATEPART(minute' ");                          this.Visit(m.Expression);                          sb.Append(")");                          return m;                      case "Second":                          sb.Append("DATEPART(second' ");                          this.Visit(m.Expression);                          sb.Append(")");                          return m;                      case "Millisecond":                          sb.Append("DATEPART(millisecond' ");                          this.Visit(m.Expression);                          sb.Append(")");                          return m;                      case "DayOfWeek":                          sb.Append("(DATEPART(weekday' ");                          this.Visit(m.Expression);                          sb.Append(") - 1)");                          return m;                      case "DayOfYear":                          sb.Append("(DATEPART(dayofyear' ");                          this.Visit(m.Expression);                          sb.Append(") - 1)");                          return m;                  }
Missing Default,SubSonic.Linq.Structure,TSqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\TSqlFormatter.cs,VisitMethodCall,The following switch statement is missing a default case: switch (m.Method.Name)                  {                      case "StartsWith":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE ");                          this.Visit(m.Arguments[0]);                          sb.Append(" + '%')");                          return m;                      case "EndsWith":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE '%' + ");                          this.Visit(m.Arguments[0]);                          sb.Append(")");                          return m;                      case "Contains":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE '%' + ");                          this.Visit(m.Arguments[0]);                          sb.Append(" + '%')");                          return m;                      case "Concat":                          IList<Expression> args = m.Arguments;                          if (args.Count == 1 && args[0].NodeType == ExpressionType.NewArrayInit)                          {                              args = ((NewArrayExpression)args[0]).Expressions;                          }                          for (int i = 0' n = args.Count; i < n; i++)                          {                              if (i > 0) sb.Append(" + ");                              this.Visit(args[i]);                          }                          return m;                      case "IsNullOrEmpty":                          sb.Append("(");                          this.Visit(m.Arguments[0]);                          sb.Append(" IS NULL OR ");                          this.Visit(m.Arguments[0]);                          sb.Append(" = '')");                          return m;                      case "ToUpper":                          sb.Append("UPPER(");                          this.Visit(m.Object);                          sb.Append(")");                          return m;                      case "ToLower":                          sb.Append("LOWER(");                          this.Visit(m.Object);                          sb.Append(")");                          return m;                      case "Replace":                          sb.Append("REPLACE(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append("' ");                          this.Visit(m.Arguments[1]);                          sb.Append(")");                          return m;                      case "Substring":                          sb.Append("SUBSTRING(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append(" + 1' ");                          if (m.Arguments.Count == 2)                          {                              this.Visit(m.Arguments[1]);                          }                          else                          {                              sb.Append("8000");                          }                          sb.Append(")");                          return m;                      case "Remove":                          sb.Append("STUFF(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append(" + 1' ");                          if (m.Arguments.Count == 2)                          {                              this.Visit(m.Arguments[1]);                          }                          else                          {                              sb.Append("8000");                          }                          sb.Append("' '')");                          return m;                      case "IndexOf":                          sb.Append("(CHARINDEX(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          if (m.Arguments.Count == 2 && m.Arguments[1].Type == typeof(int))                          {                              sb.Append("' ");                              this.Visit(m.Arguments[1]);                          }                          sb.Append(") - 1)");                          return m;                      case "Trim":                          sb.Append("RTRIM(LTRIM(");                          this.Visit(m.Object);                          sb.Append("))");                          return m;                  }
Missing Default,SubSonic.Linq.Structure,TSqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\TSqlFormatter.cs,VisitMethodCall,The following switch statement is missing a default case: switch (m.Method.Name)                  {                      case "op_Subtract":                          if (m.Arguments[1].Type == typeof(DateTime))                          {                              sb.Append("DATEDIFF(");                              this.Visit(m.Arguments[0]);                              sb.Append("' ");                              this.Visit(m.Arguments[1]);                              sb.Append(")");                              return m;                          }                          break;                  }
Missing Default,SubSonic.Linq.Structure,TSqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\TSqlFormatter.cs,VisitMethodCall,The following switch statement is missing a default case: switch (m.Method.Name) {                      case "DateDiffDay":                          if (m.Arguments[1].Type == typeof(DateTime)) {                              sb.Append("DATEDIFF(DAY'");                              this.Visit(m.Arguments[0]);                              sb.Append("' ");                              this.Visit(m.Arguments[1]);                              sb.Append(")");                              return m;                          }                          break;                      case "DateDiffHour":                          if (m.Arguments[1].Type == typeof(DateTime)) {                              sb.Append("DATEDIFF(HOUR'");                              this.Visit(m.Arguments[0]);                              sb.Append("' ");                              this.Visit(m.Arguments[1]);                              sb.Append(")");                              return m;                          }                          break;                      case "DateDiffMicrosecond":                          if (m.Arguments[1].Type == typeof(DateTime)) {                              sb.Append("DATEDIFF(MICROSECOND'");                              this.Visit(m.Arguments[0]);                              sb.Append("' ");                              this.Visit(m.Arguments[1]);                              sb.Append(")");                              return m;                          }                          break;                      case "DateDiffMillisecond":                          if (m.Arguments[1].Type == typeof(DateTime)) {                              sb.Append("DATEDIFF(MILLISECOND'");                              this.Visit(m.Arguments[0]);                              sb.Append("' ");                              this.Visit(m.Arguments[1]);                              sb.Append(")");                              return m;                          }                          break;                      case "DateDiffMinute":                          if (m.Arguments[1].Type == typeof(DateTime)) {                              sb.Append("DATEDIFF(MINUTE'");                              this.Visit(m.Arguments[0]);                              sb.Append("' ");                              this.Visit(m.Arguments[1]);                              sb.Append(")");                              return m;                          }                          break;                      case "DateDiffMonth":                          if (m.Arguments[1].Type == typeof(DateTime)) {                              sb.Append("DATEDIFF(MONTH'");                              this.Visit(m.Arguments[0]);                              sb.Append("' ");                              this.Visit(m.Arguments[1]);                              sb.Append(")");                              return m;                          }                          break;                      case "DateDiffNanosecond":                          if (m.Arguments[1].Type == typeof(DateTime)) {                              sb.Append("DATEDIFF(NANOSECOND'");                              this.Visit(m.Arguments[0]);                              sb.Append("' ");                              this.Visit(m.Arguments[1]);                              sb.Append(")");                              return m;                          }                          break;                      case "DateDiffSecond":                          if (m.Arguments[1].Type == typeof(DateTime)) {                              sb.Append("DATEDIFF(SECOND'");                              this.Visit(m.Arguments[0]);                              sb.Append("' ");                              this.Visit(m.Arguments[1]);                              sb.Append(")");                              return m;                          }                          break;                      case "DateDiffYear":                          if (m.Arguments[1].Type == typeof(DateTime)) {                              sb.Append("DATEDIFF(YEAR'");                              this.Visit(m.Arguments[0]);                              sb.Append("' ");                              this.Visit(m.Arguments[1]);                              sb.Append(")");                              return m;                          }                          break;                  }
Missing Default,SubSonic.Linq.Structure,TSqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\TSqlFormatter.cs,VisitMethodCall,The following switch statement is missing a default case: switch (m.Method.Name) {                      case "Add":                      case "Subtract":                      case "Multiply":                      case "Divide":                      case "Remainder":                          sb.Append("(");                          this.VisitValue(m.Arguments[0]);                          sb.Append(" ");                          sb.Append(GetOperator(m.Method.Name));                          sb.Append(" ");                          this.VisitValue(m.Arguments[1]);                          sb.Append(")");                          return m;                      case "Negate":                          sb.Append("-");                          this.Visit(m.Arguments[0]);                          sb.Append("");                          return m;                      case "Ceiling":                      case "Floor":                          sb.Append(m.Method.Name.ToUpper());                          sb.Append("(");                          this.Visit(m.Arguments[0]);                          sb.Append(")");                          return m;                      case "Round":                          if (m.Arguments.Count == 1) {                              sb.Append("ROUND(");                              this.Visit(m.Arguments[0]);                              sb.Append("' 0)");                              return m;                          } else if (m.Arguments.Count == 2 && m.Arguments[1].Type == typeof(int)) {                              sb.Append("ROUND(");                              this.Visit(m.Arguments[0]);                              sb.Append("' ");                              this.Visit(m.Arguments[1]);                              sb.Append(")");                              return m;                          }                          break;                      case "Truncate":                          sb.Append("ROUND(");                          this.Visit(m.Arguments[0]);                          sb.Append("' 0' 1)");                          return m;                  }
Missing Default,SubSonic.Linq.Structure,TSqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\TSqlFormatter.cs,VisitMethodCall,The following switch statement is missing a default case: switch (m.Method.Name) {                      case "Abs":                      case "Acos":                      case "Asin":                      case "Atan":                      case "Cos":                      case "Exp":                      case "Log10":                      case "Sin":                      case "Tan":                      case "Sqrt":                      case "Sign":                      case "Ceiling":                      case "Floor":                          sb.Append(m.Method.Name.ToUpper());                          sb.Append("(");                          this.Visit(m.Arguments[0]);                          sb.Append(")");                          return m;                      case "Atan2":                          sb.Append("ATN2(");                          this.Visit(m.Arguments[0]);                          sb.Append("' ");                          this.Visit(m.Arguments[1]);                          sb.Append(")");                          return m;                      case "Log":                          if (m.Arguments.Count == 1) {                              goto case "Log10";                          }                          break;                      case "Pow":                          sb.Append("POWER(");                          this.Visit(m.Arguments[0]);                          sb.Append("' ");                          this.Visit(m.Arguments[1]);                          sb.Append(")");                          return m;                      case "Round":                          if (m.Arguments.Count == 1) {                              sb.Append("ROUND(");                              this.Visit(m.Arguments[0]);                              sb.Append("' 0)");                              return m;                          } else if (m.Arguments.Count == 2 && m.Arguments[1].Type == typeof(int)) {                              sb.Append("ROUND(");                              this.Visit(m.Arguments[0]);                              sb.Append("' ");                              this.Visit(m.Arguments[1]);                              sb.Append(")");                              return m;                          }                          break;                      case "Truncate":                          sb.Append("ROUND(");                          this.Visit(m.Arguments[0]);                          sb.Append("' 0' 1)");                          return m;                  }
Missing Default,SubSonic.Linq.Structure,TSqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Structure\TSqlFormatter.cs,VisitJoin,The following switch statement is missing a default case: switch (join.Join)              {                  case JoinType.CrossJoin:                      sb.Append("CROSS JOIN ");                      break;                  case JoinType.InnerJoin:                      sb.Append("INNER JOIN ");                      break;                  case JoinType.CrossApply:                      sb.Append("CROSS APPLY ");                      break;                  case JoinType.OuterApply:                      sb.Append("OUTER APPLY ");                      break;                  case JoinType.LeftOuter:                      sb.Append("LEFT OUTER JOIN ");                      break;              }
Missing Default,SubSonic.DataProviders.MySQL,MySqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\MySQL\MySqlFormatter.cs,VisitMemberAccess,The following switch statement is missing a default case: switch (m.Member.Name) {                      case "Length":                          sb.Append("CHAR_LENGTH(");                          this.Visit(m.Expression);                          sb.Append(")");                          return m;                  }
Missing Default,SubSonic.DataProviders.MySQL,MySqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\MySQL\MySqlFormatter.cs,VisitMemberAccess,The following switch statement is missing a default case: switch (m.Member.Name) {                      case "Day":                          sb.Append("DAY(");                          this.Visit(m.Expression);                          sb.Append(")");                          return m;                      case "Month":                          sb.Append("MONTH(");                          this.Visit(m.Expression);                          sb.Append(")");                          return m;                      case "Year":                          sb.Append("YEAR(");                          this.Visit(m.Expression);                          sb.Append(")");                          return m;                      case "Hour":                          sb.Append("HOUR( ");                          this.Visit(m.Expression);                          sb.Append(")");                          return m;                      case "Minute":                          sb.Append("MINUTE( ");                          this.Visit(m.Expression);                          sb.Append(")");                          return m;                      case "Second":                          sb.Append("SECOND( ");                          this.Visit(m.Expression);                          sb.Append(")");                          return m;                      case "Millisecond":                          sb.Append("MICROSECOND( ");                          this.Visit(m.Expression);                          sb.Append(")");                          return m;                      case "DayOfWeek":                          sb.Append("(DAYOFWEEK(");                          this.Visit(m.Expression);                          sb.Append(") - 1)");                          return m;                      case "DayOfYear":                          sb.Append("(DAYOFYEAR( ");                          this.Visit(m.Expression);                          sb.Append(") - 1)");                          return m;                  }
Missing Default,SubSonic.DataProviders.MySQL,MySqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\MySQL\MySqlFormatter.cs,VisitMethodCall,The following switch statement is missing a default case: switch (m.Method.Name) {                      case "StartsWith":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE CONCAT(");                          this.Visit(m.Arguments[0]);                          sb.Append("''%'))");                          return m;                      case "EndsWith":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE CONCAT('%''");                          this.Visit(m.Arguments[0]);                          sb.Append("))");                          return m;                      case "Contains":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE CONCAT('%''");                          this.Visit(m.Arguments[0]);                          sb.Append("''%'))");                          return m;                      case "Concat":                          IList<Expression> args = m.Arguments;                          if (args.Count == 1 && args[0].NodeType == ExpressionType.NewArrayInit) {                              args = ((NewArrayExpression)args[0]).Expressions;                          }                          for (int i = 0' n = args.Count; i < n; i++) {                              if (i > 0) sb.Append(" + ");                              this.Visit(args[i]);                          }                          return m;                      case "IsNullOrEmpty":                          sb.Append("(");                          this.Visit(m.Arguments[0]);                          sb.Append(" IS NULL OR ");                          this.Visit(m.Arguments[0]);                          sb.Append(" = '')");                          return m;                      case "ToUpper":                          sb.Append("UPPER(");                          this.Visit(m.Object);                          sb.Append(")");                          return m;                      case "ToLower":                          sb.Append("LOWER(");                          this.Visit(m.Object);                          sb.Append(")");                          return m;                      case "Replace":                          sb.Append("REPLACE(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append("' ");                          this.Visit(m.Arguments[1]);                          sb.Append(")");                          return m;                      case "Substring":                          sb.Append("SUBSTRING(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append(" + 1' ");                          if (m.Arguments.Count == 2) {                              this.Visit(m.Arguments[1]);                          } else {                              sb.Append("8000");                          }                          sb.Append(")");                          return m;                      case "Remove":                          sb.Append("STUFF(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append(" + 1' ");                          if (m.Arguments.Count == 2) {                              this.Visit(m.Arguments[1]);                          } else {                              sb.Append("8000");                          }                          sb.Append("' '')");                          return m;                      case "IndexOf":                          sb.Append("(LOCATE(");                          this.Visit(m.Arguments[0]);                          sb.Append("' ");                          this.Visit(m.Object);                          if (m.Arguments.Count == 2 && m.Arguments[1].Type == typeof(int)) {                              sb.Append("' ");                              this.Visit(m.Arguments[1]);                          }                          sb.Append(") - 1)");                          return m;                      case "Trim":                          sb.Append("RTRIM(LTRIM(");                          this.Visit(m.Object);                          sb.Append("))");                          return m;                  }
Missing Default,SubSonic.DataProviders.MySQL,MySqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\MySQL\MySqlFormatter.cs,VisitMethodCall,The following switch statement is missing a default case: switch (m.Method.Name) {                      case "op_Subtract":                          if (m.Arguments[1].Type == typeof(DateTime)) {                              sb.Append("DATEDIFF(");                              this.Visit(m.Arguments[0]);                              sb.Append("' ");                              this.Visit(m.Arguments[1]);                              sb.Append(")");                              return m;                          }                          break;                  }
Missing Default,SubSonic.DataProviders.MySQL,MySqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\MySQL\MySqlFormatter.cs,VisitMethodCall,The following switch statement is missing a default case: switch (m.Method.Name) {                      case "Add":                      case "Subtract":                      case "Multiply":                      case "Divide":                      case "Remainder":                          sb.Append("(");                          this.VisitValue(m.Arguments[0]);                          sb.Append(" ");                          sb.Append(GetOperator(m.Method.Name));                          sb.Append(" ");                          this.VisitValue(m.Arguments[1]);                          sb.Append(")");                          return m;                      case "Negate":                          sb.Append("-");                          this.Visit(m.Arguments[0]);                          sb.Append("");                          return m;                      case "Ceiling":                      case "Floor":                          sb.Append(m.Method.Name.ToUpper());                          sb.Append("(");                          this.Visit(m.Arguments[0]);                          sb.Append(")");                          return m;                      case "Round":                          //if (m.Arguments.Count == 1) {                              sb.Append("ROUND(");                              this.Visit(m.Arguments[0]);                              sb.Append("' 0)");                              return m;                          //} else if (m.Arguments.Count == 2 && m.Arguments[1].Type == typeof(int)) {                              //sb.Append("ROUND(");                              //this.Visit(m.Arguments[0]);                              //sb.Append("' ");                              //this.Visit(m.Arguments[1]);                              //sb.Append(")");                              //return m;                          //}                      case "Truncate":                          sb.Append("ROUND(");                          this.Visit(m.Arguments[0]);                          sb.Append("' 0)");                          return m;                  }
Missing Default,SubSonic.DataProviders.MySQL,MySqlFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\MySQL\MySqlFormatter.cs,VisitMethodCall,The following switch statement is missing a default case: switch (m.Method.Name) {                      case "Abs":                      case "Acos":                      case "Asin":                      case "Atan":                      case "Cos":                      case "Exp":                      case "Log10":                      case "Sin":                      case "Tan":                      case "Sqrt":                      case "Sign":                      case "Ceiling":                      case "Floor":                          sb.Append(m.Method.Name.ToUpper());                          sb.Append("(");                          this.Visit(m.Arguments[0]);                          sb.Append(")");                          return m;                      case "Atan2":                          sb.Append("ATAN2(");                          this.Visit(m.Arguments[0]);                          sb.Append("' ");                          this.Visit(m.Arguments[1]);                          sb.Append(")");                          return m;                      case "Log":                          if (m.Arguments.Count == 1) {                              goto case "Log10";                          }                          break;                      case "Pow":                          sb.Append("POWER(");                          this.Visit(m.Arguments[0]);                          sb.Append("' ");                          this.Visit(m.Arguments[1]);                          sb.Append(")");                          return m;                      case "Round":                          //if (m.Arguments.Count == 1) {                              sb.Append("ROUND(");                              this.Visit(m.Arguments[0]);                              sb.Append("' 0)");                              return m;                          //} else if (m.Arguments.Count == 2 && m.Arguments[1].Type == typeof(int)) {                              //sb.Append("ROUND(");                              //this.Visit(m.Arguments[0]);                              //sb.Append("' ");                              //this.Visit(m.Arguments[1]);                              //sb.Append(")");                              //return m;                          //}                          //break;                      case "Truncate":                          sb.Append("ROUND(");                          this.Visit(m.Arguments[0]);                          sb.Append("' 0)");                          return m;                  }
Missing Default,SubSonic.DataProviders.SQLite,SQLiteFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\SQLite\SQLiteFormatter.cs,VisitMethodCall,The following switch statement is missing a default case: switch (m.Method.Name) {                      case "StartsWith":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE ");                          this.Visit(m.Arguments[0]);                          sb.Append(" || '%')");                          return m;                      case "EndsWith":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE '%' || ");                          this.Visit(m.Arguments[0]);                          sb.Append(")");                          return m;                      case "Contains":                          sb.Append("(");                          this.Visit(m.Object);                          sb.Append(" LIKE '%' || ");                          this.Visit(m.Arguments[0]);                          sb.Append(" || '%')");                          return m;                      case "Concat":                          IList<Expression> args = m.Arguments;                          if (args.Count == 1 && args[0].NodeType == ExpressionType.NewArrayInit) {                              args = ((NewArrayExpression)args[0]).Expressions;                          }                          for (int i = 0' n = args.Count; i < n; i++) {                              if (i > 0) sb.Append(" + ");                              this.Visit(args[i]);                          }                          return m;                      case "IsNullOrEmpty":                          sb.Append("(");                          this.Visit(m.Arguments[0]);                          sb.Append(" IS NULL OR ");                          this.Visit(m.Arguments[0]);                          sb.Append(" = '')");                          return m;                      case "ToUpper":                          sb.Append("UPPER(");                          this.Visit(m.Object);                          sb.Append(")");                          return m;                      case "ToLower":                          sb.Append("LOWER(");                          this.Visit(m.Object);                          sb.Append(")");                          return m;                      case "Replace":                          sb.Append("REPLACE(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append("' ");                          this.Visit(m.Arguments[1]);                          sb.Append(")");                          return m;                      case "Substring":                          sb.Append("SUBSTR(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append(" + 1' ");                          if (m.Arguments.Count == 2) {                              this.Visit(m.Arguments[1]);                          } else {                              sb.Append("8000");                          }                          sb.Append(")");                          return m;                      case "Remove":                          sb.Append("STUFF(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          sb.Append(" + 1' ");                          if (m.Arguments.Count == 2) {                              this.Visit(m.Arguments[1]);                          } else {                              sb.Append("8000");                          }                          sb.Append("' '')");                          return m;                      case "IndexOf":                          sb.Append("(CHARINDEX(");                          this.Visit(m.Object);                          sb.Append("' ");                          this.Visit(m.Arguments[0]);                          if (m.Arguments.Count == 2 && m.Arguments[1].Type == typeof(int)) {                              sb.Append("' ");                              this.Visit(m.Arguments[1]);                          }                          sb.Append(") - 1)");                          return m;                      case "Trim":                          sb.Append("RTRIM(LTRIM(");                          this.Visit(m.Object);                          sb.Append("))");                          return m;                  }
Missing Default,SubSonic.DataProviders.SQLite,SQLiteFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\SQLite\SQLiteFormatter.cs,VisitMethodCall,The following switch statement is missing a default case: switch (m.Method.Name) {                      case "op_Subtract":                          if (m.Arguments[1].Type == typeof(DateTime)) {                              sb.Append("DATEDIFF(");                              this.Visit(m.Arguments[0]);                              sb.Append("' ");                              this.Visit(m.Arguments[1]);                              sb.Append(")");                              return m;                          }                          break;                  }
Missing Default,SubSonic.DataProviders.SQLite,SQLiteFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\SQLite\SQLiteFormatter.cs,VisitMethodCall,The following switch statement is missing a default case: switch (m.Method.Name) {                      case "Add":                      case "Subtract":                      case "Multiply":                      case "Divide":                      case "Remainder":                          sb.Append("(");                          this.VisitValue(m.Arguments[0]);                          sb.Append(" ");                          sb.Append(GetOperator(m.Method.Name));                          sb.Append(" ");                          this.VisitValue(m.Arguments[1]);                          sb.Append(")");                          return m;                      case "Negate":                          sb.Append("-");                          this.Visit(m.Arguments[0]);                          sb.Append("");                          return m;                      case "Ceiling":                      case "Floor":                          sb.Append(m.Method.Name.ToUpper());                          sb.Append("(");                          this.Visit(m.Arguments[0]);                          sb.Append(")");                          return m;                      case "Round":                              sb.Append("ROUND(");                              this.Visit(m.Arguments[0]);                              sb.Append(")");                              return m;                      case "Truncate":                          sb.Append("ROUND(");                          this.Visit(m.Arguments[0]);                          sb.Append(")");                          return m;                  }
Missing Default,SubSonic.DataProviders.SQLite,SQLiteFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\SQLite\SQLiteFormatter.cs,VisitMethodCall,The following switch statement is missing a default case: switch (m.Method.Name) {                      case "Abs":                      case "Acos":                      case "Asin":                      case "Atan":                      case "Cos":                      case "Exp":                      case "Log10":                      case "Sin":                      case "Tan":                      case "Sqrt":                      case "Sign":                      case "Ceiling":                      case "Floor":                          sb.Append(m.Method.Name.ToUpper());                          sb.Append("(");                          this.Visit(m.Arguments[0]);                          sb.Append(")");                          return m;                      case "Atan2":                          sb.Append("ATN2(");                          this.Visit(m.Arguments[0]);                          sb.Append("' ");                          this.Visit(m.Arguments[1]);                          sb.Append(")");                          return m;                      case "Log":                          if (m.Arguments.Count == 1) {                              goto case "Log10";                          }                          break;                      case "Pow":                          sb.Append("POWER(");                          this.Visit(m.Arguments[0]);                          sb.Append("' ");                          this.Visit(m.Arguments[1]);                          sb.Append(")");                          return m;                      case "Round":                              sb.Append("ROUND(");                              this.Visit(m.Arguments[0]);                              sb.Append(")");                              return m;                      case "Truncate":                          sb.Append("ROUND(");                          this.Visit(m.Arguments[0]);                          sb.Append(")");                          return m;                  }
Missing Default,SubSonic.DataProviders.SQLite,SQLiteFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\SQLite\SQLiteFormatter.cs,VisitMemberAccess,The following switch statement is missing a default case: switch (m.Member.Name) {                      case "Length":                          sb.Append("LENGTH(");                          this.Visit(m.Expression);                          sb.Append(")");                          return m;                  }
Missing Default,SubSonic.DataProviders.SQLite,SQLiteFormatter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\DataProviders\SQLite\SQLiteFormatter.cs,VisitMemberAccess,The following switch statement is missing a default case: switch (m.Member.Name) {                      case "Day":                          sb.Append("CAST(strftime('%d''");                          this.Visit(m.Expression);                          sb.Append(") AS INTEGER)");                          return m;                      case "Month":                          sb.Append("CAST(strftime('%m''");                          this.Visit(m.Expression);                          sb.Append(") AS INTEGER)");                          return m;                      case "Year":                          sb.Append("CAST(strftime('%Y''");                          this.Visit(m.Expression);                          sb.Append(") AS INTEGER)");                          return m;                      case "Hour":                          sb.Append("CAST(strftime('%H''");                          this.Visit(m.Expression);                          sb.Append(") AS INTEGER)");                          return m;                      case "Minute":                          sb.Append("CAST(strftime('%M''");                          this.Visit(m.Expression);                          sb.Append(") AS INTEGER)");                          return m;                      case "Second":                          sb.Append("CAST(strftime('%S''");                          this.Visit(m.Expression);                          sb.Append(") AS INTEGER)");                          return m;                      case "Millisecond":                          sb.Append("CAST(strftime('%f''");                          this.Visit(m.Expression);                          sb.Append(") AS INTEGER)");                          return m;                      case "DayOfWeek":                          sb.Append("CAST(strftime('%w''");                          this.Visit(m.Expression);                          sb.Append(") AS INTEGER)");                          return m;                      case "DayOfYear":                          sb.Append("CAST(DATE( ");                          this.Visit(m.Expression);                          sb.Append("''MM/DD/YYYY') AS INTEGER)");                          return m;                  }
Missing Default,SubSonic.Linq.Translation,ClientJoinedProjectionRewriter,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\ClientJoinedProjectionRewriter.cs,GetEquiJoinKeyExpressions,The following switch statement is missing a default case: switch (predicate.NodeType)                  {                      case ExpressionType.And:                      case ExpressionType.AndAlso:                          return this.GetEquiJoinKeyExpressions(b.Left' outerAlias' outerExpressions' innerExpressions)                              && this.GetEquiJoinKeyExpressions(b.Right' outerAlias' outerExpressions' innerExpressions);                      case ExpressionType.Equal:                          ColumnExpression left = b.Left as ColumnExpression;                          ColumnExpression right = b.Right as ColumnExpression;                          if (left != null && right != null)                          {                              if (left.Alias == outerAlias)                              {                                  outerExpressions.Add(left);                                  innerExpressions.Add(right);                                  return true;                              }                              else if (right.Alias == outerAlias)                              {                                  innerExpressions.Add(left);                                  outerExpressions.Add(right);                                  return true;                              }                          }                          break;                  }
Missing Default,SubSonic.Linq.Translation,QueryBinder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\QueryBinder.cs,VisitMethodCall,The following switch statement is missing a default case: switch (m.Method.Name)                  {                      case "Where":                          return BindWhere(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "Select":                          return BindSelect(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1]));                      case "SelectMany":                          if (m.Arguments.Count == 2)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              return BindSelectMany(                                  m.Type' m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])                                  );                          }                          break;                      case "Join":                          return BindJoin(                              m.Type' m.Arguments[0]' m.Arguments[1]'                              (LambdaExpression) StripQuotes(m.Arguments[2])'                              (LambdaExpression) StripQuotes(m.Arguments[3])'                              (LambdaExpression) StripQuotes(m.Arguments[4])                              );                      case "OrderBy":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Ascending);                      case "OrderByDescending":                          return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                             OrderType.Descending);                      case "ThenBy":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Ascending);                      case "ThenByDescending":                          return BindThenBy(m.Arguments[0]' (LambdaExpression) StripQuotes(m.Arguments[1])'                                            OrderType.Descending);                      case "GroupBy":                          if (m.Arguments.Count == 2)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  null'                                  null                                  );                          }                          else if (m.Arguments.Count == 3)                          {                              LambdaExpression lambda1 = (LambdaExpression) StripQuotes(m.Arguments[1]);                              LambdaExpression lambda2 = (LambdaExpression) StripQuotes(m.Arguments[2]);                              if (lambda2.Parameters.Count == 1)                              {                                  // second lambda is element selector                                  return BindGroupBy(m.Arguments[0]' lambda1' lambda2' null);                              }                              else if (lambda2.Parameters.Count == 2)                              {                                  // second lambda is result selector                                  return BindGroupBy(m.Arguments[0]' lambda1' null' lambda2);                              }                          }                          else if (m.Arguments.Count == 4)                          {                              return BindGroupBy(                                  m.Arguments[0]'                                  (LambdaExpression) StripQuotes(m.Arguments[1])'                                  (LambdaExpression) StripQuotes(m.Arguments[2])'                                  (LambdaExpression) StripQuotes(m.Arguments[3])                                  );                          }                          break;                      case "Count":                      case "Min":                      case "Max":                      case "Sum":                      case "Average":                          if (m.Arguments.Count == 1)                          {                              return BindAggregate(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression selector = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAggregate(m.Arguments[0]' m.Method' selector' m == root);                          }                          break;                      case "Distinct":                          if (m.Arguments.Count == 1)                          {                              return BindDistinct(m.Arguments[0]);                          }                          break;                      case "Skip":                          if (m.Arguments.Count == 2)                          {                              return BindSkip(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "Take":                          if (m.Arguments.Count == 2)                          {                              return BindTake(m.Arguments[0]' m.Arguments[1]);                          }                          break;                      case "First":                      case "FirstOrDefault":                      case "Single":                      case "SingleOrDefault":                          if (m.Arguments.Count == 1)                          {                              return BindFirst(m.Arguments[0]' null' m.Method.Name' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindFirst(m.Arguments[0]' predicate' m.Method.Name' m == root);                          }                          break;                      case "Any":                          if (m.Arguments.Count == 1)                          {                              return BindAnyAll(m.Arguments[0]' m.Method' null' m == root);                          }                          else if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "All":                          if (m.Arguments.Count == 2)                          {                              LambdaExpression predicate = (LambdaExpression) StripQuotes(m.Arguments[1]);                              return BindAnyAll(m.Arguments[0]' m.Method' predicate' m == root);                          }                          break;                      case "Contains":                          if (m.Arguments.Count == 2)                          {                              return BindContains(m.Arguments[0]' m.Arguments[1]' m == root);                          }                          break;                  }
Missing Default,SubSonic.Linq.Translation,QueryBinder,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Linq\Translation\QueryBinder.cs,BindMember,The following switch statement is missing a default case: switch (source.NodeType)              {                  case ExpressionType.MemberInit:                      MemberInitExpression min = (MemberInitExpression) source;                      for (int i = 0' n = min.Bindings.Count; i < n; i++)                      {                          MemberAssignment assign = min.Bindings[i] as MemberAssignment;                          if (assign != null && MembersMatch(assign.Member' member))                          {                              return assign.Expression;                          }                      }                      break;                    case ExpressionType.New:                      NewExpression nex = (NewExpression) source;                      if (nex.Members != null)                      {                          for (int i = 0' n = nex.Members.Count; i < n; i++)                          {                              if (MembersMatch(nex.Members[i]' member))                              {                                  return nex.Arguments[i];                              }                          }                      }                      else if (nex.Type.IsGenericType && nex.Type.GetGenericTypeDefinition() == typeof (Grouping<'>))                      {                          if (member.Name == "Key")                          {                              return nex.Arguments[0];                          }                      }                      break;                    case (ExpressionType) DbExpressionType.Projection:                      // member access on a projection turns into a new projection w/ member access applied                      ProjectionExpression proj = (ProjectionExpression) source;                      Expression newProjector = BindMember(proj.Projector' member);                      return new ProjectionExpression(proj.Source' newProjector);                    case (ExpressionType) DbExpressionType.OuterJoined:                      OuterJoinedExpression oj = (OuterJoinedExpression) source;                      Expression em = BindMember(oj.Expression' member);                      if (em is ColumnExpression)                      {                          return em;                      }                      return new OuterJoinedExpression(oj.Test' em);                    case ExpressionType.Conditional:                      ConditionalExpression cex = (ConditionalExpression) source;                      return Expression.Condition(cex.Test' BindMember(cex.IfTrue' member)'                                                  BindMember(cex.IfFalse' member));                    case ExpressionType.Constant:                      ConstantExpression con = (ConstantExpression) source;                      if (con.Value == null)                      {                          Type memberType = TypeHelper.GetMemberType(member);                          return Expression.Constant(GetDefault(memberType)' memberType);                      }                      break;              }
Missing Default,SubSonic.Extensions,ExpressionParser,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\ExpressionParser.cs,ProcessMethodCall,The following switch statement is missing a default case: switch(expression.Method.Name)              {                  case op_Equality:                      // Handle book.Publisher == "xxx"                      BuildFromMemberAccess(expression' Comparison.Equals);                      break;                  case op_GreaterThan:                      // Handle book.Price <= xxx                      BuildFromMemberAccess(expression' Comparison.GreaterThan);                      break;                  case op_LessThan:                      // Handle book.Price <= xxx                      BuildFromMemberAccess(expression' Comparison.LessThan);                      break;                  case op_LessThanOrEqual:                      // Handle book.Price <= xxx                      BuildFromMemberAccess(expression' Comparison.LessOrEquals);                      break;                  case op_GreaterThanOrEqual:                      // Handle book.Price <= xxx                      BuildFromMemberAccess(expression' Comparison.GreaterOrEquals);                      break;                  case contains:                      BuildFromMemberAccess(expression' Comparison.Like);                      break;                  case startsWith:                      BuildFromMemberAccess(expression' Comparison.StartsWith);                      break;                  case endsWith:                      // Handle book.Title.Contains("xxx")                      BuildFromMemberAccess(expression' Comparison.EndsWith);                      break;              }
Missing Default,SubSonic.Extensions,QueryVisitor,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Extensions\QueryVisitor.cs,SetConstraintWildcards,The following switch statement is missing a default case: switch (constraint.Comparison)                  {                      case Comparison.StartsWith:                          constraint.ParameterValue = constraint.ParameterValue + "%";                          break;                      case Comparison.EndsWith:                          constraint.ParameterValue = "%" + constraint.ParameterValue;                          break;                      case Comparison.Like:                          constraint.ParameterValue = "%" + constraint.ParameterValue + "%";                          break;                  }
Missing Default,SubSonic.Query,Join,D:\research\architectureSmells\repos1\subsonic_SubSonic-3.0\SubSonic.Core\Query\Join.cs,GetJoinTypeValue,The following switch statement is missing a default case: switch(j)              {                  case JoinType.Outer:                      result = generator.sqlFragment.OUTER_JOIN;                      break;                  case JoinType.LeftInner:                      result = generator.sqlFragment.LEFT_INNER_JOIN;                      break;                  case JoinType.LeftOuter:                      result = generator.sqlFragment.LEFT_OUTER_JOIN;                      break;                  case JoinType.RightInner:                      result = generator.sqlFragment.RIGHT_INNER_JOIN;                      break;                  case JoinType.RightOuter:                      result = generator.sqlFragment.RIGHT_OUTER_JOIN;                      break;                  case JoinType.Cross:                      result = generator.sqlFragment.CROSS_JOIN;                      break;                  case JoinType.NotEqual:                      result = generator.sqlFragment.UNEQUAL_JOIN;                      break;              }
