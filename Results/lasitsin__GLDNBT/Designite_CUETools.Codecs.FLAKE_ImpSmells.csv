Implementation smell,Namespace,Class,File,Method,Description
Long Method,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The method has 111 lines of code.
Complex Method,CUETools.Codecs.FLAKE,FlacFrame,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\Flake.cs,ChooseSubframes,Cyclomatic complexity of the method is 10
Complex Method,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_frame_header,Cyclomatic complexity of the method is 11
Complex Method,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_residual,Cyclomatic complexity of the method is 8
Complex Method,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,Cyclomatic complexity of the method is 24
Complex Method,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples,Cyclomatic complexity of the method is 31
Complex Method,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,Cyclomatic complexity of the method is 15
Complex Method,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,get_wasted_bits,Cyclomatic complexity of the method is 9
Complex Method,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,Cyclomatic complexity of the method is 25
Complex Method,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,Cyclomatic complexity of the method is 12
Complex Method,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual,Cyclomatic complexity of the method is 16
Complex Method,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_subframes,Cyclomatic complexity of the method is 16
Complex Method,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,estimate_frame,Cyclomatic complexity of the method is 14
Complex Method,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,measure_frame_size,Cyclomatic complexity of the method is 8
Complex Method,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_estimated_frame,Cyclomatic complexity of the method is 11
Complex Method,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_frame,Cyclomatic complexity of the method is 12
Complex Method,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_encode_init,Cyclomatic complexity of the method is 15
Complex Method,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,Cyclomatic complexity of the method is 58
Long Parameter List,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,calc_optimal_rice_params,The method has 6 parameters.
Long Parameter List,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,calc_sums,The method has 6 parameters.
Long Parameter List,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,calc_sums18,The method has 6 parameters.
Long Parameter List,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,calc_sums16,The method has 6 parameters.
Long Parameter List,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,calc_rice_params,The method has 7 parameters.
Long Parameter List,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The method has 5 parameters.
Long Parameter List,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual,The method has 6 parameters.
Long Identifier,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The length of the parameter FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN is 51.
Long Identifier,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The length of the parameter FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN is 51.
Long Identifier,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The length of the parameter FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN is 51.
Long Identifier,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The length of the parameter FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN is 51.
Long Identifier,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The length of the parameter FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN is 48.
Long Identifier,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The length of the parameter FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN is 45.
Long Identifier,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The length of the parameter FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN is 52.
Long Identifier,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The length of the parameter FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN is 50.
Long Identifier,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The length of the parameter FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN is 43.
Long Statement,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,fill_frames_buffer,The length of the statement  "		int read = _IO.Read (_framesBuffer' _framesBufferOffset + _framesBufferLength' _framesBuffer.Length - _framesBufferOffset - _framesBufferLength); " is 145.
Long Statement,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The length of the statement  "			data [i] = residual [i] + ((data [i - 1] + data [i - 3]) << 2) - ((data [i - 2] << 2) + (data [i - 2] << 1)) - data [i - 4]; " is 124.
Long Statement,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,calc_lower_sums,The length of the statement  "			sums [i * Flake.MAX_PARTITIONS + j] = sums [(i + 1) * Flake.MAX_PARTITIONS + 2 * j] + sums [(i + 1) * Flake.MAX_PARTITIONS + 2 * j + 1]; " is 136.
Long Statement,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,calc_sums18,The length of the statement  "		sums [i] = 0UL + *(res++) + *(res++) + *(res++) + *(res++) + *(res++) + *(res++) + *(res++) + *(res++) + *(res++) + *(res++) + *(res++) + *(res++) + *(res++) + *(res++) + *(res++) + *(res++) + *(res++) + *(res++); " is 213.
Long Statement,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,calc_sums16,The length of the statement  "		sums [i] = 0UL + *(res++) + *(res++) + *(res++) + *(res++) + *(res++) + *(res++) + *(res++) + *(res++) + *(res++) + *(res++) + *(res++) + *(res++) + *(res++) + *(res++) + *(res++) + *(res++); " is 191.
Long Statement,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,calc_rice_params,The length of the statement  "		uint bits = calc_optimal_rice_params (i' parm + i * Flake.MAX_PARTITIONS' sums + i * Flake.MAX_PARTITIONS' n' pred_order' ref method); " is 134.
Long Statement,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The length of the statement  "	for (int i_precision = eparams.lpc_min_precision_search; i_precision <= eparams.lpc_max_precision_search && lpc_precision + i_precision < 16; i_precision++) " is 156.
Long Statement,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The length of the statement  "				lpc.quantize_lpc_coefs (lpcs + (frame.current.order - 1) * lpc.MAX_LPC_ORDER' frame.current.order' cbits' coefs' out frame.current.shift' 15' 0); " is 145.
Long Statement,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The length of the statement  "					lpc.encode_residual_long (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift); " is 146.
Long Statement,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The length of the statement  "					lpc.encode_residual (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift); " is 141.
Long Statement,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The length of the statement  "			uint best_size = calc_rice_params (frame.current.rc' pmin' pmax' frame.current.residual' (uint)frame.blocksize' (uint)frame.current.order' PCM.BitsPerSample); " is 158.
Long Statement,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The length of the statement  "			//        uint new_size = calc_rice_params(ref frame.current.rc' pmin' pmax' frame.current.residual' (uint)frame.blocksize' (uint)frame.current.order); " is 151.
Long Statement,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The length of the statement  "			frame.current.size = (uint)(frame.current.order * frame.subframes [ch].obits + 4 + 5 + frame.current.order * (int)cbits + 6 + (int)best_size); " is 142.
Long Statement,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed_sub,The length of the statement  "	frame.current.size = (uint)(frame.current.order * frame.subframes [ch].obits) + 6 + calc_rice_params (frame.current.rc' pmin' pmax' frame.current.residual' (uint)frame.blocksize' (uint)frame.current.order' PCM.BitsPerSample); " is 225.
Long Statement,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual,The length of the statement  "	if (predict == PredictionType.Fixed || (predict == PredictionType.Search && pass != 1) || //predict == PredictionType.Search || " is 127.
Long Statement,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual,The length of the statement  "	if (n > eparams.max_prediction_order && (predict == PredictionType.Levinson || predict == PredictionType.Search)//predict == PredictionType.Search || " is 149.
Long Statement,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,estimate_best_window,The length of the statement  "			frame.subframes [ch].lpc_ctx [i].GetReflection (order' frame.subframes [ch].samples' frame.blocksize' frame.window_buffer + i * Flake.MAX_BLOCKSIZE * 2); " is 153.
Long Statement,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,estimate_best_window,The length of the statement  "			double err = frame.subframes [ch].lpc_ctx [i].prediction_error [order - 1] / frame.subframes [ch].lpc_ctx [i].autocorr_values [0]; " is 130.
Long Statement,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,estimate_frame,The length of the statement  "			frame.subframes [ch].best.size = (uint)Math.Max (0' lpc_ctx.Akaike (frame.blocksize' lpc_ctx.best_orders [0]' 4.5' 0.0) + 7.1 * frame.subframes [ch].obits * eparams.max_prediction_order); " is 187.
Long Statement,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,measure_frame_size,The length of the statement  "	uint total = (uint)(32 + ((BitReader.log2i (frame_count) + 4) / 5) * 8 + (eparams.variable_block_size != 0 ? 16 : 0) + 16); " is 123.
Long Statement,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The length of the statement  "					frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize)); " is 172.
Long Statement,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The length of the statement  "				//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize); " is 127.
Long Statement,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The length of the statement  "					frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize)); " is 192.
Long Statement,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The length of the statement  "				//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2); " is 168.
Long Statement,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The length of the statement  "							frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits); " is 198.
Long Statement,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The length of the statement  "								frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits); " is 218.
Long Statement,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_frame,The length of the statement  "			Buffer.BlockCopy (samplesBuffer' (bs + ch * Flake.MAX_BLOCKSIZE) * sizeof(int)' samplesBuffer' ch * Flake.MAX_BLOCKSIZE * sizeof(int)' (eparams.block_size - bs) * sizeof(int)); " is 176.
Long Statement,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_frame,The length of the statement  "		//        AudioSamples.MemCpy(s + ch * Flake.MAX_BLOCKSIZE' s + bs + ch * Flake.MAX_BLOCKSIZE' eparams.block_size - bs); " is 120.
Complex Conditional,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,FlakeReader,The conditional expression  "(PCM.BitsPerSample != 16 && PCM.BitsPerSample != 24) || PCM.ChannelCount != 2 || (PCM.SampleRate != 44100 && PCM.SampleRate != 48000)"  is complex.
Complex Conditional,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual,The conditional expression  "predict == PredictionType.Fixed || (predict == PredictionType.Search && pass != 1) || //predict == PredictionType.Search ||  //(pass == 2 && frame.subframes[ch].best.type == SubframeType.Fixed) ||  n <= eparams.max_prediction_order"  is complex.
Magic Number,CUETools.Codecs.FLAKE,FlacFrame,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\Flake.cs,InitSize,The following statement contains a magic number: if (!vbs) {  	for (i = 0; i < 15; i++) {  		if (bs == Flake.flac_blocksizes [i]) {  			bs_code0 = i;  			bs_code1 = -1;  			break;  		}  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlacFrame,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\Flake.cs,InitSize,The following statement contains a magic number: for (i = 0; i < 15; i++) {  	if (bs == Flake.flac_blocksizes [i]) {  		bs_code0 = i;  		bs_code1 = -1;  		break;  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlacFrame,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\Flake.cs,InitSize,The following statement contains a magic number: if (i == 15) {  	if (blocksize <= 256) {  		bs_code0 = 6;  		bs_code1 = blocksize - 1;  	}  	else {  		bs_code0 = 7;  		bs_code1 = blocksize - 1;  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlacFrame,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\Flake.cs,InitSize,The following statement contains a magic number: if (i == 15) {  	if (blocksize <= 256) {  		bs_code0 = 6;  		bs_code1 = blocksize - 1;  	}  	else {  		bs_code0 = 7;  		bs_code1 = blocksize - 1;  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlacFrame,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\Flake.cs,InitSize,The following statement contains a magic number: if (i == 15) {  	if (blocksize <= 256) {  		bs_code0 = 6;  		bs_code1 = blocksize - 1;  	}  	else {  		bs_code0 = 7;  		bs_code1 = blocksize - 1;  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlacFrame,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\Flake.cs,InitSize,The following statement contains a magic number: if (i == 15) {  	if (blocksize <= 256) {  		bs_code0 = 6;  		bs_code1 = blocksize - 1;  	}  	else {  		bs_code0 = 7;  		bs_code1 = blocksize - 1;  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlacFrame,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\Flake.cs,InitSize,The following statement contains a magic number: if (blocksize <= 256) {  	bs_code0 = 6;  	bs_code1 = blocksize - 1;  }  else {  	bs_code0 = 7;  	bs_code1 = blocksize - 1;  }  
Magic Number,CUETools.Codecs.FLAKE,FlacFrame,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\Flake.cs,InitSize,The following statement contains a magic number: if (blocksize <= 256) {  	bs_code0 = 6;  	bs_code1 = blocksize - 1;  }  else {  	bs_code0 = 7;  	bs_code1 = blocksize - 1;  }  
Magic Number,CUETools.Codecs.FLAKE,FlacFrame,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\Flake.cs,InitSize,The following statement contains a magic number: if (blocksize <= 256) {  	bs_code0 = 6;  	bs_code1 = blocksize - 1;  }  else {  	bs_code0 = 7;  	bs_code1 = blocksize - 1;  }  
Magic Number,CUETools.Codecs.FLAKE,FlacFrame,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\Flake.cs,InitSize,The following statement contains a magic number: bs_code0 = 6;  
Magic Number,CUETools.Codecs.FLAKE,FlacFrame,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\Flake.cs,InitSize,The following statement contains a magic number: bs_code0 = 7;  
Magic Number,CUETools.Codecs.FLAKE,FlacFrame,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\Flake.cs,ChooseSubframes,The following statement contains a magic number: switch (ch_mode) {  case ChannelMode.MidSide:  	SwapSubframes (0' 2);  	SwapSubframes (1' 3);  	break;  case ChannelMode.RightSide:  	SwapSubframes (0' 3);  	break;  case ChannelMode.LeftSide:  	SwapSubframes (1' 3);  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlacFrame,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\Flake.cs,ChooseSubframes,The following statement contains a magic number: switch (ch_mode) {  case ChannelMode.MidSide:  	SwapSubframes (0' 2);  	SwapSubframes (1' 3);  	break;  case ChannelMode.RightSide:  	SwapSubframes (0' 3);  	break;  case ChannelMode.LeftSide:  	SwapSubframes (1' 3);  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlacFrame,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\Flake.cs,ChooseSubframes,The following statement contains a magic number: switch (ch_mode) {  case ChannelMode.MidSide:  	SwapSubframes (0' 2);  	SwapSubframes (1' 3);  	break;  case ChannelMode.RightSide:  	SwapSubframes (0' 3);  	break;  case ChannelMode.LeftSide:  	SwapSubframes (1' 3);  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlacFrame,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\Flake.cs,ChooseSubframes,The following statement contains a magic number: switch (ch_mode) {  case ChannelMode.MidSide:  	SwapSubframes (0' 2);  	SwapSubframes (1' 3);  	break;  case ChannelMode.RightSide:  	SwapSubframes (0' 3);  	break;  case ChannelMode.LeftSide:  	SwapSubframes (1' 3);  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlacFrame,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\Flake.cs,ChooseSubframes,The following statement contains a magic number: SwapSubframes (0' 2);  
Magic Number,CUETools.Codecs.FLAKE,FlacFrame,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\Flake.cs,ChooseSubframes,The following statement contains a magic number: SwapSubframes (1' 3);  
Magic Number,CUETools.Codecs.FLAKE,FlacFrame,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\Flake.cs,ChooseSubframes,The following statement contains a magic number: SwapSubframes (0' 3);  
Magic Number,CUETools.Codecs.FLAKE,FlacFrame,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\Flake.cs,ChooseSubframes,The following statement contains a magic number: SwapSubframes (1' 3);  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,FlakeReader,The following statement contains a magic number: if (((int)max_frame_size * PCM.BitsPerSample * PCM.ChannelCount * 2 >> 3) > _framesBuffer.Length) {  	byte[] temp = _framesBuffer;  	_framesBuffer = new byte[((int)max_frame_size * PCM.BitsPerSample * PCM.ChannelCount * 2 >> 3)];  	if (_framesBufferLength > 0)  		Array.Copy (temp' _framesBufferOffset' _framesBuffer' 0' _framesBufferLength);  	_framesBufferOffset = 0;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,FlakeReader,The following statement contains a magic number: if (((int)max_frame_size * PCM.BitsPerSample * PCM.ChannelCount * 2 >> 3) > _framesBuffer.Length) {  	byte[] temp = _framesBuffer;  	_framesBuffer = new byte[((int)max_frame_size * PCM.BitsPerSample * PCM.ChannelCount * 2 >> 3)];  	if (_framesBufferLength > 0)  		Array.Copy (temp' _framesBufferOffset' _framesBuffer' 0' _framesBufferLength);  	_framesBufferOffset = 0;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,FlakeReader,The following statement contains a magic number: if (((int)max_frame_size * PCM.BitsPerSample * PCM.ChannelCount * 2 >> 3) > _framesBuffer.Length) {  	byte[] temp = _framesBuffer;  	_framesBuffer = new byte[((int)max_frame_size * PCM.BitsPerSample * PCM.ChannelCount * 2 >> 3)];  	if (_framesBufferLength > 0)  		Array.Copy (temp' _framesBufferOffset' _framesBuffer' 0' _framesBufferLength);  	_framesBufferOffset = 0;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,FlakeReader,The following statement contains a magic number: if (((int)max_frame_size * PCM.BitsPerSample * PCM.ChannelCount * 2 >> 3) > _framesBuffer.Length) {  	byte[] temp = _framesBuffer;  	_framesBuffer = new byte[((int)max_frame_size * PCM.BitsPerSample * PCM.ChannelCount * 2 >> 3)];  	if (_framesBufferLength > 0)  		Array.Copy (temp' _framesBufferOffset' _framesBuffer' 0' _framesBufferLength);  	_framesBufferOffset = 0;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,FlakeReader,The following statement contains a magic number: _framesBuffer = new byte[((int)max_frame_size * PCM.BitsPerSample * PCM.ChannelCount * 2 >> 3)];  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,FlakeReader,The following statement contains a magic number: _framesBuffer = new byte[((int)max_frame_size * PCM.BitsPerSample * PCM.ChannelCount * 2 >> 3)];  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,FlakeReader,The following statement contains a magic number: if ((PCM.BitsPerSample != 16 && PCM.BitsPerSample != 24) || PCM.ChannelCount != 2 || (PCM.SampleRate != 44100 && PCM.SampleRate != 48000))  	throw new Exception ("invalid flac file");  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,FlakeReader,The following statement contains a magic number: if ((PCM.BitsPerSample != 16 && PCM.BitsPerSample != 24) || PCM.ChannelCount != 2 || (PCM.SampleRate != 44100 && PCM.SampleRate != 48000))  	throw new Exception ("invalid flac file");  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,FlakeReader,The following statement contains a magic number: if ((PCM.BitsPerSample != 16 && PCM.BitsPerSample != 24) || PCM.ChannelCount != 2 || (PCM.SampleRate != 44100 && PCM.SampleRate != 48000))  	throw new Exception ("invalid flac file");  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,FlakeReader,The following statement contains a magic number: if ((PCM.BitsPerSample != 16 && PCM.BitsPerSample != 24) || PCM.ChannelCount != 2 || (PCM.SampleRate != 44100 && PCM.SampleRate != 48000))  	throw new Exception ("invalid flac file");  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,FlakeReader,The following statement contains a magic number: if ((PCM.BitsPerSample != 16 && PCM.BitsPerSample != 24) || PCM.ChannelCount != 2 || (PCM.SampleRate != 44100 && PCM.SampleRate != 48000))  	throw new Exception ("invalid flac file");  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,interlace,The following statement contains a magic number: if (PCM.ChannelCount == 2) {  	fixed (int* src = &samplesBuffer [_samplesBufferOffset])  		buff.Interlace (offset' src' src + Flake.MAX_BLOCKSIZE' count);  }  else {  	for (int ch = 0; ch < PCM.ChannelCount; ch++)  		fixed (int* res = &buff.Samples [offset' ch]' src = &samplesBuffer [_samplesBufferOffset + ch * Flake.MAX_BLOCKSIZE]) {  			int* psrc = src;  			for (int i = 0; i < count; i++)  				res [i + i] = *(psrc++);  		}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,fill_frames_buffer,The following statement contains a magic number: if (_framesBufferLength == 0)  	_framesBufferOffset = 0;  else if (_framesBufferLength < _framesBuffer.Length / 2 && _framesBufferOffset >= _framesBuffer.Length / 2) {  	fixed (byte* buff = _framesBuffer)  		AudioSamples.MemCpy (buff' buff + _framesBufferOffset' _framesBufferLength);  	_framesBufferOffset = 0;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,fill_frames_buffer,The following statement contains a magic number: if (_framesBufferLength == 0)  	_framesBufferOffset = 0;  else if (_framesBufferLength < _framesBuffer.Length / 2 && _framesBufferOffset >= _framesBuffer.Length / 2) {  	fixed (byte* buff = _framesBuffer)  		AudioSamples.MemCpy (buff' buff + _framesBufferOffset' _framesBufferLength);  	_framesBufferOffset = 0;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,fill_frames_buffer,The following statement contains a magic number: if (_framesBufferLength < _framesBuffer.Length / 2 && _framesBufferOffset >= _framesBuffer.Length / 2) {  	fixed (byte* buff = _framesBuffer)  		AudioSamples.MemCpy (buff' buff + _framesBufferOffset' _framesBufferLength);  	_framesBufferOffset = 0;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,fill_frames_buffer,The following statement contains a magic number: if (_framesBufferLength < _framesBuffer.Length / 2 && _framesBufferOffset >= _framesBuffer.Length / 2) {  	fixed (byte* buff = _framesBuffer)  		AudioSamples.MemCpy (buff' buff + _framesBufferOffset' _framesBufferLength);  	_framesBufferOffset = 0;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,fill_frames_buffer,The following statement contains a magic number: while (_framesBufferLength < _framesBuffer.Length / 2) {  	int read = _IO.Read (_framesBuffer' _framesBufferOffset + _framesBufferLength' _framesBuffer.Length - _framesBufferOffset - _framesBufferLength);  	_framesBufferLength += read;  	if (read == 0)  		break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_frame_header,The following statement contains a magic number: if (bitreader.readbits (15) != 0x7FFC)  	throw new Exception ("invalid frame");  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_frame_header,The following statement contains a magic number: frame.bs_code0 = (int)bitreader.readbits (4);  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_frame_header,The following statement contains a magic number: frame.ch_mode = (ChannelMode)bitreader.readbits (4);  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_frame_header,The following statement contains a magic number: if (frame.bs_code0 == 6) {  	frame.bs_code1 = (int)bitreader.readbits (8);  	frame.blocksize = frame.bs_code1 + 1;  }  else if (frame.bs_code0 == 7) {  	frame.bs_code1 = (int)bitreader.readbits (16);  	frame.blocksize = frame.bs_code1 + 1;  }  else  	frame.blocksize = Flake.flac_blocksizes [frame.bs_code0];  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_frame_header,The following statement contains a magic number: if (frame.bs_code0 == 6) {  	frame.bs_code1 = (int)bitreader.readbits (8);  	frame.blocksize = frame.bs_code1 + 1;  }  else if (frame.bs_code0 == 7) {  	frame.bs_code1 = (int)bitreader.readbits (16);  	frame.blocksize = frame.bs_code1 + 1;  }  else  	frame.blocksize = Flake.flac_blocksizes [frame.bs_code0];  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_frame_header,The following statement contains a magic number: if (frame.bs_code0 == 6) {  	frame.bs_code1 = (int)bitreader.readbits (8);  	frame.blocksize = frame.bs_code1 + 1;  }  else if (frame.bs_code0 == 7) {  	frame.bs_code1 = (int)bitreader.readbits (16);  	frame.blocksize = frame.bs_code1 + 1;  }  else  	frame.blocksize = Flake.flac_blocksizes [frame.bs_code0];  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_frame_header,The following statement contains a magic number: if (frame.bs_code0 == 6) {  	frame.bs_code1 = (int)bitreader.readbits (8);  	frame.blocksize = frame.bs_code1 + 1;  }  else if (frame.bs_code0 == 7) {  	frame.bs_code1 = (int)bitreader.readbits (16);  	frame.blocksize = frame.bs_code1 + 1;  }  else  	frame.blocksize = Flake.flac_blocksizes [frame.bs_code0];  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_frame_header,The following statement contains a magic number: frame.bs_code1 = (int)bitreader.readbits (8);  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_frame_header,The following statement contains a magic number: if (frame.bs_code0 == 7) {  	frame.bs_code1 = (int)bitreader.readbits (16);  	frame.blocksize = frame.bs_code1 + 1;  }  else  	frame.blocksize = Flake.flac_blocksizes [frame.bs_code0];  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_frame_header,The following statement contains a magic number: if (frame.bs_code0 == 7) {  	frame.bs_code1 = (int)bitreader.readbits (16);  	frame.blocksize = frame.bs_code1 + 1;  }  else  	frame.blocksize = Flake.flac_blocksizes [frame.bs_code0];  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_frame_header,The following statement contains a magic number: frame.bs_code1 = (int)bitreader.readbits (16);  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_frame_header,The following statement contains a magic number: if (sr_code0 < 4 || sr_code0 > 11) {  	// sr_code0 == 12 -> sr == bitreader.readbits(8) * 1000;  	// sr_code0 == 13 -> sr == bitreader.readbits(16);  	// sr_code0 == 14 -> sr == bitreader.readbits(16) * 10;  	throw new Exception ("invalid sample rate mode");  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_frame_header,The following statement contains a magic number: if (sr_code0 < 4 || sr_code0 > 11) {  	// sr_code0 == 12 -> sr == bitreader.readbits(8) * 1000;  	// sr_code0 == 13 -> sr == bitreader.readbits(16);  	// sr_code0 == 14 -> sr == bitreader.readbits(16) * 10;  	throw new Exception ("invalid sample rate mode");  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_frame_header,The following statement contains a magic number: if (frame_channels > 11)  	throw new Exception ("invalid channel mode");  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_frame_header,The following statement contains a magic number: if (frame_channels == 2 || frame_channels > 8)  	// Mid/Left/Right Side Stereo  	frame_channels = 2;  else  	frame.ch_mode = ChannelMode.NotStereo;  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_frame_header,The following statement contains a magic number: if (frame_channels == 2 || frame_channels > 8)  	// Mid/Left/Right Side Stereo  	frame_channels = 2;  else  	frame.ch_mode = ChannelMode.NotStereo;  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_frame_header,The following statement contains a magic number: if (frame_channels == 2 || frame_channels > 8)  	// Mid/Left/Right Side Stereo  	frame_channels = 2;  else  	frame.ch_mode = ChannelMode.NotStereo;  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_frame_header,The following statement contains a magic number: frame_channels = 2;  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_frame_header,The following statement contains a magic number: frame.crc8 = (byte)bitreader.readbits (8);  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_residual,The following statement contains a magic number: frame.subframes [ch].best.rc.coding_method = (int)bitreader.readbits (2);  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_residual,The following statement contains a magic number: frame.subframes [ch].best.rc.porder = (int)bitreader.readbits (4);  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_residual,The following statement contains a magic number: if (frame.subframes [ch].best.rc.porder > 8)  	throw new Exception ("invalid partition order");  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_residual,The following statement contains a magic number: for (int p = 0; p < (1 << frame.subframes [ch].best.rc.porder); p++) {  	if (p == 1)  		res_cnt = psize;  	int n = Math.Min (res_cnt' frame.blocksize - j);  	int k = frame.subframes [ch].best.rc.rparams [p] = (int)bitreader.readbits (rice_len);  	if (k == (1 << rice_len) - 1) {  		k = frame.subframes [ch].best.rc.esc_bps [p] = (int)bitreader.readbits (5);  		for (int i = n; i > 0; i--)  			*(r++) = bitreader.readbits_signed ((int)k);  	}  	else {  		bitreader.read_rice_block (n' (int)k' r);  		r += n;  	}  	j += n;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_residual,The following statement contains a magic number: if (k == (1 << rice_len) - 1) {  	k = frame.subframes [ch].best.rc.esc_bps [p] = (int)bitreader.readbits (5);  	for (int i = n; i > 0; i--)  		*(r++) = bitreader.readbits_signed ((int)k);  }  else {  	bitreader.read_rice_block (n' (int)k' r);  	r += n;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_residual,The following statement contains a magic number: k = frame.subframes [ch].best.rc.esc_bps [p] = (int)bitreader.readbits (5);  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_subframe_lpc,The following statement contains a magic number: frame.subframes [ch].best.cbits = (int)bitreader.readbits (4) + 1;  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_subframe_lpc,The following statement contains a magic number: frame.subframes [ch].best.shift = bitreader.readbits_signed (5);  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_subframes,The following statement contains a magic number: fixed (int* r = residualBuffer' s = samplesBuffer)  	for (int ch = 0; ch < PCM.ChannelCount; ch++) {  		// subframe header  		uint t1 = bitreader.readbit ();  		// ?????? == 0  		if (t1 != 0)  			throw new Exception ("unsupported subframe coding (ch == " + ch.ToString () + ")");  		int type_code = (int)bitreader.readbits (6);  		frame.subframes [ch].wbits = (int)bitreader.readbit ();  		if (frame.subframes [ch].wbits != 0)  			frame.subframes [ch].wbits += (int)bitreader.read_unary ();  		frame.subframes [ch].obits = PCM.BitsPerSample - frame.subframes [ch].wbits;  		switch (frame.ch_mode) {  		case ChannelMode.MidSide:  			frame.subframes [ch].obits += ch;  			break;  		case ChannelMode.LeftSide:  			frame.subframes [ch].obits += ch;  			break;  		case ChannelMode.RightSide:  			frame.subframes [ch].obits += 1 - ch;  			break;  		}  		frame.subframes [ch].best.type = (SubframeType)type_code;  		frame.subframes [ch].best.order = 0;  		if ((type_code & (uint)SubframeType.LPC) != 0) {  			frame.subframes [ch].best.order = (type_code - (int)SubframeType.LPC) + 1;  			frame.subframes [ch].best.type = SubframeType.LPC;  		}  		else if ((type_code & (uint)SubframeType.Fixed) != 0) {  			frame.subframes [ch].best.order = (type_code - (int)SubframeType.Fixed);  			frame.subframes [ch].best.type = SubframeType.Fixed;  		}  		frame.subframes [ch].best.residual = r + ch * Flake.MAX_BLOCKSIZE;  		frame.subframes [ch].samples = s + ch * Flake.MAX_BLOCKSIZE;  		// subframe  		switch (frame.subframes [ch].best.type) {  		case SubframeType.Constant:  			decode_subframe_constant (bitreader' frame' ch);  			break;  		case SubframeType.Verbatim:  			decode_subframe_verbatim (bitreader' frame' ch);  			break;  		case SubframeType.Fixed:  			decode_subframe_fixed (bitreader' frame' ch);  			break;  		case SubframeType.LPC:  			decode_subframe_lpc (bitreader' frame' ch);  			break;  		default:  			throw new Exception ("invalid subframe type");  		}  	}  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_subframes,The following statement contains a magic number: for (int ch = 0; ch < PCM.ChannelCount; ch++) {  	// subframe header  	uint t1 = bitreader.readbit ();  	// ?????? == 0  	if (t1 != 0)  		throw new Exception ("unsupported subframe coding (ch == " + ch.ToString () + ")");  	int type_code = (int)bitreader.readbits (6);  	frame.subframes [ch].wbits = (int)bitreader.readbit ();  	if (frame.subframes [ch].wbits != 0)  		frame.subframes [ch].wbits += (int)bitreader.read_unary ();  	frame.subframes [ch].obits = PCM.BitsPerSample - frame.subframes [ch].wbits;  	switch (frame.ch_mode) {  	case ChannelMode.MidSide:  		frame.subframes [ch].obits += ch;  		break;  	case ChannelMode.LeftSide:  		frame.subframes [ch].obits += ch;  		break;  	case ChannelMode.RightSide:  		frame.subframes [ch].obits += 1 - ch;  		break;  	}  	frame.subframes [ch].best.type = (SubframeType)type_code;  	frame.subframes [ch].best.order = 0;  	if ((type_code & (uint)SubframeType.LPC) != 0) {  		frame.subframes [ch].best.order = (type_code - (int)SubframeType.LPC) + 1;  		frame.subframes [ch].best.type = SubframeType.LPC;  	}  	else if ((type_code & (uint)SubframeType.Fixed) != 0) {  		frame.subframes [ch].best.order = (type_code - (int)SubframeType.Fixed);  		frame.subframes [ch].best.type = SubframeType.Fixed;  	}  	frame.subframes [ch].best.residual = r + ch * Flake.MAX_BLOCKSIZE;  	frame.subframes [ch].samples = s + ch * Flake.MAX_BLOCKSIZE;  	// subframe  	switch (frame.subframes [ch].best.type) {  	case SubframeType.Constant:  		decode_subframe_constant (bitreader' frame' ch);  		break;  	case SubframeType.Verbatim:  		decode_subframe_verbatim (bitreader' frame' ch);  		break;  	case SubframeType.Fixed:  		decode_subframe_fixed (bitreader' frame' ch);  		break;  	case SubframeType.LPC:  		decode_subframe_lpc (bitreader' frame' ch);  		break;  	default:  		throw new Exception ("invalid subframe type");  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The following statement contains a magic number: switch (sub.best.order) {  case 0:  	AudioSamples.MemCpy (data' residual' data_len);  	break;  case 1:  	s1 = data [-1];  	for (int i = data_len; i > 0; i--) {  		s1 += *(residual++);  		*(data++) = s1;  	}  	//data[i] = residual[i] + data[i - 1];  	break;  case 2:  	s2 = data [-2];  	s1 = data [-1];  	for (int i = data_len; i > 0; i--) {  		s0 = *(residual++) + (s1 << 1) - s2;  		*(data++) = s0;  		s2 = s1;  		s1 = s0;  	}  	//data[i] = residual[i] + data[i - 1] * 2  - data[i - 2];  	break;  case 3:  	for (int i = 0; i < data_len; i++)  		data [i] = residual [i] + (((data [i - 1] - data [i - 2]) << 1) + (data [i - 1] - data [i - 2])) + data [i - 3];  	break;  case 4:  	for (int i = 0; i < data_len; i++)  		data [i] = residual [i] + ((data [i - 1] + data [i - 3]) << 2) - ((data [i - 2] << 2) + (data [i - 2] << 1)) - data [i - 4];  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The following statement contains a magic number: switch (sub.best.order) {  case 0:  	AudioSamples.MemCpy (data' residual' data_len);  	break;  case 1:  	s1 = data [-1];  	for (int i = data_len; i > 0; i--) {  		s1 += *(residual++);  		*(data++) = s1;  	}  	//data[i] = residual[i] + data[i - 1];  	break;  case 2:  	s2 = data [-2];  	s1 = data [-1];  	for (int i = data_len; i > 0; i--) {  		s0 = *(residual++) + (s1 << 1) - s2;  		*(data++) = s0;  		s2 = s1;  		s1 = s0;  	}  	//data[i] = residual[i] + data[i - 1] * 2  - data[i - 2];  	break;  case 3:  	for (int i = 0; i < data_len; i++)  		data [i] = residual [i] + (((data [i - 1] - data [i - 2]) << 1) + (data [i - 1] - data [i - 2])) + data [i - 3];  	break;  case 4:  	for (int i = 0; i < data_len; i++)  		data [i] = residual [i] + ((data [i - 1] + data [i - 3]) << 2) - ((data [i - 2] << 2) + (data [i - 2] << 1)) - data [i - 4];  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The following statement contains a magic number: switch (sub.best.order) {  case 0:  	AudioSamples.MemCpy (data' residual' data_len);  	break;  case 1:  	s1 = data [-1];  	for (int i = data_len; i > 0; i--) {  		s1 += *(residual++);  		*(data++) = s1;  	}  	//data[i] = residual[i] + data[i - 1];  	break;  case 2:  	s2 = data [-2];  	s1 = data [-1];  	for (int i = data_len; i > 0; i--) {  		s0 = *(residual++) + (s1 << 1) - s2;  		*(data++) = s0;  		s2 = s1;  		s1 = s0;  	}  	//data[i] = residual[i] + data[i - 1] * 2  - data[i - 2];  	break;  case 3:  	for (int i = 0; i < data_len; i++)  		data [i] = residual [i] + (((data [i - 1] - data [i - 2]) << 1) + (data [i - 1] - data [i - 2])) + data [i - 3];  	break;  case 4:  	for (int i = 0; i < data_len; i++)  		data [i] = residual [i] + ((data [i - 1] + data [i - 3]) << 2) - ((data [i - 2] << 2) + (data [i - 2] << 1)) - data [i - 4];  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The following statement contains a magic number: switch (sub.best.order) {  case 0:  	AudioSamples.MemCpy (data' residual' data_len);  	break;  case 1:  	s1 = data [-1];  	for (int i = data_len; i > 0; i--) {  		s1 += *(residual++);  		*(data++) = s1;  	}  	//data[i] = residual[i] + data[i - 1];  	break;  case 2:  	s2 = data [-2];  	s1 = data [-1];  	for (int i = data_len; i > 0; i--) {  		s0 = *(residual++) + (s1 << 1) - s2;  		*(data++) = s0;  		s2 = s1;  		s1 = s0;  	}  	//data[i] = residual[i] + data[i - 1] * 2  - data[i - 2];  	break;  case 3:  	for (int i = 0; i < data_len; i++)  		data [i] = residual [i] + (((data [i - 1] - data [i - 2]) << 1) + (data [i - 1] - data [i - 2])) + data [i - 3];  	break;  case 4:  	for (int i = 0; i < data_len; i++)  		data [i] = residual [i] + ((data [i - 1] + data [i - 3]) << 2) - ((data [i - 2] << 2) + (data [i - 2] << 1)) - data [i - 4];  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The following statement contains a magic number: switch (sub.best.order) {  case 0:  	AudioSamples.MemCpy (data' residual' data_len);  	break;  case 1:  	s1 = data [-1];  	for (int i = data_len; i > 0; i--) {  		s1 += *(residual++);  		*(data++) = s1;  	}  	//data[i] = residual[i] + data[i - 1];  	break;  case 2:  	s2 = data [-2];  	s1 = data [-1];  	for (int i = data_len; i > 0; i--) {  		s0 = *(residual++) + (s1 << 1) - s2;  		*(data++) = s0;  		s2 = s1;  		s1 = s0;  	}  	//data[i] = residual[i] + data[i - 1] * 2  - data[i - 2];  	break;  case 3:  	for (int i = 0; i < data_len; i++)  		data [i] = residual [i] + (((data [i - 1] - data [i - 2]) << 1) + (data [i - 1] - data [i - 2])) + data [i - 3];  	break;  case 4:  	for (int i = 0; i < data_len; i++)  		data [i] = residual [i] + ((data [i - 1] + data [i - 3]) << 2) - ((data [i - 2] << 2) + (data [i - 2] << 1)) - data [i - 4];  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The following statement contains a magic number: switch (sub.best.order) {  case 0:  	AudioSamples.MemCpy (data' residual' data_len);  	break;  case 1:  	s1 = data [-1];  	for (int i = data_len; i > 0; i--) {  		s1 += *(residual++);  		*(data++) = s1;  	}  	//data[i] = residual[i] + data[i - 1];  	break;  case 2:  	s2 = data [-2];  	s1 = data [-1];  	for (int i = data_len; i > 0; i--) {  		s0 = *(residual++) + (s1 << 1) - s2;  		*(data++) = s0;  		s2 = s1;  		s1 = s0;  	}  	//data[i] = residual[i] + data[i - 1] * 2  - data[i - 2];  	break;  case 3:  	for (int i = 0; i < data_len; i++)  		data [i] = residual [i] + (((data [i - 1] - data [i - 2]) << 1) + (data [i - 1] - data [i - 2])) + data [i - 3];  	break;  case 4:  	for (int i = 0; i < data_len; i++)  		data [i] = residual [i] + ((data [i - 1] + data [i - 3]) << 2) - ((data [i - 2] << 2) + (data [i - 2] << 1)) - data [i - 4];  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The following statement contains a magic number: switch (sub.best.order) {  case 0:  	AudioSamples.MemCpy (data' residual' data_len);  	break;  case 1:  	s1 = data [-1];  	for (int i = data_len; i > 0; i--) {  		s1 += *(residual++);  		*(data++) = s1;  	}  	//data[i] = residual[i] + data[i - 1];  	break;  case 2:  	s2 = data [-2];  	s1 = data [-1];  	for (int i = data_len; i > 0; i--) {  		s0 = *(residual++) + (s1 << 1) - s2;  		*(data++) = s0;  		s2 = s1;  		s1 = s0;  	}  	//data[i] = residual[i] + data[i - 1] * 2  - data[i - 2];  	break;  case 3:  	for (int i = 0; i < data_len; i++)  		data [i] = residual [i] + (((data [i - 1] - data [i - 2]) << 1) + (data [i - 1] - data [i - 2])) + data [i - 3];  	break;  case 4:  	for (int i = 0; i < data_len; i++)  		data [i] = residual [i] + ((data [i - 1] + data [i - 3]) << 2) - ((data [i - 2] << 2) + (data [i - 2] << 1)) - data [i - 4];  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The following statement contains a magic number: switch (sub.best.order) {  case 0:  	AudioSamples.MemCpy (data' residual' data_len);  	break;  case 1:  	s1 = data [-1];  	for (int i = data_len; i > 0; i--) {  		s1 += *(residual++);  		*(data++) = s1;  	}  	//data[i] = residual[i] + data[i - 1];  	break;  case 2:  	s2 = data [-2];  	s1 = data [-1];  	for (int i = data_len; i > 0; i--) {  		s0 = *(residual++) + (s1 << 1) - s2;  		*(data++) = s0;  		s2 = s1;  		s1 = s0;  	}  	//data[i] = residual[i] + data[i - 1] * 2  - data[i - 2];  	break;  case 3:  	for (int i = 0; i < data_len; i++)  		data [i] = residual [i] + (((data [i - 1] - data [i - 2]) << 1) + (data [i - 1] - data [i - 2])) + data [i - 3];  	break;  case 4:  	for (int i = 0; i < data_len; i++)  		data [i] = residual [i] + ((data [i - 1] + data [i - 3]) << 2) - ((data [i - 2] << 2) + (data [i - 2] << 1)) - data [i - 4];  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The following statement contains a magic number: switch (sub.best.order) {  case 0:  	AudioSamples.MemCpy (data' residual' data_len);  	break;  case 1:  	s1 = data [-1];  	for (int i = data_len; i > 0; i--) {  		s1 += *(residual++);  		*(data++) = s1;  	}  	//data[i] = residual[i] + data[i - 1];  	break;  case 2:  	s2 = data [-2];  	s1 = data [-1];  	for (int i = data_len; i > 0; i--) {  		s0 = *(residual++) + (s1 << 1) - s2;  		*(data++) = s0;  		s2 = s1;  		s1 = s0;  	}  	//data[i] = residual[i] + data[i - 1] * 2  - data[i - 2];  	break;  case 3:  	for (int i = 0; i < data_len; i++)  		data [i] = residual [i] + (((data [i - 1] - data [i - 2]) << 1) + (data [i - 1] - data [i - 2])) + data [i - 3];  	break;  case 4:  	for (int i = 0; i < data_len; i++)  		data [i] = residual [i] + ((data [i - 1] + data [i - 3]) << 2) - ((data [i - 2] << 2) + (data [i - 2] << 1)) - data [i - 4];  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The following statement contains a magic number: switch (sub.best.order) {  case 0:  	AudioSamples.MemCpy (data' residual' data_len);  	break;  case 1:  	s1 = data [-1];  	for (int i = data_len; i > 0; i--) {  		s1 += *(residual++);  		*(data++) = s1;  	}  	//data[i] = residual[i] + data[i - 1];  	break;  case 2:  	s2 = data [-2];  	s1 = data [-1];  	for (int i = data_len; i > 0; i--) {  		s0 = *(residual++) + (s1 << 1) - s2;  		*(data++) = s0;  		s2 = s1;  		s1 = s0;  	}  	//data[i] = residual[i] + data[i - 1] * 2  - data[i - 2];  	break;  case 3:  	for (int i = 0; i < data_len; i++)  		data [i] = residual [i] + (((data [i - 1] - data [i - 2]) << 1) + (data [i - 1] - data [i - 2])) + data [i - 3];  	break;  case 4:  	for (int i = 0; i < data_len; i++)  		data [i] = residual [i] + ((data [i - 1] + data [i - 3]) << 2) - ((data [i - 2] << 2) + (data [i - 2] << 1)) - data [i - 4];  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The following statement contains a magic number: switch (sub.best.order) {  case 0:  	AudioSamples.MemCpy (data' residual' data_len);  	break;  case 1:  	s1 = data [-1];  	for (int i = data_len; i > 0; i--) {  		s1 += *(residual++);  		*(data++) = s1;  	}  	//data[i] = residual[i] + data[i - 1];  	break;  case 2:  	s2 = data [-2];  	s1 = data [-1];  	for (int i = data_len; i > 0; i--) {  		s0 = *(residual++) + (s1 << 1) - s2;  		*(data++) = s0;  		s2 = s1;  		s1 = s0;  	}  	//data[i] = residual[i] + data[i - 1] * 2  - data[i - 2];  	break;  case 3:  	for (int i = 0; i < data_len; i++)  		data [i] = residual [i] + (((data [i - 1] - data [i - 2]) << 1) + (data [i - 1] - data [i - 2])) + data [i - 3];  	break;  case 4:  	for (int i = 0; i < data_len; i++)  		data [i] = residual [i] + ((data [i - 1] + data [i - 3]) << 2) - ((data [i - 2] << 2) + (data [i - 2] << 1)) - data [i - 4];  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The following statement contains a magic number: switch (sub.best.order) {  case 0:  	AudioSamples.MemCpy (data' residual' data_len);  	break;  case 1:  	s1 = data [-1];  	for (int i = data_len; i > 0; i--) {  		s1 += *(residual++);  		*(data++) = s1;  	}  	//data[i] = residual[i] + data[i - 1];  	break;  case 2:  	s2 = data [-2];  	s1 = data [-1];  	for (int i = data_len; i > 0; i--) {  		s0 = *(residual++) + (s1 << 1) - s2;  		*(data++) = s0;  		s2 = s1;  		s1 = s0;  	}  	//data[i] = residual[i] + data[i - 1] * 2  - data[i - 2];  	break;  case 3:  	for (int i = 0; i < data_len; i++)  		data [i] = residual [i] + (((data [i - 1] - data [i - 2]) << 1) + (data [i - 1] - data [i - 2])) + data [i - 3];  	break;  case 4:  	for (int i = 0; i < data_len; i++)  		data [i] = residual [i] + ((data [i - 1] + data [i - 3]) << 2) - ((data [i - 2] << 2) + (data [i - 2] << 1)) - data [i - 4];  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The following statement contains a magic number: switch (sub.best.order) {  case 0:  	AudioSamples.MemCpy (data' residual' data_len);  	break;  case 1:  	s1 = data [-1];  	for (int i = data_len; i > 0; i--) {  		s1 += *(residual++);  		*(data++) = s1;  	}  	//data[i] = residual[i] + data[i - 1];  	break;  case 2:  	s2 = data [-2];  	s1 = data [-1];  	for (int i = data_len; i > 0; i--) {  		s0 = *(residual++) + (s1 << 1) - s2;  		*(data++) = s0;  		s2 = s1;  		s1 = s0;  	}  	//data[i] = residual[i] + data[i - 1] * 2  - data[i - 2];  	break;  case 3:  	for (int i = 0; i < data_len; i++)  		data [i] = residual [i] + (((data [i - 1] - data [i - 2]) << 1) + (data [i - 1] - data [i - 2])) + data [i - 3];  	break;  case 4:  	for (int i = 0; i < data_len; i++)  		data [i] = residual [i] + ((data [i - 1] + data [i - 3]) << 2) - ((data [i - 2] << 2) + (data [i - 2] << 1)) - data [i - 4];  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The following statement contains a magic number: s2 = data [-2];  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The following statement contains a magic number: for (int i = 0; i < data_len; i++)  	data [i] = residual [i] + (((data [i - 1] - data [i - 2]) << 1) + (data [i - 1] - data [i - 2])) + data [i - 3];  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The following statement contains a magic number: for (int i = 0; i < data_len; i++)  	data [i] = residual [i] + (((data [i - 1] - data [i - 2]) << 1) + (data [i - 1] - data [i - 2])) + data [i - 3];  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The following statement contains a magic number: for (int i = 0; i < data_len; i++)  	data [i] = residual [i] + (((data [i - 1] - data [i - 2]) << 1) + (data [i - 1] - data [i - 2])) + data [i - 3];  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The following statement contains a magic number: data [i] = residual [i] + (((data [i - 1] - data [i - 2]) << 1) + (data [i - 1] - data [i - 2])) + data [i - 3];  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The following statement contains a magic number: data [i] = residual [i] + (((data [i - 1] - data [i - 2]) << 1) + (data [i - 1] - data [i - 2])) + data [i - 3];  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The following statement contains a magic number: data [i] = residual [i] + (((data [i - 1] - data [i - 2]) << 1) + (data [i - 1] - data [i - 2])) + data [i - 3];  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The following statement contains a magic number: for (int i = 0; i < data_len; i++)  	data [i] = residual [i] + ((data [i - 1] + data [i - 3]) << 2) - ((data [i - 2] << 2) + (data [i - 2] << 1)) - data [i - 4];  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The following statement contains a magic number: for (int i = 0; i < data_len; i++)  	data [i] = residual [i] + ((data [i - 1] + data [i - 3]) << 2) - ((data [i - 2] << 2) + (data [i - 2] << 1)) - data [i - 4];  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The following statement contains a magic number: for (int i = 0; i < data_len; i++)  	data [i] = residual [i] + ((data [i - 1] + data [i - 3]) << 2) - ((data [i - 2] << 2) + (data [i - 2] << 1)) - data [i - 4];  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The following statement contains a magic number: for (int i = 0; i < data_len; i++)  	data [i] = residual [i] + ((data [i - 1] + data [i - 3]) << 2) - ((data [i - 2] << 2) + (data [i - 2] << 1)) - data [i - 4];  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The following statement contains a magic number: for (int i = 0; i < data_len; i++)  	data [i] = residual [i] + ((data [i - 1] + data [i - 3]) << 2) - ((data [i - 2] << 2) + (data [i - 2] << 1)) - data [i - 4];  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The following statement contains a magic number: for (int i = 0; i < data_len; i++)  	data [i] = residual [i] + ((data [i - 1] + data [i - 3]) << 2) - ((data [i - 2] << 2) + (data [i - 2] << 1)) - data [i - 4];  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The following statement contains a magic number: data [i] = residual [i] + ((data [i - 1] + data [i - 3]) << 2) - ((data [i - 2] << 2) + (data [i - 2] << 1)) - data [i - 4];  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The following statement contains a magic number: data [i] = residual [i] + ((data [i - 1] + data [i - 3]) << 2) - ((data [i - 2] << 2) + (data [i - 2] << 1)) - data [i - 4];  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The following statement contains a magic number: data [i] = residual [i] + ((data [i - 1] + data [i - 3]) << 2) - ((data [i - 2] << 2) + (data [i - 2] << 1)) - data [i - 4];  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The following statement contains a magic number: data [i] = residual [i] + ((data [i - 1] + data [i - 3]) << 2) - ((data [i - 2] << 2) + (data [i - 2] << 1)) - data [i - 4];  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The following statement contains a magic number: data [i] = residual [i] + ((data [i - 1] + data [i - 3]) << 2) - ((data [i - 2] << 2) + (data [i - 2] << 1)) - data [i - 4];  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The following statement contains a magic number: data [i] = residual [i] + ((data [i - 1] + data [i - 3]) << 2) - ((data [i - 2] << 2) + (data [i - 2] << 1)) - data [i - 4];  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_lpc,The following statement contains a magic number: fixed (int* coefs = sub.best.coefs) {  	for (int i = sub.best.order; i > 0; i--)  		csum += (ulong)Math.Abs (coefs [i - 1]);  	if ((csum << sub.obits) >= 1UL << 32)  		lpc.decode_residual_long (sub.best.residual' sub.samples' frame.blocksize' sub.best.order' coefs' sub.best.shift);  	else  		lpc.decode_residual (sub.best.residual' sub.samples' frame.blocksize' sub.best.order' coefs' sub.best.shift);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_lpc,The following statement contains a magic number: if ((csum << sub.obits) >= 1UL << 32)  	lpc.decode_residual_long (sub.best.residual' sub.samples' frame.blocksize' sub.best.order' coefs' sub.best.shift);  else  	lpc.decode_residual (sub.best.residual' sub.samples' frame.blocksize' sub.best.order' coefs' sub.best.shift);  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,DecodeFrame,The following statement contains a magic number: fixed (byte* buf = buffer) {  	framereader.Reset (buf' pos' len);  	decode_frame_header (framereader' frame);  	decode_subframes (framereader' frame);  	framereader.flush ();  	ushort crc_1 = do_crc ? crc16.ComputeChecksum (framereader.Buffer + pos' framereader.Position - pos) : (ushort)0;  	ushort crc_2 = (ushort)framereader.readbits (16);  	if (do_crc && crc_1 != crc_2)  		throw new Exception ("frame crc mismatch");  	restore_samples (frame);  	_samplesInBuffer = frame.blocksize;  	return framereader.Position - pos;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: for (i = id = 0; i < 4;) {  	if (_IO.Read (_framesBuffer' 0' 1) == 0)  		throw new Exception ("FLAC stream not found");  	x = _framesBuffer [0];  	if (x == FLAC__STREAM_SYNC_STRING [i]) {  		first = true;  		i++;  		id = 0;  		continue;  	}  	if (id < 3 && x == ID3V2_TAG_ [id]) {  		id++;  		i = 0;  		if (id == 3) {  			if (!skip_bytes (3))  				throw new Exception ("FLAC stream not found");  			int skip = 0;  			for (int j = 0; j < 4; j++) {  				if (0 == _IO.Read (_framesBuffer' 0' 1))  					throw new Exception ("FLAC stream not found");  				skip <<= 7;  				skip |= ((int)_framesBuffer [0] & 0x7f);  			}  			if (!skip_bytes (skip))  				throw new Exception ("FLAC stream not found");  		}  		continue;  	}  	id = 0;  	if (x == 0xff)/* MAGIC NUMBER for the first 8 frame sync bits */ {  		do {  			if (_IO.Read (_framesBuffer' 0' 1) == 0)  				throw new Exception ("FLAC stream not found");  			x = _framesBuffer [0];  		}  		while (x == 0xff);  		if (x >> 2 == 0x3e)/* MAGIC NUMBER for the last 6 sync bits */ {  			//_IO.Position -= 2;  			// state = frame  			throw new Exception ("headerless file unsupported");  		}  	}  	throw new Exception ("FLAC stream not found");  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: for (i = id = 0; i < 4;) {  	if (_IO.Read (_framesBuffer' 0' 1) == 0)  		throw new Exception ("FLAC stream not found");  	x = _framesBuffer [0];  	if (x == FLAC__STREAM_SYNC_STRING [i]) {  		first = true;  		i++;  		id = 0;  		continue;  	}  	if (id < 3 && x == ID3V2_TAG_ [id]) {  		id++;  		i = 0;  		if (id == 3) {  			if (!skip_bytes (3))  				throw new Exception ("FLAC stream not found");  			int skip = 0;  			for (int j = 0; j < 4; j++) {  				if (0 == _IO.Read (_framesBuffer' 0' 1))  					throw new Exception ("FLAC stream not found");  				skip <<= 7;  				skip |= ((int)_framesBuffer [0] & 0x7f);  			}  			if (!skip_bytes (skip))  				throw new Exception ("FLAC stream not found");  		}  		continue;  	}  	id = 0;  	if (x == 0xff)/* MAGIC NUMBER for the first 8 frame sync bits */ {  		do {  			if (_IO.Read (_framesBuffer' 0' 1) == 0)  				throw new Exception ("FLAC stream not found");  			x = _framesBuffer [0];  		}  		while (x == 0xff);  		if (x >> 2 == 0x3e)/* MAGIC NUMBER for the last 6 sync bits */ {  			//_IO.Position -= 2;  			// state = frame  			throw new Exception ("headerless file unsupported");  		}  	}  	throw new Exception ("FLAC stream not found");  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: for (i = id = 0; i < 4;) {  	if (_IO.Read (_framesBuffer' 0' 1) == 0)  		throw new Exception ("FLAC stream not found");  	x = _framesBuffer [0];  	if (x == FLAC__STREAM_SYNC_STRING [i]) {  		first = true;  		i++;  		id = 0;  		continue;  	}  	if (id < 3 && x == ID3V2_TAG_ [id]) {  		id++;  		i = 0;  		if (id == 3) {  			if (!skip_bytes (3))  				throw new Exception ("FLAC stream not found");  			int skip = 0;  			for (int j = 0; j < 4; j++) {  				if (0 == _IO.Read (_framesBuffer' 0' 1))  					throw new Exception ("FLAC stream not found");  				skip <<= 7;  				skip |= ((int)_framesBuffer [0] & 0x7f);  			}  			if (!skip_bytes (skip))  				throw new Exception ("FLAC stream not found");  		}  		continue;  	}  	id = 0;  	if (x == 0xff)/* MAGIC NUMBER for the first 8 frame sync bits */ {  		do {  			if (_IO.Read (_framesBuffer' 0' 1) == 0)  				throw new Exception ("FLAC stream not found");  			x = _framesBuffer [0];  		}  		while (x == 0xff);  		if (x >> 2 == 0x3e)/* MAGIC NUMBER for the last 6 sync bits */ {  			//_IO.Position -= 2;  			// state = frame  			throw new Exception ("headerless file unsupported");  		}  	}  	throw new Exception ("FLAC stream not found");  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: for (i = id = 0; i < 4;) {  	if (_IO.Read (_framesBuffer' 0' 1) == 0)  		throw new Exception ("FLAC stream not found");  	x = _framesBuffer [0];  	if (x == FLAC__STREAM_SYNC_STRING [i]) {  		first = true;  		i++;  		id = 0;  		continue;  	}  	if (id < 3 && x == ID3V2_TAG_ [id]) {  		id++;  		i = 0;  		if (id == 3) {  			if (!skip_bytes (3))  				throw new Exception ("FLAC stream not found");  			int skip = 0;  			for (int j = 0; j < 4; j++) {  				if (0 == _IO.Read (_framesBuffer' 0' 1))  					throw new Exception ("FLAC stream not found");  				skip <<= 7;  				skip |= ((int)_framesBuffer [0] & 0x7f);  			}  			if (!skip_bytes (skip))  				throw new Exception ("FLAC stream not found");  		}  		continue;  	}  	id = 0;  	if (x == 0xff)/* MAGIC NUMBER for the first 8 frame sync bits */ {  		do {  			if (_IO.Read (_framesBuffer' 0' 1) == 0)  				throw new Exception ("FLAC stream not found");  			x = _framesBuffer [0];  		}  		while (x == 0xff);  		if (x >> 2 == 0x3e)/* MAGIC NUMBER for the last 6 sync bits */ {  			//_IO.Position -= 2;  			// state = frame  			throw new Exception ("headerless file unsupported");  		}  	}  	throw new Exception ("FLAC stream not found");  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: for (i = id = 0; i < 4;) {  	if (_IO.Read (_framesBuffer' 0' 1) == 0)  		throw new Exception ("FLAC stream not found");  	x = _framesBuffer [0];  	if (x == FLAC__STREAM_SYNC_STRING [i]) {  		first = true;  		i++;  		id = 0;  		continue;  	}  	if (id < 3 && x == ID3V2_TAG_ [id]) {  		id++;  		i = 0;  		if (id == 3) {  			if (!skip_bytes (3))  				throw new Exception ("FLAC stream not found");  			int skip = 0;  			for (int j = 0; j < 4; j++) {  				if (0 == _IO.Read (_framesBuffer' 0' 1))  					throw new Exception ("FLAC stream not found");  				skip <<= 7;  				skip |= ((int)_framesBuffer [0] & 0x7f);  			}  			if (!skip_bytes (skip))  				throw new Exception ("FLAC stream not found");  		}  		continue;  	}  	id = 0;  	if (x == 0xff)/* MAGIC NUMBER for the first 8 frame sync bits */ {  		do {  			if (_IO.Read (_framesBuffer' 0' 1) == 0)  				throw new Exception ("FLAC stream not found");  			x = _framesBuffer [0];  		}  		while (x == 0xff);  		if (x >> 2 == 0x3e)/* MAGIC NUMBER for the last 6 sync bits */ {  			//_IO.Position -= 2;  			// state = frame  			throw new Exception ("headerless file unsupported");  		}  	}  	throw new Exception ("FLAC stream not found");  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: for (i = id = 0; i < 4;) {  	if (_IO.Read (_framesBuffer' 0' 1) == 0)  		throw new Exception ("FLAC stream not found");  	x = _framesBuffer [0];  	if (x == FLAC__STREAM_SYNC_STRING [i]) {  		first = true;  		i++;  		id = 0;  		continue;  	}  	if (id < 3 && x == ID3V2_TAG_ [id]) {  		id++;  		i = 0;  		if (id == 3) {  			if (!skip_bytes (3))  				throw new Exception ("FLAC stream not found");  			int skip = 0;  			for (int j = 0; j < 4; j++) {  				if (0 == _IO.Read (_framesBuffer' 0' 1))  					throw new Exception ("FLAC stream not found");  				skip <<= 7;  				skip |= ((int)_framesBuffer [0] & 0x7f);  			}  			if (!skip_bytes (skip))  				throw new Exception ("FLAC stream not found");  		}  		continue;  	}  	id = 0;  	if (x == 0xff)/* MAGIC NUMBER for the first 8 frame sync bits */ {  		do {  			if (_IO.Read (_framesBuffer' 0' 1) == 0)  				throw new Exception ("FLAC stream not found");  			x = _framesBuffer [0];  		}  		while (x == 0xff);  		if (x >> 2 == 0x3e)/* MAGIC NUMBER for the last 6 sync bits */ {  			//_IO.Position -= 2;  			// state = frame  			throw new Exception ("headerless file unsupported");  		}  	}  	throw new Exception ("FLAC stream not found");  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: for (i = id = 0; i < 4;) {  	if (_IO.Read (_framesBuffer' 0' 1) == 0)  		throw new Exception ("FLAC stream not found");  	x = _framesBuffer [0];  	if (x == FLAC__STREAM_SYNC_STRING [i]) {  		first = true;  		i++;  		id = 0;  		continue;  	}  	if (id < 3 && x == ID3V2_TAG_ [id]) {  		id++;  		i = 0;  		if (id == 3) {  			if (!skip_bytes (3))  				throw new Exception ("FLAC stream not found");  			int skip = 0;  			for (int j = 0; j < 4; j++) {  				if (0 == _IO.Read (_framesBuffer' 0' 1))  					throw new Exception ("FLAC stream not found");  				skip <<= 7;  				skip |= ((int)_framesBuffer [0] & 0x7f);  			}  			if (!skip_bytes (skip))  				throw new Exception ("FLAC stream not found");  		}  		continue;  	}  	id = 0;  	if (x == 0xff)/* MAGIC NUMBER for the first 8 frame sync bits */ {  		do {  			if (_IO.Read (_framesBuffer' 0' 1) == 0)  				throw new Exception ("FLAC stream not found");  			x = _framesBuffer [0];  		}  		while (x == 0xff);  		if (x >> 2 == 0x3e)/* MAGIC NUMBER for the last 6 sync bits */ {  			//_IO.Position -= 2;  			// state = frame  			throw new Exception ("headerless file unsupported");  		}  	}  	throw new Exception ("FLAC stream not found");  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: if (id < 3 && x == ID3V2_TAG_ [id]) {  	id++;  	i = 0;  	if (id == 3) {  		if (!skip_bytes (3))  			throw new Exception ("FLAC stream not found");  		int skip = 0;  		for (int j = 0; j < 4; j++) {  			if (0 == _IO.Read (_framesBuffer' 0' 1))  				throw new Exception ("FLAC stream not found");  			skip <<= 7;  			skip |= ((int)_framesBuffer [0] & 0x7f);  		}  		if (!skip_bytes (skip))  			throw new Exception ("FLAC stream not found");  	}  	continue;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: if (id < 3 && x == ID3V2_TAG_ [id]) {  	id++;  	i = 0;  	if (id == 3) {  		if (!skip_bytes (3))  			throw new Exception ("FLAC stream not found");  		int skip = 0;  		for (int j = 0; j < 4; j++) {  			if (0 == _IO.Read (_framesBuffer' 0' 1))  				throw new Exception ("FLAC stream not found");  			skip <<= 7;  			skip |= ((int)_framesBuffer [0] & 0x7f);  		}  		if (!skip_bytes (skip))  			throw new Exception ("FLAC stream not found");  	}  	continue;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: if (id < 3 && x == ID3V2_TAG_ [id]) {  	id++;  	i = 0;  	if (id == 3) {  		if (!skip_bytes (3))  			throw new Exception ("FLAC stream not found");  		int skip = 0;  		for (int j = 0; j < 4; j++) {  			if (0 == _IO.Read (_framesBuffer' 0' 1))  				throw new Exception ("FLAC stream not found");  			skip <<= 7;  			skip |= ((int)_framesBuffer [0] & 0x7f);  		}  		if (!skip_bytes (skip))  			throw new Exception ("FLAC stream not found");  	}  	continue;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: if (id < 3 && x == ID3V2_TAG_ [id]) {  	id++;  	i = 0;  	if (id == 3) {  		if (!skip_bytes (3))  			throw new Exception ("FLAC stream not found");  		int skip = 0;  		for (int j = 0; j < 4; j++) {  			if (0 == _IO.Read (_framesBuffer' 0' 1))  				throw new Exception ("FLAC stream not found");  			skip <<= 7;  			skip |= ((int)_framesBuffer [0] & 0x7f);  		}  		if (!skip_bytes (skip))  			throw new Exception ("FLAC stream not found");  	}  	continue;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: if (id < 3 && x == ID3V2_TAG_ [id]) {  	id++;  	i = 0;  	if (id == 3) {  		if (!skip_bytes (3))  			throw new Exception ("FLAC stream not found");  		int skip = 0;  		for (int j = 0; j < 4; j++) {  			if (0 == _IO.Read (_framesBuffer' 0' 1))  				throw new Exception ("FLAC stream not found");  			skip <<= 7;  			skip |= ((int)_framesBuffer [0] & 0x7f);  		}  		if (!skip_bytes (skip))  			throw new Exception ("FLAC stream not found");  	}  	continue;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: if (id == 3) {  	if (!skip_bytes (3))  		throw new Exception ("FLAC stream not found");  	int skip = 0;  	for (int j = 0; j < 4; j++) {  		if (0 == _IO.Read (_framesBuffer' 0' 1))  			throw new Exception ("FLAC stream not found");  		skip <<= 7;  		skip |= ((int)_framesBuffer [0] & 0x7f);  	}  	if (!skip_bytes (skip))  		throw new Exception ("FLAC stream not found");  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: if (id == 3) {  	if (!skip_bytes (3))  		throw new Exception ("FLAC stream not found");  	int skip = 0;  	for (int j = 0; j < 4; j++) {  		if (0 == _IO.Read (_framesBuffer' 0' 1))  			throw new Exception ("FLAC stream not found");  		skip <<= 7;  		skip |= ((int)_framesBuffer [0] & 0x7f);  	}  	if (!skip_bytes (skip))  		throw new Exception ("FLAC stream not found");  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: if (id == 3) {  	if (!skip_bytes (3))  		throw new Exception ("FLAC stream not found");  	int skip = 0;  	for (int j = 0; j < 4; j++) {  		if (0 == _IO.Read (_framesBuffer' 0' 1))  			throw new Exception ("FLAC stream not found");  		skip <<= 7;  		skip |= ((int)_framesBuffer [0] & 0x7f);  	}  	if (!skip_bytes (skip))  		throw new Exception ("FLAC stream not found");  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: if (id == 3) {  	if (!skip_bytes (3))  		throw new Exception ("FLAC stream not found");  	int skip = 0;  	for (int j = 0; j < 4; j++) {  		if (0 == _IO.Read (_framesBuffer' 0' 1))  			throw new Exception ("FLAC stream not found");  		skip <<= 7;  		skip |= ((int)_framesBuffer [0] & 0x7f);  	}  	if (!skip_bytes (skip))  		throw new Exception ("FLAC stream not found");  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: if (!skip_bytes (3))  	throw new Exception ("FLAC stream not found");  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: for (int j = 0; j < 4; j++) {  	if (0 == _IO.Read (_framesBuffer' 0' 1))  		throw new Exception ("FLAC stream not found");  	skip <<= 7;  	skip |= ((int)_framesBuffer [0] & 0x7f);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: for (int j = 0; j < 4; j++) {  	if (0 == _IO.Read (_framesBuffer' 0' 1))  		throw new Exception ("FLAC stream not found");  	skip <<= 7;  	skip |= ((int)_framesBuffer [0] & 0x7f);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: skip <<= 7;  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: if (x == 0xff)/* MAGIC NUMBER for the first 8 frame sync bits */ {  	do {  		if (_IO.Read (_framesBuffer' 0' 1) == 0)  			throw new Exception ("FLAC stream not found");  		x = _framesBuffer [0];  	}  	while (x == 0xff);  	if (x >> 2 == 0x3e)/* MAGIC NUMBER for the last 6 sync bits */ {  		//_IO.Position -= 2;  		// state = frame  		throw new Exception ("headerless file unsupported");  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: if (x >> 2 == 0x3e)/* MAGIC NUMBER for the last 6 sync bits */ {  	//_IO.Position -= 2;  	// state = frame  	throw new Exception ("headerless file unsupported");  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: do {  	fill_frames_buffer ();  	fixed (byte* buf = _framesBuffer) {  		BitReader bitreader = new BitReader (buf' _framesBufferOffset' _framesBufferLength - _framesBufferOffset);  		bool is_last = bitreader.readbit () != 0;  		MetadataType type = (MetadataType)bitreader.readbits (7);  		int len = (int)bitreader.readbits (24);  		if (type == MetadataType.StreamInfo) {  			const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  			/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  			max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  			min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  			max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  			int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  			int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  			int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  			pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  			_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  			bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  		}  		else if (type == MetadataType.Seektable) {  			int num_entries = len / 18;  			seek_table = new SeekPoint[num_entries];  			for (int e = 0; e < num_entries; e++) {  				seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  				seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  				seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  			}  		}  		if (_framesBufferLength < 4 + len) {  			_IO.Position += 4 + len - _framesBufferLength;  			_framesBufferLength = 0;  		}  		else {  			_framesBufferLength -= 4 + len;  			_framesBufferOffset += 4 + len;  		}  		if (is_last)  			break;  	}  }  while (true);  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: do {  	fill_frames_buffer ();  	fixed (byte* buf = _framesBuffer) {  		BitReader bitreader = new BitReader (buf' _framesBufferOffset' _framesBufferLength - _framesBufferOffset);  		bool is_last = bitreader.readbit () != 0;  		MetadataType type = (MetadataType)bitreader.readbits (7);  		int len = (int)bitreader.readbits (24);  		if (type == MetadataType.StreamInfo) {  			const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  			/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  			max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  			min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  			max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  			int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  			int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  			int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  			pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  			_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  			bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  		}  		else if (type == MetadataType.Seektable) {  			int num_entries = len / 18;  			seek_table = new SeekPoint[num_entries];  			for (int e = 0; e < num_entries; e++) {  				seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  				seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  				seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  			}  		}  		if (_framesBufferLength < 4 + len) {  			_IO.Position += 4 + len - _framesBufferLength;  			_framesBufferLength = 0;  		}  		else {  			_framesBufferLength -= 4 + len;  			_framesBufferOffset += 4 + len;  		}  		if (is_last)  			break;  	}  }  while (true);  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: do {  	fill_frames_buffer ();  	fixed (byte* buf = _framesBuffer) {  		BitReader bitreader = new BitReader (buf' _framesBufferOffset' _framesBufferLength - _framesBufferOffset);  		bool is_last = bitreader.readbit () != 0;  		MetadataType type = (MetadataType)bitreader.readbits (7);  		int len = (int)bitreader.readbits (24);  		if (type == MetadataType.StreamInfo) {  			const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  			/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  			max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  			min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  			max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  			int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  			int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  			int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  			pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  			_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  			bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  		}  		else if (type == MetadataType.Seektable) {  			int num_entries = len / 18;  			seek_table = new SeekPoint[num_entries];  			for (int e = 0; e < num_entries; e++) {  				seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  				seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  				seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  			}  		}  		if (_framesBufferLength < 4 + len) {  			_IO.Position += 4 + len - _framesBufferLength;  			_framesBufferLength = 0;  		}  		else {  			_framesBufferLength -= 4 + len;  			_framesBufferOffset += 4 + len;  		}  		if (is_last)  			break;  	}  }  while (true);  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: do {  	fill_frames_buffer ();  	fixed (byte* buf = _framesBuffer) {  		BitReader bitreader = new BitReader (buf' _framesBufferOffset' _framesBufferLength - _framesBufferOffset);  		bool is_last = bitreader.readbit () != 0;  		MetadataType type = (MetadataType)bitreader.readbits (7);  		int len = (int)bitreader.readbits (24);  		if (type == MetadataType.StreamInfo) {  			const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  			/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  			max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  			min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  			max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  			int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  			int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  			int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  			pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  			_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  			bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  		}  		else if (type == MetadataType.Seektable) {  			int num_entries = len / 18;  			seek_table = new SeekPoint[num_entries];  			for (int e = 0; e < num_entries; e++) {  				seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  				seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  				seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  			}  		}  		if (_framesBufferLength < 4 + len) {  			_IO.Position += 4 + len - _framesBufferLength;  			_framesBufferLength = 0;  		}  		else {  			_framesBufferLength -= 4 + len;  			_framesBufferOffset += 4 + len;  		}  		if (is_last)  			break;  	}  }  while (true);  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: do {  	fill_frames_buffer ();  	fixed (byte* buf = _framesBuffer) {  		BitReader bitreader = new BitReader (buf' _framesBufferOffset' _framesBufferLength - _framesBufferOffset);  		bool is_last = bitreader.readbit () != 0;  		MetadataType type = (MetadataType)bitreader.readbits (7);  		int len = (int)bitreader.readbits (24);  		if (type == MetadataType.StreamInfo) {  			const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  			/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  			max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  			min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  			max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  			int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  			int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  			int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  			pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  			_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  			bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  		}  		else if (type == MetadataType.Seektable) {  			int num_entries = len / 18;  			seek_table = new SeekPoint[num_entries];  			for (int e = 0; e < num_entries; e++) {  				seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  				seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  				seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  			}  		}  		if (_framesBufferLength < 4 + len) {  			_IO.Position += 4 + len - _framesBufferLength;  			_framesBufferLength = 0;  		}  		else {  			_framesBufferLength -= 4 + len;  			_framesBufferOffset += 4 + len;  		}  		if (is_last)  			break;  	}  }  while (true);  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: do {  	fill_frames_buffer ();  	fixed (byte* buf = _framesBuffer) {  		BitReader bitreader = new BitReader (buf' _framesBufferOffset' _framesBufferLength - _framesBufferOffset);  		bool is_last = bitreader.readbit () != 0;  		MetadataType type = (MetadataType)bitreader.readbits (7);  		int len = (int)bitreader.readbits (24);  		if (type == MetadataType.StreamInfo) {  			const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  			/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  			max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  			min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  			max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  			int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  			int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  			int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  			pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  			_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  			bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  		}  		else if (type == MetadataType.Seektable) {  			int num_entries = len / 18;  			seek_table = new SeekPoint[num_entries];  			for (int e = 0; e < num_entries; e++) {  				seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  				seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  				seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  			}  		}  		if (_framesBufferLength < 4 + len) {  			_IO.Position += 4 + len - _framesBufferLength;  			_framesBufferLength = 0;  		}  		else {  			_framesBufferLength -= 4 + len;  			_framesBufferOffset += 4 + len;  		}  		if (is_last)  			break;  	}  }  while (true);  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: do {  	fill_frames_buffer ();  	fixed (byte* buf = _framesBuffer) {  		BitReader bitreader = new BitReader (buf' _framesBufferOffset' _framesBufferLength - _framesBufferOffset);  		bool is_last = bitreader.readbit () != 0;  		MetadataType type = (MetadataType)bitreader.readbits (7);  		int len = (int)bitreader.readbits (24);  		if (type == MetadataType.StreamInfo) {  			const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  			/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  			max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  			min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  			max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  			int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  			int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  			int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  			pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  			_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  			bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  		}  		else if (type == MetadataType.Seektable) {  			int num_entries = len / 18;  			seek_table = new SeekPoint[num_entries];  			for (int e = 0; e < num_entries; e++) {  				seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  				seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  				seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  			}  		}  		if (_framesBufferLength < 4 + len) {  			_IO.Position += 4 + len - _framesBufferLength;  			_framesBufferLength = 0;  		}  		else {  			_framesBufferLength -= 4 + len;  			_framesBufferOffset += 4 + len;  		}  		if (is_last)  			break;  	}  }  while (true);  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: do {  	fill_frames_buffer ();  	fixed (byte* buf = _framesBuffer) {  		BitReader bitreader = new BitReader (buf' _framesBufferOffset' _framesBufferLength - _framesBufferOffset);  		bool is_last = bitreader.readbit () != 0;  		MetadataType type = (MetadataType)bitreader.readbits (7);  		int len = (int)bitreader.readbits (24);  		if (type == MetadataType.StreamInfo) {  			const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  			/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  			max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  			min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  			max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  			int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  			int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  			int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  			pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  			_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  			bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  		}  		else if (type == MetadataType.Seektable) {  			int num_entries = len / 18;  			seek_table = new SeekPoint[num_entries];  			for (int e = 0; e < num_entries; e++) {  				seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  				seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  				seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  			}  		}  		if (_framesBufferLength < 4 + len) {  			_IO.Position += 4 + len - _framesBufferLength;  			_framesBufferLength = 0;  		}  		else {  			_framesBufferLength -= 4 + len;  			_framesBufferOffset += 4 + len;  		}  		if (is_last)  			break;  	}  }  while (true);  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: do {  	fill_frames_buffer ();  	fixed (byte* buf = _framesBuffer) {  		BitReader bitreader = new BitReader (buf' _framesBufferOffset' _framesBufferLength - _framesBufferOffset);  		bool is_last = bitreader.readbit () != 0;  		MetadataType type = (MetadataType)bitreader.readbits (7);  		int len = (int)bitreader.readbits (24);  		if (type == MetadataType.StreamInfo) {  			const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  			/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  			max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  			min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  			max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  			int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  			int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  			int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  			pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  			_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  			bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  		}  		else if (type == MetadataType.Seektable) {  			int num_entries = len / 18;  			seek_table = new SeekPoint[num_entries];  			for (int e = 0; e < num_entries; e++) {  				seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  				seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  				seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  			}  		}  		if (_framesBufferLength < 4 + len) {  			_IO.Position += 4 + len - _framesBufferLength;  			_framesBufferLength = 0;  		}  		else {  			_framesBufferLength -= 4 + len;  			_framesBufferOffset += 4 + len;  		}  		if (is_last)  			break;  	}  }  while (true);  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: do {  	fill_frames_buffer ();  	fixed (byte* buf = _framesBuffer) {  		BitReader bitreader = new BitReader (buf' _framesBufferOffset' _framesBufferLength - _framesBufferOffset);  		bool is_last = bitreader.readbit () != 0;  		MetadataType type = (MetadataType)bitreader.readbits (7);  		int len = (int)bitreader.readbits (24);  		if (type == MetadataType.StreamInfo) {  			const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  			/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  			max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  			min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  			max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  			int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  			int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  			int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  			pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  			_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  			bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  		}  		else if (type == MetadataType.Seektable) {  			int num_entries = len / 18;  			seek_table = new SeekPoint[num_entries];  			for (int e = 0; e < num_entries; e++) {  				seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  				seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  				seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  			}  		}  		if (_framesBufferLength < 4 + len) {  			_IO.Position += 4 + len - _framesBufferLength;  			_framesBufferLength = 0;  		}  		else {  			_framesBufferLength -= 4 + len;  			_framesBufferOffset += 4 + len;  		}  		if (is_last)  			break;  	}  }  while (true);  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: do {  	fill_frames_buffer ();  	fixed (byte* buf = _framesBuffer) {  		BitReader bitreader = new BitReader (buf' _framesBufferOffset' _framesBufferLength - _framesBufferOffset);  		bool is_last = bitreader.readbit () != 0;  		MetadataType type = (MetadataType)bitreader.readbits (7);  		int len = (int)bitreader.readbits (24);  		if (type == MetadataType.StreamInfo) {  			const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  			/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  			max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  			min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  			max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  			int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  			int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  			int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  			pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  			_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  			bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  		}  		else if (type == MetadataType.Seektable) {  			int num_entries = len / 18;  			seek_table = new SeekPoint[num_entries];  			for (int e = 0; e < num_entries; e++) {  				seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  				seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  				seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  			}  		}  		if (_framesBufferLength < 4 + len) {  			_IO.Position += 4 + len - _framesBufferLength;  			_framesBufferLength = 0;  		}  		else {  			_framesBufferLength -= 4 + len;  			_framesBufferOffset += 4 + len;  		}  		if (is_last)  			break;  	}  }  while (true);  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: do {  	fill_frames_buffer ();  	fixed (byte* buf = _framesBuffer) {  		BitReader bitreader = new BitReader (buf' _framesBufferOffset' _framesBufferLength - _framesBufferOffset);  		bool is_last = bitreader.readbit () != 0;  		MetadataType type = (MetadataType)bitreader.readbits (7);  		int len = (int)bitreader.readbits (24);  		if (type == MetadataType.StreamInfo) {  			const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  			/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  			max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  			min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  			max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  			int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  			int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  			int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  			pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  			_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  			bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  		}  		else if (type == MetadataType.Seektable) {  			int num_entries = len / 18;  			seek_table = new SeekPoint[num_entries];  			for (int e = 0; e < num_entries; e++) {  				seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  				seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  				seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  			}  		}  		if (_framesBufferLength < 4 + len) {  			_IO.Position += 4 + len - _framesBufferLength;  			_framesBufferLength = 0;  		}  		else {  			_framesBufferLength -= 4 + len;  			_framesBufferOffset += 4 + len;  		}  		if (is_last)  			break;  	}  }  while (true);  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: do {  	fill_frames_buffer ();  	fixed (byte* buf = _framesBuffer) {  		BitReader bitreader = new BitReader (buf' _framesBufferOffset' _framesBufferLength - _framesBufferOffset);  		bool is_last = bitreader.readbit () != 0;  		MetadataType type = (MetadataType)bitreader.readbits (7);  		int len = (int)bitreader.readbits (24);  		if (type == MetadataType.StreamInfo) {  			const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  			/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  			max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  			min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  			max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  			int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  			int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  			int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  			pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  			_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  			bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  		}  		else if (type == MetadataType.Seektable) {  			int num_entries = len / 18;  			seek_table = new SeekPoint[num_entries];  			for (int e = 0; e < num_entries; e++) {  				seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  				seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  				seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  			}  		}  		if (_framesBufferLength < 4 + len) {  			_IO.Position += 4 + len - _framesBufferLength;  			_framesBufferLength = 0;  		}  		else {  			_framesBufferLength -= 4 + len;  			_framesBufferOffset += 4 + len;  		}  		if (is_last)  			break;  	}  }  while (true);  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: do {  	fill_frames_buffer ();  	fixed (byte* buf = _framesBuffer) {  		BitReader bitreader = new BitReader (buf' _framesBufferOffset' _framesBufferLength - _framesBufferOffset);  		bool is_last = bitreader.readbit () != 0;  		MetadataType type = (MetadataType)bitreader.readbits (7);  		int len = (int)bitreader.readbits (24);  		if (type == MetadataType.StreamInfo) {  			const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  			/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  			max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  			min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  			max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  			int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  			int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  			int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  			pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  			_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  			bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  		}  		else if (type == MetadataType.Seektable) {  			int num_entries = len / 18;  			seek_table = new SeekPoint[num_entries];  			for (int e = 0; e < num_entries; e++) {  				seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  				seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  				seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  			}  		}  		if (_framesBufferLength < 4 + len) {  			_IO.Position += 4 + len - _framesBufferLength;  			_framesBufferLength = 0;  		}  		else {  			_framesBufferLength -= 4 + len;  			_framesBufferOffset += 4 + len;  		}  		if (is_last)  			break;  	}  }  while (true);  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: do {  	fill_frames_buffer ();  	fixed (byte* buf = _framesBuffer) {  		BitReader bitreader = new BitReader (buf' _framesBufferOffset' _framesBufferLength - _framesBufferOffset);  		bool is_last = bitreader.readbit () != 0;  		MetadataType type = (MetadataType)bitreader.readbits (7);  		int len = (int)bitreader.readbits (24);  		if (type == MetadataType.StreamInfo) {  			const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  			/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  			max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  			min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  			max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  			int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  			int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  			int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  			pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  			_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  			bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  		}  		else if (type == MetadataType.Seektable) {  			int num_entries = len / 18;  			seek_table = new SeekPoint[num_entries];  			for (int e = 0; e < num_entries; e++) {  				seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  				seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  				seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  			}  		}  		if (_framesBufferLength < 4 + len) {  			_IO.Position += 4 + len - _framesBufferLength;  			_framesBufferLength = 0;  		}  		else {  			_framesBufferLength -= 4 + len;  			_framesBufferOffset += 4 + len;  		}  		if (is_last)  			break;  	}  }  while (true);  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: do {  	fill_frames_buffer ();  	fixed (byte* buf = _framesBuffer) {  		BitReader bitreader = new BitReader (buf' _framesBufferOffset' _framesBufferLength - _framesBufferOffset);  		bool is_last = bitreader.readbit () != 0;  		MetadataType type = (MetadataType)bitreader.readbits (7);  		int len = (int)bitreader.readbits (24);  		if (type == MetadataType.StreamInfo) {  			const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  			/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  			/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  			max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  			min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  			max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  			int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  			int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  			int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  			pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  			_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  			bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  		}  		else if (type == MetadataType.Seektable) {  			int num_entries = len / 18;  			seek_table = new SeekPoint[num_entries];  			for (int e = 0; e < num_entries; e++) {  				seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  				seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  				seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  			}  		}  		if (_framesBufferLength < 4 + len) {  			_IO.Position += 4 + len - _framesBufferLength;  			_framesBufferLength = 0;  		}  		else {  			_framesBufferLength -= 4 + len;  			_framesBufferOffset += 4 + len;  		}  		if (is_last)  			break;  	}  }  while (true);  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: fixed (byte* buf = _framesBuffer) {  	BitReader bitreader = new BitReader (buf' _framesBufferOffset' _framesBufferLength - _framesBufferOffset);  	bool is_last = bitreader.readbit () != 0;  	MetadataType type = (MetadataType)bitreader.readbits (7);  	int len = (int)bitreader.readbits (24);  	if (type == MetadataType.StreamInfo) {  		const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  		/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  		max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  		min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  		max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  		int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  		int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  		int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  		pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  		_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  		bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  	}  	else if (type == MetadataType.Seektable) {  		int num_entries = len / 18;  		seek_table = new SeekPoint[num_entries];  		for (int e = 0; e < num_entries; e++) {  			seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  			seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  			seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  		}  	}  	if (_framesBufferLength < 4 + len) {  		_IO.Position += 4 + len - _framesBufferLength;  		_framesBufferLength = 0;  	}  	else {  		_framesBufferLength -= 4 + len;  		_framesBufferOffset += 4 + len;  	}  	if (is_last)  		break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: fixed (byte* buf = _framesBuffer) {  	BitReader bitreader = new BitReader (buf' _framesBufferOffset' _framesBufferLength - _framesBufferOffset);  	bool is_last = bitreader.readbit () != 0;  	MetadataType type = (MetadataType)bitreader.readbits (7);  	int len = (int)bitreader.readbits (24);  	if (type == MetadataType.StreamInfo) {  		const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  		/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  		max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  		min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  		max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  		int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  		int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  		int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  		pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  		_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  		bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  	}  	else if (type == MetadataType.Seektable) {  		int num_entries = len / 18;  		seek_table = new SeekPoint[num_entries];  		for (int e = 0; e < num_entries; e++) {  			seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  			seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  			seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  		}  	}  	if (_framesBufferLength < 4 + len) {  		_IO.Position += 4 + len - _framesBufferLength;  		_framesBufferLength = 0;  	}  	else {  		_framesBufferLength -= 4 + len;  		_framesBufferOffset += 4 + len;  	}  	if (is_last)  		break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: fixed (byte* buf = _framesBuffer) {  	BitReader bitreader = new BitReader (buf' _framesBufferOffset' _framesBufferLength - _framesBufferOffset);  	bool is_last = bitreader.readbit () != 0;  	MetadataType type = (MetadataType)bitreader.readbits (7);  	int len = (int)bitreader.readbits (24);  	if (type == MetadataType.StreamInfo) {  		const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  		/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  		max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  		min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  		max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  		int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  		int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  		int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  		pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  		_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  		bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  	}  	else if (type == MetadataType.Seektable) {  		int num_entries = len / 18;  		seek_table = new SeekPoint[num_entries];  		for (int e = 0; e < num_entries; e++) {  			seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  			seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  			seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  		}  	}  	if (_framesBufferLength < 4 + len) {  		_IO.Position += 4 + len - _framesBufferLength;  		_framesBufferLength = 0;  	}  	else {  		_framesBufferLength -= 4 + len;  		_framesBufferOffset += 4 + len;  	}  	if (is_last)  		break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: fixed (byte* buf = _framesBuffer) {  	BitReader bitreader = new BitReader (buf' _framesBufferOffset' _framesBufferLength - _framesBufferOffset);  	bool is_last = bitreader.readbit () != 0;  	MetadataType type = (MetadataType)bitreader.readbits (7);  	int len = (int)bitreader.readbits (24);  	if (type == MetadataType.StreamInfo) {  		const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  		/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  		max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  		min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  		max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  		int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  		int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  		int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  		pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  		_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  		bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  	}  	else if (type == MetadataType.Seektable) {  		int num_entries = len / 18;  		seek_table = new SeekPoint[num_entries];  		for (int e = 0; e < num_entries; e++) {  			seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  			seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  			seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  		}  	}  	if (_framesBufferLength < 4 + len) {  		_IO.Position += 4 + len - _framesBufferLength;  		_framesBufferLength = 0;  	}  	else {  		_framesBufferLength -= 4 + len;  		_framesBufferOffset += 4 + len;  	}  	if (is_last)  		break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: fixed (byte* buf = _framesBuffer) {  	BitReader bitreader = new BitReader (buf' _framesBufferOffset' _framesBufferLength - _framesBufferOffset);  	bool is_last = bitreader.readbit () != 0;  	MetadataType type = (MetadataType)bitreader.readbits (7);  	int len = (int)bitreader.readbits (24);  	if (type == MetadataType.StreamInfo) {  		const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  		/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  		max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  		min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  		max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  		int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  		int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  		int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  		pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  		_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  		bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  	}  	else if (type == MetadataType.Seektable) {  		int num_entries = len / 18;  		seek_table = new SeekPoint[num_entries];  		for (int e = 0; e < num_entries; e++) {  			seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  			seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  			seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  		}  	}  	if (_framesBufferLength < 4 + len) {  		_IO.Position += 4 + len - _framesBufferLength;  		_framesBufferLength = 0;  	}  	else {  		_framesBufferLength -= 4 + len;  		_framesBufferOffset += 4 + len;  	}  	if (is_last)  		break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: fixed (byte* buf = _framesBuffer) {  	BitReader bitreader = new BitReader (buf' _framesBufferOffset' _framesBufferLength - _framesBufferOffset);  	bool is_last = bitreader.readbit () != 0;  	MetadataType type = (MetadataType)bitreader.readbits (7);  	int len = (int)bitreader.readbits (24);  	if (type == MetadataType.StreamInfo) {  		const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  		/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  		max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  		min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  		max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  		int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  		int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  		int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  		pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  		_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  		bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  	}  	else if (type == MetadataType.Seektable) {  		int num_entries = len / 18;  		seek_table = new SeekPoint[num_entries];  		for (int e = 0; e < num_entries; e++) {  			seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  			seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  			seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  		}  	}  	if (_framesBufferLength < 4 + len) {  		_IO.Position += 4 + len - _framesBufferLength;  		_framesBufferLength = 0;  	}  	else {  		_framesBufferLength -= 4 + len;  		_framesBufferOffset += 4 + len;  	}  	if (is_last)  		break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: fixed (byte* buf = _framesBuffer) {  	BitReader bitreader = new BitReader (buf' _framesBufferOffset' _framesBufferLength - _framesBufferOffset);  	bool is_last = bitreader.readbit () != 0;  	MetadataType type = (MetadataType)bitreader.readbits (7);  	int len = (int)bitreader.readbits (24);  	if (type == MetadataType.StreamInfo) {  		const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  		/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  		max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  		min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  		max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  		int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  		int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  		int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  		pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  		_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  		bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  	}  	else if (type == MetadataType.Seektable) {  		int num_entries = len / 18;  		seek_table = new SeekPoint[num_entries];  		for (int e = 0; e < num_entries; e++) {  			seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  			seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  			seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  		}  	}  	if (_framesBufferLength < 4 + len) {  		_IO.Position += 4 + len - _framesBufferLength;  		_framesBufferLength = 0;  	}  	else {  		_framesBufferLength -= 4 + len;  		_framesBufferOffset += 4 + len;  	}  	if (is_last)  		break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: fixed (byte* buf = _framesBuffer) {  	BitReader bitreader = new BitReader (buf' _framesBufferOffset' _framesBufferLength - _framesBufferOffset);  	bool is_last = bitreader.readbit () != 0;  	MetadataType type = (MetadataType)bitreader.readbits (7);  	int len = (int)bitreader.readbits (24);  	if (type == MetadataType.StreamInfo) {  		const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  		/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  		max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  		min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  		max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  		int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  		int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  		int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  		pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  		_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  		bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  	}  	else if (type == MetadataType.Seektable) {  		int num_entries = len / 18;  		seek_table = new SeekPoint[num_entries];  		for (int e = 0; e < num_entries; e++) {  			seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  			seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  			seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  		}  	}  	if (_framesBufferLength < 4 + len) {  		_IO.Position += 4 + len - _framesBufferLength;  		_framesBufferLength = 0;  	}  	else {  		_framesBufferLength -= 4 + len;  		_framesBufferOffset += 4 + len;  	}  	if (is_last)  		break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: fixed (byte* buf = _framesBuffer) {  	BitReader bitreader = new BitReader (buf' _framesBufferOffset' _framesBufferLength - _framesBufferOffset);  	bool is_last = bitreader.readbit () != 0;  	MetadataType type = (MetadataType)bitreader.readbits (7);  	int len = (int)bitreader.readbits (24);  	if (type == MetadataType.StreamInfo) {  		const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  		/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  		max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  		min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  		max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  		int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  		int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  		int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  		pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  		_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  		bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  	}  	else if (type == MetadataType.Seektable) {  		int num_entries = len / 18;  		seek_table = new SeekPoint[num_entries];  		for (int e = 0; e < num_entries; e++) {  			seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  			seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  			seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  		}  	}  	if (_framesBufferLength < 4 + len) {  		_IO.Position += 4 + len - _framesBufferLength;  		_framesBufferLength = 0;  	}  	else {  		_framesBufferLength -= 4 + len;  		_framesBufferOffset += 4 + len;  	}  	if (is_last)  		break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: fixed (byte* buf = _framesBuffer) {  	BitReader bitreader = new BitReader (buf' _framesBufferOffset' _framesBufferLength - _framesBufferOffset);  	bool is_last = bitreader.readbit () != 0;  	MetadataType type = (MetadataType)bitreader.readbits (7);  	int len = (int)bitreader.readbits (24);  	if (type == MetadataType.StreamInfo) {  		const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  		/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  		max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  		min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  		max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  		int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  		int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  		int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  		pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  		_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  		bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  	}  	else if (type == MetadataType.Seektable) {  		int num_entries = len / 18;  		seek_table = new SeekPoint[num_entries];  		for (int e = 0; e < num_entries; e++) {  			seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  			seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  			seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  		}  	}  	if (_framesBufferLength < 4 + len) {  		_IO.Position += 4 + len - _framesBufferLength;  		_framesBufferLength = 0;  	}  	else {  		_framesBufferLength -= 4 + len;  		_framesBufferOffset += 4 + len;  	}  	if (is_last)  		break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: fixed (byte* buf = _framesBuffer) {  	BitReader bitreader = new BitReader (buf' _framesBufferOffset' _framesBufferLength - _framesBufferOffset);  	bool is_last = bitreader.readbit () != 0;  	MetadataType type = (MetadataType)bitreader.readbits (7);  	int len = (int)bitreader.readbits (24);  	if (type == MetadataType.StreamInfo) {  		const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  		/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  		max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  		min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  		max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  		int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  		int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  		int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  		pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  		_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  		bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  	}  	else if (type == MetadataType.Seektable) {  		int num_entries = len / 18;  		seek_table = new SeekPoint[num_entries];  		for (int e = 0; e < num_entries; e++) {  			seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  			seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  			seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  		}  	}  	if (_framesBufferLength < 4 + len) {  		_IO.Position += 4 + len - _framesBufferLength;  		_framesBufferLength = 0;  	}  	else {  		_framesBufferLength -= 4 + len;  		_framesBufferOffset += 4 + len;  	}  	if (is_last)  		break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: fixed (byte* buf = _framesBuffer) {  	BitReader bitreader = new BitReader (buf' _framesBufferOffset' _framesBufferLength - _framesBufferOffset);  	bool is_last = bitreader.readbit () != 0;  	MetadataType type = (MetadataType)bitreader.readbits (7);  	int len = (int)bitreader.readbits (24);  	if (type == MetadataType.StreamInfo) {  		const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  		/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  		max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  		min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  		max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  		int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  		int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  		int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  		pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  		_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  		bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  	}  	else if (type == MetadataType.Seektable) {  		int num_entries = len / 18;  		seek_table = new SeekPoint[num_entries];  		for (int e = 0; e < num_entries; e++) {  			seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  			seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  			seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  		}  	}  	if (_framesBufferLength < 4 + len) {  		_IO.Position += 4 + len - _framesBufferLength;  		_framesBufferLength = 0;  	}  	else {  		_framesBufferLength -= 4 + len;  		_framesBufferOffset += 4 + len;  	}  	if (is_last)  		break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: fixed (byte* buf = _framesBuffer) {  	BitReader bitreader = new BitReader (buf' _framesBufferOffset' _framesBufferLength - _framesBufferOffset);  	bool is_last = bitreader.readbit () != 0;  	MetadataType type = (MetadataType)bitreader.readbits (7);  	int len = (int)bitreader.readbits (24);  	if (type == MetadataType.StreamInfo) {  		const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  		/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  		max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  		min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  		max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  		int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  		int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  		int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  		pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  		_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  		bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  	}  	else if (type == MetadataType.Seektable) {  		int num_entries = len / 18;  		seek_table = new SeekPoint[num_entries];  		for (int e = 0; e < num_entries; e++) {  			seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  			seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  			seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  		}  	}  	if (_framesBufferLength < 4 + len) {  		_IO.Position += 4 + len - _framesBufferLength;  		_framesBufferLength = 0;  	}  	else {  		_framesBufferLength -= 4 + len;  		_framesBufferOffset += 4 + len;  	}  	if (is_last)  		break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: fixed (byte* buf = _framesBuffer) {  	BitReader bitreader = new BitReader (buf' _framesBufferOffset' _framesBufferLength - _framesBufferOffset);  	bool is_last = bitreader.readbit () != 0;  	MetadataType type = (MetadataType)bitreader.readbits (7);  	int len = (int)bitreader.readbits (24);  	if (type == MetadataType.StreamInfo) {  		const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  		/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  		max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  		min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  		max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  		int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  		int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  		int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  		pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  		_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  		bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  	}  	else if (type == MetadataType.Seektable) {  		int num_entries = len / 18;  		seek_table = new SeekPoint[num_entries];  		for (int e = 0; e < num_entries; e++) {  			seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  			seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  			seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  		}  	}  	if (_framesBufferLength < 4 + len) {  		_IO.Position += 4 + len - _framesBufferLength;  		_framesBufferLength = 0;  	}  	else {  		_framesBufferLength -= 4 + len;  		_framesBufferOffset += 4 + len;  	}  	if (is_last)  		break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: fixed (byte* buf = _framesBuffer) {  	BitReader bitreader = new BitReader (buf' _framesBufferOffset' _framesBufferLength - _framesBufferOffset);  	bool is_last = bitreader.readbit () != 0;  	MetadataType type = (MetadataType)bitreader.readbits (7);  	int len = (int)bitreader.readbits (24);  	if (type == MetadataType.StreamInfo) {  		const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  		/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  		max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  		min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  		max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  		int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  		int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  		int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  		pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  		_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  		bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  	}  	else if (type == MetadataType.Seektable) {  		int num_entries = len / 18;  		seek_table = new SeekPoint[num_entries];  		for (int e = 0; e < num_entries; e++) {  			seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  			seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  			seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  		}  	}  	if (_framesBufferLength < 4 + len) {  		_IO.Position += 4 + len - _framesBufferLength;  		_framesBufferLength = 0;  	}  	else {  		_framesBufferLength -= 4 + len;  		_framesBufferOffset += 4 + len;  	}  	if (is_last)  		break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: fixed (byte* buf = _framesBuffer) {  	BitReader bitreader = new BitReader (buf' _framesBufferOffset' _framesBufferLength - _framesBufferOffset);  	bool is_last = bitreader.readbit () != 0;  	MetadataType type = (MetadataType)bitreader.readbits (7);  	int len = (int)bitreader.readbits (24);  	if (type == MetadataType.StreamInfo) {  		const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  		/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  		/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  		max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  		min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  		max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  		int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  		int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  		int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  		pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  		_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  		bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  	}  	else if (type == MetadataType.Seektable) {  		int num_entries = len / 18;  		seek_table = new SeekPoint[num_entries];  		for (int e = 0; e < num_entries; e++) {  			seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  			seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  			seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  		}  	}  	if (_framesBufferLength < 4 + len) {  		_IO.Position += 4 + len - _framesBufferLength;  		_framesBufferLength = 0;  	}  	else {  		_framesBufferLength -= 4 + len;  		_framesBufferOffset += 4 + len;  	}  	if (is_last)  		break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: if (type == MetadataType.StreamInfo) {  	const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  	/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  	max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  	min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  	max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  	int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  	int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  	int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  	pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  	_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  	bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  }  else if (type == MetadataType.Seektable) {  	int num_entries = len / 18;  	seek_table = new SeekPoint[num_entries];  	for (int e = 0; e < num_entries; e++) {  		seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  		seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  		seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: if (type == MetadataType.StreamInfo) {  	const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  	/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  	max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  	min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  	max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  	int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  	int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  	int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  	pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  	_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  	bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  }  else if (type == MetadataType.Seektable) {  	int num_entries = len / 18;  	seek_table = new SeekPoint[num_entries];  	for (int e = 0; e < num_entries; e++) {  		seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  		seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  		seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: if (type == MetadataType.StreamInfo) {  	const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  	/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  	max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  	min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  	max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  	int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  	int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  	int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  	pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  	_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  	bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  }  else if (type == MetadataType.Seektable) {  	int num_entries = len / 18;  	seek_table = new SeekPoint[num_entries];  	for (int e = 0; e < num_entries; e++) {  		seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  		seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  		seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: if (type == MetadataType.StreamInfo) {  	const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  	/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  	max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  	min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  	max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  	int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  	int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  	int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  	pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  	_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  	bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  }  else if (type == MetadataType.Seektable) {  	int num_entries = len / 18;  	seek_table = new SeekPoint[num_entries];  	for (int e = 0; e < num_entries; e++) {  		seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  		seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  		seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: if (type == MetadataType.StreamInfo) {  	const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  	/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  	max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  	min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  	max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  	int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  	int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  	int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  	pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  	_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  	bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  }  else if (type == MetadataType.Seektable) {  	int num_entries = len / 18;  	seek_table = new SeekPoint[num_entries];  	for (int e = 0; e < num_entries; e++) {  		seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  		seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  		seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: if (type == MetadataType.StreamInfo) {  	const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  	/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  	max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  	min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  	max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  	int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  	int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  	int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  	pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  	_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  	bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  }  else if (type == MetadataType.Seektable) {  	int num_entries = len / 18;  	seek_table = new SeekPoint[num_entries];  	for (int e = 0; e < num_entries; e++) {  		seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  		seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  		seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: if (type == MetadataType.StreamInfo) {  	const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  	/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  	max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  	min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  	max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  	int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  	int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  	int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  	pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  	_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  	bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  }  else if (type == MetadataType.Seektable) {  	int num_entries = len / 18;  	seek_table = new SeekPoint[num_entries];  	for (int e = 0; e < num_entries; e++) {  		seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  		seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  		seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: if (type == MetadataType.StreamInfo) {  	const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  	/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  	max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  	min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  	max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  	int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  	int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  	int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  	pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  	_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  	bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  }  else if (type == MetadataType.Seektable) {  	int num_entries = len / 18;  	seek_table = new SeekPoint[num_entries];  	for (int e = 0; e < num_entries; e++) {  		seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  		seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  		seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: if (type == MetadataType.StreamInfo) {  	const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  	/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  	max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  	min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  	max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  	int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  	int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  	int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  	pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  	_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  	bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  }  else if (type == MetadataType.Seektable) {  	int num_entries = len / 18;  	seek_table = new SeekPoint[num_entries];  	for (int e = 0; e < num_entries; e++) {  		seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  		seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  		seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: if (type == MetadataType.StreamInfo) {  	const int FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36;  	/* bits */const int FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128;  	/* bits */min_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN);  	max_block_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN);  	min_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN);  	max_frame_size = bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN);  	int sample_rate = (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN);  	int channels = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN);  	int bits_per_sample = 1 + (int)bitreader.readbits (FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN);  	pcm = new AudioPCMConfig (bits_per_sample' channels' sample_rate);  	_sampleCount = (long)bitreader.readbits64 (FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN);  	bitreader.skipbits (FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN);  }  else if (type == MetadataType.Seektable) {  	int num_entries = len / 18;  	seek_table = new SeekPoint[num_entries];  	for (int e = 0; e < num_entries; e++) {  		seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  		seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  		seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: if (type == MetadataType.Seektable) {  	int num_entries = len / 18;  	seek_table = new SeekPoint[num_entries];  	for (int e = 0; e < num_entries; e++) {  		seek_table [e].number = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN);  		seek_table [e].offset = (long)bitreader.readbits64 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN);  		seek_table [e].framesize = (int)bitreader.readbits24 (Flake.FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN);  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: if (_framesBufferLength < 4 + len) {  	_IO.Position += 4 + len - _framesBufferLength;  	_framesBufferLength = 0;  }  else {  	_framesBufferLength -= 4 + len;  	_framesBufferOffset += 4 + len;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: if (_framesBufferLength < 4 + len) {  	_IO.Position += 4 + len - _framesBufferLength;  	_framesBufferLength = 0;  }  else {  	_framesBufferLength -= 4 + len;  	_framesBufferOffset += 4 + len;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: if (_framesBufferLength < 4 + len) {  	_IO.Position += 4 + len - _framesBufferLength;  	_framesBufferLength = 0;  }  else {  	_framesBufferLength -= 4 + len;  	_framesBufferOffset += 4 + len;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: if (_framesBufferLength < 4 + len) {  	_IO.Position += 4 + len - _framesBufferLength;  	_framesBufferLength = 0;  }  else {  	_framesBufferLength -= 4 + len;  	_framesBufferOffset += 4 + len;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: _IO.Position += 4 + len - _framesBufferLength;  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: _framesBufferLength -= 4 + len;  
Magic Number,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_metadata,The following statement contains a magic number: _framesBufferOffset += 4 + len;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,FlakeWriter,The following statement contains a magic number: samplesBuffer = new int[Flake.MAX_BLOCKSIZE * (channels == 2 ? 4 : channels)];  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,FlakeWriter,The following statement contains a magic number: samplesBuffer = new int[Flake.MAX_BLOCKSIZE * (channels == 2 ? 4 : channels)];  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,FlakeWriter,The following statement contains a magic number: residualBuffer = new int[Flake.MAX_BLOCKSIZE * (channels == 2 ? 10 : channels + 1)];  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,FlakeWriter,The following statement contains a magic number: residualBuffer = new int[Flake.MAX_BLOCKSIZE * (channels == 2 ? 10 : channels + 1)];  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,FlakeWriter,The following statement contains a magic number: windowBuffer = new float[Flake.MAX_BLOCKSIZE * 2 * lpc.MAX_LPC_WINDOWS];  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,FlakeWriter,The following statement contains a magic number: eparams.padding_size = 8192;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,FlakeWriter,The following statement contains a magic number: frame = new FlacFrame (channels * 2);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,DoClose,The following statement contains a magic number: if (inited) {  	while (samplesInBuffer > 0) {  		eparams.block_size = samplesInBuffer;  		output_frame ();  	}  	if (_IO.CanSeek) {  		if (sample_count <= 0 && _position != 0) {  			BitWriter bitwriter = new BitWriter (header' 0' 4);  			bitwriter.writebits (32' (int)_position);  			bitwriter.flush ();  			_IO.Position = 22;  			_IO.Write (header' 0' 4);  		}  		if (md5 != null) {  			md5.TransformFinalBlock (frame_buffer' 0' 0);  			_IO.Position = 26;  			_IO.Write (md5.Hash' 0' md5.Hash.Length);  		}  		if (seek_table != null) {  			_IO.Position = seek_table_offset;  			int len = write_seekpoints (header' 0' 0);  			_IO.Write (header' 4' len - 4);  		}  	}  	_IO.Close ();  	inited = false;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,DoClose,The following statement contains a magic number: if (inited) {  	while (samplesInBuffer > 0) {  		eparams.block_size = samplesInBuffer;  		output_frame ();  	}  	if (_IO.CanSeek) {  		if (sample_count <= 0 && _position != 0) {  			BitWriter bitwriter = new BitWriter (header' 0' 4);  			bitwriter.writebits (32' (int)_position);  			bitwriter.flush ();  			_IO.Position = 22;  			_IO.Write (header' 0' 4);  		}  		if (md5 != null) {  			md5.TransformFinalBlock (frame_buffer' 0' 0);  			_IO.Position = 26;  			_IO.Write (md5.Hash' 0' md5.Hash.Length);  		}  		if (seek_table != null) {  			_IO.Position = seek_table_offset;  			int len = write_seekpoints (header' 0' 0);  			_IO.Write (header' 4' len - 4);  		}  	}  	_IO.Close ();  	inited = false;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,DoClose,The following statement contains a magic number: if (inited) {  	while (samplesInBuffer > 0) {  		eparams.block_size = samplesInBuffer;  		output_frame ();  	}  	if (_IO.CanSeek) {  		if (sample_count <= 0 && _position != 0) {  			BitWriter bitwriter = new BitWriter (header' 0' 4);  			bitwriter.writebits (32' (int)_position);  			bitwriter.flush ();  			_IO.Position = 22;  			_IO.Write (header' 0' 4);  		}  		if (md5 != null) {  			md5.TransformFinalBlock (frame_buffer' 0' 0);  			_IO.Position = 26;  			_IO.Write (md5.Hash' 0' md5.Hash.Length);  		}  		if (seek_table != null) {  			_IO.Position = seek_table_offset;  			int len = write_seekpoints (header' 0' 0);  			_IO.Write (header' 4' len - 4);  		}  	}  	_IO.Close ();  	inited = false;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,DoClose,The following statement contains a magic number: if (inited) {  	while (samplesInBuffer > 0) {  		eparams.block_size = samplesInBuffer;  		output_frame ();  	}  	if (_IO.CanSeek) {  		if (sample_count <= 0 && _position != 0) {  			BitWriter bitwriter = new BitWriter (header' 0' 4);  			bitwriter.writebits (32' (int)_position);  			bitwriter.flush ();  			_IO.Position = 22;  			_IO.Write (header' 0' 4);  		}  		if (md5 != null) {  			md5.TransformFinalBlock (frame_buffer' 0' 0);  			_IO.Position = 26;  			_IO.Write (md5.Hash' 0' md5.Hash.Length);  		}  		if (seek_table != null) {  			_IO.Position = seek_table_offset;  			int len = write_seekpoints (header' 0' 0);  			_IO.Write (header' 4' len - 4);  		}  	}  	_IO.Close ();  	inited = false;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,DoClose,The following statement contains a magic number: if (inited) {  	while (samplesInBuffer > 0) {  		eparams.block_size = samplesInBuffer;  		output_frame ();  	}  	if (_IO.CanSeek) {  		if (sample_count <= 0 && _position != 0) {  			BitWriter bitwriter = new BitWriter (header' 0' 4);  			bitwriter.writebits (32' (int)_position);  			bitwriter.flush ();  			_IO.Position = 22;  			_IO.Write (header' 0' 4);  		}  		if (md5 != null) {  			md5.TransformFinalBlock (frame_buffer' 0' 0);  			_IO.Position = 26;  			_IO.Write (md5.Hash' 0' md5.Hash.Length);  		}  		if (seek_table != null) {  			_IO.Position = seek_table_offset;  			int len = write_seekpoints (header' 0' 0);  			_IO.Write (header' 4' len - 4);  		}  	}  	_IO.Close ();  	inited = false;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,DoClose,The following statement contains a magic number: if (inited) {  	while (samplesInBuffer > 0) {  		eparams.block_size = samplesInBuffer;  		output_frame ();  	}  	if (_IO.CanSeek) {  		if (sample_count <= 0 && _position != 0) {  			BitWriter bitwriter = new BitWriter (header' 0' 4);  			bitwriter.writebits (32' (int)_position);  			bitwriter.flush ();  			_IO.Position = 22;  			_IO.Write (header' 0' 4);  		}  		if (md5 != null) {  			md5.TransformFinalBlock (frame_buffer' 0' 0);  			_IO.Position = 26;  			_IO.Write (md5.Hash' 0' md5.Hash.Length);  		}  		if (seek_table != null) {  			_IO.Position = seek_table_offset;  			int len = write_seekpoints (header' 0' 0);  			_IO.Write (header' 4' len - 4);  		}  	}  	_IO.Close ();  	inited = false;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,DoClose,The following statement contains a magic number: if (inited) {  	while (samplesInBuffer > 0) {  		eparams.block_size = samplesInBuffer;  		output_frame ();  	}  	if (_IO.CanSeek) {  		if (sample_count <= 0 && _position != 0) {  			BitWriter bitwriter = new BitWriter (header' 0' 4);  			bitwriter.writebits (32' (int)_position);  			bitwriter.flush ();  			_IO.Position = 22;  			_IO.Write (header' 0' 4);  		}  		if (md5 != null) {  			md5.TransformFinalBlock (frame_buffer' 0' 0);  			_IO.Position = 26;  			_IO.Write (md5.Hash' 0' md5.Hash.Length);  		}  		if (seek_table != null) {  			_IO.Position = seek_table_offset;  			int len = write_seekpoints (header' 0' 0);  			_IO.Write (header' 4' len - 4);  		}  	}  	_IO.Close ();  	inited = false;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,DoClose,The following statement contains a magic number: if (_IO.CanSeek) {  	if (sample_count <= 0 && _position != 0) {  		BitWriter bitwriter = new BitWriter (header' 0' 4);  		bitwriter.writebits (32' (int)_position);  		bitwriter.flush ();  		_IO.Position = 22;  		_IO.Write (header' 0' 4);  	}  	if (md5 != null) {  		md5.TransformFinalBlock (frame_buffer' 0' 0);  		_IO.Position = 26;  		_IO.Write (md5.Hash' 0' md5.Hash.Length);  	}  	if (seek_table != null) {  		_IO.Position = seek_table_offset;  		int len = write_seekpoints (header' 0' 0);  		_IO.Write (header' 4' len - 4);  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,DoClose,The following statement contains a magic number: if (_IO.CanSeek) {  	if (sample_count <= 0 && _position != 0) {  		BitWriter bitwriter = new BitWriter (header' 0' 4);  		bitwriter.writebits (32' (int)_position);  		bitwriter.flush ();  		_IO.Position = 22;  		_IO.Write (header' 0' 4);  	}  	if (md5 != null) {  		md5.TransformFinalBlock (frame_buffer' 0' 0);  		_IO.Position = 26;  		_IO.Write (md5.Hash' 0' md5.Hash.Length);  	}  	if (seek_table != null) {  		_IO.Position = seek_table_offset;  		int len = write_seekpoints (header' 0' 0);  		_IO.Write (header' 4' len - 4);  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,DoClose,The following statement contains a magic number: if (_IO.CanSeek) {  	if (sample_count <= 0 && _position != 0) {  		BitWriter bitwriter = new BitWriter (header' 0' 4);  		bitwriter.writebits (32' (int)_position);  		bitwriter.flush ();  		_IO.Position = 22;  		_IO.Write (header' 0' 4);  	}  	if (md5 != null) {  		md5.TransformFinalBlock (frame_buffer' 0' 0);  		_IO.Position = 26;  		_IO.Write (md5.Hash' 0' md5.Hash.Length);  	}  	if (seek_table != null) {  		_IO.Position = seek_table_offset;  		int len = write_seekpoints (header' 0' 0);  		_IO.Write (header' 4' len - 4);  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,DoClose,The following statement contains a magic number: if (_IO.CanSeek) {  	if (sample_count <= 0 && _position != 0) {  		BitWriter bitwriter = new BitWriter (header' 0' 4);  		bitwriter.writebits (32' (int)_position);  		bitwriter.flush ();  		_IO.Position = 22;  		_IO.Write (header' 0' 4);  	}  	if (md5 != null) {  		md5.TransformFinalBlock (frame_buffer' 0' 0);  		_IO.Position = 26;  		_IO.Write (md5.Hash' 0' md5.Hash.Length);  	}  	if (seek_table != null) {  		_IO.Position = seek_table_offset;  		int len = write_seekpoints (header' 0' 0);  		_IO.Write (header' 4' len - 4);  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,DoClose,The following statement contains a magic number: if (_IO.CanSeek) {  	if (sample_count <= 0 && _position != 0) {  		BitWriter bitwriter = new BitWriter (header' 0' 4);  		bitwriter.writebits (32' (int)_position);  		bitwriter.flush ();  		_IO.Position = 22;  		_IO.Write (header' 0' 4);  	}  	if (md5 != null) {  		md5.TransformFinalBlock (frame_buffer' 0' 0);  		_IO.Position = 26;  		_IO.Write (md5.Hash' 0' md5.Hash.Length);  	}  	if (seek_table != null) {  		_IO.Position = seek_table_offset;  		int len = write_seekpoints (header' 0' 0);  		_IO.Write (header' 4' len - 4);  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,DoClose,The following statement contains a magic number: if (_IO.CanSeek) {  	if (sample_count <= 0 && _position != 0) {  		BitWriter bitwriter = new BitWriter (header' 0' 4);  		bitwriter.writebits (32' (int)_position);  		bitwriter.flush ();  		_IO.Position = 22;  		_IO.Write (header' 0' 4);  	}  	if (md5 != null) {  		md5.TransformFinalBlock (frame_buffer' 0' 0);  		_IO.Position = 26;  		_IO.Write (md5.Hash' 0' md5.Hash.Length);  	}  	if (seek_table != null) {  		_IO.Position = seek_table_offset;  		int len = write_seekpoints (header' 0' 0);  		_IO.Write (header' 4' len - 4);  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,DoClose,The following statement contains a magic number: if (_IO.CanSeek) {  	if (sample_count <= 0 && _position != 0) {  		BitWriter bitwriter = new BitWriter (header' 0' 4);  		bitwriter.writebits (32' (int)_position);  		bitwriter.flush ();  		_IO.Position = 22;  		_IO.Write (header' 0' 4);  	}  	if (md5 != null) {  		md5.TransformFinalBlock (frame_buffer' 0' 0);  		_IO.Position = 26;  		_IO.Write (md5.Hash' 0' md5.Hash.Length);  	}  	if (seek_table != null) {  		_IO.Position = seek_table_offset;  		int len = write_seekpoints (header' 0' 0);  		_IO.Write (header' 4' len - 4);  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,DoClose,The following statement contains a magic number: if (sample_count <= 0 && _position != 0) {  	BitWriter bitwriter = new BitWriter (header' 0' 4);  	bitwriter.writebits (32' (int)_position);  	bitwriter.flush ();  	_IO.Position = 22;  	_IO.Write (header' 0' 4);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,DoClose,The following statement contains a magic number: if (sample_count <= 0 && _position != 0) {  	BitWriter bitwriter = new BitWriter (header' 0' 4);  	bitwriter.writebits (32' (int)_position);  	bitwriter.flush ();  	_IO.Position = 22;  	_IO.Write (header' 0' 4);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,DoClose,The following statement contains a magic number: if (sample_count <= 0 && _position != 0) {  	BitWriter bitwriter = new BitWriter (header' 0' 4);  	bitwriter.writebits (32' (int)_position);  	bitwriter.flush ();  	_IO.Position = 22;  	_IO.Write (header' 0' 4);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,DoClose,The following statement contains a magic number: if (sample_count <= 0 && _position != 0) {  	BitWriter bitwriter = new BitWriter (header' 0' 4);  	bitwriter.writebits (32' (int)_position);  	bitwriter.flush ();  	_IO.Position = 22;  	_IO.Write (header' 0' 4);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,DoClose,The following statement contains a magic number: bitwriter.writebits (32' (int)_position);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,DoClose,The following statement contains a magic number: _IO.Position = 22;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,DoClose,The following statement contains a magic number: _IO.Write (header' 0' 4);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,DoClose,The following statement contains a magic number: if (md5 != null) {  	md5.TransformFinalBlock (frame_buffer' 0' 0);  	_IO.Position = 26;  	_IO.Write (md5.Hash' 0' md5.Hash.Length);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,DoClose,The following statement contains a magic number: _IO.Position = 26;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,DoClose,The following statement contains a magic number: if (seek_table != null) {  	_IO.Position = seek_table_offset;  	int len = write_seekpoints (header' 0' 0);  	_IO.Write (header' 4' len - 4);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,DoClose,The following statement contains a magic number: if (seek_table != null) {  	_IO.Position = seek_table_offset;  	int len = write_seekpoints (header' 0' 0);  	_IO.Write (header' 4' len - 4);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,DoClose,The following statement contains a magic number: _IO.Write (header' 4' len - 4);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,DoClose,The following statement contains a magic number: _IO.Write (header' 4' len - 4);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,copy_samples,The following statement contains a magic number: fixed (int* fsamples = samplesBuffer' src = &samples [pos' 0]) {  	if (channels == 2) {  		if (eparams.stereo_method == StereoMethod.Independent)  			AudioSamples.Deinterlace (fsamples + samplesInBuffer' fsamples + Flake.MAX_BLOCKSIZE + samplesInBuffer' src' block);  		else {  			int* left = fsamples + samplesInBuffer;  			int* right = left + Flake.MAX_BLOCKSIZE;  			int* leftM = right + Flake.MAX_BLOCKSIZE;  			int* rightM = leftM + Flake.MAX_BLOCKSIZE;  			for (int i = 0; i < block; i++) {  				int l = src [2 * i];  				int r = src [2 * i + 1];  				left [i] = l;  				right [i] = r;  				leftM [i] = (l + r) >> 1;  				rightM [i] = l - r;  			}  		}  	}  	else  		for (int ch = 0; ch < channels; ch++) {  			int* psamples = fsamples + ch * Flake.MAX_BLOCKSIZE + samplesInBuffer;  			for (int i = 0; i < block; i++)  				psamples [i] = src [i * channels + ch];  		}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,copy_samples,The following statement contains a magic number: fixed (int* fsamples = samplesBuffer' src = &samples [pos' 0]) {  	if (channels == 2) {  		if (eparams.stereo_method == StereoMethod.Independent)  			AudioSamples.Deinterlace (fsamples + samplesInBuffer' fsamples + Flake.MAX_BLOCKSIZE + samplesInBuffer' src' block);  		else {  			int* left = fsamples + samplesInBuffer;  			int* right = left + Flake.MAX_BLOCKSIZE;  			int* leftM = right + Flake.MAX_BLOCKSIZE;  			int* rightM = leftM + Flake.MAX_BLOCKSIZE;  			for (int i = 0; i < block; i++) {  				int l = src [2 * i];  				int r = src [2 * i + 1];  				left [i] = l;  				right [i] = r;  				leftM [i] = (l + r) >> 1;  				rightM [i] = l - r;  			}  		}  	}  	else  		for (int ch = 0; ch < channels; ch++) {  			int* psamples = fsamples + ch * Flake.MAX_BLOCKSIZE + samplesInBuffer;  			for (int i = 0; i < block; i++)  				psamples [i] = src [i * channels + ch];  		}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,copy_samples,The following statement contains a magic number: fixed (int* fsamples = samplesBuffer' src = &samples [pos' 0]) {  	if (channels == 2) {  		if (eparams.stereo_method == StereoMethod.Independent)  			AudioSamples.Deinterlace (fsamples + samplesInBuffer' fsamples + Flake.MAX_BLOCKSIZE + samplesInBuffer' src' block);  		else {  			int* left = fsamples + samplesInBuffer;  			int* right = left + Flake.MAX_BLOCKSIZE;  			int* leftM = right + Flake.MAX_BLOCKSIZE;  			int* rightM = leftM + Flake.MAX_BLOCKSIZE;  			for (int i = 0; i < block; i++) {  				int l = src [2 * i];  				int r = src [2 * i + 1];  				left [i] = l;  				right [i] = r;  				leftM [i] = (l + r) >> 1;  				rightM [i] = l - r;  			}  		}  	}  	else  		for (int ch = 0; ch < channels; ch++) {  			int* psamples = fsamples + ch * Flake.MAX_BLOCKSIZE + samplesInBuffer;  			for (int i = 0; i < block; i++)  				psamples [i] = src [i * channels + ch];  		}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,copy_samples,The following statement contains a magic number: if (channels == 2) {  	if (eparams.stereo_method == StereoMethod.Independent)  		AudioSamples.Deinterlace (fsamples + samplesInBuffer' fsamples + Flake.MAX_BLOCKSIZE + samplesInBuffer' src' block);  	else {  		int* left = fsamples + samplesInBuffer;  		int* right = left + Flake.MAX_BLOCKSIZE;  		int* leftM = right + Flake.MAX_BLOCKSIZE;  		int* rightM = leftM + Flake.MAX_BLOCKSIZE;  		for (int i = 0; i < block; i++) {  			int l = src [2 * i];  			int r = src [2 * i + 1];  			left [i] = l;  			right [i] = r;  			leftM [i] = (l + r) >> 1;  			rightM [i] = l - r;  		}  	}  }  else  	for (int ch = 0; ch < channels; ch++) {  		int* psamples = fsamples + ch * Flake.MAX_BLOCKSIZE + samplesInBuffer;  		for (int i = 0; i < block; i++)  			psamples [i] = src [i * channels + ch];  	}  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,copy_samples,The following statement contains a magic number: if (channels == 2) {  	if (eparams.stereo_method == StereoMethod.Independent)  		AudioSamples.Deinterlace (fsamples + samplesInBuffer' fsamples + Flake.MAX_BLOCKSIZE + samplesInBuffer' src' block);  	else {  		int* left = fsamples + samplesInBuffer;  		int* right = left + Flake.MAX_BLOCKSIZE;  		int* leftM = right + Flake.MAX_BLOCKSIZE;  		int* rightM = leftM + Flake.MAX_BLOCKSIZE;  		for (int i = 0; i < block; i++) {  			int l = src [2 * i];  			int r = src [2 * i + 1];  			left [i] = l;  			right [i] = r;  			leftM [i] = (l + r) >> 1;  			rightM [i] = l - r;  		}  	}  }  else  	for (int ch = 0; ch < channels; ch++) {  		int* psamples = fsamples + ch * Flake.MAX_BLOCKSIZE + samplesInBuffer;  		for (int i = 0; i < block; i++)  			psamples [i] = src [i * channels + ch];  	}  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,copy_samples,The following statement contains a magic number: if (channels == 2) {  	if (eparams.stereo_method == StereoMethod.Independent)  		AudioSamples.Deinterlace (fsamples + samplesInBuffer' fsamples + Flake.MAX_BLOCKSIZE + samplesInBuffer' src' block);  	else {  		int* left = fsamples + samplesInBuffer;  		int* right = left + Flake.MAX_BLOCKSIZE;  		int* leftM = right + Flake.MAX_BLOCKSIZE;  		int* rightM = leftM + Flake.MAX_BLOCKSIZE;  		for (int i = 0; i < block; i++) {  			int l = src [2 * i];  			int r = src [2 * i + 1];  			left [i] = l;  			right [i] = r;  			leftM [i] = (l + r) >> 1;  			rightM [i] = l - r;  		}  	}  }  else  	for (int ch = 0; ch < channels; ch++) {  		int* psamples = fsamples + ch * Flake.MAX_BLOCKSIZE + samplesInBuffer;  		for (int i = 0; i < block; i++)  			psamples [i] = src [i * channels + ch];  	}  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,copy_samples,The following statement contains a magic number: if (eparams.stereo_method == StereoMethod.Independent)  	AudioSamples.Deinterlace (fsamples + samplesInBuffer' fsamples + Flake.MAX_BLOCKSIZE + samplesInBuffer' src' block);  else {  	int* left = fsamples + samplesInBuffer;  	int* right = left + Flake.MAX_BLOCKSIZE;  	int* leftM = right + Flake.MAX_BLOCKSIZE;  	int* rightM = leftM + Flake.MAX_BLOCKSIZE;  	for (int i = 0; i < block; i++) {  		int l = src [2 * i];  		int r = src [2 * i + 1];  		left [i] = l;  		right [i] = r;  		leftM [i] = (l + r) >> 1;  		rightM [i] = l - r;  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,copy_samples,The following statement contains a magic number: if (eparams.stereo_method == StereoMethod.Independent)  	AudioSamples.Deinterlace (fsamples + samplesInBuffer' fsamples + Flake.MAX_BLOCKSIZE + samplesInBuffer' src' block);  else {  	int* left = fsamples + samplesInBuffer;  	int* right = left + Flake.MAX_BLOCKSIZE;  	int* leftM = right + Flake.MAX_BLOCKSIZE;  	int* rightM = leftM + Flake.MAX_BLOCKSIZE;  	for (int i = 0; i < block; i++) {  		int l = src [2 * i];  		int r = src [2 * i + 1];  		left [i] = l;  		right [i] = r;  		leftM [i] = (l + r) >> 1;  		rightM [i] = l - r;  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,copy_samples,The following statement contains a magic number: for (int i = 0; i < block; i++) {  	int l = src [2 * i];  	int r = src [2 * i + 1];  	left [i] = l;  	right [i] = r;  	leftM [i] = (l + r) >> 1;  	rightM [i] = l - r;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,copy_samples,The following statement contains a magic number: for (int i = 0; i < block; i++) {  	int l = src [2 * i];  	int r = src [2 * i + 1];  	left [i] = l;  	right [i] = r;  	leftM [i] = (l + r) >> 1;  	rightM [i] = l - r;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: switch (order) {  case 0:  	AudioSamples.MemCpy (res' smp' n);  	return;  case 1:  	*(res++) = s1 = *(smp++);  	for (i = n - 1; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - s1;  		s1 = s0;  	}  	return;  case 2:  	*(res++) = s2 = *(smp++);  	*(res++) = s1 = *(smp++);  	for (i = n - 2; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - 2 * s1 + s2;  		s2 = s1;  		s1 = s0;  	}  	return;  case 3:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	for (i = 3; i < n; i++) {  		res [i] = smp [i] - 3 * smp [i - 1] + 3 * smp [i - 2] - smp [i - 3];  	}  	return;  case 4:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	res [3] = smp [3];  	for (i = 4; i < n; i++) {  		res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  	}  	return;  default:  	return;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: switch (order) {  case 0:  	AudioSamples.MemCpy (res' smp' n);  	return;  case 1:  	*(res++) = s1 = *(smp++);  	for (i = n - 1; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - s1;  		s1 = s0;  	}  	return;  case 2:  	*(res++) = s2 = *(smp++);  	*(res++) = s1 = *(smp++);  	for (i = n - 2; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - 2 * s1 + s2;  		s2 = s1;  		s1 = s0;  	}  	return;  case 3:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	for (i = 3; i < n; i++) {  		res [i] = smp [i] - 3 * smp [i - 1] + 3 * smp [i - 2] - smp [i - 3];  	}  	return;  case 4:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	res [3] = smp [3];  	for (i = 4; i < n; i++) {  		res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  	}  	return;  default:  	return;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: switch (order) {  case 0:  	AudioSamples.MemCpy (res' smp' n);  	return;  case 1:  	*(res++) = s1 = *(smp++);  	for (i = n - 1; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - s1;  		s1 = s0;  	}  	return;  case 2:  	*(res++) = s2 = *(smp++);  	*(res++) = s1 = *(smp++);  	for (i = n - 2; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - 2 * s1 + s2;  		s2 = s1;  		s1 = s0;  	}  	return;  case 3:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	for (i = 3; i < n; i++) {  		res [i] = smp [i] - 3 * smp [i - 1] + 3 * smp [i - 2] - smp [i - 3];  	}  	return;  case 4:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	res [3] = smp [3];  	for (i = 4; i < n; i++) {  		res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  	}  	return;  default:  	return;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: switch (order) {  case 0:  	AudioSamples.MemCpy (res' smp' n);  	return;  case 1:  	*(res++) = s1 = *(smp++);  	for (i = n - 1; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - s1;  		s1 = s0;  	}  	return;  case 2:  	*(res++) = s2 = *(smp++);  	*(res++) = s1 = *(smp++);  	for (i = n - 2; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - 2 * s1 + s2;  		s2 = s1;  		s1 = s0;  	}  	return;  case 3:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	for (i = 3; i < n; i++) {  		res [i] = smp [i] - 3 * smp [i - 1] + 3 * smp [i - 2] - smp [i - 3];  	}  	return;  case 4:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	res [3] = smp [3];  	for (i = 4; i < n; i++) {  		res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  	}  	return;  default:  	return;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: switch (order) {  case 0:  	AudioSamples.MemCpy (res' smp' n);  	return;  case 1:  	*(res++) = s1 = *(smp++);  	for (i = n - 1; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - s1;  		s1 = s0;  	}  	return;  case 2:  	*(res++) = s2 = *(smp++);  	*(res++) = s1 = *(smp++);  	for (i = n - 2; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - 2 * s1 + s2;  		s2 = s1;  		s1 = s0;  	}  	return;  case 3:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	for (i = 3; i < n; i++) {  		res [i] = smp [i] - 3 * smp [i - 1] + 3 * smp [i - 2] - smp [i - 3];  	}  	return;  case 4:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	res [3] = smp [3];  	for (i = 4; i < n; i++) {  		res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  	}  	return;  default:  	return;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: switch (order) {  case 0:  	AudioSamples.MemCpy (res' smp' n);  	return;  case 1:  	*(res++) = s1 = *(smp++);  	for (i = n - 1; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - s1;  		s1 = s0;  	}  	return;  case 2:  	*(res++) = s2 = *(smp++);  	*(res++) = s1 = *(smp++);  	for (i = n - 2; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - 2 * s1 + s2;  		s2 = s1;  		s1 = s0;  	}  	return;  case 3:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	for (i = 3; i < n; i++) {  		res [i] = smp [i] - 3 * smp [i - 1] + 3 * smp [i - 2] - smp [i - 3];  	}  	return;  case 4:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	res [3] = smp [3];  	for (i = 4; i < n; i++) {  		res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  	}  	return;  default:  	return;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: switch (order) {  case 0:  	AudioSamples.MemCpy (res' smp' n);  	return;  case 1:  	*(res++) = s1 = *(smp++);  	for (i = n - 1; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - s1;  		s1 = s0;  	}  	return;  case 2:  	*(res++) = s2 = *(smp++);  	*(res++) = s1 = *(smp++);  	for (i = n - 2; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - 2 * s1 + s2;  		s2 = s1;  		s1 = s0;  	}  	return;  case 3:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	for (i = 3; i < n; i++) {  		res [i] = smp [i] - 3 * smp [i - 1] + 3 * smp [i - 2] - smp [i - 3];  	}  	return;  case 4:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	res [3] = smp [3];  	for (i = 4; i < n; i++) {  		res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  	}  	return;  default:  	return;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: switch (order) {  case 0:  	AudioSamples.MemCpy (res' smp' n);  	return;  case 1:  	*(res++) = s1 = *(smp++);  	for (i = n - 1; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - s1;  		s1 = s0;  	}  	return;  case 2:  	*(res++) = s2 = *(smp++);  	*(res++) = s1 = *(smp++);  	for (i = n - 2; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - 2 * s1 + s2;  		s2 = s1;  		s1 = s0;  	}  	return;  case 3:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	for (i = 3; i < n; i++) {  		res [i] = smp [i] - 3 * smp [i - 1] + 3 * smp [i - 2] - smp [i - 3];  	}  	return;  case 4:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	res [3] = smp [3];  	for (i = 4; i < n; i++) {  		res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  	}  	return;  default:  	return;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: switch (order) {  case 0:  	AudioSamples.MemCpy (res' smp' n);  	return;  case 1:  	*(res++) = s1 = *(smp++);  	for (i = n - 1; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - s1;  		s1 = s0;  	}  	return;  case 2:  	*(res++) = s2 = *(smp++);  	*(res++) = s1 = *(smp++);  	for (i = n - 2; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - 2 * s1 + s2;  		s2 = s1;  		s1 = s0;  	}  	return;  case 3:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	for (i = 3; i < n; i++) {  		res [i] = smp [i] - 3 * smp [i - 1] + 3 * smp [i - 2] - smp [i - 3];  	}  	return;  case 4:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	res [3] = smp [3];  	for (i = 4; i < n; i++) {  		res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  	}  	return;  default:  	return;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: switch (order) {  case 0:  	AudioSamples.MemCpy (res' smp' n);  	return;  case 1:  	*(res++) = s1 = *(smp++);  	for (i = n - 1; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - s1;  		s1 = s0;  	}  	return;  case 2:  	*(res++) = s2 = *(smp++);  	*(res++) = s1 = *(smp++);  	for (i = n - 2; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - 2 * s1 + s2;  		s2 = s1;  		s1 = s0;  	}  	return;  case 3:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	for (i = 3; i < n; i++) {  		res [i] = smp [i] - 3 * smp [i - 1] + 3 * smp [i - 2] - smp [i - 3];  	}  	return;  case 4:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	res [3] = smp [3];  	for (i = 4; i < n; i++) {  		res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  	}  	return;  default:  	return;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: switch (order) {  case 0:  	AudioSamples.MemCpy (res' smp' n);  	return;  case 1:  	*(res++) = s1 = *(smp++);  	for (i = n - 1; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - s1;  		s1 = s0;  	}  	return;  case 2:  	*(res++) = s2 = *(smp++);  	*(res++) = s1 = *(smp++);  	for (i = n - 2; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - 2 * s1 + s2;  		s2 = s1;  		s1 = s0;  	}  	return;  case 3:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	for (i = 3; i < n; i++) {  		res [i] = smp [i] - 3 * smp [i - 1] + 3 * smp [i - 2] - smp [i - 3];  	}  	return;  case 4:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	res [3] = smp [3];  	for (i = 4; i < n; i++) {  		res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  	}  	return;  default:  	return;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: switch (order) {  case 0:  	AudioSamples.MemCpy (res' smp' n);  	return;  case 1:  	*(res++) = s1 = *(smp++);  	for (i = n - 1; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - s1;  		s1 = s0;  	}  	return;  case 2:  	*(res++) = s2 = *(smp++);  	*(res++) = s1 = *(smp++);  	for (i = n - 2; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - 2 * s1 + s2;  		s2 = s1;  		s1 = s0;  	}  	return;  case 3:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	for (i = 3; i < n; i++) {  		res [i] = smp [i] - 3 * smp [i - 1] + 3 * smp [i - 2] - smp [i - 3];  	}  	return;  case 4:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	res [3] = smp [3];  	for (i = 4; i < n; i++) {  		res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  	}  	return;  default:  	return;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: switch (order) {  case 0:  	AudioSamples.MemCpy (res' smp' n);  	return;  case 1:  	*(res++) = s1 = *(smp++);  	for (i = n - 1; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - s1;  		s1 = s0;  	}  	return;  case 2:  	*(res++) = s2 = *(smp++);  	*(res++) = s1 = *(smp++);  	for (i = n - 2; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - 2 * s1 + s2;  		s2 = s1;  		s1 = s0;  	}  	return;  case 3:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	for (i = 3; i < n; i++) {  		res [i] = smp [i] - 3 * smp [i - 1] + 3 * smp [i - 2] - smp [i - 3];  	}  	return;  case 4:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	res [3] = smp [3];  	for (i = 4; i < n; i++) {  		res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  	}  	return;  default:  	return;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: switch (order) {  case 0:  	AudioSamples.MemCpy (res' smp' n);  	return;  case 1:  	*(res++) = s1 = *(smp++);  	for (i = n - 1; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - s1;  		s1 = s0;  	}  	return;  case 2:  	*(res++) = s2 = *(smp++);  	*(res++) = s1 = *(smp++);  	for (i = n - 2; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - 2 * s1 + s2;  		s2 = s1;  		s1 = s0;  	}  	return;  case 3:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	for (i = 3; i < n; i++) {  		res [i] = smp [i] - 3 * smp [i - 1] + 3 * smp [i - 2] - smp [i - 3];  	}  	return;  case 4:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	res [3] = smp [3];  	for (i = 4; i < n; i++) {  		res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  	}  	return;  default:  	return;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: switch (order) {  case 0:  	AudioSamples.MemCpy (res' smp' n);  	return;  case 1:  	*(res++) = s1 = *(smp++);  	for (i = n - 1; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - s1;  		s1 = s0;  	}  	return;  case 2:  	*(res++) = s2 = *(smp++);  	*(res++) = s1 = *(smp++);  	for (i = n - 2; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - 2 * s1 + s2;  		s2 = s1;  		s1 = s0;  	}  	return;  case 3:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	for (i = 3; i < n; i++) {  		res [i] = smp [i] - 3 * smp [i - 1] + 3 * smp [i - 2] - smp [i - 3];  	}  	return;  case 4:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	res [3] = smp [3];  	for (i = 4; i < n; i++) {  		res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  	}  	return;  default:  	return;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: switch (order) {  case 0:  	AudioSamples.MemCpy (res' smp' n);  	return;  case 1:  	*(res++) = s1 = *(smp++);  	for (i = n - 1; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - s1;  		s1 = s0;  	}  	return;  case 2:  	*(res++) = s2 = *(smp++);  	*(res++) = s1 = *(smp++);  	for (i = n - 2; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - 2 * s1 + s2;  		s2 = s1;  		s1 = s0;  	}  	return;  case 3:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	for (i = 3; i < n; i++) {  		res [i] = smp [i] - 3 * smp [i - 1] + 3 * smp [i - 2] - smp [i - 3];  	}  	return;  case 4:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	res [3] = smp [3];  	for (i = 4; i < n; i++) {  		res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  	}  	return;  default:  	return;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: switch (order) {  case 0:  	AudioSamples.MemCpy (res' smp' n);  	return;  case 1:  	*(res++) = s1 = *(smp++);  	for (i = n - 1; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - s1;  		s1 = s0;  	}  	return;  case 2:  	*(res++) = s2 = *(smp++);  	*(res++) = s1 = *(smp++);  	for (i = n - 2; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - 2 * s1 + s2;  		s2 = s1;  		s1 = s0;  	}  	return;  case 3:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	for (i = 3; i < n; i++) {  		res [i] = smp [i] - 3 * smp [i - 1] + 3 * smp [i - 2] - smp [i - 3];  	}  	return;  case 4:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	res [3] = smp [3];  	for (i = 4; i < n; i++) {  		res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  	}  	return;  default:  	return;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: switch (order) {  case 0:  	AudioSamples.MemCpy (res' smp' n);  	return;  case 1:  	*(res++) = s1 = *(smp++);  	for (i = n - 1; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - s1;  		s1 = s0;  	}  	return;  case 2:  	*(res++) = s2 = *(smp++);  	*(res++) = s1 = *(smp++);  	for (i = n - 2; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - 2 * s1 + s2;  		s2 = s1;  		s1 = s0;  	}  	return;  case 3:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	for (i = 3; i < n; i++) {  		res [i] = smp [i] - 3 * smp [i - 1] + 3 * smp [i - 2] - smp [i - 3];  	}  	return;  case 4:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	res [3] = smp [3];  	for (i = 4; i < n; i++) {  		res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  	}  	return;  default:  	return;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: switch (order) {  case 0:  	AudioSamples.MemCpy (res' smp' n);  	return;  case 1:  	*(res++) = s1 = *(smp++);  	for (i = n - 1; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - s1;  		s1 = s0;  	}  	return;  case 2:  	*(res++) = s2 = *(smp++);  	*(res++) = s1 = *(smp++);  	for (i = n - 2; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - 2 * s1 + s2;  		s2 = s1;  		s1 = s0;  	}  	return;  case 3:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	for (i = 3; i < n; i++) {  		res [i] = smp [i] - 3 * smp [i - 1] + 3 * smp [i - 2] - smp [i - 3];  	}  	return;  case 4:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	res [3] = smp [3];  	for (i = 4; i < n; i++) {  		res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  	}  	return;  default:  	return;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: switch (order) {  case 0:  	AudioSamples.MemCpy (res' smp' n);  	return;  case 1:  	*(res++) = s1 = *(smp++);  	for (i = n - 1; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - s1;  		s1 = s0;  	}  	return;  case 2:  	*(res++) = s2 = *(smp++);  	*(res++) = s1 = *(smp++);  	for (i = n - 2; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - 2 * s1 + s2;  		s2 = s1;  		s1 = s0;  	}  	return;  case 3:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	for (i = 3; i < n; i++) {  		res [i] = smp [i] - 3 * smp [i - 1] + 3 * smp [i - 2] - smp [i - 3];  	}  	return;  case 4:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	res [3] = smp [3];  	for (i = 4; i < n; i++) {  		res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  	}  	return;  default:  	return;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: switch (order) {  case 0:  	AudioSamples.MemCpy (res' smp' n);  	return;  case 1:  	*(res++) = s1 = *(smp++);  	for (i = n - 1; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - s1;  		s1 = s0;  	}  	return;  case 2:  	*(res++) = s2 = *(smp++);  	*(res++) = s1 = *(smp++);  	for (i = n - 2; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - 2 * s1 + s2;  		s2 = s1;  		s1 = s0;  	}  	return;  case 3:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	for (i = 3; i < n; i++) {  		res [i] = smp [i] - 3 * smp [i - 1] + 3 * smp [i - 2] - smp [i - 3];  	}  	return;  case 4:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	res [3] = smp [3];  	for (i = 4; i < n; i++) {  		res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  	}  	return;  default:  	return;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: switch (order) {  case 0:  	AudioSamples.MemCpy (res' smp' n);  	return;  case 1:  	*(res++) = s1 = *(smp++);  	for (i = n - 1; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - s1;  		s1 = s0;  	}  	return;  case 2:  	*(res++) = s2 = *(smp++);  	*(res++) = s1 = *(smp++);  	for (i = n - 2; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - 2 * s1 + s2;  		s2 = s1;  		s1 = s0;  	}  	return;  case 3:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	for (i = 3; i < n; i++) {  		res [i] = smp [i] - 3 * smp [i - 1] + 3 * smp [i - 2] - smp [i - 3];  	}  	return;  case 4:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	res [3] = smp [3];  	for (i = 4; i < n; i++) {  		res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  	}  	return;  default:  	return;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: switch (order) {  case 0:  	AudioSamples.MemCpy (res' smp' n);  	return;  case 1:  	*(res++) = s1 = *(smp++);  	for (i = n - 1; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - s1;  		s1 = s0;  	}  	return;  case 2:  	*(res++) = s2 = *(smp++);  	*(res++) = s1 = *(smp++);  	for (i = n - 2; i > 0; i--) {  		s0 = *(smp++);  		*(res++) = s0 - 2 * s1 + s2;  		s2 = s1;  		s1 = s0;  	}  	return;  case 3:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	for (i = 3; i < n; i++) {  		res [i] = smp [i] - 3 * smp [i - 1] + 3 * smp [i - 2] - smp [i - 3];  	}  	return;  case 4:  	res [0] = smp [0];  	res [1] = smp [1];  	res [2] = smp [2];  	res [3] = smp [3];  	for (i = 4; i < n; i++) {  		res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  	}  	return;  default:  	return;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: for (i = n - 2; i > 0; i--) {  	s0 = *(smp++);  	*(res++) = s0 - 2 * s1 + s2;  	s2 = s1;  	s1 = s0;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: for (i = n - 2; i > 0; i--) {  	s0 = *(smp++);  	*(res++) = s0 - 2 * s1 + s2;  	s2 = s1;  	s1 = s0;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: i = n - 2
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: *(res++) = s0 - 2 * s1 + s2;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: res [2] = smp [2];  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: res [2] = smp [2];  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: for (i = 3; i < n; i++) {  	res [i] = smp [i] - 3 * smp [i - 1] + 3 * smp [i - 2] - smp [i - 3];  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: for (i = 3; i < n; i++) {  	res [i] = smp [i] - 3 * smp [i - 1] + 3 * smp [i - 2] - smp [i - 3];  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: for (i = 3; i < n; i++) {  	res [i] = smp [i] - 3 * smp [i - 1] + 3 * smp [i - 2] - smp [i - 3];  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: for (i = 3; i < n; i++) {  	res [i] = smp [i] - 3 * smp [i - 1] + 3 * smp [i - 2] - smp [i - 3];  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: for (i = 3; i < n; i++) {  	res [i] = smp [i] - 3 * smp [i - 1] + 3 * smp [i - 2] - smp [i - 3];  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: i = 3
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: res [i] = smp [i] - 3 * smp [i - 1] + 3 * smp [i - 2] - smp [i - 3];  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: res [i] = smp [i] - 3 * smp [i - 1] + 3 * smp [i - 2] - smp [i - 3];  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: res [i] = smp [i] - 3 * smp [i - 1] + 3 * smp [i - 2] - smp [i - 3];  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: res [i] = smp [i] - 3 * smp [i - 1] + 3 * smp [i - 2] - smp [i - 3];  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: res [2] = smp [2];  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: res [2] = smp [2];  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: res [3] = smp [3];  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: res [3] = smp [3];  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: for (i = 4; i < n; i++) {  	res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: for (i = 4; i < n; i++) {  	res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: for (i = 4; i < n; i++) {  	res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: for (i = 4; i < n; i++) {  	res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: for (i = 4; i < n; i++) {  	res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: for (i = 4; i < n; i++) {  	res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: for (i = 4; i < n; i++) {  	res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: i = 4
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed,The following statement contains a magic number: res [i] = smp [i] - 4 * smp [i - 1] + 6 * smp [i - 2] - 4 * smp [i - 3] + smp [i - 4];  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,calc_lower_sums,The following statement contains a magic number: for (int i = pmax - 1; i >= pmin; i--) {  	for (int j = 0; j < (1 << i); j++) {  		sums [i * Flake.MAX_PARTITIONS + j] = sums [(i + 1) * Flake.MAX_PARTITIONS + 2 * j] + sums [(i + 1) * Flake.MAX_PARTITIONS + 2 * j + 1];  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,calc_lower_sums,The following statement contains a magic number: for (int i = pmax - 1; i >= pmin; i--) {  	for (int j = 0; j < (1 << i); j++) {  		sums [i * Flake.MAX_PARTITIONS + j] = sums [(i + 1) * Flake.MAX_PARTITIONS + 2 * j] + sums [(i + 1) * Flake.MAX_PARTITIONS + 2 * j + 1];  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,calc_lower_sums,The following statement contains a magic number: for (int j = 0; j < (1 << i); j++) {  	sums [i * Flake.MAX_PARTITIONS + j] = sums [(i + 1) * Flake.MAX_PARTITIONS + 2 * j] + sums [(i + 1) * Flake.MAX_PARTITIONS + 2 * j + 1];  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,calc_lower_sums,The following statement contains a magic number: for (int j = 0; j < (1 << i); j++) {  	sums [i * Flake.MAX_PARTITIONS + j] = sums [(i + 1) * Flake.MAX_PARTITIONS + 2 * j] + sums [(i + 1) * Flake.MAX_PARTITIONS + 2 * j + 1];  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,calc_lower_sums,The following statement contains a magic number: sums [i * Flake.MAX_PARTITIONS + j] = sums [(i + 1) * Flake.MAX_PARTITIONS + 2 * j] + sums [(i + 1) * Flake.MAX_PARTITIONS + 2 * j + 1];  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,calc_lower_sums,The following statement contains a magic number: sums [i * Flake.MAX_PARTITIONS + j] = sums [(i + 1) * Flake.MAX_PARTITIONS + 2 * j] + sums [(i + 1) * Flake.MAX_PARTITIONS + 2 * j + 1];  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,calc_rice_params,The following statement contains a magic number: for (uint i = 0; i < n; i++)  	udata [i] = (uint)((data [i] << 1) ^ (data [i] >> 31));  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,calc_rice_params,The following statement contains a magic number: udata [i] = (uint)((data [i] << 1) ^ (data [i] >> 31));  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,calc_rice_params,The following statement contains a magic number: if ((n >> pmax) == 18)  	calc_sums18 (pmin' pmax' udata' n' pred_order' sums + pmax * Flake.MAX_PARTITIONS);  else if ((n >> pmax) == 16)  	calc_sums16 (pmin' pmax' udata' n' pred_order' sums + pmax * Flake.MAX_PARTITIONS);  else  	calc_sums (pmin' pmax' udata' n' pred_order' sums + pmax * Flake.MAX_PARTITIONS);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,calc_rice_params,The following statement contains a magic number: if ((n >> pmax) == 18)  	calc_sums18 (pmin' pmax' udata' n' pred_order' sums + pmax * Flake.MAX_PARTITIONS);  else if ((n >> pmax) == 16)  	calc_sums16 (pmin' pmax' udata' n' pred_order' sums + pmax * Flake.MAX_PARTITIONS);  else  	calc_sums (pmin' pmax' udata' n' pred_order' sums + pmax * Flake.MAX_PARTITIONS);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,calc_rice_params,The following statement contains a magic number: if ((n >> pmax) == 16)  	calc_sums16 (pmin' pmax' udata' n' pred_order' sums + pmax * Flake.MAX_PARTITIONS);  else  	calc_sums (pmin' pmax' udata' n' pred_order' sums + pmax * Flake.MAX_PARTITIONS);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,calc_rice_params,The following statement contains a magic number: for (int i = pmin; i <= pmax; i++) {  	int method = bps > 16 ? 1 : 0;  	uint bits = calc_optimal_rice_params (i' parm + i * Flake.MAX_PARTITIONS' sums + i * Flake.MAX_PARTITIONS' n' pred_order' ref method);  	if (bits <= opt_bits) {  		opt_bits = bits;  		opt_porder = i;  		opt_method = method;  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 192)  	lpc_precision = 7U;  else if (frame.blocksize <= 384)  	lpc_precision = 8U;  else if (frame.blocksize <= 576)  	lpc_precision = 9U;  else if (frame.blocksize <= 1152)  	lpc_precision = 10U;  else if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 192)  	lpc_precision = 7U;  else if (frame.blocksize <= 384)  	lpc_precision = 8U;  else if (frame.blocksize <= 576)  	lpc_precision = 9U;  else if (frame.blocksize <= 1152)  	lpc_precision = 10U;  else if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 192)  	lpc_precision = 7U;  else if (frame.blocksize <= 384)  	lpc_precision = 8U;  else if (frame.blocksize <= 576)  	lpc_precision = 9U;  else if (frame.blocksize <= 1152)  	lpc_precision = 10U;  else if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 192)  	lpc_precision = 7U;  else if (frame.blocksize <= 384)  	lpc_precision = 8U;  else if (frame.blocksize <= 576)  	lpc_precision = 9U;  else if (frame.blocksize <= 1152)  	lpc_precision = 10U;  else if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 192)  	lpc_precision = 7U;  else if (frame.blocksize <= 384)  	lpc_precision = 8U;  else if (frame.blocksize <= 576)  	lpc_precision = 9U;  else if (frame.blocksize <= 1152)  	lpc_precision = 10U;  else if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 192)  	lpc_precision = 7U;  else if (frame.blocksize <= 384)  	lpc_precision = 8U;  else if (frame.blocksize <= 576)  	lpc_precision = 9U;  else if (frame.blocksize <= 1152)  	lpc_precision = 10U;  else if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 192)  	lpc_precision = 7U;  else if (frame.blocksize <= 384)  	lpc_precision = 8U;  else if (frame.blocksize <= 576)  	lpc_precision = 9U;  else if (frame.blocksize <= 1152)  	lpc_precision = 10U;  else if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 192)  	lpc_precision = 7U;  else if (frame.blocksize <= 384)  	lpc_precision = 8U;  else if (frame.blocksize <= 576)  	lpc_precision = 9U;  else if (frame.blocksize <= 1152)  	lpc_precision = 10U;  else if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 192)  	lpc_precision = 7U;  else if (frame.blocksize <= 384)  	lpc_precision = 8U;  else if (frame.blocksize <= 576)  	lpc_precision = 9U;  else if (frame.blocksize <= 1152)  	lpc_precision = 10U;  else if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 384)  	lpc_precision = 8U;  else if (frame.blocksize <= 576)  	lpc_precision = 9U;  else if (frame.blocksize <= 1152)  	lpc_precision = 10U;  else if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 384)  	lpc_precision = 8U;  else if (frame.blocksize <= 576)  	lpc_precision = 9U;  else if (frame.blocksize <= 1152)  	lpc_precision = 10U;  else if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 384)  	lpc_precision = 8U;  else if (frame.blocksize <= 576)  	lpc_precision = 9U;  else if (frame.blocksize <= 1152)  	lpc_precision = 10U;  else if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 384)  	lpc_precision = 8U;  else if (frame.blocksize <= 576)  	lpc_precision = 9U;  else if (frame.blocksize <= 1152)  	lpc_precision = 10U;  else if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 384)  	lpc_precision = 8U;  else if (frame.blocksize <= 576)  	lpc_precision = 9U;  else if (frame.blocksize <= 1152)  	lpc_precision = 10U;  else if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 384)  	lpc_precision = 8U;  else if (frame.blocksize <= 576)  	lpc_precision = 9U;  else if (frame.blocksize <= 1152)  	lpc_precision = 10U;  else if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 384)  	lpc_precision = 8U;  else if (frame.blocksize <= 576)  	lpc_precision = 9U;  else if (frame.blocksize <= 1152)  	lpc_precision = 10U;  else if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 384)  	lpc_precision = 8U;  else if (frame.blocksize <= 576)  	lpc_precision = 9U;  else if (frame.blocksize <= 1152)  	lpc_precision = 10U;  else if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 576)  	lpc_precision = 9U;  else if (frame.blocksize <= 1152)  	lpc_precision = 10U;  else if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 576)  	lpc_precision = 9U;  else if (frame.blocksize <= 1152)  	lpc_precision = 10U;  else if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 576)  	lpc_precision = 9U;  else if (frame.blocksize <= 1152)  	lpc_precision = 10U;  else if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 576)  	lpc_precision = 9U;  else if (frame.blocksize <= 1152)  	lpc_precision = 10U;  else if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 576)  	lpc_precision = 9U;  else if (frame.blocksize <= 1152)  	lpc_precision = 10U;  else if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 576)  	lpc_precision = 9U;  else if (frame.blocksize <= 1152)  	lpc_precision = 10U;  else if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 576)  	lpc_precision = 9U;  else if (frame.blocksize <= 1152)  	lpc_precision = 10U;  else if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 1152)  	lpc_precision = 10U;  else if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 1152)  	lpc_precision = 10U;  else if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 1152)  	lpc_precision = 10U;  else if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 1152)  	lpc_precision = 10U;  else if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 1152)  	lpc_precision = 10U;  else if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 1152)  	lpc_precision = 10U;  else if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 2304)  	lpc_precision = 11U;  else if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 4608)  	lpc_precision = 12U;  else if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 8192)  	lpc_precision = 13U;  else if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.blocksize <= 16384)  	lpc_precision = 14U;  else  	lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: lpc_precision = 15;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: for (int i_precision = eparams.lpc_min_precision_search; i_precision <= eparams.lpc_max_precision_search && lpc_precision + i_precision < 16; i_precision++)  	// check if we already calculated with this order' window and precision  	if ((frame.subframes [ch].lpc_ctx [iWindow].done_lpcs [i_precision] & (1U << (order - 1))) == 0) {  		frame.subframes [ch].lpc_ctx [iWindow].done_lpcs [i_precision] |= (1U << (order - 1));  		uint cbits = lpc_precision + (uint)i_precision;  		frame.current.type = SubframeType.LPC;  		frame.current.order = order;  		frame.current.window = iWindow;  		fixed (int* coefs = frame.current.coefs) {  			lpc.quantize_lpc_coefs (lpcs + (frame.current.order - 1) * lpc.MAX_LPC_ORDER' frame.current.order' cbits' coefs' out frame.current.shift' 15' 0);  			if (frame.current.shift < 0 || frame.current.shift > 15)  				throw new Exception ("negative shift");  			ulong csum = 0;  			for (int i = frame.current.order; i > 0; i--)  				csum += (ulong)Math.Abs (coefs [i - 1]);  			if ((csum << frame.subframes [ch].obits) >= 1UL << 32)  				lpc.encode_residual_long (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  			else  				lpc.encode_residual (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  		}  		int pmax = get_max_p_order (eparams.max_partition_order' frame.blocksize' frame.current.order);  		int pmin = Math.Min (eparams.min_partition_order' pmax);  		uint best_size = calc_rice_params (frame.current.rc' pmin' pmax' frame.current.residual' (uint)frame.blocksize' (uint)frame.current.order' PCM.BitsPerSample);  		// not working  		//for (int o = 1; o <= frame.current.order; o++)  		//{  		//    if (frame.current.coefs[o - 1] > -(1 << frame.current.shift))  		//    {  		//        for (int i = o; i < frame.blocksize; i++)  		//            frame.current.residual[i] += frame.subframes[ch].samples[i - o] >> frame.current.shift;  		//        frame.current.coefs[o - 1]--;  		//        uint new_size = calc_rice_params(ref frame.current.rc' pmin' pmax' frame.current.residual' (uint)frame.blocksize' (uint)frame.current.order);  		//        if (new_size > best_size)  		//        {  		//            for (int i = o; i < frame.blocksize; i++)  		//                frame.current.residual[i] -= frame.subframes[ch].samples[i - o] >> frame.current.shift;  		//            frame.current.coefs[o - 1]++;  		//        }  		//    }  		//}  		frame.current.size = (uint)(frame.current.order * frame.subframes [ch].obits + 4 + 5 + frame.current.order * (int)cbits + 6 + (int)best_size);  		frame.ChooseBestSubframe (ch);  	}  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: for (int i_precision = eparams.lpc_min_precision_search; i_precision <= eparams.lpc_max_precision_search && lpc_precision + i_precision < 16; i_precision++)  	// check if we already calculated with this order' window and precision  	if ((frame.subframes [ch].lpc_ctx [iWindow].done_lpcs [i_precision] & (1U << (order - 1))) == 0) {  		frame.subframes [ch].lpc_ctx [iWindow].done_lpcs [i_precision] |= (1U << (order - 1));  		uint cbits = lpc_precision + (uint)i_precision;  		frame.current.type = SubframeType.LPC;  		frame.current.order = order;  		frame.current.window = iWindow;  		fixed (int* coefs = frame.current.coefs) {  			lpc.quantize_lpc_coefs (lpcs + (frame.current.order - 1) * lpc.MAX_LPC_ORDER' frame.current.order' cbits' coefs' out frame.current.shift' 15' 0);  			if (frame.current.shift < 0 || frame.current.shift > 15)  				throw new Exception ("negative shift");  			ulong csum = 0;  			for (int i = frame.current.order; i > 0; i--)  				csum += (ulong)Math.Abs (coefs [i - 1]);  			if ((csum << frame.subframes [ch].obits) >= 1UL << 32)  				lpc.encode_residual_long (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  			else  				lpc.encode_residual (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  		}  		int pmax = get_max_p_order (eparams.max_partition_order' frame.blocksize' frame.current.order);  		int pmin = Math.Min (eparams.min_partition_order' pmax);  		uint best_size = calc_rice_params (frame.current.rc' pmin' pmax' frame.current.residual' (uint)frame.blocksize' (uint)frame.current.order' PCM.BitsPerSample);  		// not working  		//for (int o = 1; o <= frame.current.order; o++)  		//{  		//    if (frame.current.coefs[o - 1] > -(1 << frame.current.shift))  		//    {  		//        for (int i = o; i < frame.blocksize; i++)  		//            frame.current.residual[i] += frame.subframes[ch].samples[i - o] >> frame.current.shift;  		//        frame.current.coefs[o - 1]--;  		//        uint new_size = calc_rice_params(ref frame.current.rc' pmin' pmax' frame.current.residual' (uint)frame.blocksize' (uint)frame.current.order);  		//        if (new_size > best_size)  		//        {  		//            for (int i = o; i < frame.blocksize; i++)  		//                frame.current.residual[i] -= frame.subframes[ch].samples[i - o] >> frame.current.shift;  		//            frame.current.coefs[o - 1]++;  		//        }  		//    }  		//}  		frame.current.size = (uint)(frame.current.order * frame.subframes [ch].obits + 4 + 5 + frame.current.order * (int)cbits + 6 + (int)best_size);  		frame.ChooseBestSubframe (ch);  	}  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: for (int i_precision = eparams.lpc_min_precision_search; i_precision <= eparams.lpc_max_precision_search && lpc_precision + i_precision < 16; i_precision++)  	// check if we already calculated with this order' window and precision  	if ((frame.subframes [ch].lpc_ctx [iWindow].done_lpcs [i_precision] & (1U << (order - 1))) == 0) {  		frame.subframes [ch].lpc_ctx [iWindow].done_lpcs [i_precision] |= (1U << (order - 1));  		uint cbits = lpc_precision + (uint)i_precision;  		frame.current.type = SubframeType.LPC;  		frame.current.order = order;  		frame.current.window = iWindow;  		fixed (int* coefs = frame.current.coefs) {  			lpc.quantize_lpc_coefs (lpcs + (frame.current.order - 1) * lpc.MAX_LPC_ORDER' frame.current.order' cbits' coefs' out frame.current.shift' 15' 0);  			if (frame.current.shift < 0 || frame.current.shift > 15)  				throw new Exception ("negative shift");  			ulong csum = 0;  			for (int i = frame.current.order; i > 0; i--)  				csum += (ulong)Math.Abs (coefs [i - 1]);  			if ((csum << frame.subframes [ch].obits) >= 1UL << 32)  				lpc.encode_residual_long (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  			else  				lpc.encode_residual (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  		}  		int pmax = get_max_p_order (eparams.max_partition_order' frame.blocksize' frame.current.order);  		int pmin = Math.Min (eparams.min_partition_order' pmax);  		uint best_size = calc_rice_params (frame.current.rc' pmin' pmax' frame.current.residual' (uint)frame.blocksize' (uint)frame.current.order' PCM.BitsPerSample);  		// not working  		//for (int o = 1; o <= frame.current.order; o++)  		//{  		//    if (frame.current.coefs[o - 1] > -(1 << frame.current.shift))  		//    {  		//        for (int i = o; i < frame.blocksize; i++)  		//            frame.current.residual[i] += frame.subframes[ch].samples[i - o] >> frame.current.shift;  		//        frame.current.coefs[o - 1]--;  		//        uint new_size = calc_rice_params(ref frame.current.rc' pmin' pmax' frame.current.residual' (uint)frame.blocksize' (uint)frame.current.order);  		//        if (new_size > best_size)  		//        {  		//            for (int i = o; i < frame.blocksize; i++)  		//                frame.current.residual[i] -= frame.subframes[ch].samples[i - o] >> frame.current.shift;  		//            frame.current.coefs[o - 1]++;  		//        }  		//    }  		//}  		frame.current.size = (uint)(frame.current.order * frame.subframes [ch].obits + 4 + 5 + frame.current.order * (int)cbits + 6 + (int)best_size);  		frame.ChooseBestSubframe (ch);  	}  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: for (int i_precision = eparams.lpc_min_precision_search; i_precision <= eparams.lpc_max_precision_search && lpc_precision + i_precision < 16; i_precision++)  	// check if we already calculated with this order' window and precision  	if ((frame.subframes [ch].lpc_ctx [iWindow].done_lpcs [i_precision] & (1U << (order - 1))) == 0) {  		frame.subframes [ch].lpc_ctx [iWindow].done_lpcs [i_precision] |= (1U << (order - 1));  		uint cbits = lpc_precision + (uint)i_precision;  		frame.current.type = SubframeType.LPC;  		frame.current.order = order;  		frame.current.window = iWindow;  		fixed (int* coefs = frame.current.coefs) {  			lpc.quantize_lpc_coefs (lpcs + (frame.current.order - 1) * lpc.MAX_LPC_ORDER' frame.current.order' cbits' coefs' out frame.current.shift' 15' 0);  			if (frame.current.shift < 0 || frame.current.shift > 15)  				throw new Exception ("negative shift");  			ulong csum = 0;  			for (int i = frame.current.order; i > 0; i--)  				csum += (ulong)Math.Abs (coefs [i - 1]);  			if ((csum << frame.subframes [ch].obits) >= 1UL << 32)  				lpc.encode_residual_long (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  			else  				lpc.encode_residual (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  		}  		int pmax = get_max_p_order (eparams.max_partition_order' frame.blocksize' frame.current.order);  		int pmin = Math.Min (eparams.min_partition_order' pmax);  		uint best_size = calc_rice_params (frame.current.rc' pmin' pmax' frame.current.residual' (uint)frame.blocksize' (uint)frame.current.order' PCM.BitsPerSample);  		// not working  		//for (int o = 1; o <= frame.current.order; o++)  		//{  		//    if (frame.current.coefs[o - 1] > -(1 << frame.current.shift))  		//    {  		//        for (int i = o; i < frame.blocksize; i++)  		//            frame.current.residual[i] += frame.subframes[ch].samples[i - o] >> frame.current.shift;  		//        frame.current.coefs[o - 1]--;  		//        uint new_size = calc_rice_params(ref frame.current.rc' pmin' pmax' frame.current.residual' (uint)frame.blocksize' (uint)frame.current.order);  		//        if (new_size > best_size)  		//        {  		//            for (int i = o; i < frame.blocksize; i++)  		//                frame.current.residual[i] -= frame.subframes[ch].samples[i - o] >> frame.current.shift;  		//            frame.current.coefs[o - 1]++;  		//        }  		//    }  		//}  		frame.current.size = (uint)(frame.current.order * frame.subframes [ch].obits + 4 + 5 + frame.current.order * (int)cbits + 6 + (int)best_size);  		frame.ChooseBestSubframe (ch);  	}  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: for (int i_precision = eparams.lpc_min_precision_search; i_precision <= eparams.lpc_max_precision_search && lpc_precision + i_precision < 16; i_precision++)  	// check if we already calculated with this order' window and precision  	if ((frame.subframes [ch].lpc_ctx [iWindow].done_lpcs [i_precision] & (1U << (order - 1))) == 0) {  		frame.subframes [ch].lpc_ctx [iWindow].done_lpcs [i_precision] |= (1U << (order - 1));  		uint cbits = lpc_precision + (uint)i_precision;  		frame.current.type = SubframeType.LPC;  		frame.current.order = order;  		frame.current.window = iWindow;  		fixed (int* coefs = frame.current.coefs) {  			lpc.quantize_lpc_coefs (lpcs + (frame.current.order - 1) * lpc.MAX_LPC_ORDER' frame.current.order' cbits' coefs' out frame.current.shift' 15' 0);  			if (frame.current.shift < 0 || frame.current.shift > 15)  				throw new Exception ("negative shift");  			ulong csum = 0;  			for (int i = frame.current.order; i > 0; i--)  				csum += (ulong)Math.Abs (coefs [i - 1]);  			if ((csum << frame.subframes [ch].obits) >= 1UL << 32)  				lpc.encode_residual_long (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  			else  				lpc.encode_residual (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  		}  		int pmax = get_max_p_order (eparams.max_partition_order' frame.blocksize' frame.current.order);  		int pmin = Math.Min (eparams.min_partition_order' pmax);  		uint best_size = calc_rice_params (frame.current.rc' pmin' pmax' frame.current.residual' (uint)frame.blocksize' (uint)frame.current.order' PCM.BitsPerSample);  		// not working  		//for (int o = 1; o <= frame.current.order; o++)  		//{  		//    if (frame.current.coefs[o - 1] > -(1 << frame.current.shift))  		//    {  		//        for (int i = o; i < frame.blocksize; i++)  		//            frame.current.residual[i] += frame.subframes[ch].samples[i - o] >> frame.current.shift;  		//        frame.current.coefs[o - 1]--;  		//        uint new_size = calc_rice_params(ref frame.current.rc' pmin' pmax' frame.current.residual' (uint)frame.blocksize' (uint)frame.current.order);  		//        if (new_size > best_size)  		//        {  		//            for (int i = o; i < frame.blocksize; i++)  		//                frame.current.residual[i] -= frame.subframes[ch].samples[i - o] >> frame.current.shift;  		//            frame.current.coefs[o - 1]++;  		//        }  		//    }  		//}  		frame.current.size = (uint)(frame.current.order * frame.subframes [ch].obits + 4 + 5 + frame.current.order * (int)cbits + 6 + (int)best_size);  		frame.ChooseBestSubframe (ch);  	}  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: for (int i_precision = eparams.lpc_min_precision_search; i_precision <= eparams.lpc_max_precision_search && lpc_precision + i_precision < 16; i_precision++)  	// check if we already calculated with this order' window and precision  	if ((frame.subframes [ch].lpc_ctx [iWindow].done_lpcs [i_precision] & (1U << (order - 1))) == 0) {  		frame.subframes [ch].lpc_ctx [iWindow].done_lpcs [i_precision] |= (1U << (order - 1));  		uint cbits = lpc_precision + (uint)i_precision;  		frame.current.type = SubframeType.LPC;  		frame.current.order = order;  		frame.current.window = iWindow;  		fixed (int* coefs = frame.current.coefs) {  			lpc.quantize_lpc_coefs (lpcs + (frame.current.order - 1) * lpc.MAX_LPC_ORDER' frame.current.order' cbits' coefs' out frame.current.shift' 15' 0);  			if (frame.current.shift < 0 || frame.current.shift > 15)  				throw new Exception ("negative shift");  			ulong csum = 0;  			for (int i = frame.current.order; i > 0; i--)  				csum += (ulong)Math.Abs (coefs [i - 1]);  			if ((csum << frame.subframes [ch].obits) >= 1UL << 32)  				lpc.encode_residual_long (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  			else  				lpc.encode_residual (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  		}  		int pmax = get_max_p_order (eparams.max_partition_order' frame.blocksize' frame.current.order);  		int pmin = Math.Min (eparams.min_partition_order' pmax);  		uint best_size = calc_rice_params (frame.current.rc' pmin' pmax' frame.current.residual' (uint)frame.blocksize' (uint)frame.current.order' PCM.BitsPerSample);  		// not working  		//for (int o = 1; o <= frame.current.order; o++)  		//{  		//    if (frame.current.coefs[o - 1] > -(1 << frame.current.shift))  		//    {  		//        for (int i = o; i < frame.blocksize; i++)  		//            frame.current.residual[i] += frame.subframes[ch].samples[i - o] >> frame.current.shift;  		//        frame.current.coefs[o - 1]--;  		//        uint new_size = calc_rice_params(ref frame.current.rc' pmin' pmax' frame.current.residual' (uint)frame.blocksize' (uint)frame.current.order);  		//        if (new_size > best_size)  		//        {  		//            for (int i = o; i < frame.blocksize; i++)  		//                frame.current.residual[i] -= frame.subframes[ch].samples[i - o] >> frame.current.shift;  		//            frame.current.coefs[o - 1]++;  		//        }  		//    }  		//}  		frame.current.size = (uint)(frame.current.order * frame.subframes [ch].obits + 4 + 5 + frame.current.order * (int)cbits + 6 + (int)best_size);  		frame.ChooseBestSubframe (ch);  	}  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: for (int i_precision = eparams.lpc_min_precision_search; i_precision <= eparams.lpc_max_precision_search && lpc_precision + i_precision < 16; i_precision++)  	// check if we already calculated with this order' window and precision  	if ((frame.subframes [ch].lpc_ctx [iWindow].done_lpcs [i_precision] & (1U << (order - 1))) == 0) {  		frame.subframes [ch].lpc_ctx [iWindow].done_lpcs [i_precision] |= (1U << (order - 1));  		uint cbits = lpc_precision + (uint)i_precision;  		frame.current.type = SubframeType.LPC;  		frame.current.order = order;  		frame.current.window = iWindow;  		fixed (int* coefs = frame.current.coefs) {  			lpc.quantize_lpc_coefs (lpcs + (frame.current.order - 1) * lpc.MAX_LPC_ORDER' frame.current.order' cbits' coefs' out frame.current.shift' 15' 0);  			if (frame.current.shift < 0 || frame.current.shift > 15)  				throw new Exception ("negative shift");  			ulong csum = 0;  			for (int i = frame.current.order; i > 0; i--)  				csum += (ulong)Math.Abs (coefs [i - 1]);  			if ((csum << frame.subframes [ch].obits) >= 1UL << 32)  				lpc.encode_residual_long (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  			else  				lpc.encode_residual (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  		}  		int pmax = get_max_p_order (eparams.max_partition_order' frame.blocksize' frame.current.order);  		int pmin = Math.Min (eparams.min_partition_order' pmax);  		uint best_size = calc_rice_params (frame.current.rc' pmin' pmax' frame.current.residual' (uint)frame.blocksize' (uint)frame.current.order' PCM.BitsPerSample);  		// not working  		//for (int o = 1; o <= frame.current.order; o++)  		//{  		//    if (frame.current.coefs[o - 1] > -(1 << frame.current.shift))  		//    {  		//        for (int i = o; i < frame.blocksize; i++)  		//            frame.current.residual[i] += frame.subframes[ch].samples[i - o] >> frame.current.shift;  		//        frame.current.coefs[o - 1]--;  		//        uint new_size = calc_rice_params(ref frame.current.rc' pmin' pmax' frame.current.residual' (uint)frame.blocksize' (uint)frame.current.order);  		//        if (new_size > best_size)  		//        {  		//            for (int i = o; i < frame.blocksize; i++)  		//                frame.current.residual[i] -= frame.subframes[ch].samples[i - o] >> frame.current.shift;  		//            frame.current.coefs[o - 1]++;  		//        }  		//    }  		//}  		frame.current.size = (uint)(frame.current.order * frame.subframes [ch].obits + 4 + 5 + frame.current.order * (int)cbits + 6 + (int)best_size);  		frame.ChooseBestSubframe (ch);  	}  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if ((frame.subframes [ch].lpc_ctx [iWindow].done_lpcs [i_precision] & (1U << (order - 1))) == 0) {  	frame.subframes [ch].lpc_ctx [iWindow].done_lpcs [i_precision] |= (1U << (order - 1));  	uint cbits = lpc_precision + (uint)i_precision;  	frame.current.type = SubframeType.LPC;  	frame.current.order = order;  	frame.current.window = iWindow;  	fixed (int* coefs = frame.current.coefs) {  		lpc.quantize_lpc_coefs (lpcs + (frame.current.order - 1) * lpc.MAX_LPC_ORDER' frame.current.order' cbits' coefs' out frame.current.shift' 15' 0);  		if (frame.current.shift < 0 || frame.current.shift > 15)  			throw new Exception ("negative shift");  		ulong csum = 0;  		for (int i = frame.current.order; i > 0; i--)  			csum += (ulong)Math.Abs (coefs [i - 1]);  		if ((csum << frame.subframes [ch].obits) >= 1UL << 32)  			lpc.encode_residual_long (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  		else  			lpc.encode_residual (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  	}  	int pmax = get_max_p_order (eparams.max_partition_order' frame.blocksize' frame.current.order);  	int pmin = Math.Min (eparams.min_partition_order' pmax);  	uint best_size = calc_rice_params (frame.current.rc' pmin' pmax' frame.current.residual' (uint)frame.blocksize' (uint)frame.current.order' PCM.BitsPerSample);  	// not working  	//for (int o = 1; o <= frame.current.order; o++)  	//{  	//    if (frame.current.coefs[o - 1] > -(1 << frame.current.shift))  	//    {  	//        for (int i = o; i < frame.blocksize; i++)  	//            frame.current.residual[i] += frame.subframes[ch].samples[i - o] >> frame.current.shift;  	//        frame.current.coefs[o - 1]--;  	//        uint new_size = calc_rice_params(ref frame.current.rc' pmin' pmax' frame.current.residual' (uint)frame.blocksize' (uint)frame.current.order);  	//        if (new_size > best_size)  	//        {  	//            for (int i = o; i < frame.blocksize; i++)  	//                frame.current.residual[i] -= frame.subframes[ch].samples[i - o] >> frame.current.shift;  	//            frame.current.coefs[o - 1]++;  	//        }  	//    }  	//}  	frame.current.size = (uint)(frame.current.order * frame.subframes [ch].obits + 4 + 5 + frame.current.order * (int)cbits + 6 + (int)best_size);  	frame.ChooseBestSubframe (ch);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if ((frame.subframes [ch].lpc_ctx [iWindow].done_lpcs [i_precision] & (1U << (order - 1))) == 0) {  	frame.subframes [ch].lpc_ctx [iWindow].done_lpcs [i_precision] |= (1U << (order - 1));  	uint cbits = lpc_precision + (uint)i_precision;  	frame.current.type = SubframeType.LPC;  	frame.current.order = order;  	frame.current.window = iWindow;  	fixed (int* coefs = frame.current.coefs) {  		lpc.quantize_lpc_coefs (lpcs + (frame.current.order - 1) * lpc.MAX_LPC_ORDER' frame.current.order' cbits' coefs' out frame.current.shift' 15' 0);  		if (frame.current.shift < 0 || frame.current.shift > 15)  			throw new Exception ("negative shift");  		ulong csum = 0;  		for (int i = frame.current.order; i > 0; i--)  			csum += (ulong)Math.Abs (coefs [i - 1]);  		if ((csum << frame.subframes [ch].obits) >= 1UL << 32)  			lpc.encode_residual_long (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  		else  			lpc.encode_residual (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  	}  	int pmax = get_max_p_order (eparams.max_partition_order' frame.blocksize' frame.current.order);  	int pmin = Math.Min (eparams.min_partition_order' pmax);  	uint best_size = calc_rice_params (frame.current.rc' pmin' pmax' frame.current.residual' (uint)frame.blocksize' (uint)frame.current.order' PCM.BitsPerSample);  	// not working  	//for (int o = 1; o <= frame.current.order; o++)  	//{  	//    if (frame.current.coefs[o - 1] > -(1 << frame.current.shift))  	//    {  	//        for (int i = o; i < frame.blocksize; i++)  	//            frame.current.residual[i] += frame.subframes[ch].samples[i - o] >> frame.current.shift;  	//        frame.current.coefs[o - 1]--;  	//        uint new_size = calc_rice_params(ref frame.current.rc' pmin' pmax' frame.current.residual' (uint)frame.blocksize' (uint)frame.current.order);  	//        if (new_size > best_size)  	//        {  	//            for (int i = o; i < frame.blocksize; i++)  	//                frame.current.residual[i] -= frame.subframes[ch].samples[i - o] >> frame.current.shift;  	//            frame.current.coefs[o - 1]++;  	//        }  	//    }  	//}  	frame.current.size = (uint)(frame.current.order * frame.subframes [ch].obits + 4 + 5 + frame.current.order * (int)cbits + 6 + (int)best_size);  	frame.ChooseBestSubframe (ch);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if ((frame.subframes [ch].lpc_ctx [iWindow].done_lpcs [i_precision] & (1U << (order - 1))) == 0) {  	frame.subframes [ch].lpc_ctx [iWindow].done_lpcs [i_precision] |= (1U << (order - 1));  	uint cbits = lpc_precision + (uint)i_precision;  	frame.current.type = SubframeType.LPC;  	frame.current.order = order;  	frame.current.window = iWindow;  	fixed (int* coefs = frame.current.coefs) {  		lpc.quantize_lpc_coefs (lpcs + (frame.current.order - 1) * lpc.MAX_LPC_ORDER' frame.current.order' cbits' coefs' out frame.current.shift' 15' 0);  		if (frame.current.shift < 0 || frame.current.shift > 15)  			throw new Exception ("negative shift");  		ulong csum = 0;  		for (int i = frame.current.order; i > 0; i--)  			csum += (ulong)Math.Abs (coefs [i - 1]);  		if ((csum << frame.subframes [ch].obits) >= 1UL << 32)  			lpc.encode_residual_long (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  		else  			lpc.encode_residual (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  	}  	int pmax = get_max_p_order (eparams.max_partition_order' frame.blocksize' frame.current.order);  	int pmin = Math.Min (eparams.min_partition_order' pmax);  	uint best_size = calc_rice_params (frame.current.rc' pmin' pmax' frame.current.residual' (uint)frame.blocksize' (uint)frame.current.order' PCM.BitsPerSample);  	// not working  	//for (int o = 1; o <= frame.current.order; o++)  	//{  	//    if (frame.current.coefs[o - 1] > -(1 << frame.current.shift))  	//    {  	//        for (int i = o; i < frame.blocksize; i++)  	//            frame.current.residual[i] += frame.subframes[ch].samples[i - o] >> frame.current.shift;  	//        frame.current.coefs[o - 1]--;  	//        uint new_size = calc_rice_params(ref frame.current.rc' pmin' pmax' frame.current.residual' (uint)frame.blocksize' (uint)frame.current.order);  	//        if (new_size > best_size)  	//        {  	//            for (int i = o; i < frame.blocksize; i++)  	//                frame.current.residual[i] -= frame.subframes[ch].samples[i - o] >> frame.current.shift;  	//            frame.current.coefs[o - 1]++;  	//        }  	//    }  	//}  	frame.current.size = (uint)(frame.current.order * frame.subframes [ch].obits + 4 + 5 + frame.current.order * (int)cbits + 6 + (int)best_size);  	frame.ChooseBestSubframe (ch);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if ((frame.subframes [ch].lpc_ctx [iWindow].done_lpcs [i_precision] & (1U << (order - 1))) == 0) {  	frame.subframes [ch].lpc_ctx [iWindow].done_lpcs [i_precision] |= (1U << (order - 1));  	uint cbits = lpc_precision + (uint)i_precision;  	frame.current.type = SubframeType.LPC;  	frame.current.order = order;  	frame.current.window = iWindow;  	fixed (int* coefs = frame.current.coefs) {  		lpc.quantize_lpc_coefs (lpcs + (frame.current.order - 1) * lpc.MAX_LPC_ORDER' frame.current.order' cbits' coefs' out frame.current.shift' 15' 0);  		if (frame.current.shift < 0 || frame.current.shift > 15)  			throw new Exception ("negative shift");  		ulong csum = 0;  		for (int i = frame.current.order; i > 0; i--)  			csum += (ulong)Math.Abs (coefs [i - 1]);  		if ((csum << frame.subframes [ch].obits) >= 1UL << 32)  			lpc.encode_residual_long (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  		else  			lpc.encode_residual (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  	}  	int pmax = get_max_p_order (eparams.max_partition_order' frame.blocksize' frame.current.order);  	int pmin = Math.Min (eparams.min_partition_order' pmax);  	uint best_size = calc_rice_params (frame.current.rc' pmin' pmax' frame.current.residual' (uint)frame.blocksize' (uint)frame.current.order' PCM.BitsPerSample);  	// not working  	//for (int o = 1; o <= frame.current.order; o++)  	//{  	//    if (frame.current.coefs[o - 1] > -(1 << frame.current.shift))  	//    {  	//        for (int i = o; i < frame.blocksize; i++)  	//            frame.current.residual[i] += frame.subframes[ch].samples[i - o] >> frame.current.shift;  	//        frame.current.coefs[o - 1]--;  	//        uint new_size = calc_rice_params(ref frame.current.rc' pmin' pmax' frame.current.residual' (uint)frame.blocksize' (uint)frame.current.order);  	//        if (new_size > best_size)  	//        {  	//            for (int i = o; i < frame.blocksize; i++)  	//                frame.current.residual[i] -= frame.subframes[ch].samples[i - o] >> frame.current.shift;  	//            frame.current.coefs[o - 1]++;  	//        }  	//    }  	//}  	frame.current.size = (uint)(frame.current.order * frame.subframes [ch].obits + 4 + 5 + frame.current.order * (int)cbits + 6 + (int)best_size);  	frame.ChooseBestSubframe (ch);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if ((frame.subframes [ch].lpc_ctx [iWindow].done_lpcs [i_precision] & (1U << (order - 1))) == 0) {  	frame.subframes [ch].lpc_ctx [iWindow].done_lpcs [i_precision] |= (1U << (order - 1));  	uint cbits = lpc_precision + (uint)i_precision;  	frame.current.type = SubframeType.LPC;  	frame.current.order = order;  	frame.current.window = iWindow;  	fixed (int* coefs = frame.current.coefs) {  		lpc.quantize_lpc_coefs (lpcs + (frame.current.order - 1) * lpc.MAX_LPC_ORDER' frame.current.order' cbits' coefs' out frame.current.shift' 15' 0);  		if (frame.current.shift < 0 || frame.current.shift > 15)  			throw new Exception ("negative shift");  		ulong csum = 0;  		for (int i = frame.current.order; i > 0; i--)  			csum += (ulong)Math.Abs (coefs [i - 1]);  		if ((csum << frame.subframes [ch].obits) >= 1UL << 32)  			lpc.encode_residual_long (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  		else  			lpc.encode_residual (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  	}  	int pmax = get_max_p_order (eparams.max_partition_order' frame.blocksize' frame.current.order);  	int pmin = Math.Min (eparams.min_partition_order' pmax);  	uint best_size = calc_rice_params (frame.current.rc' pmin' pmax' frame.current.residual' (uint)frame.blocksize' (uint)frame.current.order' PCM.BitsPerSample);  	// not working  	//for (int o = 1; o <= frame.current.order; o++)  	//{  	//    if (frame.current.coefs[o - 1] > -(1 << frame.current.shift))  	//    {  	//        for (int i = o; i < frame.blocksize; i++)  	//            frame.current.residual[i] += frame.subframes[ch].samples[i - o] >> frame.current.shift;  	//        frame.current.coefs[o - 1]--;  	//        uint new_size = calc_rice_params(ref frame.current.rc' pmin' pmax' frame.current.residual' (uint)frame.blocksize' (uint)frame.current.order);  	//        if (new_size > best_size)  	//        {  	//            for (int i = o; i < frame.blocksize; i++)  	//                frame.current.residual[i] -= frame.subframes[ch].samples[i - o] >> frame.current.shift;  	//            frame.current.coefs[o - 1]++;  	//        }  	//    }  	//}  	frame.current.size = (uint)(frame.current.order * frame.subframes [ch].obits + 4 + 5 + frame.current.order * (int)cbits + 6 + (int)best_size);  	frame.ChooseBestSubframe (ch);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if ((frame.subframes [ch].lpc_ctx [iWindow].done_lpcs [i_precision] & (1U << (order - 1))) == 0) {  	frame.subframes [ch].lpc_ctx [iWindow].done_lpcs [i_precision] |= (1U << (order - 1));  	uint cbits = lpc_precision + (uint)i_precision;  	frame.current.type = SubframeType.LPC;  	frame.current.order = order;  	frame.current.window = iWindow;  	fixed (int* coefs = frame.current.coefs) {  		lpc.quantize_lpc_coefs (lpcs + (frame.current.order - 1) * lpc.MAX_LPC_ORDER' frame.current.order' cbits' coefs' out frame.current.shift' 15' 0);  		if (frame.current.shift < 0 || frame.current.shift > 15)  			throw new Exception ("negative shift");  		ulong csum = 0;  		for (int i = frame.current.order; i > 0; i--)  			csum += (ulong)Math.Abs (coefs [i - 1]);  		if ((csum << frame.subframes [ch].obits) >= 1UL << 32)  			lpc.encode_residual_long (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  		else  			lpc.encode_residual (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  	}  	int pmax = get_max_p_order (eparams.max_partition_order' frame.blocksize' frame.current.order);  	int pmin = Math.Min (eparams.min_partition_order' pmax);  	uint best_size = calc_rice_params (frame.current.rc' pmin' pmax' frame.current.residual' (uint)frame.blocksize' (uint)frame.current.order' PCM.BitsPerSample);  	// not working  	//for (int o = 1; o <= frame.current.order; o++)  	//{  	//    if (frame.current.coefs[o - 1] > -(1 << frame.current.shift))  	//    {  	//        for (int i = o; i < frame.blocksize; i++)  	//            frame.current.residual[i] += frame.subframes[ch].samples[i - o] >> frame.current.shift;  	//        frame.current.coefs[o - 1]--;  	//        uint new_size = calc_rice_params(ref frame.current.rc' pmin' pmax' frame.current.residual' (uint)frame.blocksize' (uint)frame.current.order);  	//        if (new_size > best_size)  	//        {  	//            for (int i = o; i < frame.blocksize; i++)  	//                frame.current.residual[i] -= frame.subframes[ch].samples[i - o] >> frame.current.shift;  	//            frame.current.coefs[o - 1]++;  	//        }  	//    }  	//}  	frame.current.size = (uint)(frame.current.order * frame.subframes [ch].obits + 4 + 5 + frame.current.order * (int)cbits + 6 + (int)best_size);  	frame.ChooseBestSubframe (ch);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: fixed (int* coefs = frame.current.coefs) {  	lpc.quantize_lpc_coefs (lpcs + (frame.current.order - 1) * lpc.MAX_LPC_ORDER' frame.current.order' cbits' coefs' out frame.current.shift' 15' 0);  	if (frame.current.shift < 0 || frame.current.shift > 15)  		throw new Exception ("negative shift");  	ulong csum = 0;  	for (int i = frame.current.order; i > 0; i--)  		csum += (ulong)Math.Abs (coefs [i - 1]);  	if ((csum << frame.subframes [ch].obits) >= 1UL << 32)  		lpc.encode_residual_long (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  	else  		lpc.encode_residual (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: fixed (int* coefs = frame.current.coefs) {  	lpc.quantize_lpc_coefs (lpcs + (frame.current.order - 1) * lpc.MAX_LPC_ORDER' frame.current.order' cbits' coefs' out frame.current.shift' 15' 0);  	if (frame.current.shift < 0 || frame.current.shift > 15)  		throw new Exception ("negative shift");  	ulong csum = 0;  	for (int i = frame.current.order; i > 0; i--)  		csum += (ulong)Math.Abs (coefs [i - 1]);  	if ((csum << frame.subframes [ch].obits) >= 1UL << 32)  		lpc.encode_residual_long (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  	else  		lpc.encode_residual (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: fixed (int* coefs = frame.current.coefs) {  	lpc.quantize_lpc_coefs (lpcs + (frame.current.order - 1) * lpc.MAX_LPC_ORDER' frame.current.order' cbits' coefs' out frame.current.shift' 15' 0);  	if (frame.current.shift < 0 || frame.current.shift > 15)  		throw new Exception ("negative shift");  	ulong csum = 0;  	for (int i = frame.current.order; i > 0; i--)  		csum += (ulong)Math.Abs (coefs [i - 1]);  	if ((csum << frame.subframes [ch].obits) >= 1UL << 32)  		lpc.encode_residual_long (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  	else  		lpc.encode_residual (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: lpc.quantize_lpc_coefs (lpcs + (frame.current.order - 1) * lpc.MAX_LPC_ORDER' frame.current.order' cbits' coefs' out frame.current.shift' 15' 0);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if (frame.current.shift < 0 || frame.current.shift > 15)  	throw new Exception ("negative shift");  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: if ((csum << frame.subframes [ch].obits) >= 1UL << 32)  	lpc.encode_residual_long (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  else  	lpc.encode_residual (frame.current.residual' frame.subframes [ch].samples' frame.blocksize' frame.current.order' coefs' frame.current.shift);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: frame.current.size = (uint)(frame.current.order * frame.subframes [ch].obits + 4 + 5 + frame.current.order * (int)cbits + 6 + (int)best_size);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: frame.current.size = (uint)(frame.current.order * frame.subframes [ch].obits + 4 + 5 + frame.current.order * (int)cbits + 6 + (int)best_size);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_lpc_sub,The following statement contains a magic number: frame.current.size = (uint)(frame.current.order * frame.subframes [ch].obits + 4 + 5 + frame.current.order * (int)cbits + 6 + (int)best_size);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_fixed_sub,The following statement contains a magic number: frame.current.size = (uint)(frame.current.order * frame.subframes [ch].obits) + 6 + calc_rice_params (frame.current.rc' pmin' pmax' frame.current.residual' (uint)frame.blocksize' (uint)frame.current.order' PCM.BitsPerSample);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual,The following statement contains a magic number: if (n < 5 || predict == PredictionType.None)  	return;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual,The following statement contains a magic number: if (predict == PredictionType.Fixed || (predict == PredictionType.Search && pass != 1) || //predict == PredictionType.Search ||  //(pass == 2 && frame.subframes[ch].best.type == SubframeType.Fixed) ||  n <= eparams.max_prediction_order) {  	int max_fixed_order = Math.Min (eparams.max_fixed_order' 4);  	int min_fixed_order = Math.Min (eparams.min_fixed_order' max_fixed_order);  	for (i = min_fixed_order; i <= max_fixed_order; i++)  		encode_residual_fixed_sub (frame' i' ch);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual,The following statement contains a magic number: if (n > eparams.max_prediction_order && (predict == PredictionType.Levinson || predict == PredictionType.Search)//predict == PredictionType.Search ||  //(pass == 2 && frame.subframes[ch].best.type == SubframeType.LPC))  ) {  	float* lpcs = stackalloc float[lpc.MAX_LPC_ORDER * lpc.MAX_LPC_ORDER];  	int min_order = eparams.min_prediction_order;  	int max_order = eparams.max_prediction_order;  	for (int iWindow = 0; iWindow < _windowcount; iWindow++) {  		if (best_window != -1 && iWindow != best_window)  			continue;  		LpcContext lpc_ctx = frame.subframes [ch].lpc_ctx [iWindow];  		lpc_ctx.GetReflection (max_order' smp' n' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  		lpc_ctx.ComputeLPC (lpcs);  		//int frameSize = n;  		//float* F = stackalloc float[frameSize];  		//float* B = stackalloc float[frameSize];  		//float* PE = stackalloc float[max_order + 1];  		//float* arp = stackalloc float[max_order];  		//float* rc = stackalloc float[max_order];  		//for (int j = 0; j < frameSize; j++)  		//    F[j] = B[j] = smp[j];  		//for (int K = 1; K <= max_order; K++)  		//{  		//    // BURG:  		//    float denominator = 0.0f;  		//    //float denominator = F[K - 1] * F[K - 1] + B[frameSize - K] * B[frameSize - K];  		//    for (int j = 0; j < frameSize - K; j++)  		//        denominator += F[j + K] * F[j + K] + B[j] * B[j];  		//    denominator /= 2;  		//    // Estimate error  		//    PE[K - 1] = denominator / (frameSize - K);  		//    float reflectionCoeff = 0.0f;  		//    for (int j = 0; j < frameSize - K; j++)  		//        reflectionCoeff += F[j + K] * B[j];  		//    reflectionCoeff /= denominator;  		//    rc[K - 1] = arp[K - 1] = reflectionCoeff;  		//    // Levinson-Durbin  		//    for (int j = 0; j < (K - 1) >> 1; j++)  		//    {  		//        float arptmp = arp[j];  		//        arp[j] -= reflectionCoeff * arp[K - 2 - j];  		//        arp[K - 2 - j] -= reflectionCoeff * arptmp;  		//    }  		//    if (((K - 1) & 1) != 0)  		//        arp[(K - 1) >> 1] -= reflectionCoeff * arp[(K - 1) >> 1];  		//    for (int j = 0; j < frameSize - K; j++)  		//    {  		//        float f = F[j + K];  		//        float b = B[j];  		//        F[j + K] = f - reflectionCoeff * b;  		//        B[j] = b - reflectionCoeff * f;  		//    }  		//    for (int j = 0; j < K; j++)  		//        lpcs[(K - 1) * lpc.MAX_LPC_ORDER + j] = (float)arp[j];  		//}  		switch (omethod) {  		case OrderMethod.Akaike:  			//lpc_ctx.SortOrdersAkaike(frame.blocksize' eparams.estimation_depth' max_order' 7.1' 0.0);  			lpc_ctx.SortOrdersAkaike (frame.blocksize' eparams.estimation_depth' max_order' 4.5' 0.0);  			break;  		default:  			throw new Exception ("unknown order method");  		}  		for (i = 0; i < eparams.estimation_depth && i < max_order; i++)  			encode_residual_lpc_sub (frame' lpcs' iWindow' lpc_ctx.best_orders [i]' ch);  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual,The following statement contains a magic number: if (n > eparams.max_prediction_order && (predict == PredictionType.Levinson || predict == PredictionType.Search)//predict == PredictionType.Search ||  //(pass == 2 && frame.subframes[ch].best.type == SubframeType.LPC))  ) {  	float* lpcs = stackalloc float[lpc.MAX_LPC_ORDER * lpc.MAX_LPC_ORDER];  	int min_order = eparams.min_prediction_order;  	int max_order = eparams.max_prediction_order;  	for (int iWindow = 0; iWindow < _windowcount; iWindow++) {  		if (best_window != -1 && iWindow != best_window)  			continue;  		LpcContext lpc_ctx = frame.subframes [ch].lpc_ctx [iWindow];  		lpc_ctx.GetReflection (max_order' smp' n' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  		lpc_ctx.ComputeLPC (lpcs);  		//int frameSize = n;  		//float* F = stackalloc float[frameSize];  		//float* B = stackalloc float[frameSize];  		//float* PE = stackalloc float[max_order + 1];  		//float* arp = stackalloc float[max_order];  		//float* rc = stackalloc float[max_order];  		//for (int j = 0; j < frameSize; j++)  		//    F[j] = B[j] = smp[j];  		//for (int K = 1; K <= max_order; K++)  		//{  		//    // BURG:  		//    float denominator = 0.0f;  		//    //float denominator = F[K - 1] * F[K - 1] + B[frameSize - K] * B[frameSize - K];  		//    for (int j = 0; j < frameSize - K; j++)  		//        denominator += F[j + K] * F[j + K] + B[j] * B[j];  		//    denominator /= 2;  		//    // Estimate error  		//    PE[K - 1] = denominator / (frameSize - K);  		//    float reflectionCoeff = 0.0f;  		//    for (int j = 0; j < frameSize - K; j++)  		//        reflectionCoeff += F[j + K] * B[j];  		//    reflectionCoeff /= denominator;  		//    rc[K - 1] = arp[K - 1] = reflectionCoeff;  		//    // Levinson-Durbin  		//    for (int j = 0; j < (K - 1) >> 1; j++)  		//    {  		//        float arptmp = arp[j];  		//        arp[j] -= reflectionCoeff * arp[K - 2 - j];  		//        arp[K - 2 - j] -= reflectionCoeff * arptmp;  		//    }  		//    if (((K - 1) & 1) != 0)  		//        arp[(K - 1) >> 1] -= reflectionCoeff * arp[(K - 1) >> 1];  		//    for (int j = 0; j < frameSize - K; j++)  		//    {  		//        float f = F[j + K];  		//        float b = B[j];  		//        F[j + K] = f - reflectionCoeff * b;  		//        B[j] = b - reflectionCoeff * f;  		//    }  		//    for (int j = 0; j < K; j++)  		//        lpcs[(K - 1) * lpc.MAX_LPC_ORDER + j] = (float)arp[j];  		//}  		switch (omethod) {  		case OrderMethod.Akaike:  			//lpc_ctx.SortOrdersAkaike(frame.blocksize' eparams.estimation_depth' max_order' 7.1' 0.0);  			lpc_ctx.SortOrdersAkaike (frame.blocksize' eparams.estimation_depth' max_order' 4.5' 0.0);  			break;  		default:  			throw new Exception ("unknown order method");  		}  		for (i = 0; i < eparams.estimation_depth && i < max_order; i++)  			encode_residual_lpc_sub (frame' lpcs' iWindow' lpc_ctx.best_orders [i]' ch);  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual,The following statement contains a magic number: for (int iWindow = 0; iWindow < _windowcount; iWindow++) {  	if (best_window != -1 && iWindow != best_window)  		continue;  	LpcContext lpc_ctx = frame.subframes [ch].lpc_ctx [iWindow];  	lpc_ctx.GetReflection (max_order' smp' n' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  	lpc_ctx.ComputeLPC (lpcs);  	//int frameSize = n;  	//float* F = stackalloc float[frameSize];  	//float* B = stackalloc float[frameSize];  	//float* PE = stackalloc float[max_order + 1];  	//float* arp = stackalloc float[max_order];  	//float* rc = stackalloc float[max_order];  	//for (int j = 0; j < frameSize; j++)  	//    F[j] = B[j] = smp[j];  	//for (int K = 1; K <= max_order; K++)  	//{  	//    // BURG:  	//    float denominator = 0.0f;  	//    //float denominator = F[K - 1] * F[K - 1] + B[frameSize - K] * B[frameSize - K];  	//    for (int j = 0; j < frameSize - K; j++)  	//        denominator += F[j + K] * F[j + K] + B[j] * B[j];  	//    denominator /= 2;  	//    // Estimate error  	//    PE[K - 1] = denominator / (frameSize - K);  	//    float reflectionCoeff = 0.0f;  	//    for (int j = 0; j < frameSize - K; j++)  	//        reflectionCoeff += F[j + K] * B[j];  	//    reflectionCoeff /= denominator;  	//    rc[K - 1] = arp[K - 1] = reflectionCoeff;  	//    // Levinson-Durbin  	//    for (int j = 0; j < (K - 1) >> 1; j++)  	//    {  	//        float arptmp = arp[j];  	//        arp[j] -= reflectionCoeff * arp[K - 2 - j];  	//        arp[K - 2 - j] -= reflectionCoeff * arptmp;  	//    }  	//    if (((K - 1) & 1) != 0)  	//        arp[(K - 1) >> 1] -= reflectionCoeff * arp[(K - 1) >> 1];  	//    for (int j = 0; j < frameSize - K; j++)  	//    {  	//        float f = F[j + K];  	//        float b = B[j];  	//        F[j + K] = f - reflectionCoeff * b;  	//        B[j] = b - reflectionCoeff * f;  	//    }  	//    for (int j = 0; j < K; j++)  	//        lpcs[(K - 1) * lpc.MAX_LPC_ORDER + j] = (float)arp[j];  	//}  	switch (omethod) {  	case OrderMethod.Akaike:  		//lpc_ctx.SortOrdersAkaike(frame.blocksize' eparams.estimation_depth' max_order' 7.1' 0.0);  		lpc_ctx.SortOrdersAkaike (frame.blocksize' eparams.estimation_depth' max_order' 4.5' 0.0);  		break;  	default:  		throw new Exception ("unknown order method");  	}  	for (i = 0; i < eparams.estimation_depth && i < max_order; i++)  		encode_residual_lpc_sub (frame' lpcs' iWindow' lpc_ctx.best_orders [i]' ch);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual,The following statement contains a magic number: for (int iWindow = 0; iWindow < _windowcount; iWindow++) {  	if (best_window != -1 && iWindow != best_window)  		continue;  	LpcContext lpc_ctx = frame.subframes [ch].lpc_ctx [iWindow];  	lpc_ctx.GetReflection (max_order' smp' n' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  	lpc_ctx.ComputeLPC (lpcs);  	//int frameSize = n;  	//float* F = stackalloc float[frameSize];  	//float* B = stackalloc float[frameSize];  	//float* PE = stackalloc float[max_order + 1];  	//float* arp = stackalloc float[max_order];  	//float* rc = stackalloc float[max_order];  	//for (int j = 0; j < frameSize; j++)  	//    F[j] = B[j] = smp[j];  	//for (int K = 1; K <= max_order; K++)  	//{  	//    // BURG:  	//    float denominator = 0.0f;  	//    //float denominator = F[K - 1] * F[K - 1] + B[frameSize - K] * B[frameSize - K];  	//    for (int j = 0; j < frameSize - K; j++)  	//        denominator += F[j + K] * F[j + K] + B[j] * B[j];  	//    denominator /= 2;  	//    // Estimate error  	//    PE[K - 1] = denominator / (frameSize - K);  	//    float reflectionCoeff = 0.0f;  	//    for (int j = 0; j < frameSize - K; j++)  	//        reflectionCoeff += F[j + K] * B[j];  	//    reflectionCoeff /= denominator;  	//    rc[K - 1] = arp[K - 1] = reflectionCoeff;  	//    // Levinson-Durbin  	//    for (int j = 0; j < (K - 1) >> 1; j++)  	//    {  	//        float arptmp = arp[j];  	//        arp[j] -= reflectionCoeff * arp[K - 2 - j];  	//        arp[K - 2 - j] -= reflectionCoeff * arptmp;  	//    }  	//    if (((K - 1) & 1) != 0)  	//        arp[(K - 1) >> 1] -= reflectionCoeff * arp[(K - 1) >> 1];  	//    for (int j = 0; j < frameSize - K; j++)  	//    {  	//        float f = F[j + K];  	//        float b = B[j];  	//        F[j + K] = f - reflectionCoeff * b;  	//        B[j] = b - reflectionCoeff * f;  	//    }  	//    for (int j = 0; j < K; j++)  	//        lpcs[(K - 1) * lpc.MAX_LPC_ORDER + j] = (float)arp[j];  	//}  	switch (omethod) {  	case OrderMethod.Akaike:  		//lpc_ctx.SortOrdersAkaike(frame.blocksize' eparams.estimation_depth' max_order' 7.1' 0.0);  		lpc_ctx.SortOrdersAkaike (frame.blocksize' eparams.estimation_depth' max_order' 4.5' 0.0);  		break;  	default:  		throw new Exception ("unknown order method");  	}  	for (i = 0; i < eparams.estimation_depth && i < max_order; i++)  		encode_residual_lpc_sub (frame' lpcs' iWindow' lpc_ctx.best_orders [i]' ch);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual,The following statement contains a magic number: lpc_ctx.GetReflection (max_order' smp' n' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual,The following statement contains a magic number: switch (omethod) {  case OrderMethod.Akaike:  	//lpc_ctx.SortOrdersAkaike(frame.blocksize' eparams.estimation_depth' max_order' 7.1' 0.0);  	lpc_ctx.SortOrdersAkaike (frame.blocksize' eparams.estimation_depth' max_order' 4.5' 0.0);  	break;  default:  	throw new Exception ("unknown order method");  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual,The following statement contains a magic number: lpc_ctx.SortOrdersAkaike (frame.blocksize' eparams.estimation_depth' max_order' 4.5' 0.0);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_frame_header,The following statement contains a magic number: bitwriter.writebits (15' 0x7FFC);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_frame_header,The following statement contains a magic number: bitwriter.writebits (4' frame.bs_code0);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_frame_header,The following statement contains a magic number: bitwriter.writebits (4' sr_code0);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_frame_header,The following statement contains a magic number: if (frame.ch_mode == ChannelMode.NotStereo)  	bitwriter.writebits (4' ch_code);  else  	bitwriter.writebits (4' (int)frame.ch_mode);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_frame_header,The following statement contains a magic number: if (frame.ch_mode == ChannelMode.NotStereo)  	bitwriter.writebits (4' ch_code);  else  	bitwriter.writebits (4' (int)frame.ch_mode);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_frame_header,The following statement contains a magic number: bitwriter.writebits (4' ch_code);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_frame_header,The following statement contains a magic number: bitwriter.writebits (4' (int)frame.ch_mode);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_frame_header,The following statement contains a magic number: bitwriter.writebits (3' bps_code);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_frame_header,The following statement contains a magic number: if (frame.bs_code1 >= 0) {  	if (frame.bs_code1 < 256)  		bitwriter.writebits (8' frame.bs_code1);  	else  		bitwriter.writebits (16' frame.bs_code1);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_frame_header,The following statement contains a magic number: if (frame.bs_code1 >= 0) {  	if (frame.bs_code1 < 256)  		bitwriter.writebits (8' frame.bs_code1);  	else  		bitwriter.writebits (16' frame.bs_code1);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_frame_header,The following statement contains a magic number: if (frame.bs_code1 >= 0) {  	if (frame.bs_code1 < 256)  		bitwriter.writebits (8' frame.bs_code1);  	else  		bitwriter.writebits (16' frame.bs_code1);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_frame_header,The following statement contains a magic number: if (frame.bs_code1 < 256)  	bitwriter.writebits (8' frame.bs_code1);  else  	bitwriter.writebits (16' frame.bs_code1);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_frame_header,The following statement contains a magic number: if (frame.bs_code1 < 256)  	bitwriter.writebits (8' frame.bs_code1);  else  	bitwriter.writebits (16' frame.bs_code1);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_frame_header,The following statement contains a magic number: if (frame.bs_code1 < 256)  	bitwriter.writebits (8' frame.bs_code1);  else  	bitwriter.writebits (16' frame.bs_code1);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_frame_header,The following statement contains a magic number: bitwriter.writebits (8' frame.bs_code1);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_frame_header,The following statement contains a magic number: bitwriter.writebits (16' frame.bs_code1);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_frame_header,The following statement contains a magic number: if (sr_code1 > 0) {  	if (sr_code1 < 256)  		bitwriter.writebits (8' sr_code1);  	else  		bitwriter.writebits (16' sr_code1);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_frame_header,The following statement contains a magic number: if (sr_code1 > 0) {  	if (sr_code1 < 256)  		bitwriter.writebits (8' sr_code1);  	else  		bitwriter.writebits (16' sr_code1);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_frame_header,The following statement contains a magic number: if (sr_code1 > 0) {  	if (sr_code1 < 256)  		bitwriter.writebits (8' sr_code1);  	else  		bitwriter.writebits (16' sr_code1);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_frame_header,The following statement contains a magic number: if (sr_code1 < 256)  	bitwriter.writebits (8' sr_code1);  else  	bitwriter.writebits (16' sr_code1);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_frame_header,The following statement contains a magic number: if (sr_code1 < 256)  	bitwriter.writebits (8' sr_code1);  else  	bitwriter.writebits (16' sr_code1);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_frame_header,The following statement contains a magic number: if (sr_code1 < 256)  	bitwriter.writebits (8' sr_code1);  else  	bitwriter.writebits (16' sr_code1);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_frame_header,The following statement contains a magic number: bitwriter.writebits (8' sr_code1);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_frame_header,The following statement contains a magic number: bitwriter.writebits (16' sr_code1);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_frame_header,The following statement contains a magic number: bitwriter.writebits (8' crc);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_residual,The following statement contains a magic number: bitwriter.writebits (2' sub.best.rc.coding_method);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_residual,The following statement contains a magic number: bitwriter.writebits (4' porder);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_subframe_lpc,The following statement contains a magic number: for (int i = 0; i < sub.best.order; i++)  	while (cbits < 16 && sub.best.coefs [i] != (sub.best.coefs [i] << (32 - cbits)) >> (32 - cbits))  		cbits++;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_subframe_lpc,The following statement contains a magic number: for (int i = 0; i < sub.best.order; i++)  	while (cbits < 16 && sub.best.coefs [i] != (sub.best.coefs [i] << (32 - cbits)) >> (32 - cbits))  		cbits++;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_subframe_lpc,The following statement contains a magic number: for (int i = 0; i < sub.best.order; i++)  	while (cbits < 16 && sub.best.coefs [i] != (sub.best.coefs [i] << (32 - cbits)) >> (32 - cbits))  		cbits++;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_subframe_lpc,The following statement contains a magic number: while (cbits < 16 && sub.best.coefs [i] != (sub.best.coefs [i] << (32 - cbits)) >> (32 - cbits))  	cbits++;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_subframe_lpc,The following statement contains a magic number: while (cbits < 16 && sub.best.coefs [i] != (sub.best.coefs [i] << (32 - cbits)) >> (32 - cbits))  	cbits++;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_subframe_lpc,The following statement contains a magic number: while (cbits < 16 && sub.best.coefs [i] != (sub.best.coefs [i] << (32 - cbits)) >> (32 - cbits))  	cbits++;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_subframe_lpc,The following statement contains a magic number: bitwriter.writebits (4' cbits - 1);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_subframe_lpc,The following statement contains a magic number: bitwriter.writebits_signed (5' sub.best.shift);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_subframes,The following statement contains a magic number: for (int ch = 0; ch < channels; ch++) {  	FlacSubframeInfo sub = frame.subframes [ch];  	// subframe header  	int type_code = (int)sub.best.type;  	if (sub.best.type == SubframeType.Fixed)  		type_code |= sub.best.order;  	if (sub.best.type == SubframeType.LPC)  		type_code |= sub.best.order - 1;  	bitwriter.writebits (1' 0);  	bitwriter.writebits (6' type_code);  	bitwriter.writebits (1' sub.wbits != 0 ? 1 : 0);  	if (sub.wbits > 0)  		bitwriter.writebits ((int)sub.wbits' 1);  	// subframe  	switch (sub.best.type) {  	case SubframeType.Constant:  		output_subframe_constant (frame' bitwriter' sub);  		break;  	case SubframeType.Verbatim:  		output_subframe_verbatim (frame' bitwriter' sub);  		break;  	case SubframeType.Fixed:  		output_subframe_fixed (frame' bitwriter' sub);  		break;  	case SubframeType.LPC:  		output_subframe_lpc (frame' bitwriter' sub);  		break;  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_subframes,The following statement contains a magic number: bitwriter.writebits (6' type_code);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_frame_footer,The following statement contains a magic number: bitwriter.writebits (16' crc);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_pass1,The following statement contains a magic number: eparams.min_fixed_order = 2;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_pass1,The following statement contains a magic number: eparams.max_fixed_order = 2;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_pass1,The following statement contains a magic number: eparams.max_prediction_order = 8;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_residual_pass2,The following statement contains a magic number: encode_residual (frame' ch' eparams.prediction_type' eparams.order_method' 2' estimate_best_window (frame' ch));  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,estimate_best_window,The following statement contains a magic number: switch (eparams.window_method) {  case WindowMethod.Estimate: {  	int best_window = -1;  	double best_error = 0;  	int order = 2;  	for (int i = 0; i < _windowcount; i++) {  		frame.subframes [ch].lpc_ctx [i].GetReflection (order' frame.subframes [ch].samples' frame.blocksize' frame.window_buffer + i * Flake.MAX_BLOCKSIZE * 2);  		double err = frame.subframes [ch].lpc_ctx [i].prediction_error [order - 1] / frame.subframes [ch].lpc_ctx [i].autocorr_values [0];  		//double err = frame.subframes[ch].lpc_ctx[i].autocorr_values[0] / frame.subframes[ch].lpc_ctx[i].autocorr_values[2];  		if (best_window == -1 || best_error > err) {  			best_window = i;  			best_error = err;  		}  	}  	return best_window;  }  case WindowMethod.Evaluate:  	encode_residual_pass1 (frame' ch' -1);  	return frame.subframes [ch].best.type == SubframeType.LPC ? frame.subframes [ch].best.window : -1;  case WindowMethod.Search:  	return -1;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,estimate_best_window,The following statement contains a magic number: switch (eparams.window_method) {  case WindowMethod.Estimate: {  	int best_window = -1;  	double best_error = 0;  	int order = 2;  	for (int i = 0; i < _windowcount; i++) {  		frame.subframes [ch].lpc_ctx [i].GetReflection (order' frame.subframes [ch].samples' frame.blocksize' frame.window_buffer + i * Flake.MAX_BLOCKSIZE * 2);  		double err = frame.subframes [ch].lpc_ctx [i].prediction_error [order - 1] / frame.subframes [ch].lpc_ctx [i].autocorr_values [0];  		//double err = frame.subframes[ch].lpc_ctx[i].autocorr_values[0] / frame.subframes[ch].lpc_ctx[i].autocorr_values[2];  		if (best_window == -1 || best_error > err) {  			best_window = i;  			best_error = err;  		}  	}  	return best_window;  }  case WindowMethod.Evaluate:  	encode_residual_pass1 (frame' ch' -1);  	return frame.subframes [ch].best.type == SubframeType.LPC ? frame.subframes [ch].best.window : -1;  case WindowMethod.Search:  	return -1;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,estimate_best_window,The following statement contains a magic number: for (int i = 0; i < _windowcount; i++) {  	frame.subframes [ch].lpc_ctx [i].GetReflection (order' frame.subframes [ch].samples' frame.blocksize' frame.window_buffer + i * Flake.MAX_BLOCKSIZE * 2);  	double err = frame.subframes [ch].lpc_ctx [i].prediction_error [order - 1] / frame.subframes [ch].lpc_ctx [i].autocorr_values [0];  	//double err = frame.subframes[ch].lpc_ctx[i].autocorr_values[0] / frame.subframes[ch].lpc_ctx[i].autocorr_values[2];  	if (best_window == -1 || best_error > err) {  		best_window = i;  		best_error = err;  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,estimate_best_window,The following statement contains a magic number: frame.subframes [ch].lpc_ctx [i].GetReflection (order' frame.subframes [ch].samples' frame.blocksize' frame.window_buffer + i * Flake.MAX_BLOCKSIZE * 2);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,estimate_frame,The following statement contains a magic number: switch (eparams.stereo_method) {  case StereoMethod.Estimate:  	for (int ch = 0; ch < subframes; ch++) {  		LpcContext lpc_ctx = frame.subframes [ch].lpc_ctx [0];  		lpc_ctx.GetReflection (4' frame.subframes [ch].samples' frame.blocksize' frame.window_buffer);  		lpc_ctx.SortOrdersAkaike (frame.blocksize' 1' 4' 4.5' 0.0);  		frame.subframes [ch].best.size = (uint)Math.Max (0' lpc_ctx.Akaike (frame.blocksize' lpc_ctx.best_orders [0]' 4.5' 0.0) + 7.1 * frame.subframes [ch].obits * eparams.max_prediction_order);  	}  	break;  case StereoMethod.Evaluate:  	for (int ch = 0; ch < subframes; ch++)  		encode_residual_pass1 (frame' ch' 0);  	break;  case StereoMethod.Search:  	for (int ch = 0; ch < subframes; ch++)  		encode_residual_pass2 (frame' ch);  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,estimate_frame,The following statement contains a magic number: switch (eparams.stereo_method) {  case StereoMethod.Estimate:  	for (int ch = 0; ch < subframes; ch++) {  		LpcContext lpc_ctx = frame.subframes [ch].lpc_ctx [0];  		lpc_ctx.GetReflection (4' frame.subframes [ch].samples' frame.blocksize' frame.window_buffer);  		lpc_ctx.SortOrdersAkaike (frame.blocksize' 1' 4' 4.5' 0.0);  		frame.subframes [ch].best.size = (uint)Math.Max (0' lpc_ctx.Akaike (frame.blocksize' lpc_ctx.best_orders [0]' 4.5' 0.0) + 7.1 * frame.subframes [ch].obits * eparams.max_prediction_order);  	}  	break;  case StereoMethod.Evaluate:  	for (int ch = 0; ch < subframes; ch++)  		encode_residual_pass1 (frame' ch' 0);  	break;  case StereoMethod.Search:  	for (int ch = 0; ch < subframes; ch++)  		encode_residual_pass2 (frame' ch);  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,estimate_frame,The following statement contains a magic number: switch (eparams.stereo_method) {  case StereoMethod.Estimate:  	for (int ch = 0; ch < subframes; ch++) {  		LpcContext lpc_ctx = frame.subframes [ch].lpc_ctx [0];  		lpc_ctx.GetReflection (4' frame.subframes [ch].samples' frame.blocksize' frame.window_buffer);  		lpc_ctx.SortOrdersAkaike (frame.blocksize' 1' 4' 4.5' 0.0);  		frame.subframes [ch].best.size = (uint)Math.Max (0' lpc_ctx.Akaike (frame.blocksize' lpc_ctx.best_orders [0]' 4.5' 0.0) + 7.1 * frame.subframes [ch].obits * eparams.max_prediction_order);  	}  	break;  case StereoMethod.Evaluate:  	for (int ch = 0; ch < subframes; ch++)  		encode_residual_pass1 (frame' ch' 0);  	break;  case StereoMethod.Search:  	for (int ch = 0; ch < subframes; ch++)  		encode_residual_pass2 (frame' ch);  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,estimate_frame,The following statement contains a magic number: switch (eparams.stereo_method) {  case StereoMethod.Estimate:  	for (int ch = 0; ch < subframes; ch++) {  		LpcContext lpc_ctx = frame.subframes [ch].lpc_ctx [0];  		lpc_ctx.GetReflection (4' frame.subframes [ch].samples' frame.blocksize' frame.window_buffer);  		lpc_ctx.SortOrdersAkaike (frame.blocksize' 1' 4' 4.5' 0.0);  		frame.subframes [ch].best.size = (uint)Math.Max (0' lpc_ctx.Akaike (frame.blocksize' lpc_ctx.best_orders [0]' 4.5' 0.0) + 7.1 * frame.subframes [ch].obits * eparams.max_prediction_order);  	}  	break;  case StereoMethod.Evaluate:  	for (int ch = 0; ch < subframes; ch++)  		encode_residual_pass1 (frame' ch' 0);  	break;  case StereoMethod.Search:  	for (int ch = 0; ch < subframes; ch++)  		encode_residual_pass2 (frame' ch);  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,estimate_frame,The following statement contains a magic number: switch (eparams.stereo_method) {  case StereoMethod.Estimate:  	for (int ch = 0; ch < subframes; ch++) {  		LpcContext lpc_ctx = frame.subframes [ch].lpc_ctx [0];  		lpc_ctx.GetReflection (4' frame.subframes [ch].samples' frame.blocksize' frame.window_buffer);  		lpc_ctx.SortOrdersAkaike (frame.blocksize' 1' 4' 4.5' 0.0);  		frame.subframes [ch].best.size = (uint)Math.Max (0' lpc_ctx.Akaike (frame.blocksize' lpc_ctx.best_orders [0]' 4.5' 0.0) + 7.1 * frame.subframes [ch].obits * eparams.max_prediction_order);  	}  	break;  case StereoMethod.Evaluate:  	for (int ch = 0; ch < subframes; ch++)  		encode_residual_pass1 (frame' ch' 0);  	break;  case StereoMethod.Search:  	for (int ch = 0; ch < subframes; ch++)  		encode_residual_pass2 (frame' ch);  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,estimate_frame,The following statement contains a magic number: for (int ch = 0; ch < subframes; ch++) {  	LpcContext lpc_ctx = frame.subframes [ch].lpc_ctx [0];  	lpc_ctx.GetReflection (4' frame.subframes [ch].samples' frame.blocksize' frame.window_buffer);  	lpc_ctx.SortOrdersAkaike (frame.blocksize' 1' 4' 4.5' 0.0);  	frame.subframes [ch].best.size = (uint)Math.Max (0' lpc_ctx.Akaike (frame.blocksize' lpc_ctx.best_orders [0]' 4.5' 0.0) + 7.1 * frame.subframes [ch].obits * eparams.max_prediction_order);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,estimate_frame,The following statement contains a magic number: for (int ch = 0; ch < subframes; ch++) {  	LpcContext lpc_ctx = frame.subframes [ch].lpc_ctx [0];  	lpc_ctx.GetReflection (4' frame.subframes [ch].samples' frame.blocksize' frame.window_buffer);  	lpc_ctx.SortOrdersAkaike (frame.blocksize' 1' 4' 4.5' 0.0);  	frame.subframes [ch].best.size = (uint)Math.Max (0' lpc_ctx.Akaike (frame.blocksize' lpc_ctx.best_orders [0]' 4.5' 0.0) + 7.1 * frame.subframes [ch].obits * eparams.max_prediction_order);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,estimate_frame,The following statement contains a magic number: for (int ch = 0; ch < subframes; ch++) {  	LpcContext lpc_ctx = frame.subframes [ch].lpc_ctx [0];  	lpc_ctx.GetReflection (4' frame.subframes [ch].samples' frame.blocksize' frame.window_buffer);  	lpc_ctx.SortOrdersAkaike (frame.blocksize' 1' 4' 4.5' 0.0);  	frame.subframes [ch].best.size = (uint)Math.Max (0' lpc_ctx.Akaike (frame.blocksize' lpc_ctx.best_orders [0]' 4.5' 0.0) + 7.1 * frame.subframes [ch].obits * eparams.max_prediction_order);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,estimate_frame,The following statement contains a magic number: for (int ch = 0; ch < subframes; ch++) {  	LpcContext lpc_ctx = frame.subframes [ch].lpc_ctx [0];  	lpc_ctx.GetReflection (4' frame.subframes [ch].samples' frame.blocksize' frame.window_buffer);  	lpc_ctx.SortOrdersAkaike (frame.blocksize' 1' 4' 4.5' 0.0);  	frame.subframes [ch].best.size = (uint)Math.Max (0' lpc_ctx.Akaike (frame.blocksize' lpc_ctx.best_orders [0]' 4.5' 0.0) + 7.1 * frame.subframes [ch].obits * eparams.max_prediction_order);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,estimate_frame,The following statement contains a magic number: for (int ch = 0; ch < subframes; ch++) {  	LpcContext lpc_ctx = frame.subframes [ch].lpc_ctx [0];  	lpc_ctx.GetReflection (4' frame.subframes [ch].samples' frame.blocksize' frame.window_buffer);  	lpc_ctx.SortOrdersAkaike (frame.blocksize' 1' 4' 4.5' 0.0);  	frame.subframes [ch].best.size = (uint)Math.Max (0' lpc_ctx.Akaike (frame.blocksize' lpc_ctx.best_orders [0]' 4.5' 0.0) + 7.1 * frame.subframes [ch].obits * eparams.max_prediction_order);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,estimate_frame,The following statement contains a magic number: lpc_ctx.GetReflection (4' frame.subframes [ch].samples' frame.blocksize' frame.window_buffer);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,estimate_frame,The following statement contains a magic number: lpc_ctx.SortOrdersAkaike (frame.blocksize' 1' 4' 4.5' 0.0);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,estimate_frame,The following statement contains a magic number: lpc_ctx.SortOrdersAkaike (frame.blocksize' 1' 4' 4.5' 0.0);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,estimate_frame,The following statement contains a magic number: frame.subframes [ch].best.size = (uint)Math.Max (0' lpc_ctx.Akaike (frame.blocksize' lpc_ctx.best_orders [0]' 4.5' 0.0) + 7.1 * frame.subframes [ch].obits * eparams.max_prediction_order);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,estimate_frame,The following statement contains a magic number: frame.subframes [ch].best.size = (uint)Math.Max (0' lpc_ctx.Akaike (frame.blocksize' lpc_ctx.best_orders [0]' 4.5' 0.0) + 7.1 * frame.subframes [ch].obits * eparams.max_prediction_order);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,measure_frame_size,The following statement contains a magic number: if (do_midside) {  	uint bitsBest = AudioSamples.UINT32_MAX;  	ChannelMode modeBest = ChannelMode.LeftRight;  	if (bitsBest > frame.subframes [2].best.size + frame.subframes [3].best.size) {  		bitsBest = frame.subframes [2].best.size + frame.subframes [3].best.size;  		modeBest = ChannelMode.MidSide;  	}  	if (bitsBest > frame.subframes [3].best.size + frame.subframes [1].best.size) {  		bitsBest = frame.subframes [3].best.size + frame.subframes [1].best.size;  		modeBest = ChannelMode.RightSide;  	}  	if (bitsBest > frame.subframes [3].best.size + frame.subframes [0].best.size) {  		bitsBest = frame.subframes [3].best.size + frame.subframes [0].best.size;  		modeBest = ChannelMode.LeftSide;  	}  	if (bitsBest > frame.subframes [0].best.size + frame.subframes [1].best.size) {  		bitsBest = frame.subframes [0].best.size + frame.subframes [1].best.size;  		modeBest = ChannelMode.LeftRight;  	}  	frame.ch_mode = modeBest;  	return total + bitsBest;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,measure_frame_size,The following statement contains a magic number: if (do_midside) {  	uint bitsBest = AudioSamples.UINT32_MAX;  	ChannelMode modeBest = ChannelMode.LeftRight;  	if (bitsBest > frame.subframes [2].best.size + frame.subframes [3].best.size) {  		bitsBest = frame.subframes [2].best.size + frame.subframes [3].best.size;  		modeBest = ChannelMode.MidSide;  	}  	if (bitsBest > frame.subframes [3].best.size + frame.subframes [1].best.size) {  		bitsBest = frame.subframes [3].best.size + frame.subframes [1].best.size;  		modeBest = ChannelMode.RightSide;  	}  	if (bitsBest > frame.subframes [3].best.size + frame.subframes [0].best.size) {  		bitsBest = frame.subframes [3].best.size + frame.subframes [0].best.size;  		modeBest = ChannelMode.LeftSide;  	}  	if (bitsBest > frame.subframes [0].best.size + frame.subframes [1].best.size) {  		bitsBest = frame.subframes [0].best.size + frame.subframes [1].best.size;  		modeBest = ChannelMode.LeftRight;  	}  	frame.ch_mode = modeBest;  	return total + bitsBest;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,measure_frame_size,The following statement contains a magic number: if (do_midside) {  	uint bitsBest = AudioSamples.UINT32_MAX;  	ChannelMode modeBest = ChannelMode.LeftRight;  	if (bitsBest > frame.subframes [2].best.size + frame.subframes [3].best.size) {  		bitsBest = frame.subframes [2].best.size + frame.subframes [3].best.size;  		modeBest = ChannelMode.MidSide;  	}  	if (bitsBest > frame.subframes [3].best.size + frame.subframes [1].best.size) {  		bitsBest = frame.subframes [3].best.size + frame.subframes [1].best.size;  		modeBest = ChannelMode.RightSide;  	}  	if (bitsBest > frame.subframes [3].best.size + frame.subframes [0].best.size) {  		bitsBest = frame.subframes [3].best.size + frame.subframes [0].best.size;  		modeBest = ChannelMode.LeftSide;  	}  	if (bitsBest > frame.subframes [0].best.size + frame.subframes [1].best.size) {  		bitsBest = frame.subframes [0].best.size + frame.subframes [1].best.size;  		modeBest = ChannelMode.LeftRight;  	}  	frame.ch_mode = modeBest;  	return total + bitsBest;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,measure_frame_size,The following statement contains a magic number: if (do_midside) {  	uint bitsBest = AudioSamples.UINT32_MAX;  	ChannelMode modeBest = ChannelMode.LeftRight;  	if (bitsBest > frame.subframes [2].best.size + frame.subframes [3].best.size) {  		bitsBest = frame.subframes [2].best.size + frame.subframes [3].best.size;  		modeBest = ChannelMode.MidSide;  	}  	if (bitsBest > frame.subframes [3].best.size + frame.subframes [1].best.size) {  		bitsBest = frame.subframes [3].best.size + frame.subframes [1].best.size;  		modeBest = ChannelMode.RightSide;  	}  	if (bitsBest > frame.subframes [3].best.size + frame.subframes [0].best.size) {  		bitsBest = frame.subframes [3].best.size + frame.subframes [0].best.size;  		modeBest = ChannelMode.LeftSide;  	}  	if (bitsBest > frame.subframes [0].best.size + frame.subframes [1].best.size) {  		bitsBest = frame.subframes [0].best.size + frame.subframes [1].best.size;  		modeBest = ChannelMode.LeftRight;  	}  	frame.ch_mode = modeBest;  	return total + bitsBest;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,measure_frame_size,The following statement contains a magic number: if (do_midside) {  	uint bitsBest = AudioSamples.UINT32_MAX;  	ChannelMode modeBest = ChannelMode.LeftRight;  	if (bitsBest > frame.subframes [2].best.size + frame.subframes [3].best.size) {  		bitsBest = frame.subframes [2].best.size + frame.subframes [3].best.size;  		modeBest = ChannelMode.MidSide;  	}  	if (bitsBest > frame.subframes [3].best.size + frame.subframes [1].best.size) {  		bitsBest = frame.subframes [3].best.size + frame.subframes [1].best.size;  		modeBest = ChannelMode.RightSide;  	}  	if (bitsBest > frame.subframes [3].best.size + frame.subframes [0].best.size) {  		bitsBest = frame.subframes [3].best.size + frame.subframes [0].best.size;  		modeBest = ChannelMode.LeftSide;  	}  	if (bitsBest > frame.subframes [0].best.size + frame.subframes [1].best.size) {  		bitsBest = frame.subframes [0].best.size + frame.subframes [1].best.size;  		modeBest = ChannelMode.LeftRight;  	}  	frame.ch_mode = modeBest;  	return total + bitsBest;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,measure_frame_size,The following statement contains a magic number: if (do_midside) {  	uint bitsBest = AudioSamples.UINT32_MAX;  	ChannelMode modeBest = ChannelMode.LeftRight;  	if (bitsBest > frame.subframes [2].best.size + frame.subframes [3].best.size) {  		bitsBest = frame.subframes [2].best.size + frame.subframes [3].best.size;  		modeBest = ChannelMode.MidSide;  	}  	if (bitsBest > frame.subframes [3].best.size + frame.subframes [1].best.size) {  		bitsBest = frame.subframes [3].best.size + frame.subframes [1].best.size;  		modeBest = ChannelMode.RightSide;  	}  	if (bitsBest > frame.subframes [3].best.size + frame.subframes [0].best.size) {  		bitsBest = frame.subframes [3].best.size + frame.subframes [0].best.size;  		modeBest = ChannelMode.LeftSide;  	}  	if (bitsBest > frame.subframes [0].best.size + frame.subframes [1].best.size) {  		bitsBest = frame.subframes [0].best.size + frame.subframes [1].best.size;  		modeBest = ChannelMode.LeftRight;  	}  	frame.ch_mode = modeBest;  	return total + bitsBest;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,measure_frame_size,The following statement contains a magic number: if (do_midside) {  	uint bitsBest = AudioSamples.UINT32_MAX;  	ChannelMode modeBest = ChannelMode.LeftRight;  	if (bitsBest > frame.subframes [2].best.size + frame.subframes [3].best.size) {  		bitsBest = frame.subframes [2].best.size + frame.subframes [3].best.size;  		modeBest = ChannelMode.MidSide;  	}  	if (bitsBest > frame.subframes [3].best.size + frame.subframes [1].best.size) {  		bitsBest = frame.subframes [3].best.size + frame.subframes [1].best.size;  		modeBest = ChannelMode.RightSide;  	}  	if (bitsBest > frame.subframes [3].best.size + frame.subframes [0].best.size) {  		bitsBest = frame.subframes [3].best.size + frame.subframes [0].best.size;  		modeBest = ChannelMode.LeftSide;  	}  	if (bitsBest > frame.subframes [0].best.size + frame.subframes [1].best.size) {  		bitsBest = frame.subframes [0].best.size + frame.subframes [1].best.size;  		modeBest = ChannelMode.LeftRight;  	}  	frame.ch_mode = modeBest;  	return total + bitsBest;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,measure_frame_size,The following statement contains a magic number: if (do_midside) {  	uint bitsBest = AudioSamples.UINT32_MAX;  	ChannelMode modeBest = ChannelMode.LeftRight;  	if (bitsBest > frame.subframes [2].best.size + frame.subframes [3].best.size) {  		bitsBest = frame.subframes [2].best.size + frame.subframes [3].best.size;  		modeBest = ChannelMode.MidSide;  	}  	if (bitsBest > frame.subframes [3].best.size + frame.subframes [1].best.size) {  		bitsBest = frame.subframes [3].best.size + frame.subframes [1].best.size;  		modeBest = ChannelMode.RightSide;  	}  	if (bitsBest > frame.subframes [3].best.size + frame.subframes [0].best.size) {  		bitsBest = frame.subframes [3].best.size + frame.subframes [0].best.size;  		modeBest = ChannelMode.LeftSide;  	}  	if (bitsBest > frame.subframes [0].best.size + frame.subframes [1].best.size) {  		bitsBest = frame.subframes [0].best.size + frame.subframes [1].best.size;  		modeBest = ChannelMode.LeftRight;  	}  	frame.ch_mode = modeBest;  	return total + bitsBest;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,measure_frame_size,The following statement contains a magic number: if (bitsBest > frame.subframes [2].best.size + frame.subframes [3].best.size) {  	bitsBest = frame.subframes [2].best.size + frame.subframes [3].best.size;  	modeBest = ChannelMode.MidSide;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,measure_frame_size,The following statement contains a magic number: if (bitsBest > frame.subframes [2].best.size + frame.subframes [3].best.size) {  	bitsBest = frame.subframes [2].best.size + frame.subframes [3].best.size;  	modeBest = ChannelMode.MidSide;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,measure_frame_size,The following statement contains a magic number: if (bitsBest > frame.subframes [2].best.size + frame.subframes [3].best.size) {  	bitsBest = frame.subframes [2].best.size + frame.subframes [3].best.size;  	modeBest = ChannelMode.MidSide;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,measure_frame_size,The following statement contains a magic number: if (bitsBest > frame.subframes [2].best.size + frame.subframes [3].best.size) {  	bitsBest = frame.subframes [2].best.size + frame.subframes [3].best.size;  	modeBest = ChannelMode.MidSide;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,measure_frame_size,The following statement contains a magic number: bitsBest = frame.subframes [2].best.size + frame.subframes [3].best.size;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,measure_frame_size,The following statement contains a magic number: bitsBest = frame.subframes [2].best.size + frame.subframes [3].best.size;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,measure_frame_size,The following statement contains a magic number: if (bitsBest > frame.subframes [3].best.size + frame.subframes [1].best.size) {  	bitsBest = frame.subframes [3].best.size + frame.subframes [1].best.size;  	modeBest = ChannelMode.RightSide;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,measure_frame_size,The following statement contains a magic number: if (bitsBest > frame.subframes [3].best.size + frame.subframes [1].best.size) {  	bitsBest = frame.subframes [3].best.size + frame.subframes [1].best.size;  	modeBest = ChannelMode.RightSide;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,measure_frame_size,The following statement contains a magic number: bitsBest = frame.subframes [3].best.size + frame.subframes [1].best.size;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,measure_frame_size,The following statement contains a magic number: if (bitsBest > frame.subframes [3].best.size + frame.subframes [0].best.size) {  	bitsBest = frame.subframes [3].best.size + frame.subframes [0].best.size;  	modeBest = ChannelMode.LeftSide;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,measure_frame_size,The following statement contains a magic number: if (bitsBest > frame.subframes [3].best.size + frame.subframes [0].best.size) {  	bitsBest = frame.subframes [3].best.size + frame.subframes [0].best.size;  	modeBest = ChannelMode.LeftSide;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,measure_frame_size,The following statement contains a magic number: bitsBest = frame.subframes [3].best.size + frame.subframes [0].best.size;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,calculate_window,The following statement contains a magic number: do {  	func (pos' sz);  	if ((sz & 1) != 0)  		break;  	pos += sz;  	sz >>= 1;  }  while (sz >= 32);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (int* s = samplesBuffer' r = residualBuffer)  	fixed (float* window = windowBuffer) {  		frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  		if (frame.blocksize != _windowsize && frame.blocksize > 4) {  			_windowsize = frame.blocksize;  			_windowcount = 0;  			calculate_window (window' lpc.window_welch' WindowFunction.Welch);  			calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  			calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  			calculate_window (window' lpc.window_hann' WindowFunction.Hann);  			calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  			if (_windowcount == 0)  				throw new Exception ("invalid windowfunction");  		}  		if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  			frame.window_buffer = window;  			frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  			frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  			for (int ch = 0; ch < channels; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			for (int ch = 0; ch < channels; ch++)  				encode_residual_pass2 (frame' ch);  		}  		else {  			//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  			frame.window_buffer = window;  			frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			//for (int ch = 0; ch < 4; ch++)  			//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  			//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  			estimate_frame (frame' true);  			uint fs = measure_frame_size (frame' true);  			if (0 != eparams.variable_block_size) {  				FlacFrame frame2 = new FlacFrame (channels * 2);  				FlacFrame frame3 = new FlacFrame (channels * 2);  				int tumbler = 1;  				while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  					frame2.InitSize (frame.blocksize / 2' true);  					frame2.window_buffer = frame.window_buffer + frame.blocksize;  					frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  					for (int ch = 0; ch < 4; ch++)  						frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame2' true);  					uint fs2 = measure_frame_size (frame2' true);  					uint fs3 = fs2;  					if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  						frame3.InitSize (frame2.blocksize' true);  						frame3.window_buffer = frame2.window_buffer;  						frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  						for (int ch = 0; ch < 4; ch++)  							frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  						estimate_frame (frame3' true);  						fs3 = measure_frame_size (frame3' true);  					}  					if (fs2 + fs3 > fs)  						break;  					FlacFrame tmp = frame;  					frame = frame2;  					frame2 = tmp;  					fs = fs2;  					if (eparams.variable_block_size <= 2)  						break;  					tumbler = 1 - tumbler;  				}  			}  			frame.ChooseSubframes ();  			encode_estimated_frame (frame);  		}  		BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  		output_frame_header (frame' bitwriter);  		output_subframes (frame' bitwriter);  		output_frame_footer (bitwriter);  		if (bitwriter.Length >= max_frame_size)  			throw new Exception ("buffer overflow");  		if (frame_buffer != null) {  			if (eparams.variable_block_size > 0)  				frame_count += frame.blocksize;  			else  				frame_count++;  		}  		size = frame.blocksize;  		return bitwriter.Length;  	}  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (int* s = samplesBuffer' r = residualBuffer)  	fixed (float* window = windowBuffer) {  		frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  		if (frame.blocksize != _windowsize && frame.blocksize > 4) {  			_windowsize = frame.blocksize;  			_windowcount = 0;  			calculate_window (window' lpc.window_welch' WindowFunction.Welch);  			calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  			calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  			calculate_window (window' lpc.window_hann' WindowFunction.Hann);  			calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  			if (_windowcount == 0)  				throw new Exception ("invalid windowfunction");  		}  		if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  			frame.window_buffer = window;  			frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  			frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  			for (int ch = 0; ch < channels; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			for (int ch = 0; ch < channels; ch++)  				encode_residual_pass2 (frame' ch);  		}  		else {  			//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  			frame.window_buffer = window;  			frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			//for (int ch = 0; ch < 4; ch++)  			//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  			//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  			estimate_frame (frame' true);  			uint fs = measure_frame_size (frame' true);  			if (0 != eparams.variable_block_size) {  				FlacFrame frame2 = new FlacFrame (channels * 2);  				FlacFrame frame3 = new FlacFrame (channels * 2);  				int tumbler = 1;  				while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  					frame2.InitSize (frame.blocksize / 2' true);  					frame2.window_buffer = frame.window_buffer + frame.blocksize;  					frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  					for (int ch = 0; ch < 4; ch++)  						frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame2' true);  					uint fs2 = measure_frame_size (frame2' true);  					uint fs3 = fs2;  					if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  						frame3.InitSize (frame2.blocksize' true);  						frame3.window_buffer = frame2.window_buffer;  						frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  						for (int ch = 0; ch < 4; ch++)  							frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  						estimate_frame (frame3' true);  						fs3 = measure_frame_size (frame3' true);  					}  					if (fs2 + fs3 > fs)  						break;  					FlacFrame tmp = frame;  					frame = frame2;  					frame2 = tmp;  					fs = fs2;  					if (eparams.variable_block_size <= 2)  						break;  					tumbler = 1 - tumbler;  				}  			}  			frame.ChooseSubframes ();  			encode_estimated_frame (frame);  		}  		BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  		output_frame_header (frame' bitwriter);  		output_subframes (frame' bitwriter);  		output_frame_footer (bitwriter);  		if (bitwriter.Length >= max_frame_size)  			throw new Exception ("buffer overflow");  		if (frame_buffer != null) {  			if (eparams.variable_block_size > 0)  				frame_count += frame.blocksize;  			else  				frame_count++;  		}  		size = frame.blocksize;  		return bitwriter.Length;  	}  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (int* s = samplesBuffer' r = residualBuffer)  	fixed (float* window = windowBuffer) {  		frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  		if (frame.blocksize != _windowsize && frame.blocksize > 4) {  			_windowsize = frame.blocksize;  			_windowcount = 0;  			calculate_window (window' lpc.window_welch' WindowFunction.Welch);  			calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  			calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  			calculate_window (window' lpc.window_hann' WindowFunction.Hann);  			calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  			if (_windowcount == 0)  				throw new Exception ("invalid windowfunction");  		}  		if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  			frame.window_buffer = window;  			frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  			frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  			for (int ch = 0; ch < channels; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			for (int ch = 0; ch < channels; ch++)  				encode_residual_pass2 (frame' ch);  		}  		else {  			//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  			frame.window_buffer = window;  			frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			//for (int ch = 0; ch < 4; ch++)  			//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  			//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  			estimate_frame (frame' true);  			uint fs = measure_frame_size (frame' true);  			if (0 != eparams.variable_block_size) {  				FlacFrame frame2 = new FlacFrame (channels * 2);  				FlacFrame frame3 = new FlacFrame (channels * 2);  				int tumbler = 1;  				while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  					frame2.InitSize (frame.blocksize / 2' true);  					frame2.window_buffer = frame.window_buffer + frame.blocksize;  					frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  					for (int ch = 0; ch < 4; ch++)  						frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame2' true);  					uint fs2 = measure_frame_size (frame2' true);  					uint fs3 = fs2;  					if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  						frame3.InitSize (frame2.blocksize' true);  						frame3.window_buffer = frame2.window_buffer;  						frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  						for (int ch = 0; ch < 4; ch++)  							frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  						estimate_frame (frame3' true);  						fs3 = measure_frame_size (frame3' true);  					}  					if (fs2 + fs3 > fs)  						break;  					FlacFrame tmp = frame;  					frame = frame2;  					frame2 = tmp;  					fs = fs2;  					if (eparams.variable_block_size <= 2)  						break;  					tumbler = 1 - tumbler;  				}  			}  			frame.ChooseSubframes ();  			encode_estimated_frame (frame);  		}  		BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  		output_frame_header (frame' bitwriter);  		output_subframes (frame' bitwriter);  		output_frame_footer (bitwriter);  		if (bitwriter.Length >= max_frame_size)  			throw new Exception ("buffer overflow");  		if (frame_buffer != null) {  			if (eparams.variable_block_size > 0)  				frame_count += frame.blocksize;  			else  				frame_count++;  		}  		size = frame.blocksize;  		return bitwriter.Length;  	}  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (int* s = samplesBuffer' r = residualBuffer)  	fixed (float* window = windowBuffer) {  		frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  		if (frame.blocksize != _windowsize && frame.blocksize > 4) {  			_windowsize = frame.blocksize;  			_windowcount = 0;  			calculate_window (window' lpc.window_welch' WindowFunction.Welch);  			calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  			calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  			calculate_window (window' lpc.window_hann' WindowFunction.Hann);  			calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  			if (_windowcount == 0)  				throw new Exception ("invalid windowfunction");  		}  		if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  			frame.window_buffer = window;  			frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  			frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  			for (int ch = 0; ch < channels; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			for (int ch = 0; ch < channels; ch++)  				encode_residual_pass2 (frame' ch);  		}  		else {  			//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  			frame.window_buffer = window;  			frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			//for (int ch = 0; ch < 4; ch++)  			//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  			//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  			estimate_frame (frame' true);  			uint fs = measure_frame_size (frame' true);  			if (0 != eparams.variable_block_size) {  				FlacFrame frame2 = new FlacFrame (channels * 2);  				FlacFrame frame3 = new FlacFrame (channels * 2);  				int tumbler = 1;  				while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  					frame2.InitSize (frame.blocksize / 2' true);  					frame2.window_buffer = frame.window_buffer + frame.blocksize;  					frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  					for (int ch = 0; ch < 4; ch++)  						frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame2' true);  					uint fs2 = measure_frame_size (frame2' true);  					uint fs3 = fs2;  					if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  						frame3.InitSize (frame2.blocksize' true);  						frame3.window_buffer = frame2.window_buffer;  						frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  						for (int ch = 0; ch < 4; ch++)  							frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  						estimate_frame (frame3' true);  						fs3 = measure_frame_size (frame3' true);  					}  					if (fs2 + fs3 > fs)  						break;  					FlacFrame tmp = frame;  					frame = frame2;  					frame2 = tmp;  					fs = fs2;  					if (eparams.variable_block_size <= 2)  						break;  					tumbler = 1 - tumbler;  				}  			}  			frame.ChooseSubframes ();  			encode_estimated_frame (frame);  		}  		BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  		output_frame_header (frame' bitwriter);  		output_subframes (frame' bitwriter);  		output_frame_footer (bitwriter);  		if (bitwriter.Length >= max_frame_size)  			throw new Exception ("buffer overflow");  		if (frame_buffer != null) {  			if (eparams.variable_block_size > 0)  				frame_count += frame.blocksize;  			else  				frame_count++;  		}  		size = frame.blocksize;  		return bitwriter.Length;  	}  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (int* s = samplesBuffer' r = residualBuffer)  	fixed (float* window = windowBuffer) {  		frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  		if (frame.blocksize != _windowsize && frame.blocksize > 4) {  			_windowsize = frame.blocksize;  			_windowcount = 0;  			calculate_window (window' lpc.window_welch' WindowFunction.Welch);  			calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  			calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  			calculate_window (window' lpc.window_hann' WindowFunction.Hann);  			calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  			if (_windowcount == 0)  				throw new Exception ("invalid windowfunction");  		}  		if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  			frame.window_buffer = window;  			frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  			frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  			for (int ch = 0; ch < channels; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			for (int ch = 0; ch < channels; ch++)  				encode_residual_pass2 (frame' ch);  		}  		else {  			//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  			frame.window_buffer = window;  			frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			//for (int ch = 0; ch < 4; ch++)  			//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  			//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  			estimate_frame (frame' true);  			uint fs = measure_frame_size (frame' true);  			if (0 != eparams.variable_block_size) {  				FlacFrame frame2 = new FlacFrame (channels * 2);  				FlacFrame frame3 = new FlacFrame (channels * 2);  				int tumbler = 1;  				while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  					frame2.InitSize (frame.blocksize / 2' true);  					frame2.window_buffer = frame.window_buffer + frame.blocksize;  					frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  					for (int ch = 0; ch < 4; ch++)  						frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame2' true);  					uint fs2 = measure_frame_size (frame2' true);  					uint fs3 = fs2;  					if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  						frame3.InitSize (frame2.blocksize' true);  						frame3.window_buffer = frame2.window_buffer;  						frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  						for (int ch = 0; ch < 4; ch++)  							frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  						estimate_frame (frame3' true);  						fs3 = measure_frame_size (frame3' true);  					}  					if (fs2 + fs3 > fs)  						break;  					FlacFrame tmp = frame;  					frame = frame2;  					frame2 = tmp;  					fs = fs2;  					if (eparams.variable_block_size <= 2)  						break;  					tumbler = 1 - tumbler;  				}  			}  			frame.ChooseSubframes ();  			encode_estimated_frame (frame);  		}  		BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  		output_frame_header (frame' bitwriter);  		output_subframes (frame' bitwriter);  		output_frame_footer (bitwriter);  		if (bitwriter.Length >= max_frame_size)  			throw new Exception ("buffer overflow");  		if (frame_buffer != null) {  			if (eparams.variable_block_size > 0)  				frame_count += frame.blocksize;  			else  				frame_count++;  		}  		size = frame.blocksize;  		return bitwriter.Length;  	}  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (int* s = samplesBuffer' r = residualBuffer)  	fixed (float* window = windowBuffer) {  		frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  		if (frame.blocksize != _windowsize && frame.blocksize > 4) {  			_windowsize = frame.blocksize;  			_windowcount = 0;  			calculate_window (window' lpc.window_welch' WindowFunction.Welch);  			calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  			calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  			calculate_window (window' lpc.window_hann' WindowFunction.Hann);  			calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  			if (_windowcount == 0)  				throw new Exception ("invalid windowfunction");  		}  		if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  			frame.window_buffer = window;  			frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  			frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  			for (int ch = 0; ch < channels; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			for (int ch = 0; ch < channels; ch++)  				encode_residual_pass2 (frame' ch);  		}  		else {  			//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  			frame.window_buffer = window;  			frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			//for (int ch = 0; ch < 4; ch++)  			//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  			//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  			estimate_frame (frame' true);  			uint fs = measure_frame_size (frame' true);  			if (0 != eparams.variable_block_size) {  				FlacFrame frame2 = new FlacFrame (channels * 2);  				FlacFrame frame3 = new FlacFrame (channels * 2);  				int tumbler = 1;  				while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  					frame2.InitSize (frame.blocksize / 2' true);  					frame2.window_buffer = frame.window_buffer + frame.blocksize;  					frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  					for (int ch = 0; ch < 4; ch++)  						frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame2' true);  					uint fs2 = measure_frame_size (frame2' true);  					uint fs3 = fs2;  					if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  						frame3.InitSize (frame2.blocksize' true);  						frame3.window_buffer = frame2.window_buffer;  						frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  						for (int ch = 0; ch < 4; ch++)  							frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  						estimate_frame (frame3' true);  						fs3 = measure_frame_size (frame3' true);  					}  					if (fs2 + fs3 > fs)  						break;  					FlacFrame tmp = frame;  					frame = frame2;  					frame2 = tmp;  					fs = fs2;  					if (eparams.variable_block_size <= 2)  						break;  					tumbler = 1 - tumbler;  				}  			}  			frame.ChooseSubframes ();  			encode_estimated_frame (frame);  		}  		BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  		output_frame_header (frame' bitwriter);  		output_subframes (frame' bitwriter);  		output_frame_footer (bitwriter);  		if (bitwriter.Length >= max_frame_size)  			throw new Exception ("buffer overflow");  		if (frame_buffer != null) {  			if (eparams.variable_block_size > 0)  				frame_count += frame.blocksize;  			else  				frame_count++;  		}  		size = frame.blocksize;  		return bitwriter.Length;  	}  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (int* s = samplesBuffer' r = residualBuffer)  	fixed (float* window = windowBuffer) {  		frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  		if (frame.blocksize != _windowsize && frame.blocksize > 4) {  			_windowsize = frame.blocksize;  			_windowcount = 0;  			calculate_window (window' lpc.window_welch' WindowFunction.Welch);  			calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  			calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  			calculate_window (window' lpc.window_hann' WindowFunction.Hann);  			calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  			if (_windowcount == 0)  				throw new Exception ("invalid windowfunction");  		}  		if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  			frame.window_buffer = window;  			frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  			frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  			for (int ch = 0; ch < channels; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			for (int ch = 0; ch < channels; ch++)  				encode_residual_pass2 (frame' ch);  		}  		else {  			//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  			frame.window_buffer = window;  			frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			//for (int ch = 0; ch < 4; ch++)  			//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  			//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  			estimate_frame (frame' true);  			uint fs = measure_frame_size (frame' true);  			if (0 != eparams.variable_block_size) {  				FlacFrame frame2 = new FlacFrame (channels * 2);  				FlacFrame frame3 = new FlacFrame (channels * 2);  				int tumbler = 1;  				while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  					frame2.InitSize (frame.blocksize / 2' true);  					frame2.window_buffer = frame.window_buffer + frame.blocksize;  					frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  					for (int ch = 0; ch < 4; ch++)  						frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame2' true);  					uint fs2 = measure_frame_size (frame2' true);  					uint fs3 = fs2;  					if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  						frame3.InitSize (frame2.blocksize' true);  						frame3.window_buffer = frame2.window_buffer;  						frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  						for (int ch = 0; ch < 4; ch++)  							frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  						estimate_frame (frame3' true);  						fs3 = measure_frame_size (frame3' true);  					}  					if (fs2 + fs3 > fs)  						break;  					FlacFrame tmp = frame;  					frame = frame2;  					frame2 = tmp;  					fs = fs2;  					if (eparams.variable_block_size <= 2)  						break;  					tumbler = 1 - tumbler;  				}  			}  			frame.ChooseSubframes ();  			encode_estimated_frame (frame);  		}  		BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  		output_frame_header (frame' bitwriter);  		output_subframes (frame' bitwriter);  		output_frame_footer (bitwriter);  		if (bitwriter.Length >= max_frame_size)  			throw new Exception ("buffer overflow");  		if (frame_buffer != null) {  			if (eparams.variable_block_size > 0)  				frame_count += frame.blocksize;  			else  				frame_count++;  		}  		size = frame.blocksize;  		return bitwriter.Length;  	}  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (int* s = samplesBuffer' r = residualBuffer)  	fixed (float* window = windowBuffer) {  		frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  		if (frame.blocksize != _windowsize && frame.blocksize > 4) {  			_windowsize = frame.blocksize;  			_windowcount = 0;  			calculate_window (window' lpc.window_welch' WindowFunction.Welch);  			calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  			calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  			calculate_window (window' lpc.window_hann' WindowFunction.Hann);  			calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  			if (_windowcount == 0)  				throw new Exception ("invalid windowfunction");  		}  		if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  			frame.window_buffer = window;  			frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  			frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  			for (int ch = 0; ch < channels; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			for (int ch = 0; ch < channels; ch++)  				encode_residual_pass2 (frame' ch);  		}  		else {  			//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  			frame.window_buffer = window;  			frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			//for (int ch = 0; ch < 4; ch++)  			//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  			//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  			estimate_frame (frame' true);  			uint fs = measure_frame_size (frame' true);  			if (0 != eparams.variable_block_size) {  				FlacFrame frame2 = new FlacFrame (channels * 2);  				FlacFrame frame3 = new FlacFrame (channels * 2);  				int tumbler = 1;  				while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  					frame2.InitSize (frame.blocksize / 2' true);  					frame2.window_buffer = frame.window_buffer + frame.blocksize;  					frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  					for (int ch = 0; ch < 4; ch++)  						frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame2' true);  					uint fs2 = measure_frame_size (frame2' true);  					uint fs3 = fs2;  					if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  						frame3.InitSize (frame2.blocksize' true);  						frame3.window_buffer = frame2.window_buffer;  						frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  						for (int ch = 0; ch < 4; ch++)  							frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  						estimate_frame (frame3' true);  						fs3 = measure_frame_size (frame3' true);  					}  					if (fs2 + fs3 > fs)  						break;  					FlacFrame tmp = frame;  					frame = frame2;  					frame2 = tmp;  					fs = fs2;  					if (eparams.variable_block_size <= 2)  						break;  					tumbler = 1 - tumbler;  				}  			}  			frame.ChooseSubframes ();  			encode_estimated_frame (frame);  		}  		BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  		output_frame_header (frame' bitwriter);  		output_subframes (frame' bitwriter);  		output_frame_footer (bitwriter);  		if (bitwriter.Length >= max_frame_size)  			throw new Exception ("buffer overflow");  		if (frame_buffer != null) {  			if (eparams.variable_block_size > 0)  				frame_count += frame.blocksize;  			else  				frame_count++;  		}  		size = frame.blocksize;  		return bitwriter.Length;  	}  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (int* s = samplesBuffer' r = residualBuffer)  	fixed (float* window = windowBuffer) {  		frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  		if (frame.blocksize != _windowsize && frame.blocksize > 4) {  			_windowsize = frame.blocksize;  			_windowcount = 0;  			calculate_window (window' lpc.window_welch' WindowFunction.Welch);  			calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  			calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  			calculate_window (window' lpc.window_hann' WindowFunction.Hann);  			calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  			if (_windowcount == 0)  				throw new Exception ("invalid windowfunction");  		}  		if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  			frame.window_buffer = window;  			frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  			frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  			for (int ch = 0; ch < channels; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			for (int ch = 0; ch < channels; ch++)  				encode_residual_pass2 (frame' ch);  		}  		else {  			//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  			frame.window_buffer = window;  			frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			//for (int ch = 0; ch < 4; ch++)  			//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  			//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  			estimate_frame (frame' true);  			uint fs = measure_frame_size (frame' true);  			if (0 != eparams.variable_block_size) {  				FlacFrame frame2 = new FlacFrame (channels * 2);  				FlacFrame frame3 = new FlacFrame (channels * 2);  				int tumbler = 1;  				while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  					frame2.InitSize (frame.blocksize / 2' true);  					frame2.window_buffer = frame.window_buffer + frame.blocksize;  					frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  					for (int ch = 0; ch < 4; ch++)  						frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame2' true);  					uint fs2 = measure_frame_size (frame2' true);  					uint fs3 = fs2;  					if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  						frame3.InitSize (frame2.blocksize' true);  						frame3.window_buffer = frame2.window_buffer;  						frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  						for (int ch = 0; ch < 4; ch++)  							frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  						estimate_frame (frame3' true);  						fs3 = measure_frame_size (frame3' true);  					}  					if (fs2 + fs3 > fs)  						break;  					FlacFrame tmp = frame;  					frame = frame2;  					frame2 = tmp;  					fs = fs2;  					if (eparams.variable_block_size <= 2)  						break;  					tumbler = 1 - tumbler;  				}  			}  			frame.ChooseSubframes ();  			encode_estimated_frame (frame);  		}  		BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  		output_frame_header (frame' bitwriter);  		output_subframes (frame' bitwriter);  		output_frame_footer (bitwriter);  		if (bitwriter.Length >= max_frame_size)  			throw new Exception ("buffer overflow");  		if (frame_buffer != null) {  			if (eparams.variable_block_size > 0)  				frame_count += frame.blocksize;  			else  				frame_count++;  		}  		size = frame.blocksize;  		return bitwriter.Length;  	}  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (int* s = samplesBuffer' r = residualBuffer)  	fixed (float* window = windowBuffer) {  		frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  		if (frame.blocksize != _windowsize && frame.blocksize > 4) {  			_windowsize = frame.blocksize;  			_windowcount = 0;  			calculate_window (window' lpc.window_welch' WindowFunction.Welch);  			calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  			calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  			calculate_window (window' lpc.window_hann' WindowFunction.Hann);  			calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  			if (_windowcount == 0)  				throw new Exception ("invalid windowfunction");  		}  		if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  			frame.window_buffer = window;  			frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  			frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  			for (int ch = 0; ch < channels; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			for (int ch = 0; ch < channels; ch++)  				encode_residual_pass2 (frame' ch);  		}  		else {  			//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  			frame.window_buffer = window;  			frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			//for (int ch = 0; ch < 4; ch++)  			//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  			//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  			estimate_frame (frame' true);  			uint fs = measure_frame_size (frame' true);  			if (0 != eparams.variable_block_size) {  				FlacFrame frame2 = new FlacFrame (channels * 2);  				FlacFrame frame3 = new FlacFrame (channels * 2);  				int tumbler = 1;  				while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  					frame2.InitSize (frame.blocksize / 2' true);  					frame2.window_buffer = frame.window_buffer + frame.blocksize;  					frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  					for (int ch = 0; ch < 4; ch++)  						frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame2' true);  					uint fs2 = measure_frame_size (frame2' true);  					uint fs3 = fs2;  					if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  						frame3.InitSize (frame2.blocksize' true);  						frame3.window_buffer = frame2.window_buffer;  						frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  						for (int ch = 0; ch < 4; ch++)  							frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  						estimate_frame (frame3' true);  						fs3 = measure_frame_size (frame3' true);  					}  					if (fs2 + fs3 > fs)  						break;  					FlacFrame tmp = frame;  					frame = frame2;  					frame2 = tmp;  					fs = fs2;  					if (eparams.variable_block_size <= 2)  						break;  					tumbler = 1 - tumbler;  				}  			}  			frame.ChooseSubframes ();  			encode_estimated_frame (frame);  		}  		BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  		output_frame_header (frame' bitwriter);  		output_subframes (frame' bitwriter);  		output_frame_footer (bitwriter);  		if (bitwriter.Length >= max_frame_size)  			throw new Exception ("buffer overflow");  		if (frame_buffer != null) {  			if (eparams.variable_block_size > 0)  				frame_count += frame.blocksize;  			else  				frame_count++;  		}  		size = frame.blocksize;  		return bitwriter.Length;  	}  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (int* s = samplesBuffer' r = residualBuffer)  	fixed (float* window = windowBuffer) {  		frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  		if (frame.blocksize != _windowsize && frame.blocksize > 4) {  			_windowsize = frame.blocksize;  			_windowcount = 0;  			calculate_window (window' lpc.window_welch' WindowFunction.Welch);  			calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  			calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  			calculate_window (window' lpc.window_hann' WindowFunction.Hann);  			calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  			if (_windowcount == 0)  				throw new Exception ("invalid windowfunction");  		}  		if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  			frame.window_buffer = window;  			frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  			frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  			for (int ch = 0; ch < channels; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			for (int ch = 0; ch < channels; ch++)  				encode_residual_pass2 (frame' ch);  		}  		else {  			//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  			frame.window_buffer = window;  			frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			//for (int ch = 0; ch < 4; ch++)  			//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  			//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  			estimate_frame (frame' true);  			uint fs = measure_frame_size (frame' true);  			if (0 != eparams.variable_block_size) {  				FlacFrame frame2 = new FlacFrame (channels * 2);  				FlacFrame frame3 = new FlacFrame (channels * 2);  				int tumbler = 1;  				while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  					frame2.InitSize (frame.blocksize / 2' true);  					frame2.window_buffer = frame.window_buffer + frame.blocksize;  					frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  					for (int ch = 0; ch < 4; ch++)  						frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame2' true);  					uint fs2 = measure_frame_size (frame2' true);  					uint fs3 = fs2;  					if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  						frame3.InitSize (frame2.blocksize' true);  						frame3.window_buffer = frame2.window_buffer;  						frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  						for (int ch = 0; ch < 4; ch++)  							frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  						estimate_frame (frame3' true);  						fs3 = measure_frame_size (frame3' true);  					}  					if (fs2 + fs3 > fs)  						break;  					FlacFrame tmp = frame;  					frame = frame2;  					frame2 = tmp;  					fs = fs2;  					if (eparams.variable_block_size <= 2)  						break;  					tumbler = 1 - tumbler;  				}  			}  			frame.ChooseSubframes ();  			encode_estimated_frame (frame);  		}  		BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  		output_frame_header (frame' bitwriter);  		output_subframes (frame' bitwriter);  		output_frame_footer (bitwriter);  		if (bitwriter.Length >= max_frame_size)  			throw new Exception ("buffer overflow");  		if (frame_buffer != null) {  			if (eparams.variable_block_size > 0)  				frame_count += frame.blocksize;  			else  				frame_count++;  		}  		size = frame.blocksize;  		return bitwriter.Length;  	}  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (int* s = samplesBuffer' r = residualBuffer)  	fixed (float* window = windowBuffer) {  		frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  		if (frame.blocksize != _windowsize && frame.blocksize > 4) {  			_windowsize = frame.blocksize;  			_windowcount = 0;  			calculate_window (window' lpc.window_welch' WindowFunction.Welch);  			calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  			calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  			calculate_window (window' lpc.window_hann' WindowFunction.Hann);  			calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  			if (_windowcount == 0)  				throw new Exception ("invalid windowfunction");  		}  		if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  			frame.window_buffer = window;  			frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  			frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  			for (int ch = 0; ch < channels; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			for (int ch = 0; ch < channels; ch++)  				encode_residual_pass2 (frame' ch);  		}  		else {  			//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  			frame.window_buffer = window;  			frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			//for (int ch = 0; ch < 4; ch++)  			//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  			//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  			estimate_frame (frame' true);  			uint fs = measure_frame_size (frame' true);  			if (0 != eparams.variable_block_size) {  				FlacFrame frame2 = new FlacFrame (channels * 2);  				FlacFrame frame3 = new FlacFrame (channels * 2);  				int tumbler = 1;  				while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  					frame2.InitSize (frame.blocksize / 2' true);  					frame2.window_buffer = frame.window_buffer + frame.blocksize;  					frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  					for (int ch = 0; ch < 4; ch++)  						frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame2' true);  					uint fs2 = measure_frame_size (frame2' true);  					uint fs3 = fs2;  					if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  						frame3.InitSize (frame2.blocksize' true);  						frame3.window_buffer = frame2.window_buffer;  						frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  						for (int ch = 0; ch < 4; ch++)  							frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  						estimate_frame (frame3' true);  						fs3 = measure_frame_size (frame3' true);  					}  					if (fs2 + fs3 > fs)  						break;  					FlacFrame tmp = frame;  					frame = frame2;  					frame2 = tmp;  					fs = fs2;  					if (eparams.variable_block_size <= 2)  						break;  					tumbler = 1 - tumbler;  				}  			}  			frame.ChooseSubframes ();  			encode_estimated_frame (frame);  		}  		BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  		output_frame_header (frame' bitwriter);  		output_subframes (frame' bitwriter);  		output_frame_footer (bitwriter);  		if (bitwriter.Length >= max_frame_size)  			throw new Exception ("buffer overflow");  		if (frame_buffer != null) {  			if (eparams.variable_block_size > 0)  				frame_count += frame.blocksize;  			else  				frame_count++;  		}  		size = frame.blocksize;  		return bitwriter.Length;  	}  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (int* s = samplesBuffer' r = residualBuffer)  	fixed (float* window = windowBuffer) {  		frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  		if (frame.blocksize != _windowsize && frame.blocksize > 4) {  			_windowsize = frame.blocksize;  			_windowcount = 0;  			calculate_window (window' lpc.window_welch' WindowFunction.Welch);  			calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  			calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  			calculate_window (window' lpc.window_hann' WindowFunction.Hann);  			calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  			if (_windowcount == 0)  				throw new Exception ("invalid windowfunction");  		}  		if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  			frame.window_buffer = window;  			frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  			frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  			for (int ch = 0; ch < channels; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			for (int ch = 0; ch < channels; ch++)  				encode_residual_pass2 (frame' ch);  		}  		else {  			//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  			frame.window_buffer = window;  			frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			//for (int ch = 0; ch < 4; ch++)  			//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  			//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  			estimate_frame (frame' true);  			uint fs = measure_frame_size (frame' true);  			if (0 != eparams.variable_block_size) {  				FlacFrame frame2 = new FlacFrame (channels * 2);  				FlacFrame frame3 = new FlacFrame (channels * 2);  				int tumbler = 1;  				while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  					frame2.InitSize (frame.blocksize / 2' true);  					frame2.window_buffer = frame.window_buffer + frame.blocksize;  					frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  					for (int ch = 0; ch < 4; ch++)  						frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame2' true);  					uint fs2 = measure_frame_size (frame2' true);  					uint fs3 = fs2;  					if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  						frame3.InitSize (frame2.blocksize' true);  						frame3.window_buffer = frame2.window_buffer;  						frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  						for (int ch = 0; ch < 4; ch++)  							frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  						estimate_frame (frame3' true);  						fs3 = measure_frame_size (frame3' true);  					}  					if (fs2 + fs3 > fs)  						break;  					FlacFrame tmp = frame;  					frame = frame2;  					frame2 = tmp;  					fs = fs2;  					if (eparams.variable_block_size <= 2)  						break;  					tumbler = 1 - tumbler;  				}  			}  			frame.ChooseSubframes ();  			encode_estimated_frame (frame);  		}  		BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  		output_frame_header (frame' bitwriter);  		output_subframes (frame' bitwriter);  		output_frame_footer (bitwriter);  		if (bitwriter.Length >= max_frame_size)  			throw new Exception ("buffer overflow");  		if (frame_buffer != null) {  			if (eparams.variable_block_size > 0)  				frame_count += frame.blocksize;  			else  				frame_count++;  		}  		size = frame.blocksize;  		return bitwriter.Length;  	}  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (int* s = samplesBuffer' r = residualBuffer)  	fixed (float* window = windowBuffer) {  		frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  		if (frame.blocksize != _windowsize && frame.blocksize > 4) {  			_windowsize = frame.blocksize;  			_windowcount = 0;  			calculate_window (window' lpc.window_welch' WindowFunction.Welch);  			calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  			calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  			calculate_window (window' lpc.window_hann' WindowFunction.Hann);  			calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  			if (_windowcount == 0)  				throw new Exception ("invalid windowfunction");  		}  		if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  			frame.window_buffer = window;  			frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  			frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  			for (int ch = 0; ch < channels; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			for (int ch = 0; ch < channels; ch++)  				encode_residual_pass2 (frame' ch);  		}  		else {  			//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  			frame.window_buffer = window;  			frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			//for (int ch = 0; ch < 4; ch++)  			//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  			//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  			estimate_frame (frame' true);  			uint fs = measure_frame_size (frame' true);  			if (0 != eparams.variable_block_size) {  				FlacFrame frame2 = new FlacFrame (channels * 2);  				FlacFrame frame3 = new FlacFrame (channels * 2);  				int tumbler = 1;  				while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  					frame2.InitSize (frame.blocksize / 2' true);  					frame2.window_buffer = frame.window_buffer + frame.blocksize;  					frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  					for (int ch = 0; ch < 4; ch++)  						frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame2' true);  					uint fs2 = measure_frame_size (frame2' true);  					uint fs3 = fs2;  					if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  						frame3.InitSize (frame2.blocksize' true);  						frame3.window_buffer = frame2.window_buffer;  						frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  						for (int ch = 0; ch < 4; ch++)  							frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  						estimate_frame (frame3' true);  						fs3 = measure_frame_size (frame3' true);  					}  					if (fs2 + fs3 > fs)  						break;  					FlacFrame tmp = frame;  					frame = frame2;  					frame2 = tmp;  					fs = fs2;  					if (eparams.variable_block_size <= 2)  						break;  					tumbler = 1 - tumbler;  				}  			}  			frame.ChooseSubframes ();  			encode_estimated_frame (frame);  		}  		BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  		output_frame_header (frame' bitwriter);  		output_subframes (frame' bitwriter);  		output_frame_footer (bitwriter);  		if (bitwriter.Length >= max_frame_size)  			throw new Exception ("buffer overflow");  		if (frame_buffer != null) {  			if (eparams.variable_block_size > 0)  				frame_count += frame.blocksize;  			else  				frame_count++;  		}  		size = frame.blocksize;  		return bitwriter.Length;  	}  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (int* s = samplesBuffer' r = residualBuffer)  	fixed (float* window = windowBuffer) {  		frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  		if (frame.blocksize != _windowsize && frame.blocksize > 4) {  			_windowsize = frame.blocksize;  			_windowcount = 0;  			calculate_window (window' lpc.window_welch' WindowFunction.Welch);  			calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  			calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  			calculate_window (window' lpc.window_hann' WindowFunction.Hann);  			calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  			if (_windowcount == 0)  				throw new Exception ("invalid windowfunction");  		}  		if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  			frame.window_buffer = window;  			frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  			frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  			for (int ch = 0; ch < channels; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			for (int ch = 0; ch < channels; ch++)  				encode_residual_pass2 (frame' ch);  		}  		else {  			//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  			frame.window_buffer = window;  			frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			//for (int ch = 0; ch < 4; ch++)  			//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  			//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  			estimate_frame (frame' true);  			uint fs = measure_frame_size (frame' true);  			if (0 != eparams.variable_block_size) {  				FlacFrame frame2 = new FlacFrame (channels * 2);  				FlacFrame frame3 = new FlacFrame (channels * 2);  				int tumbler = 1;  				while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  					frame2.InitSize (frame.blocksize / 2' true);  					frame2.window_buffer = frame.window_buffer + frame.blocksize;  					frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  					for (int ch = 0; ch < 4; ch++)  						frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame2' true);  					uint fs2 = measure_frame_size (frame2' true);  					uint fs3 = fs2;  					if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  						frame3.InitSize (frame2.blocksize' true);  						frame3.window_buffer = frame2.window_buffer;  						frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  						for (int ch = 0; ch < 4; ch++)  							frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  						estimate_frame (frame3' true);  						fs3 = measure_frame_size (frame3' true);  					}  					if (fs2 + fs3 > fs)  						break;  					FlacFrame tmp = frame;  					frame = frame2;  					frame2 = tmp;  					fs = fs2;  					if (eparams.variable_block_size <= 2)  						break;  					tumbler = 1 - tumbler;  				}  			}  			frame.ChooseSubframes ();  			encode_estimated_frame (frame);  		}  		BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  		output_frame_header (frame' bitwriter);  		output_subframes (frame' bitwriter);  		output_frame_footer (bitwriter);  		if (bitwriter.Length >= max_frame_size)  			throw new Exception ("buffer overflow");  		if (frame_buffer != null) {  			if (eparams.variable_block_size > 0)  				frame_count += frame.blocksize;  			else  				frame_count++;  		}  		size = frame.blocksize;  		return bitwriter.Length;  	}  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (int* s = samplesBuffer' r = residualBuffer)  	fixed (float* window = windowBuffer) {  		frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  		if (frame.blocksize != _windowsize && frame.blocksize > 4) {  			_windowsize = frame.blocksize;  			_windowcount = 0;  			calculate_window (window' lpc.window_welch' WindowFunction.Welch);  			calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  			calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  			calculate_window (window' lpc.window_hann' WindowFunction.Hann);  			calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  			if (_windowcount == 0)  				throw new Exception ("invalid windowfunction");  		}  		if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  			frame.window_buffer = window;  			frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  			frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  			for (int ch = 0; ch < channels; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			for (int ch = 0; ch < channels; ch++)  				encode_residual_pass2 (frame' ch);  		}  		else {  			//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  			frame.window_buffer = window;  			frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			//for (int ch = 0; ch < 4; ch++)  			//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  			//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  			estimate_frame (frame' true);  			uint fs = measure_frame_size (frame' true);  			if (0 != eparams.variable_block_size) {  				FlacFrame frame2 = new FlacFrame (channels * 2);  				FlacFrame frame3 = new FlacFrame (channels * 2);  				int tumbler = 1;  				while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  					frame2.InitSize (frame.blocksize / 2' true);  					frame2.window_buffer = frame.window_buffer + frame.blocksize;  					frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  					for (int ch = 0; ch < 4; ch++)  						frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame2' true);  					uint fs2 = measure_frame_size (frame2' true);  					uint fs3 = fs2;  					if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  						frame3.InitSize (frame2.blocksize' true);  						frame3.window_buffer = frame2.window_buffer;  						frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  						for (int ch = 0; ch < 4; ch++)  							frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  						estimate_frame (frame3' true);  						fs3 = measure_frame_size (frame3' true);  					}  					if (fs2 + fs3 > fs)  						break;  					FlacFrame tmp = frame;  					frame = frame2;  					frame2 = tmp;  					fs = fs2;  					if (eparams.variable_block_size <= 2)  						break;  					tumbler = 1 - tumbler;  				}  			}  			frame.ChooseSubframes ();  			encode_estimated_frame (frame);  		}  		BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  		output_frame_header (frame' bitwriter);  		output_subframes (frame' bitwriter);  		output_frame_footer (bitwriter);  		if (bitwriter.Length >= max_frame_size)  			throw new Exception ("buffer overflow");  		if (frame_buffer != null) {  			if (eparams.variable_block_size > 0)  				frame_count += frame.blocksize;  			else  				frame_count++;  		}  		size = frame.blocksize;  		return bitwriter.Length;  	}  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (int* s = samplesBuffer' r = residualBuffer)  	fixed (float* window = windowBuffer) {  		frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  		if (frame.blocksize != _windowsize && frame.blocksize > 4) {  			_windowsize = frame.blocksize;  			_windowcount = 0;  			calculate_window (window' lpc.window_welch' WindowFunction.Welch);  			calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  			calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  			calculate_window (window' lpc.window_hann' WindowFunction.Hann);  			calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  			if (_windowcount == 0)  				throw new Exception ("invalid windowfunction");  		}  		if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  			frame.window_buffer = window;  			frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  			frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  			for (int ch = 0; ch < channels; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			for (int ch = 0; ch < channels; ch++)  				encode_residual_pass2 (frame' ch);  		}  		else {  			//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  			frame.window_buffer = window;  			frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			//for (int ch = 0; ch < 4; ch++)  			//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  			//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  			estimate_frame (frame' true);  			uint fs = measure_frame_size (frame' true);  			if (0 != eparams.variable_block_size) {  				FlacFrame frame2 = new FlacFrame (channels * 2);  				FlacFrame frame3 = new FlacFrame (channels * 2);  				int tumbler = 1;  				while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  					frame2.InitSize (frame.blocksize / 2' true);  					frame2.window_buffer = frame.window_buffer + frame.blocksize;  					frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  					for (int ch = 0; ch < 4; ch++)  						frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame2' true);  					uint fs2 = measure_frame_size (frame2' true);  					uint fs3 = fs2;  					if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  						frame3.InitSize (frame2.blocksize' true);  						frame3.window_buffer = frame2.window_buffer;  						frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  						for (int ch = 0; ch < 4; ch++)  							frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  						estimate_frame (frame3' true);  						fs3 = measure_frame_size (frame3' true);  					}  					if (fs2 + fs3 > fs)  						break;  					FlacFrame tmp = frame;  					frame = frame2;  					frame2 = tmp;  					fs = fs2;  					if (eparams.variable_block_size <= 2)  						break;  					tumbler = 1 - tumbler;  				}  			}  			frame.ChooseSubframes ();  			encode_estimated_frame (frame);  		}  		BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  		output_frame_header (frame' bitwriter);  		output_subframes (frame' bitwriter);  		output_frame_footer (bitwriter);  		if (bitwriter.Length >= max_frame_size)  			throw new Exception ("buffer overflow");  		if (frame_buffer != null) {  			if (eparams.variable_block_size > 0)  				frame_count += frame.blocksize;  			else  				frame_count++;  		}  		size = frame.blocksize;  		return bitwriter.Length;  	}  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (int* s = samplesBuffer' r = residualBuffer)  	fixed (float* window = windowBuffer) {  		frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  		if (frame.blocksize != _windowsize && frame.blocksize > 4) {  			_windowsize = frame.blocksize;  			_windowcount = 0;  			calculate_window (window' lpc.window_welch' WindowFunction.Welch);  			calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  			calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  			calculate_window (window' lpc.window_hann' WindowFunction.Hann);  			calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  			if (_windowcount == 0)  				throw new Exception ("invalid windowfunction");  		}  		if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  			frame.window_buffer = window;  			frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  			frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  			for (int ch = 0; ch < channels; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			for (int ch = 0; ch < channels; ch++)  				encode_residual_pass2 (frame' ch);  		}  		else {  			//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  			frame.window_buffer = window;  			frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  			//for (int ch = 0; ch < 4; ch++)  			//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  			//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  			estimate_frame (frame' true);  			uint fs = measure_frame_size (frame' true);  			if (0 != eparams.variable_block_size) {  				FlacFrame frame2 = new FlacFrame (channels * 2);  				FlacFrame frame3 = new FlacFrame (channels * 2);  				int tumbler = 1;  				while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  					frame2.InitSize (frame.blocksize / 2' true);  					frame2.window_buffer = frame.window_buffer + frame.blocksize;  					frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  					for (int ch = 0; ch < 4; ch++)  						frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame2' true);  					uint fs2 = measure_frame_size (frame2' true);  					uint fs3 = fs2;  					if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  						frame3.InitSize (frame2.blocksize' true);  						frame3.window_buffer = frame2.window_buffer;  						frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  						for (int ch = 0; ch < 4; ch++)  							frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  						estimate_frame (frame3' true);  						fs3 = measure_frame_size (frame3' true);  					}  					if (fs2 + fs3 > fs)  						break;  					FlacFrame tmp = frame;  					frame = frame2;  					frame2 = tmp;  					fs = fs2;  					if (eparams.variable_block_size <= 2)  						break;  					tumbler = 1 - tumbler;  				}  			}  			frame.ChooseSubframes ();  			encode_estimated_frame (frame);  		}  		BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  		output_frame_header (frame' bitwriter);  		output_subframes (frame' bitwriter);  		output_frame_footer (bitwriter);  		if (bitwriter.Length >= max_frame_size)  			throw new Exception ("buffer overflow");  		if (frame_buffer != null) {  			if (eparams.variable_block_size > 0)  				frame_count += frame.blocksize;  			else  				frame_count++;  		}  		size = frame.blocksize;  		return bitwriter.Length;  	}  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (float* window = windowBuffer) {  	frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  	if (frame.blocksize != _windowsize && frame.blocksize > 4) {  		_windowsize = frame.blocksize;  		_windowcount = 0;  		calculate_window (window' lpc.window_welch' WindowFunction.Welch);  		calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  		calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  		calculate_window (window' lpc.window_hann' WindowFunction.Hann);  		calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  		if (_windowcount == 0)  			throw new Exception ("invalid windowfunction");  	}  	if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  		frame.window_buffer = window;  		frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  		frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  		for (int ch = 0; ch < channels; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		for (int ch = 0; ch < channels; ch++)  			encode_residual_pass2 (frame' ch);  	}  	else {  		//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  		frame.window_buffer = window;  		frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  		for (int ch = 0; ch < 4; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		//for (int ch = 0; ch < 4; ch++)  		//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  		//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  		estimate_frame (frame' true);  		uint fs = measure_frame_size (frame' true);  		if (0 != eparams.variable_block_size) {  			FlacFrame frame2 = new FlacFrame (channels * 2);  			FlacFrame frame3 = new FlacFrame (channels * 2);  			int tumbler = 1;  			while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  				frame2.InitSize (frame.blocksize / 2' true);  				frame2.window_buffer = frame.window_buffer + frame.blocksize;  				frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  				for (int ch = 0; ch < 4; ch++)  					frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame2' true);  				uint fs2 = measure_frame_size (frame2' true);  				uint fs3 = fs2;  				if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  					frame3.InitSize (frame2.blocksize' true);  					frame3.window_buffer = frame2.window_buffer;  					frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  					for (int ch = 0; ch < 4; ch++)  						frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame3' true);  					fs3 = measure_frame_size (frame3' true);  				}  				if (fs2 + fs3 > fs)  					break;  				FlacFrame tmp = frame;  				frame = frame2;  				frame2 = tmp;  				fs = fs2;  				if (eparams.variable_block_size <= 2)  					break;  				tumbler = 1 - tumbler;  			}  		}  		frame.ChooseSubframes ();  		encode_estimated_frame (frame);  	}  	BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  	output_frame_header (frame' bitwriter);  	output_subframes (frame' bitwriter);  	output_frame_footer (bitwriter);  	if (bitwriter.Length >= max_frame_size)  		throw new Exception ("buffer overflow");  	if (frame_buffer != null) {  		if (eparams.variable_block_size > 0)  			frame_count += frame.blocksize;  		else  			frame_count++;  	}  	size = frame.blocksize;  	return bitwriter.Length;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (float* window = windowBuffer) {  	frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  	if (frame.blocksize != _windowsize && frame.blocksize > 4) {  		_windowsize = frame.blocksize;  		_windowcount = 0;  		calculate_window (window' lpc.window_welch' WindowFunction.Welch);  		calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  		calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  		calculate_window (window' lpc.window_hann' WindowFunction.Hann);  		calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  		if (_windowcount == 0)  			throw new Exception ("invalid windowfunction");  	}  	if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  		frame.window_buffer = window;  		frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  		frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  		for (int ch = 0; ch < channels; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		for (int ch = 0; ch < channels; ch++)  			encode_residual_pass2 (frame' ch);  	}  	else {  		//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  		frame.window_buffer = window;  		frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  		for (int ch = 0; ch < 4; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		//for (int ch = 0; ch < 4; ch++)  		//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  		//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  		estimate_frame (frame' true);  		uint fs = measure_frame_size (frame' true);  		if (0 != eparams.variable_block_size) {  			FlacFrame frame2 = new FlacFrame (channels * 2);  			FlacFrame frame3 = new FlacFrame (channels * 2);  			int tumbler = 1;  			while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  				frame2.InitSize (frame.blocksize / 2' true);  				frame2.window_buffer = frame.window_buffer + frame.blocksize;  				frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  				for (int ch = 0; ch < 4; ch++)  					frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame2' true);  				uint fs2 = measure_frame_size (frame2' true);  				uint fs3 = fs2;  				if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  					frame3.InitSize (frame2.blocksize' true);  					frame3.window_buffer = frame2.window_buffer;  					frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  					for (int ch = 0; ch < 4; ch++)  						frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame3' true);  					fs3 = measure_frame_size (frame3' true);  				}  				if (fs2 + fs3 > fs)  					break;  				FlacFrame tmp = frame;  				frame = frame2;  				frame2 = tmp;  				fs = fs2;  				if (eparams.variable_block_size <= 2)  					break;  				tumbler = 1 - tumbler;  			}  		}  		frame.ChooseSubframes ();  		encode_estimated_frame (frame);  	}  	BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  	output_frame_header (frame' bitwriter);  	output_subframes (frame' bitwriter);  	output_frame_footer (bitwriter);  	if (bitwriter.Length >= max_frame_size)  		throw new Exception ("buffer overflow");  	if (frame_buffer != null) {  		if (eparams.variable_block_size > 0)  			frame_count += frame.blocksize;  		else  			frame_count++;  	}  	size = frame.blocksize;  	return bitwriter.Length;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (float* window = windowBuffer) {  	frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  	if (frame.blocksize != _windowsize && frame.blocksize > 4) {  		_windowsize = frame.blocksize;  		_windowcount = 0;  		calculate_window (window' lpc.window_welch' WindowFunction.Welch);  		calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  		calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  		calculate_window (window' lpc.window_hann' WindowFunction.Hann);  		calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  		if (_windowcount == 0)  			throw new Exception ("invalid windowfunction");  	}  	if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  		frame.window_buffer = window;  		frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  		frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  		for (int ch = 0; ch < channels; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		for (int ch = 0; ch < channels; ch++)  			encode_residual_pass2 (frame' ch);  	}  	else {  		//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  		frame.window_buffer = window;  		frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  		for (int ch = 0; ch < 4; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		//for (int ch = 0; ch < 4; ch++)  		//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  		//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  		estimate_frame (frame' true);  		uint fs = measure_frame_size (frame' true);  		if (0 != eparams.variable_block_size) {  			FlacFrame frame2 = new FlacFrame (channels * 2);  			FlacFrame frame3 = new FlacFrame (channels * 2);  			int tumbler = 1;  			while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  				frame2.InitSize (frame.blocksize / 2' true);  				frame2.window_buffer = frame.window_buffer + frame.blocksize;  				frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  				for (int ch = 0; ch < 4; ch++)  					frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame2' true);  				uint fs2 = measure_frame_size (frame2' true);  				uint fs3 = fs2;  				if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  					frame3.InitSize (frame2.blocksize' true);  					frame3.window_buffer = frame2.window_buffer;  					frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  					for (int ch = 0; ch < 4; ch++)  						frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame3' true);  					fs3 = measure_frame_size (frame3' true);  				}  				if (fs2 + fs3 > fs)  					break;  				FlacFrame tmp = frame;  				frame = frame2;  				frame2 = tmp;  				fs = fs2;  				if (eparams.variable_block_size <= 2)  					break;  				tumbler = 1 - tumbler;  			}  		}  		frame.ChooseSubframes ();  		encode_estimated_frame (frame);  	}  	BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  	output_frame_header (frame' bitwriter);  	output_subframes (frame' bitwriter);  	output_frame_footer (bitwriter);  	if (bitwriter.Length >= max_frame_size)  		throw new Exception ("buffer overflow");  	if (frame_buffer != null) {  		if (eparams.variable_block_size > 0)  			frame_count += frame.blocksize;  		else  			frame_count++;  	}  	size = frame.blocksize;  	return bitwriter.Length;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (float* window = windowBuffer) {  	frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  	if (frame.blocksize != _windowsize && frame.blocksize > 4) {  		_windowsize = frame.blocksize;  		_windowcount = 0;  		calculate_window (window' lpc.window_welch' WindowFunction.Welch);  		calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  		calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  		calculate_window (window' lpc.window_hann' WindowFunction.Hann);  		calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  		if (_windowcount == 0)  			throw new Exception ("invalid windowfunction");  	}  	if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  		frame.window_buffer = window;  		frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  		frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  		for (int ch = 0; ch < channels; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		for (int ch = 0; ch < channels; ch++)  			encode_residual_pass2 (frame' ch);  	}  	else {  		//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  		frame.window_buffer = window;  		frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  		for (int ch = 0; ch < 4; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		//for (int ch = 0; ch < 4; ch++)  		//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  		//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  		estimate_frame (frame' true);  		uint fs = measure_frame_size (frame' true);  		if (0 != eparams.variable_block_size) {  			FlacFrame frame2 = new FlacFrame (channels * 2);  			FlacFrame frame3 = new FlacFrame (channels * 2);  			int tumbler = 1;  			while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  				frame2.InitSize (frame.blocksize / 2' true);  				frame2.window_buffer = frame.window_buffer + frame.blocksize;  				frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  				for (int ch = 0; ch < 4; ch++)  					frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame2' true);  				uint fs2 = measure_frame_size (frame2' true);  				uint fs3 = fs2;  				if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  					frame3.InitSize (frame2.blocksize' true);  					frame3.window_buffer = frame2.window_buffer;  					frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  					for (int ch = 0; ch < 4; ch++)  						frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame3' true);  					fs3 = measure_frame_size (frame3' true);  				}  				if (fs2 + fs3 > fs)  					break;  				FlacFrame tmp = frame;  				frame = frame2;  				frame2 = tmp;  				fs = fs2;  				if (eparams.variable_block_size <= 2)  					break;  				tumbler = 1 - tumbler;  			}  		}  		frame.ChooseSubframes ();  		encode_estimated_frame (frame);  	}  	BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  	output_frame_header (frame' bitwriter);  	output_subframes (frame' bitwriter);  	output_frame_footer (bitwriter);  	if (bitwriter.Length >= max_frame_size)  		throw new Exception ("buffer overflow");  	if (frame_buffer != null) {  		if (eparams.variable_block_size > 0)  			frame_count += frame.blocksize;  		else  			frame_count++;  	}  	size = frame.blocksize;  	return bitwriter.Length;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (float* window = windowBuffer) {  	frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  	if (frame.blocksize != _windowsize && frame.blocksize > 4) {  		_windowsize = frame.blocksize;  		_windowcount = 0;  		calculate_window (window' lpc.window_welch' WindowFunction.Welch);  		calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  		calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  		calculate_window (window' lpc.window_hann' WindowFunction.Hann);  		calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  		if (_windowcount == 0)  			throw new Exception ("invalid windowfunction");  	}  	if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  		frame.window_buffer = window;  		frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  		frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  		for (int ch = 0; ch < channels; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		for (int ch = 0; ch < channels; ch++)  			encode_residual_pass2 (frame' ch);  	}  	else {  		//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  		frame.window_buffer = window;  		frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  		for (int ch = 0; ch < 4; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		//for (int ch = 0; ch < 4; ch++)  		//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  		//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  		estimate_frame (frame' true);  		uint fs = measure_frame_size (frame' true);  		if (0 != eparams.variable_block_size) {  			FlacFrame frame2 = new FlacFrame (channels * 2);  			FlacFrame frame3 = new FlacFrame (channels * 2);  			int tumbler = 1;  			while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  				frame2.InitSize (frame.blocksize / 2' true);  				frame2.window_buffer = frame.window_buffer + frame.blocksize;  				frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  				for (int ch = 0; ch < 4; ch++)  					frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame2' true);  				uint fs2 = measure_frame_size (frame2' true);  				uint fs3 = fs2;  				if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  					frame3.InitSize (frame2.blocksize' true);  					frame3.window_buffer = frame2.window_buffer;  					frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  					for (int ch = 0; ch < 4; ch++)  						frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame3' true);  					fs3 = measure_frame_size (frame3' true);  				}  				if (fs2 + fs3 > fs)  					break;  				FlacFrame tmp = frame;  				frame = frame2;  				frame2 = tmp;  				fs = fs2;  				if (eparams.variable_block_size <= 2)  					break;  				tumbler = 1 - tumbler;  			}  		}  		frame.ChooseSubframes ();  		encode_estimated_frame (frame);  	}  	BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  	output_frame_header (frame' bitwriter);  	output_subframes (frame' bitwriter);  	output_frame_footer (bitwriter);  	if (bitwriter.Length >= max_frame_size)  		throw new Exception ("buffer overflow");  	if (frame_buffer != null) {  		if (eparams.variable_block_size > 0)  			frame_count += frame.blocksize;  		else  			frame_count++;  	}  	size = frame.blocksize;  	return bitwriter.Length;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (float* window = windowBuffer) {  	frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  	if (frame.blocksize != _windowsize && frame.blocksize > 4) {  		_windowsize = frame.blocksize;  		_windowcount = 0;  		calculate_window (window' lpc.window_welch' WindowFunction.Welch);  		calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  		calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  		calculate_window (window' lpc.window_hann' WindowFunction.Hann);  		calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  		if (_windowcount == 0)  			throw new Exception ("invalid windowfunction");  	}  	if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  		frame.window_buffer = window;  		frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  		frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  		for (int ch = 0; ch < channels; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		for (int ch = 0; ch < channels; ch++)  			encode_residual_pass2 (frame' ch);  	}  	else {  		//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  		frame.window_buffer = window;  		frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  		for (int ch = 0; ch < 4; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		//for (int ch = 0; ch < 4; ch++)  		//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  		//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  		estimate_frame (frame' true);  		uint fs = measure_frame_size (frame' true);  		if (0 != eparams.variable_block_size) {  			FlacFrame frame2 = new FlacFrame (channels * 2);  			FlacFrame frame3 = new FlacFrame (channels * 2);  			int tumbler = 1;  			while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  				frame2.InitSize (frame.blocksize / 2' true);  				frame2.window_buffer = frame.window_buffer + frame.blocksize;  				frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  				for (int ch = 0; ch < 4; ch++)  					frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame2' true);  				uint fs2 = measure_frame_size (frame2' true);  				uint fs3 = fs2;  				if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  					frame3.InitSize (frame2.blocksize' true);  					frame3.window_buffer = frame2.window_buffer;  					frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  					for (int ch = 0; ch < 4; ch++)  						frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame3' true);  					fs3 = measure_frame_size (frame3' true);  				}  				if (fs2 + fs3 > fs)  					break;  				FlacFrame tmp = frame;  				frame = frame2;  				frame2 = tmp;  				fs = fs2;  				if (eparams.variable_block_size <= 2)  					break;  				tumbler = 1 - tumbler;  			}  		}  		frame.ChooseSubframes ();  		encode_estimated_frame (frame);  	}  	BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  	output_frame_header (frame' bitwriter);  	output_subframes (frame' bitwriter);  	output_frame_footer (bitwriter);  	if (bitwriter.Length >= max_frame_size)  		throw new Exception ("buffer overflow");  	if (frame_buffer != null) {  		if (eparams.variable_block_size > 0)  			frame_count += frame.blocksize;  		else  			frame_count++;  	}  	size = frame.blocksize;  	return bitwriter.Length;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (float* window = windowBuffer) {  	frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  	if (frame.blocksize != _windowsize && frame.blocksize > 4) {  		_windowsize = frame.blocksize;  		_windowcount = 0;  		calculate_window (window' lpc.window_welch' WindowFunction.Welch);  		calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  		calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  		calculate_window (window' lpc.window_hann' WindowFunction.Hann);  		calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  		if (_windowcount == 0)  			throw new Exception ("invalid windowfunction");  	}  	if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  		frame.window_buffer = window;  		frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  		frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  		for (int ch = 0; ch < channels; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		for (int ch = 0; ch < channels; ch++)  			encode_residual_pass2 (frame' ch);  	}  	else {  		//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  		frame.window_buffer = window;  		frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  		for (int ch = 0; ch < 4; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		//for (int ch = 0; ch < 4; ch++)  		//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  		//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  		estimate_frame (frame' true);  		uint fs = measure_frame_size (frame' true);  		if (0 != eparams.variable_block_size) {  			FlacFrame frame2 = new FlacFrame (channels * 2);  			FlacFrame frame3 = new FlacFrame (channels * 2);  			int tumbler = 1;  			while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  				frame2.InitSize (frame.blocksize / 2' true);  				frame2.window_buffer = frame.window_buffer + frame.blocksize;  				frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  				for (int ch = 0; ch < 4; ch++)  					frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame2' true);  				uint fs2 = measure_frame_size (frame2' true);  				uint fs3 = fs2;  				if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  					frame3.InitSize (frame2.blocksize' true);  					frame3.window_buffer = frame2.window_buffer;  					frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  					for (int ch = 0; ch < 4; ch++)  						frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame3' true);  					fs3 = measure_frame_size (frame3' true);  				}  				if (fs2 + fs3 > fs)  					break;  				FlacFrame tmp = frame;  				frame = frame2;  				frame2 = tmp;  				fs = fs2;  				if (eparams.variable_block_size <= 2)  					break;  				tumbler = 1 - tumbler;  			}  		}  		frame.ChooseSubframes ();  		encode_estimated_frame (frame);  	}  	BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  	output_frame_header (frame' bitwriter);  	output_subframes (frame' bitwriter);  	output_frame_footer (bitwriter);  	if (bitwriter.Length >= max_frame_size)  		throw new Exception ("buffer overflow");  	if (frame_buffer != null) {  		if (eparams.variable_block_size > 0)  			frame_count += frame.blocksize;  		else  			frame_count++;  	}  	size = frame.blocksize;  	return bitwriter.Length;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (float* window = windowBuffer) {  	frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  	if (frame.blocksize != _windowsize && frame.blocksize > 4) {  		_windowsize = frame.blocksize;  		_windowcount = 0;  		calculate_window (window' lpc.window_welch' WindowFunction.Welch);  		calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  		calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  		calculate_window (window' lpc.window_hann' WindowFunction.Hann);  		calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  		if (_windowcount == 0)  			throw new Exception ("invalid windowfunction");  	}  	if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  		frame.window_buffer = window;  		frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  		frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  		for (int ch = 0; ch < channels; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		for (int ch = 0; ch < channels; ch++)  			encode_residual_pass2 (frame' ch);  	}  	else {  		//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  		frame.window_buffer = window;  		frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  		for (int ch = 0; ch < 4; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		//for (int ch = 0; ch < 4; ch++)  		//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  		//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  		estimate_frame (frame' true);  		uint fs = measure_frame_size (frame' true);  		if (0 != eparams.variable_block_size) {  			FlacFrame frame2 = new FlacFrame (channels * 2);  			FlacFrame frame3 = new FlacFrame (channels * 2);  			int tumbler = 1;  			while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  				frame2.InitSize (frame.blocksize / 2' true);  				frame2.window_buffer = frame.window_buffer + frame.blocksize;  				frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  				for (int ch = 0; ch < 4; ch++)  					frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame2' true);  				uint fs2 = measure_frame_size (frame2' true);  				uint fs3 = fs2;  				if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  					frame3.InitSize (frame2.blocksize' true);  					frame3.window_buffer = frame2.window_buffer;  					frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  					for (int ch = 0; ch < 4; ch++)  						frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame3' true);  					fs3 = measure_frame_size (frame3' true);  				}  				if (fs2 + fs3 > fs)  					break;  				FlacFrame tmp = frame;  				frame = frame2;  				frame2 = tmp;  				fs = fs2;  				if (eparams.variable_block_size <= 2)  					break;  				tumbler = 1 - tumbler;  			}  		}  		frame.ChooseSubframes ();  		encode_estimated_frame (frame);  	}  	BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  	output_frame_header (frame' bitwriter);  	output_subframes (frame' bitwriter);  	output_frame_footer (bitwriter);  	if (bitwriter.Length >= max_frame_size)  		throw new Exception ("buffer overflow");  	if (frame_buffer != null) {  		if (eparams.variable_block_size > 0)  			frame_count += frame.blocksize;  		else  			frame_count++;  	}  	size = frame.blocksize;  	return bitwriter.Length;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (float* window = windowBuffer) {  	frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  	if (frame.blocksize != _windowsize && frame.blocksize > 4) {  		_windowsize = frame.blocksize;  		_windowcount = 0;  		calculate_window (window' lpc.window_welch' WindowFunction.Welch);  		calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  		calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  		calculate_window (window' lpc.window_hann' WindowFunction.Hann);  		calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  		if (_windowcount == 0)  			throw new Exception ("invalid windowfunction");  	}  	if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  		frame.window_buffer = window;  		frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  		frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  		for (int ch = 0; ch < channels; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		for (int ch = 0; ch < channels; ch++)  			encode_residual_pass2 (frame' ch);  	}  	else {  		//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  		frame.window_buffer = window;  		frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  		for (int ch = 0; ch < 4; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		//for (int ch = 0; ch < 4; ch++)  		//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  		//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  		estimate_frame (frame' true);  		uint fs = measure_frame_size (frame' true);  		if (0 != eparams.variable_block_size) {  			FlacFrame frame2 = new FlacFrame (channels * 2);  			FlacFrame frame3 = new FlacFrame (channels * 2);  			int tumbler = 1;  			while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  				frame2.InitSize (frame.blocksize / 2' true);  				frame2.window_buffer = frame.window_buffer + frame.blocksize;  				frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  				for (int ch = 0; ch < 4; ch++)  					frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame2' true);  				uint fs2 = measure_frame_size (frame2' true);  				uint fs3 = fs2;  				if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  					frame3.InitSize (frame2.blocksize' true);  					frame3.window_buffer = frame2.window_buffer;  					frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  					for (int ch = 0; ch < 4; ch++)  						frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame3' true);  					fs3 = measure_frame_size (frame3' true);  				}  				if (fs2 + fs3 > fs)  					break;  				FlacFrame tmp = frame;  				frame = frame2;  				frame2 = tmp;  				fs = fs2;  				if (eparams.variable_block_size <= 2)  					break;  				tumbler = 1 - tumbler;  			}  		}  		frame.ChooseSubframes ();  		encode_estimated_frame (frame);  	}  	BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  	output_frame_header (frame' bitwriter);  	output_subframes (frame' bitwriter);  	output_frame_footer (bitwriter);  	if (bitwriter.Length >= max_frame_size)  		throw new Exception ("buffer overflow");  	if (frame_buffer != null) {  		if (eparams.variable_block_size > 0)  			frame_count += frame.blocksize;  		else  			frame_count++;  	}  	size = frame.blocksize;  	return bitwriter.Length;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (float* window = windowBuffer) {  	frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  	if (frame.blocksize != _windowsize && frame.blocksize > 4) {  		_windowsize = frame.blocksize;  		_windowcount = 0;  		calculate_window (window' lpc.window_welch' WindowFunction.Welch);  		calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  		calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  		calculate_window (window' lpc.window_hann' WindowFunction.Hann);  		calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  		if (_windowcount == 0)  			throw new Exception ("invalid windowfunction");  	}  	if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  		frame.window_buffer = window;  		frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  		frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  		for (int ch = 0; ch < channels; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		for (int ch = 0; ch < channels; ch++)  			encode_residual_pass2 (frame' ch);  	}  	else {  		//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  		frame.window_buffer = window;  		frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  		for (int ch = 0; ch < 4; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		//for (int ch = 0; ch < 4; ch++)  		//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  		//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  		estimate_frame (frame' true);  		uint fs = measure_frame_size (frame' true);  		if (0 != eparams.variable_block_size) {  			FlacFrame frame2 = new FlacFrame (channels * 2);  			FlacFrame frame3 = new FlacFrame (channels * 2);  			int tumbler = 1;  			while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  				frame2.InitSize (frame.blocksize / 2' true);  				frame2.window_buffer = frame.window_buffer + frame.blocksize;  				frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  				for (int ch = 0; ch < 4; ch++)  					frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame2' true);  				uint fs2 = measure_frame_size (frame2' true);  				uint fs3 = fs2;  				if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  					frame3.InitSize (frame2.blocksize' true);  					frame3.window_buffer = frame2.window_buffer;  					frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  					for (int ch = 0; ch < 4; ch++)  						frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame3' true);  					fs3 = measure_frame_size (frame3' true);  				}  				if (fs2 + fs3 > fs)  					break;  				FlacFrame tmp = frame;  				frame = frame2;  				frame2 = tmp;  				fs = fs2;  				if (eparams.variable_block_size <= 2)  					break;  				tumbler = 1 - tumbler;  			}  		}  		frame.ChooseSubframes ();  		encode_estimated_frame (frame);  	}  	BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  	output_frame_header (frame' bitwriter);  	output_subframes (frame' bitwriter);  	output_frame_footer (bitwriter);  	if (bitwriter.Length >= max_frame_size)  		throw new Exception ("buffer overflow");  	if (frame_buffer != null) {  		if (eparams.variable_block_size > 0)  			frame_count += frame.blocksize;  		else  			frame_count++;  	}  	size = frame.blocksize;  	return bitwriter.Length;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (float* window = windowBuffer) {  	frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  	if (frame.blocksize != _windowsize && frame.blocksize > 4) {  		_windowsize = frame.blocksize;  		_windowcount = 0;  		calculate_window (window' lpc.window_welch' WindowFunction.Welch);  		calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  		calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  		calculate_window (window' lpc.window_hann' WindowFunction.Hann);  		calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  		if (_windowcount == 0)  			throw new Exception ("invalid windowfunction");  	}  	if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  		frame.window_buffer = window;  		frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  		frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  		for (int ch = 0; ch < channels; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		for (int ch = 0; ch < channels; ch++)  			encode_residual_pass2 (frame' ch);  	}  	else {  		//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  		frame.window_buffer = window;  		frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  		for (int ch = 0; ch < 4; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		//for (int ch = 0; ch < 4; ch++)  		//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  		//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  		estimate_frame (frame' true);  		uint fs = measure_frame_size (frame' true);  		if (0 != eparams.variable_block_size) {  			FlacFrame frame2 = new FlacFrame (channels * 2);  			FlacFrame frame3 = new FlacFrame (channels * 2);  			int tumbler = 1;  			while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  				frame2.InitSize (frame.blocksize / 2' true);  				frame2.window_buffer = frame.window_buffer + frame.blocksize;  				frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  				for (int ch = 0; ch < 4; ch++)  					frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame2' true);  				uint fs2 = measure_frame_size (frame2' true);  				uint fs3 = fs2;  				if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  					frame3.InitSize (frame2.blocksize' true);  					frame3.window_buffer = frame2.window_buffer;  					frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  					for (int ch = 0; ch < 4; ch++)  						frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame3' true);  					fs3 = measure_frame_size (frame3' true);  				}  				if (fs2 + fs3 > fs)  					break;  				FlacFrame tmp = frame;  				frame = frame2;  				frame2 = tmp;  				fs = fs2;  				if (eparams.variable_block_size <= 2)  					break;  				tumbler = 1 - tumbler;  			}  		}  		frame.ChooseSubframes ();  		encode_estimated_frame (frame);  	}  	BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  	output_frame_header (frame' bitwriter);  	output_subframes (frame' bitwriter);  	output_frame_footer (bitwriter);  	if (bitwriter.Length >= max_frame_size)  		throw new Exception ("buffer overflow");  	if (frame_buffer != null) {  		if (eparams.variable_block_size > 0)  			frame_count += frame.blocksize;  		else  			frame_count++;  	}  	size = frame.blocksize;  	return bitwriter.Length;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (float* window = windowBuffer) {  	frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  	if (frame.blocksize != _windowsize && frame.blocksize > 4) {  		_windowsize = frame.blocksize;  		_windowcount = 0;  		calculate_window (window' lpc.window_welch' WindowFunction.Welch);  		calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  		calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  		calculate_window (window' lpc.window_hann' WindowFunction.Hann);  		calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  		if (_windowcount == 0)  			throw new Exception ("invalid windowfunction");  	}  	if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  		frame.window_buffer = window;  		frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  		frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  		for (int ch = 0; ch < channels; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		for (int ch = 0; ch < channels; ch++)  			encode_residual_pass2 (frame' ch);  	}  	else {  		//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  		frame.window_buffer = window;  		frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  		for (int ch = 0; ch < 4; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		//for (int ch = 0; ch < 4; ch++)  		//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  		//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  		estimate_frame (frame' true);  		uint fs = measure_frame_size (frame' true);  		if (0 != eparams.variable_block_size) {  			FlacFrame frame2 = new FlacFrame (channels * 2);  			FlacFrame frame3 = new FlacFrame (channels * 2);  			int tumbler = 1;  			while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  				frame2.InitSize (frame.blocksize / 2' true);  				frame2.window_buffer = frame.window_buffer + frame.blocksize;  				frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  				for (int ch = 0; ch < 4; ch++)  					frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame2' true);  				uint fs2 = measure_frame_size (frame2' true);  				uint fs3 = fs2;  				if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  					frame3.InitSize (frame2.blocksize' true);  					frame3.window_buffer = frame2.window_buffer;  					frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  					for (int ch = 0; ch < 4; ch++)  						frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame3' true);  					fs3 = measure_frame_size (frame3' true);  				}  				if (fs2 + fs3 > fs)  					break;  				FlacFrame tmp = frame;  				frame = frame2;  				frame2 = tmp;  				fs = fs2;  				if (eparams.variable_block_size <= 2)  					break;  				tumbler = 1 - tumbler;  			}  		}  		frame.ChooseSubframes ();  		encode_estimated_frame (frame);  	}  	BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  	output_frame_header (frame' bitwriter);  	output_subframes (frame' bitwriter);  	output_frame_footer (bitwriter);  	if (bitwriter.Length >= max_frame_size)  		throw new Exception ("buffer overflow");  	if (frame_buffer != null) {  		if (eparams.variable_block_size > 0)  			frame_count += frame.blocksize;  		else  			frame_count++;  	}  	size = frame.blocksize;  	return bitwriter.Length;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (float* window = windowBuffer) {  	frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  	if (frame.blocksize != _windowsize && frame.blocksize > 4) {  		_windowsize = frame.blocksize;  		_windowcount = 0;  		calculate_window (window' lpc.window_welch' WindowFunction.Welch);  		calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  		calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  		calculate_window (window' lpc.window_hann' WindowFunction.Hann);  		calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  		if (_windowcount == 0)  			throw new Exception ("invalid windowfunction");  	}  	if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  		frame.window_buffer = window;  		frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  		frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  		for (int ch = 0; ch < channels; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		for (int ch = 0; ch < channels; ch++)  			encode_residual_pass2 (frame' ch);  	}  	else {  		//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  		frame.window_buffer = window;  		frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  		for (int ch = 0; ch < 4; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		//for (int ch = 0; ch < 4; ch++)  		//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  		//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  		estimate_frame (frame' true);  		uint fs = measure_frame_size (frame' true);  		if (0 != eparams.variable_block_size) {  			FlacFrame frame2 = new FlacFrame (channels * 2);  			FlacFrame frame3 = new FlacFrame (channels * 2);  			int tumbler = 1;  			while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  				frame2.InitSize (frame.blocksize / 2' true);  				frame2.window_buffer = frame.window_buffer + frame.blocksize;  				frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  				for (int ch = 0; ch < 4; ch++)  					frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame2' true);  				uint fs2 = measure_frame_size (frame2' true);  				uint fs3 = fs2;  				if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  					frame3.InitSize (frame2.blocksize' true);  					frame3.window_buffer = frame2.window_buffer;  					frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  					for (int ch = 0; ch < 4; ch++)  						frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame3' true);  					fs3 = measure_frame_size (frame3' true);  				}  				if (fs2 + fs3 > fs)  					break;  				FlacFrame tmp = frame;  				frame = frame2;  				frame2 = tmp;  				fs = fs2;  				if (eparams.variable_block_size <= 2)  					break;  				tumbler = 1 - tumbler;  			}  		}  		frame.ChooseSubframes ();  		encode_estimated_frame (frame);  	}  	BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  	output_frame_header (frame' bitwriter);  	output_subframes (frame' bitwriter);  	output_frame_footer (bitwriter);  	if (bitwriter.Length >= max_frame_size)  		throw new Exception ("buffer overflow");  	if (frame_buffer != null) {  		if (eparams.variable_block_size > 0)  			frame_count += frame.blocksize;  		else  			frame_count++;  	}  	size = frame.blocksize;  	return bitwriter.Length;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (float* window = windowBuffer) {  	frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  	if (frame.blocksize != _windowsize && frame.blocksize > 4) {  		_windowsize = frame.blocksize;  		_windowcount = 0;  		calculate_window (window' lpc.window_welch' WindowFunction.Welch);  		calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  		calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  		calculate_window (window' lpc.window_hann' WindowFunction.Hann);  		calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  		if (_windowcount == 0)  			throw new Exception ("invalid windowfunction");  	}  	if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  		frame.window_buffer = window;  		frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  		frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  		for (int ch = 0; ch < channels; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		for (int ch = 0; ch < channels; ch++)  			encode_residual_pass2 (frame' ch);  	}  	else {  		//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  		frame.window_buffer = window;  		frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  		for (int ch = 0; ch < 4; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		//for (int ch = 0; ch < 4; ch++)  		//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  		//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  		estimate_frame (frame' true);  		uint fs = measure_frame_size (frame' true);  		if (0 != eparams.variable_block_size) {  			FlacFrame frame2 = new FlacFrame (channels * 2);  			FlacFrame frame3 = new FlacFrame (channels * 2);  			int tumbler = 1;  			while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  				frame2.InitSize (frame.blocksize / 2' true);  				frame2.window_buffer = frame.window_buffer + frame.blocksize;  				frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  				for (int ch = 0; ch < 4; ch++)  					frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame2' true);  				uint fs2 = measure_frame_size (frame2' true);  				uint fs3 = fs2;  				if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  					frame3.InitSize (frame2.blocksize' true);  					frame3.window_buffer = frame2.window_buffer;  					frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  					for (int ch = 0; ch < 4; ch++)  						frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame3' true);  					fs3 = measure_frame_size (frame3' true);  				}  				if (fs2 + fs3 > fs)  					break;  				FlacFrame tmp = frame;  				frame = frame2;  				frame2 = tmp;  				fs = fs2;  				if (eparams.variable_block_size <= 2)  					break;  				tumbler = 1 - tumbler;  			}  		}  		frame.ChooseSubframes ();  		encode_estimated_frame (frame);  	}  	BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  	output_frame_header (frame' bitwriter);  	output_subframes (frame' bitwriter);  	output_frame_footer (bitwriter);  	if (bitwriter.Length >= max_frame_size)  		throw new Exception ("buffer overflow");  	if (frame_buffer != null) {  		if (eparams.variable_block_size > 0)  			frame_count += frame.blocksize;  		else  			frame_count++;  	}  	size = frame.blocksize;  	return bitwriter.Length;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (float* window = windowBuffer) {  	frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  	if (frame.blocksize != _windowsize && frame.blocksize > 4) {  		_windowsize = frame.blocksize;  		_windowcount = 0;  		calculate_window (window' lpc.window_welch' WindowFunction.Welch);  		calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  		calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  		calculate_window (window' lpc.window_hann' WindowFunction.Hann);  		calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  		if (_windowcount == 0)  			throw new Exception ("invalid windowfunction");  	}  	if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  		frame.window_buffer = window;  		frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  		frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  		for (int ch = 0; ch < channels; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		for (int ch = 0; ch < channels; ch++)  			encode_residual_pass2 (frame' ch);  	}  	else {  		//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  		frame.window_buffer = window;  		frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  		for (int ch = 0; ch < 4; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		//for (int ch = 0; ch < 4; ch++)  		//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  		//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  		estimate_frame (frame' true);  		uint fs = measure_frame_size (frame' true);  		if (0 != eparams.variable_block_size) {  			FlacFrame frame2 = new FlacFrame (channels * 2);  			FlacFrame frame3 = new FlacFrame (channels * 2);  			int tumbler = 1;  			while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  				frame2.InitSize (frame.blocksize / 2' true);  				frame2.window_buffer = frame.window_buffer + frame.blocksize;  				frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  				for (int ch = 0; ch < 4; ch++)  					frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame2' true);  				uint fs2 = measure_frame_size (frame2' true);  				uint fs3 = fs2;  				if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  					frame3.InitSize (frame2.blocksize' true);  					frame3.window_buffer = frame2.window_buffer;  					frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  					for (int ch = 0; ch < 4; ch++)  						frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame3' true);  					fs3 = measure_frame_size (frame3' true);  				}  				if (fs2 + fs3 > fs)  					break;  				FlacFrame tmp = frame;  				frame = frame2;  				frame2 = tmp;  				fs = fs2;  				if (eparams.variable_block_size <= 2)  					break;  				tumbler = 1 - tumbler;  			}  		}  		frame.ChooseSubframes ();  		encode_estimated_frame (frame);  	}  	BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  	output_frame_header (frame' bitwriter);  	output_subframes (frame' bitwriter);  	output_frame_footer (bitwriter);  	if (bitwriter.Length >= max_frame_size)  		throw new Exception ("buffer overflow");  	if (frame_buffer != null) {  		if (eparams.variable_block_size > 0)  			frame_count += frame.blocksize;  		else  			frame_count++;  	}  	size = frame.blocksize;  	return bitwriter.Length;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (float* window = windowBuffer) {  	frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  	if (frame.blocksize != _windowsize && frame.blocksize > 4) {  		_windowsize = frame.blocksize;  		_windowcount = 0;  		calculate_window (window' lpc.window_welch' WindowFunction.Welch);  		calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  		calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  		calculate_window (window' lpc.window_hann' WindowFunction.Hann);  		calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  		if (_windowcount == 0)  			throw new Exception ("invalid windowfunction");  	}  	if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  		frame.window_buffer = window;  		frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  		frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  		for (int ch = 0; ch < channels; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		for (int ch = 0; ch < channels; ch++)  			encode_residual_pass2 (frame' ch);  	}  	else {  		//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  		frame.window_buffer = window;  		frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  		for (int ch = 0; ch < 4; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		//for (int ch = 0; ch < 4; ch++)  		//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  		//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  		estimate_frame (frame' true);  		uint fs = measure_frame_size (frame' true);  		if (0 != eparams.variable_block_size) {  			FlacFrame frame2 = new FlacFrame (channels * 2);  			FlacFrame frame3 = new FlacFrame (channels * 2);  			int tumbler = 1;  			while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  				frame2.InitSize (frame.blocksize / 2' true);  				frame2.window_buffer = frame.window_buffer + frame.blocksize;  				frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  				for (int ch = 0; ch < 4; ch++)  					frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame2' true);  				uint fs2 = measure_frame_size (frame2' true);  				uint fs3 = fs2;  				if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  					frame3.InitSize (frame2.blocksize' true);  					frame3.window_buffer = frame2.window_buffer;  					frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  					for (int ch = 0; ch < 4; ch++)  						frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame3' true);  					fs3 = measure_frame_size (frame3' true);  				}  				if (fs2 + fs3 > fs)  					break;  				FlacFrame tmp = frame;  				frame = frame2;  				frame2 = tmp;  				fs = fs2;  				if (eparams.variable_block_size <= 2)  					break;  				tumbler = 1 - tumbler;  			}  		}  		frame.ChooseSubframes ();  		encode_estimated_frame (frame);  	}  	BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  	output_frame_header (frame' bitwriter);  	output_subframes (frame' bitwriter);  	output_frame_footer (bitwriter);  	if (bitwriter.Length >= max_frame_size)  		throw new Exception ("buffer overflow");  	if (frame_buffer != null) {  		if (eparams.variable_block_size > 0)  			frame_count += frame.blocksize;  		else  			frame_count++;  	}  	size = frame.blocksize;  	return bitwriter.Length;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (float* window = windowBuffer) {  	frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  	if (frame.blocksize != _windowsize && frame.blocksize > 4) {  		_windowsize = frame.blocksize;  		_windowcount = 0;  		calculate_window (window' lpc.window_welch' WindowFunction.Welch);  		calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  		calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  		calculate_window (window' lpc.window_hann' WindowFunction.Hann);  		calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  		if (_windowcount == 0)  			throw new Exception ("invalid windowfunction");  	}  	if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  		frame.window_buffer = window;  		frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  		frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  		for (int ch = 0; ch < channels; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		for (int ch = 0; ch < channels; ch++)  			encode_residual_pass2 (frame' ch);  	}  	else {  		//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  		frame.window_buffer = window;  		frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  		for (int ch = 0; ch < 4; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		//for (int ch = 0; ch < 4; ch++)  		//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  		//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  		estimate_frame (frame' true);  		uint fs = measure_frame_size (frame' true);  		if (0 != eparams.variable_block_size) {  			FlacFrame frame2 = new FlacFrame (channels * 2);  			FlacFrame frame3 = new FlacFrame (channels * 2);  			int tumbler = 1;  			while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  				frame2.InitSize (frame.blocksize / 2' true);  				frame2.window_buffer = frame.window_buffer + frame.blocksize;  				frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  				for (int ch = 0; ch < 4; ch++)  					frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame2' true);  				uint fs2 = measure_frame_size (frame2' true);  				uint fs3 = fs2;  				if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  					frame3.InitSize (frame2.blocksize' true);  					frame3.window_buffer = frame2.window_buffer;  					frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  					for (int ch = 0; ch < 4; ch++)  						frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame3' true);  					fs3 = measure_frame_size (frame3' true);  				}  				if (fs2 + fs3 > fs)  					break;  				FlacFrame tmp = frame;  				frame = frame2;  				frame2 = tmp;  				fs = fs2;  				if (eparams.variable_block_size <= 2)  					break;  				tumbler = 1 - tumbler;  			}  		}  		frame.ChooseSubframes ();  		encode_estimated_frame (frame);  	}  	BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  	output_frame_header (frame' bitwriter);  	output_subframes (frame' bitwriter);  	output_frame_footer (bitwriter);  	if (bitwriter.Length >= max_frame_size)  		throw new Exception ("buffer overflow");  	if (frame_buffer != null) {  		if (eparams.variable_block_size > 0)  			frame_count += frame.blocksize;  		else  			frame_count++;  	}  	size = frame.blocksize;  	return bitwriter.Length;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: fixed (float* window = windowBuffer) {  	frame.InitSize (eparams.block_size' eparams.variable_block_size != 0);  	if (frame.blocksize != _windowsize && frame.blocksize > 4) {  		_windowsize = frame.blocksize;  		_windowcount = 0;  		calculate_window (window' lpc.window_welch' WindowFunction.Welch);  		calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  		calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  		calculate_window (window' lpc.window_hann' WindowFunction.Hann);  		calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  		if (_windowcount == 0)  			throw new Exception ("invalid windowfunction");  	}  	if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  		frame.window_buffer = window;  		frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  		frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  		for (int ch = 0; ch < channels; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		for (int ch = 0; ch < channels; ch++)  			encode_residual_pass2 (frame' ch);  	}  	else {  		//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  		frame.window_buffer = window;  		frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  		for (int ch = 0; ch < 4; ch++)  			frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  		//for (int ch = 0; ch < 4; ch++)  		//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  		//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  		estimate_frame (frame' true);  		uint fs = measure_frame_size (frame' true);  		if (0 != eparams.variable_block_size) {  			FlacFrame frame2 = new FlacFrame (channels * 2);  			FlacFrame frame3 = new FlacFrame (channels * 2);  			int tumbler = 1;  			while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  				frame2.InitSize (frame.blocksize / 2' true);  				frame2.window_buffer = frame.window_buffer + frame.blocksize;  				frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  				for (int ch = 0; ch < 4; ch++)  					frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame2' true);  				uint fs2 = measure_frame_size (frame2' true);  				uint fs3 = fs2;  				if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  					frame3.InitSize (frame2.blocksize' true);  					frame3.window_buffer = frame2.window_buffer;  					frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  					for (int ch = 0; ch < 4; ch++)  						frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  					estimate_frame (frame3' true);  					fs3 = measure_frame_size (frame3' true);  				}  				if (fs2 + fs3 > fs)  					break;  				FlacFrame tmp = frame;  				frame = frame2;  				frame2 = tmp;  				fs = fs2;  				if (eparams.variable_block_size <= 2)  					break;  				tumbler = 1 - tumbler;  			}  		}  		frame.ChooseSubframes ();  		encode_estimated_frame (frame);  	}  	BitWriter bitwriter = new BitWriter (frame_buffer' 0' max_frame_size);  	output_frame_header (frame' bitwriter);  	output_subframes (frame' bitwriter);  	output_frame_footer (bitwriter);  	if (bitwriter.Length >= max_frame_size)  		throw new Exception ("buffer overflow");  	if (frame_buffer != null) {  		if (eparams.variable_block_size > 0)  			frame_count += frame.blocksize;  		else  			frame_count++;  	}  	size = frame.blocksize;  	return bitwriter.Length;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (frame.blocksize != _windowsize && frame.blocksize > 4) {  	_windowsize = frame.blocksize;  	_windowcount = 0;  	calculate_window (window' lpc.window_welch' WindowFunction.Welch);  	calculate_window (window' lpc.window_tukey' WindowFunction.Tukey);  	calculate_window (window' lpc.window_flattop' WindowFunction.Flattop);  	calculate_window (window' lpc.window_hann' WindowFunction.Hann);  	calculate_window (window' lpc.window_bartlett' WindowFunction.Bartlett);  	if (_windowcount == 0)  		throw new Exception ("invalid windowfunction");  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  	frame.window_buffer = window;  	frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  	frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  	for (int ch = 0; ch < channels; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	for (int ch = 0; ch < channels; ch++)  		encode_residual_pass2 (frame' ch);  }  else {  	//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  	frame.window_buffer = window;  	frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  	for (int ch = 0; ch < 4; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	//for (int ch = 0; ch < 4; ch++)  	//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  	//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  	estimate_frame (frame' true);  	uint fs = measure_frame_size (frame' true);  	if (0 != eparams.variable_block_size) {  		FlacFrame frame2 = new FlacFrame (channels * 2);  		FlacFrame frame3 = new FlacFrame (channels * 2);  		int tumbler = 1;  		while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  			frame2.InitSize (frame.blocksize / 2' true);  			frame2.window_buffer = frame.window_buffer + frame.blocksize;  			frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  			estimate_frame (frame2' true);  			uint fs2 = measure_frame_size (frame2' true);  			uint fs3 = fs2;  			if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  				frame3.InitSize (frame2.blocksize' true);  				frame3.window_buffer = frame2.window_buffer;  				frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  				for (int ch = 0; ch < 4; ch++)  					frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame3' true);  				fs3 = measure_frame_size (frame3' true);  			}  			if (fs2 + fs3 > fs)  				break;  			FlacFrame tmp = frame;  			frame = frame2;  			frame2 = tmp;  			fs = fs2;  			if (eparams.variable_block_size <= 2)  				break;  			tumbler = 1 - tumbler;  		}  	}  	frame.ChooseSubframes ();  	encode_estimated_frame (frame);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  	frame.window_buffer = window;  	frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  	frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  	for (int ch = 0; ch < channels; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	for (int ch = 0; ch < channels; ch++)  		encode_residual_pass2 (frame' ch);  }  else {  	//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  	frame.window_buffer = window;  	frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  	for (int ch = 0; ch < 4; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	//for (int ch = 0; ch < 4; ch++)  	//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  	//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  	estimate_frame (frame' true);  	uint fs = measure_frame_size (frame' true);  	if (0 != eparams.variable_block_size) {  		FlacFrame frame2 = new FlacFrame (channels * 2);  		FlacFrame frame3 = new FlacFrame (channels * 2);  		int tumbler = 1;  		while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  			frame2.InitSize (frame.blocksize / 2' true);  			frame2.window_buffer = frame.window_buffer + frame.blocksize;  			frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  			estimate_frame (frame2' true);  			uint fs2 = measure_frame_size (frame2' true);  			uint fs3 = fs2;  			if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  				frame3.InitSize (frame2.blocksize' true);  				frame3.window_buffer = frame2.window_buffer;  				frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  				for (int ch = 0; ch < 4; ch++)  					frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame3' true);  				fs3 = measure_frame_size (frame3' true);  			}  			if (fs2 + fs3 > fs)  				break;  			FlacFrame tmp = frame;  			frame = frame2;  			frame2 = tmp;  			fs = fs2;  			if (eparams.variable_block_size <= 2)  				break;  			tumbler = 1 - tumbler;  		}  	}  	frame.ChooseSubframes ();  	encode_estimated_frame (frame);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  	frame.window_buffer = window;  	frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  	frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  	for (int ch = 0; ch < channels; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	for (int ch = 0; ch < channels; ch++)  		encode_residual_pass2 (frame' ch);  }  else {  	//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  	frame.window_buffer = window;  	frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  	for (int ch = 0; ch < 4; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	//for (int ch = 0; ch < 4; ch++)  	//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  	//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  	estimate_frame (frame' true);  	uint fs = measure_frame_size (frame' true);  	if (0 != eparams.variable_block_size) {  		FlacFrame frame2 = new FlacFrame (channels * 2);  		FlacFrame frame3 = new FlacFrame (channels * 2);  		int tumbler = 1;  		while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  			frame2.InitSize (frame.blocksize / 2' true);  			frame2.window_buffer = frame.window_buffer + frame.blocksize;  			frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  			estimate_frame (frame2' true);  			uint fs2 = measure_frame_size (frame2' true);  			uint fs3 = fs2;  			if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  				frame3.InitSize (frame2.blocksize' true);  				frame3.window_buffer = frame2.window_buffer;  				frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  				for (int ch = 0; ch < 4; ch++)  					frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame3' true);  				fs3 = measure_frame_size (frame3' true);  			}  			if (fs2 + fs3 > fs)  				break;  			FlacFrame tmp = frame;  			frame = frame2;  			frame2 = tmp;  			fs = fs2;  			if (eparams.variable_block_size <= 2)  				break;  			tumbler = 1 - tumbler;  		}  	}  	frame.ChooseSubframes ();  	encode_estimated_frame (frame);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  	frame.window_buffer = window;  	frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  	frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  	for (int ch = 0; ch < channels; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	for (int ch = 0; ch < channels; ch++)  		encode_residual_pass2 (frame' ch);  }  else {  	//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  	frame.window_buffer = window;  	frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  	for (int ch = 0; ch < 4; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	//for (int ch = 0; ch < 4; ch++)  	//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  	//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  	estimate_frame (frame' true);  	uint fs = measure_frame_size (frame' true);  	if (0 != eparams.variable_block_size) {  		FlacFrame frame2 = new FlacFrame (channels * 2);  		FlacFrame frame3 = new FlacFrame (channels * 2);  		int tumbler = 1;  		while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  			frame2.InitSize (frame.blocksize / 2' true);  			frame2.window_buffer = frame.window_buffer + frame.blocksize;  			frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  			estimate_frame (frame2' true);  			uint fs2 = measure_frame_size (frame2' true);  			uint fs3 = fs2;  			if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  				frame3.InitSize (frame2.blocksize' true);  				frame3.window_buffer = frame2.window_buffer;  				frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  				for (int ch = 0; ch < 4; ch++)  					frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame3' true);  				fs3 = measure_frame_size (frame3' true);  			}  			if (fs2 + fs3 > fs)  				break;  			FlacFrame tmp = frame;  			frame = frame2;  			frame2 = tmp;  			fs = fs2;  			if (eparams.variable_block_size <= 2)  				break;  			tumbler = 1 - tumbler;  		}  	}  	frame.ChooseSubframes ();  	encode_estimated_frame (frame);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  	frame.window_buffer = window;  	frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  	frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  	for (int ch = 0; ch < channels; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	for (int ch = 0; ch < channels; ch++)  		encode_residual_pass2 (frame' ch);  }  else {  	//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  	frame.window_buffer = window;  	frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  	for (int ch = 0; ch < 4; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	//for (int ch = 0; ch < 4; ch++)  	//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  	//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  	estimate_frame (frame' true);  	uint fs = measure_frame_size (frame' true);  	if (0 != eparams.variable_block_size) {  		FlacFrame frame2 = new FlacFrame (channels * 2);  		FlacFrame frame3 = new FlacFrame (channels * 2);  		int tumbler = 1;  		while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  			frame2.InitSize (frame.blocksize / 2' true);  			frame2.window_buffer = frame.window_buffer + frame.blocksize;  			frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  			estimate_frame (frame2' true);  			uint fs2 = measure_frame_size (frame2' true);  			uint fs3 = fs2;  			if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  				frame3.InitSize (frame2.blocksize' true);  				frame3.window_buffer = frame2.window_buffer;  				frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  				for (int ch = 0; ch < 4; ch++)  					frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame3' true);  				fs3 = measure_frame_size (frame3' true);  			}  			if (fs2 + fs3 > fs)  				break;  			FlacFrame tmp = frame;  			frame = frame2;  			frame2 = tmp;  			fs = fs2;  			if (eparams.variable_block_size <= 2)  				break;  			tumbler = 1 - tumbler;  		}  	}  	frame.ChooseSubframes ();  	encode_estimated_frame (frame);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  	frame.window_buffer = window;  	frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  	frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  	for (int ch = 0; ch < channels; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	for (int ch = 0; ch < channels; ch++)  		encode_residual_pass2 (frame' ch);  }  else {  	//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  	frame.window_buffer = window;  	frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  	for (int ch = 0; ch < 4; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	//for (int ch = 0; ch < 4; ch++)  	//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  	//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  	estimate_frame (frame' true);  	uint fs = measure_frame_size (frame' true);  	if (0 != eparams.variable_block_size) {  		FlacFrame frame2 = new FlacFrame (channels * 2);  		FlacFrame frame3 = new FlacFrame (channels * 2);  		int tumbler = 1;  		while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  			frame2.InitSize (frame.blocksize / 2' true);  			frame2.window_buffer = frame.window_buffer + frame.blocksize;  			frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  			estimate_frame (frame2' true);  			uint fs2 = measure_frame_size (frame2' true);  			uint fs3 = fs2;  			if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  				frame3.InitSize (frame2.blocksize' true);  				frame3.window_buffer = frame2.window_buffer;  				frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  				for (int ch = 0; ch < 4; ch++)  					frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame3' true);  				fs3 = measure_frame_size (frame3' true);  			}  			if (fs2 + fs3 > fs)  				break;  			FlacFrame tmp = frame;  			frame = frame2;  			frame2 = tmp;  			fs = fs2;  			if (eparams.variable_block_size <= 2)  				break;  			tumbler = 1 - tumbler;  		}  	}  	frame.ChooseSubframes ();  	encode_estimated_frame (frame);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  	frame.window_buffer = window;  	frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  	frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  	for (int ch = 0; ch < channels; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	for (int ch = 0; ch < channels; ch++)  		encode_residual_pass2 (frame' ch);  }  else {  	//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  	frame.window_buffer = window;  	frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  	for (int ch = 0; ch < 4; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	//for (int ch = 0; ch < 4; ch++)  	//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  	//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  	estimate_frame (frame' true);  	uint fs = measure_frame_size (frame' true);  	if (0 != eparams.variable_block_size) {  		FlacFrame frame2 = new FlacFrame (channels * 2);  		FlacFrame frame3 = new FlacFrame (channels * 2);  		int tumbler = 1;  		while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  			frame2.InitSize (frame.blocksize / 2' true);  			frame2.window_buffer = frame.window_buffer + frame.blocksize;  			frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  			estimate_frame (frame2' true);  			uint fs2 = measure_frame_size (frame2' true);  			uint fs3 = fs2;  			if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  				frame3.InitSize (frame2.blocksize' true);  				frame3.window_buffer = frame2.window_buffer;  				frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  				for (int ch = 0; ch < 4; ch++)  					frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame3' true);  				fs3 = measure_frame_size (frame3' true);  			}  			if (fs2 + fs3 > fs)  				break;  			FlacFrame tmp = frame;  			frame = frame2;  			frame2 = tmp;  			fs = fs2;  			if (eparams.variable_block_size <= 2)  				break;  			tumbler = 1 - tumbler;  		}  	}  	frame.ChooseSubframes ();  	encode_estimated_frame (frame);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  	frame.window_buffer = window;  	frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  	frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  	for (int ch = 0; ch < channels; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	for (int ch = 0; ch < channels; ch++)  		encode_residual_pass2 (frame' ch);  }  else {  	//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  	frame.window_buffer = window;  	frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  	for (int ch = 0; ch < 4; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	//for (int ch = 0; ch < 4; ch++)  	//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  	//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  	estimate_frame (frame' true);  	uint fs = measure_frame_size (frame' true);  	if (0 != eparams.variable_block_size) {  		FlacFrame frame2 = new FlacFrame (channels * 2);  		FlacFrame frame3 = new FlacFrame (channels * 2);  		int tumbler = 1;  		while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  			frame2.InitSize (frame.blocksize / 2' true);  			frame2.window_buffer = frame.window_buffer + frame.blocksize;  			frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  			estimate_frame (frame2' true);  			uint fs2 = measure_frame_size (frame2' true);  			uint fs3 = fs2;  			if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  				frame3.InitSize (frame2.blocksize' true);  				frame3.window_buffer = frame2.window_buffer;  				frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  				for (int ch = 0; ch < 4; ch++)  					frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame3' true);  				fs3 = measure_frame_size (frame3' true);  			}  			if (fs2 + fs3 > fs)  				break;  			FlacFrame tmp = frame;  			frame = frame2;  			frame2 = tmp;  			fs = fs2;  			if (eparams.variable_block_size <= 2)  				break;  			tumbler = 1 - tumbler;  		}  	}  	frame.ChooseSubframes ();  	encode_estimated_frame (frame);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  	frame.window_buffer = window;  	frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  	frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  	for (int ch = 0; ch < channels; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	for (int ch = 0; ch < channels; ch++)  		encode_residual_pass2 (frame' ch);  }  else {  	//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  	frame.window_buffer = window;  	frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  	for (int ch = 0; ch < 4; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	//for (int ch = 0; ch < 4; ch++)  	//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  	//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  	estimate_frame (frame' true);  	uint fs = measure_frame_size (frame' true);  	if (0 != eparams.variable_block_size) {  		FlacFrame frame2 = new FlacFrame (channels * 2);  		FlacFrame frame3 = new FlacFrame (channels * 2);  		int tumbler = 1;  		while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  			frame2.InitSize (frame.blocksize / 2' true);  			frame2.window_buffer = frame.window_buffer + frame.blocksize;  			frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  			estimate_frame (frame2' true);  			uint fs2 = measure_frame_size (frame2' true);  			uint fs3 = fs2;  			if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  				frame3.InitSize (frame2.blocksize' true);  				frame3.window_buffer = frame2.window_buffer;  				frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  				for (int ch = 0; ch < 4; ch++)  					frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame3' true);  				fs3 = measure_frame_size (frame3' true);  			}  			if (fs2 + fs3 > fs)  				break;  			FlacFrame tmp = frame;  			frame = frame2;  			frame2 = tmp;  			fs = fs2;  			if (eparams.variable_block_size <= 2)  				break;  			tumbler = 1 - tumbler;  		}  	}  	frame.ChooseSubframes ();  	encode_estimated_frame (frame);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  	frame.window_buffer = window;  	frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  	frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  	for (int ch = 0; ch < channels; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	for (int ch = 0; ch < channels; ch++)  		encode_residual_pass2 (frame' ch);  }  else {  	//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  	frame.window_buffer = window;  	frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  	for (int ch = 0; ch < 4; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	//for (int ch = 0; ch < 4; ch++)  	//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  	//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  	estimate_frame (frame' true);  	uint fs = measure_frame_size (frame' true);  	if (0 != eparams.variable_block_size) {  		FlacFrame frame2 = new FlacFrame (channels * 2);  		FlacFrame frame3 = new FlacFrame (channels * 2);  		int tumbler = 1;  		while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  			frame2.InitSize (frame.blocksize / 2' true);  			frame2.window_buffer = frame.window_buffer + frame.blocksize;  			frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  			estimate_frame (frame2' true);  			uint fs2 = measure_frame_size (frame2' true);  			uint fs3 = fs2;  			if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  				frame3.InitSize (frame2.blocksize' true);  				frame3.window_buffer = frame2.window_buffer;  				frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  				for (int ch = 0; ch < 4; ch++)  					frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame3' true);  				fs3 = measure_frame_size (frame3' true);  			}  			if (fs2 + fs3 > fs)  				break;  			FlacFrame tmp = frame;  			frame = frame2;  			frame2 = tmp;  			fs = fs2;  			if (eparams.variable_block_size <= 2)  				break;  			tumbler = 1 - tumbler;  		}  	}  	frame.ChooseSubframes ();  	encode_estimated_frame (frame);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  	frame.window_buffer = window;  	frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  	frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  	for (int ch = 0; ch < channels; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	for (int ch = 0; ch < channels; ch++)  		encode_residual_pass2 (frame' ch);  }  else {  	//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  	frame.window_buffer = window;  	frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  	for (int ch = 0; ch < 4; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	//for (int ch = 0; ch < 4; ch++)  	//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  	//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  	estimate_frame (frame' true);  	uint fs = measure_frame_size (frame' true);  	if (0 != eparams.variable_block_size) {  		FlacFrame frame2 = new FlacFrame (channels * 2);  		FlacFrame frame3 = new FlacFrame (channels * 2);  		int tumbler = 1;  		while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  			frame2.InitSize (frame.blocksize / 2' true);  			frame2.window_buffer = frame.window_buffer + frame.blocksize;  			frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  			estimate_frame (frame2' true);  			uint fs2 = measure_frame_size (frame2' true);  			uint fs3 = fs2;  			if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  				frame3.InitSize (frame2.blocksize' true);  				frame3.window_buffer = frame2.window_buffer;  				frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  				for (int ch = 0; ch < 4; ch++)  					frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame3' true);  				fs3 = measure_frame_size (frame3' true);  			}  			if (fs2 + fs3 > fs)  				break;  			FlacFrame tmp = frame;  			frame = frame2;  			frame2 = tmp;  			fs = fs2;  			if (eparams.variable_block_size <= 2)  				break;  			tumbler = 1 - tumbler;  		}  	}  	frame.ChooseSubframes ();  	encode_estimated_frame (frame);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  	frame.window_buffer = window;  	frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  	frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  	for (int ch = 0; ch < channels; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	for (int ch = 0; ch < channels; ch++)  		encode_residual_pass2 (frame' ch);  }  else {  	//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  	frame.window_buffer = window;  	frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  	for (int ch = 0; ch < 4; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	//for (int ch = 0; ch < 4; ch++)  	//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  	//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  	estimate_frame (frame' true);  	uint fs = measure_frame_size (frame' true);  	if (0 != eparams.variable_block_size) {  		FlacFrame frame2 = new FlacFrame (channels * 2);  		FlacFrame frame3 = new FlacFrame (channels * 2);  		int tumbler = 1;  		while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  			frame2.InitSize (frame.blocksize / 2' true);  			frame2.window_buffer = frame.window_buffer + frame.blocksize;  			frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  			estimate_frame (frame2' true);  			uint fs2 = measure_frame_size (frame2' true);  			uint fs3 = fs2;  			if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  				frame3.InitSize (frame2.blocksize' true);  				frame3.window_buffer = frame2.window_buffer;  				frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  				for (int ch = 0; ch < 4; ch++)  					frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame3' true);  				fs3 = measure_frame_size (frame3' true);  			}  			if (fs2 + fs3 > fs)  				break;  			FlacFrame tmp = frame;  			frame = frame2;  			frame2 = tmp;  			fs = fs2;  			if (eparams.variable_block_size <= 2)  				break;  			tumbler = 1 - tumbler;  		}  	}  	frame.ChooseSubframes ();  	encode_estimated_frame (frame);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  	frame.window_buffer = window;  	frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  	frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  	for (int ch = 0; ch < channels; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	for (int ch = 0; ch < channels; ch++)  		encode_residual_pass2 (frame' ch);  }  else {  	//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  	frame.window_buffer = window;  	frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  	for (int ch = 0; ch < 4; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	//for (int ch = 0; ch < 4; ch++)  	//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  	//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  	estimate_frame (frame' true);  	uint fs = measure_frame_size (frame' true);  	if (0 != eparams.variable_block_size) {  		FlacFrame frame2 = new FlacFrame (channels * 2);  		FlacFrame frame3 = new FlacFrame (channels * 2);  		int tumbler = 1;  		while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  			frame2.InitSize (frame.blocksize / 2' true);  			frame2.window_buffer = frame.window_buffer + frame.blocksize;  			frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  			estimate_frame (frame2' true);  			uint fs2 = measure_frame_size (frame2' true);  			uint fs3 = fs2;  			if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  				frame3.InitSize (frame2.blocksize' true);  				frame3.window_buffer = frame2.window_buffer;  				frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  				for (int ch = 0; ch < 4; ch++)  					frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame3' true);  				fs3 = measure_frame_size (frame3' true);  			}  			if (fs2 + fs3 > fs)  				break;  			FlacFrame tmp = frame;  			frame = frame2;  			frame2 = tmp;  			fs = fs2;  			if (eparams.variable_block_size <= 2)  				break;  			tumbler = 1 - tumbler;  		}  	}  	frame.ChooseSubframes ();  	encode_estimated_frame (frame);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  	frame.window_buffer = window;  	frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  	frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  	for (int ch = 0; ch < channels; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	for (int ch = 0; ch < channels; ch++)  		encode_residual_pass2 (frame' ch);  }  else {  	//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  	frame.window_buffer = window;  	frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  	for (int ch = 0; ch < 4; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	//for (int ch = 0; ch < 4; ch++)  	//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  	//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  	estimate_frame (frame' true);  	uint fs = measure_frame_size (frame' true);  	if (0 != eparams.variable_block_size) {  		FlacFrame frame2 = new FlacFrame (channels * 2);  		FlacFrame frame3 = new FlacFrame (channels * 2);  		int tumbler = 1;  		while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  			frame2.InitSize (frame.blocksize / 2' true);  			frame2.window_buffer = frame.window_buffer + frame.blocksize;  			frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  			estimate_frame (frame2' true);  			uint fs2 = measure_frame_size (frame2' true);  			uint fs3 = fs2;  			if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  				frame3.InitSize (frame2.blocksize' true);  				frame3.window_buffer = frame2.window_buffer;  				frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  				for (int ch = 0; ch < 4; ch++)  					frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame3' true);  				fs3 = measure_frame_size (frame3' true);  			}  			if (fs2 + fs3 > fs)  				break;  			FlacFrame tmp = frame;  			frame = frame2;  			frame2 = tmp;  			fs = fs2;  			if (eparams.variable_block_size <= 2)  				break;  			tumbler = 1 - tumbler;  		}  	}  	frame.ChooseSubframes ();  	encode_estimated_frame (frame);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  	frame.window_buffer = window;  	frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  	frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  	for (int ch = 0; ch < channels; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	for (int ch = 0; ch < channels; ch++)  		encode_residual_pass2 (frame' ch);  }  else {  	//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  	frame.window_buffer = window;  	frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  	for (int ch = 0; ch < 4; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	//for (int ch = 0; ch < 4; ch++)  	//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  	//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  	estimate_frame (frame' true);  	uint fs = measure_frame_size (frame' true);  	if (0 != eparams.variable_block_size) {  		FlacFrame frame2 = new FlacFrame (channels * 2);  		FlacFrame frame3 = new FlacFrame (channels * 2);  		int tumbler = 1;  		while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  			frame2.InitSize (frame.blocksize / 2' true);  			frame2.window_buffer = frame.window_buffer + frame.blocksize;  			frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  			estimate_frame (frame2' true);  			uint fs2 = measure_frame_size (frame2' true);  			uint fs3 = fs2;  			if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  				frame3.InitSize (frame2.blocksize' true);  				frame3.window_buffer = frame2.window_buffer;  				frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  				for (int ch = 0; ch < 4; ch++)  					frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame3' true);  				fs3 = measure_frame_size (frame3' true);  			}  			if (fs2 + fs3 > fs)  				break;  			FlacFrame tmp = frame;  			frame = frame2;  			frame2 = tmp;  			fs = fs2;  			if (eparams.variable_block_size <= 2)  				break;  			tumbler = 1 - tumbler;  		}  	}  	frame.ChooseSubframes ();  	encode_estimated_frame (frame);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  	frame.window_buffer = window;  	frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  	frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  	for (int ch = 0; ch < channels; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	for (int ch = 0; ch < channels; ch++)  		encode_residual_pass2 (frame' ch);  }  else {  	//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  	frame.window_buffer = window;  	frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  	for (int ch = 0; ch < 4; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	//for (int ch = 0; ch < 4; ch++)  	//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  	//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  	estimate_frame (frame' true);  	uint fs = measure_frame_size (frame' true);  	if (0 != eparams.variable_block_size) {  		FlacFrame frame2 = new FlacFrame (channels * 2);  		FlacFrame frame3 = new FlacFrame (channels * 2);  		int tumbler = 1;  		while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  			frame2.InitSize (frame.blocksize / 2' true);  			frame2.window_buffer = frame.window_buffer + frame.blocksize;  			frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  			estimate_frame (frame2' true);  			uint fs2 = measure_frame_size (frame2' true);  			uint fs3 = fs2;  			if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  				frame3.InitSize (frame2.blocksize' true);  				frame3.window_buffer = frame2.window_buffer;  				frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  				for (int ch = 0; ch < 4; ch++)  					frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame3' true);  				fs3 = measure_frame_size (frame3' true);  			}  			if (fs2 + fs3 > fs)  				break;  			FlacFrame tmp = frame;  			frame = frame2;  			frame2 = tmp;  			fs = fs2;  			if (eparams.variable_block_size <= 2)  				break;  			tumbler = 1 - tumbler;  		}  	}  	frame.ChooseSubframes ();  	encode_estimated_frame (frame);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (channels != 2 || frame.blocksize <= 32 || eparams.stereo_method == StereoMethod.Independent) {  	frame.window_buffer = window;  	frame.current.residual = r + channels * Flake.MAX_BLOCKSIZE;  	frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  	for (int ch = 0; ch < channels; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	for (int ch = 0; ch < channels; ch++)  		encode_residual_pass2 (frame' ch);  }  else {  	//channel_decorrelation(s' s + Flake.MAX_BLOCKSIZE' s + 2 * Flake.MAX_BLOCKSIZE' s + 3 * Flake.MAX_BLOCKSIZE' frame.blocksize);  	frame.window_buffer = window;  	frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  	for (int ch = 0; ch < 4; ch++)  		frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  	//for (int ch = 0; ch < 4; ch++)  	//    for (int iWindow = 0; iWindow < _windowcount; iWindow++)  	//        frame.subframes[ch].lpc_ctx[iWindow].GetReflection(32' frame.subframes[ch].samples' frame.blocksize' frame.window_buffer + iWindow * Flake.MAX_BLOCKSIZE * 2);  	estimate_frame (frame' true);  	uint fs = measure_frame_size (frame' true);  	if (0 != eparams.variable_block_size) {  		FlacFrame frame2 = new FlacFrame (channels * 2);  		FlacFrame frame3 = new FlacFrame (channels * 2);  		int tumbler = 1;  		while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  			frame2.InitSize (frame.blocksize / 2' true);  			frame2.window_buffer = frame.window_buffer + frame.blocksize;  			frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  			for (int ch = 0; ch < 4; ch++)  				frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  			estimate_frame (frame2' true);  			uint fs2 = measure_frame_size (frame2' true);  			uint fs3 = fs2;  			if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  				frame3.InitSize (frame2.blocksize' true);  				frame3.window_buffer = frame2.window_buffer;  				frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  				for (int ch = 0; ch < 4; ch++)  					frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  				estimate_frame (frame3' true);  				fs3 = measure_frame_size (frame3' true);  			}  			if (fs2 + fs3 > fs)  				break;  			FlacFrame tmp = frame;  			frame = frame2;  			frame2 = tmp;  			fs = fs2;  			if (eparams.variable_block_size <= 2)  				break;  			tumbler = 1 - tumbler;  		}  	}  	frame.ChooseSubframes ();  	encode_estimated_frame (frame);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: frame.ch_mode = channels != 2 ? ChannelMode.NotStereo : ChannelMode.LeftRight;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: frame.current.residual = r + 4 * Flake.MAX_BLOCKSIZE;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: for (int ch = 0; ch < 4; ch++)  	frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: for (int ch = 0; ch < 4; ch++)  	frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: frame.subframes [ch].Init (s + ch * Flake.MAX_BLOCKSIZE' r + ch * Flake.MAX_BLOCKSIZE' _pcm.BitsPerSample + (ch == 3 ? 1 : 0)' get_wasted_bits (s + ch * Flake.MAX_BLOCKSIZE' frame.blocksize));  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (0 != eparams.variable_block_size) {  	FlacFrame frame2 = new FlacFrame (channels * 2);  	FlacFrame frame3 = new FlacFrame (channels * 2);  	int tumbler = 1;  	while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  		frame2.InitSize (frame.blocksize / 2' true);  		frame2.window_buffer = frame.window_buffer + frame.blocksize;  		frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  		for (int ch = 0; ch < 4; ch++)  			frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  		estimate_frame (frame2' true);  		uint fs2 = measure_frame_size (frame2' true);  		uint fs3 = fs2;  		if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  			frame3.InitSize (frame2.blocksize' true);  			frame3.window_buffer = frame2.window_buffer;  			frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  			for (int ch = 0; ch < 4; ch++)  				frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  			estimate_frame (frame3' true);  			fs3 = measure_frame_size (frame3' true);  		}  		if (fs2 + fs3 > fs)  			break;  		FlacFrame tmp = frame;  		frame = frame2;  		frame2 = tmp;  		fs = fs2;  		if (eparams.variable_block_size <= 2)  			break;  		tumbler = 1 - tumbler;  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (0 != eparams.variable_block_size) {  	FlacFrame frame2 = new FlacFrame (channels * 2);  	FlacFrame frame3 = new FlacFrame (channels * 2);  	int tumbler = 1;  	while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  		frame2.InitSize (frame.blocksize / 2' true);  		frame2.window_buffer = frame.window_buffer + frame.blocksize;  		frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  		for (int ch = 0; ch < 4; ch++)  			frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  		estimate_frame (frame2' true);  		uint fs2 = measure_frame_size (frame2' true);  		uint fs3 = fs2;  		if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  			frame3.InitSize (frame2.blocksize' true);  			frame3.window_buffer = frame2.window_buffer;  			frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  			for (int ch = 0; ch < 4; ch++)  				frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  			estimate_frame (frame3' true);  			fs3 = measure_frame_size (frame3' true);  		}  		if (fs2 + fs3 > fs)  			break;  		FlacFrame tmp = frame;  		frame = frame2;  		frame2 = tmp;  		fs = fs2;  		if (eparams.variable_block_size <= 2)  			break;  		tumbler = 1 - tumbler;  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (0 != eparams.variable_block_size) {  	FlacFrame frame2 = new FlacFrame (channels * 2);  	FlacFrame frame3 = new FlacFrame (channels * 2);  	int tumbler = 1;  	while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  		frame2.InitSize (frame.blocksize / 2' true);  		frame2.window_buffer = frame.window_buffer + frame.blocksize;  		frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  		for (int ch = 0; ch < 4; ch++)  			frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  		estimate_frame (frame2' true);  		uint fs2 = measure_frame_size (frame2' true);  		uint fs3 = fs2;  		if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  			frame3.InitSize (frame2.blocksize' true);  			frame3.window_buffer = frame2.window_buffer;  			frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  			for (int ch = 0; ch < 4; ch++)  				frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  			estimate_frame (frame3' true);  			fs3 = measure_frame_size (frame3' true);  		}  		if (fs2 + fs3 > fs)  			break;  		FlacFrame tmp = frame;  		frame = frame2;  		frame2 = tmp;  		fs = fs2;  		if (eparams.variable_block_size <= 2)  			break;  		tumbler = 1 - tumbler;  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (0 != eparams.variable_block_size) {  	FlacFrame frame2 = new FlacFrame (channels * 2);  	FlacFrame frame3 = new FlacFrame (channels * 2);  	int tumbler = 1;  	while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  		frame2.InitSize (frame.blocksize / 2' true);  		frame2.window_buffer = frame.window_buffer + frame.blocksize;  		frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  		for (int ch = 0; ch < 4; ch++)  			frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  		estimate_frame (frame2' true);  		uint fs2 = measure_frame_size (frame2' true);  		uint fs3 = fs2;  		if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  			frame3.InitSize (frame2.blocksize' true);  			frame3.window_buffer = frame2.window_buffer;  			frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  			for (int ch = 0; ch < 4; ch++)  				frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  			estimate_frame (frame3' true);  			fs3 = measure_frame_size (frame3' true);  		}  		if (fs2 + fs3 > fs)  			break;  		FlacFrame tmp = frame;  		frame = frame2;  		frame2 = tmp;  		fs = fs2;  		if (eparams.variable_block_size <= 2)  			break;  		tumbler = 1 - tumbler;  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (0 != eparams.variable_block_size) {  	FlacFrame frame2 = new FlacFrame (channels * 2);  	FlacFrame frame3 = new FlacFrame (channels * 2);  	int tumbler = 1;  	while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  		frame2.InitSize (frame.blocksize / 2' true);  		frame2.window_buffer = frame.window_buffer + frame.blocksize;  		frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  		for (int ch = 0; ch < 4; ch++)  			frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  		estimate_frame (frame2' true);  		uint fs2 = measure_frame_size (frame2' true);  		uint fs3 = fs2;  		if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  			frame3.InitSize (frame2.blocksize' true);  			frame3.window_buffer = frame2.window_buffer;  			frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  			for (int ch = 0; ch < 4; ch++)  				frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  			estimate_frame (frame3' true);  			fs3 = measure_frame_size (frame3' true);  		}  		if (fs2 + fs3 > fs)  			break;  		FlacFrame tmp = frame;  		frame = frame2;  		frame2 = tmp;  		fs = fs2;  		if (eparams.variable_block_size <= 2)  			break;  		tumbler = 1 - tumbler;  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (0 != eparams.variable_block_size) {  	FlacFrame frame2 = new FlacFrame (channels * 2);  	FlacFrame frame3 = new FlacFrame (channels * 2);  	int tumbler = 1;  	while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  		frame2.InitSize (frame.blocksize / 2' true);  		frame2.window_buffer = frame.window_buffer + frame.blocksize;  		frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  		for (int ch = 0; ch < 4; ch++)  			frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  		estimate_frame (frame2' true);  		uint fs2 = measure_frame_size (frame2' true);  		uint fs3 = fs2;  		if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  			frame3.InitSize (frame2.blocksize' true);  			frame3.window_buffer = frame2.window_buffer;  			frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  			for (int ch = 0; ch < 4; ch++)  				frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  			estimate_frame (frame3' true);  			fs3 = measure_frame_size (frame3' true);  		}  		if (fs2 + fs3 > fs)  			break;  		FlacFrame tmp = frame;  		frame = frame2;  		frame2 = tmp;  		fs = fs2;  		if (eparams.variable_block_size <= 2)  			break;  		tumbler = 1 - tumbler;  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (0 != eparams.variable_block_size) {  	FlacFrame frame2 = new FlacFrame (channels * 2);  	FlacFrame frame3 = new FlacFrame (channels * 2);  	int tumbler = 1;  	while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  		frame2.InitSize (frame.blocksize / 2' true);  		frame2.window_buffer = frame.window_buffer + frame.blocksize;  		frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  		for (int ch = 0; ch < 4; ch++)  			frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  		estimate_frame (frame2' true);  		uint fs2 = measure_frame_size (frame2' true);  		uint fs3 = fs2;  		if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  			frame3.InitSize (frame2.blocksize' true);  			frame3.window_buffer = frame2.window_buffer;  			frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  			for (int ch = 0; ch < 4; ch++)  				frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  			estimate_frame (frame3' true);  			fs3 = measure_frame_size (frame3' true);  		}  		if (fs2 + fs3 > fs)  			break;  		FlacFrame tmp = frame;  		frame = frame2;  		frame2 = tmp;  		fs = fs2;  		if (eparams.variable_block_size <= 2)  			break;  		tumbler = 1 - tumbler;  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (0 != eparams.variable_block_size) {  	FlacFrame frame2 = new FlacFrame (channels * 2);  	FlacFrame frame3 = new FlacFrame (channels * 2);  	int tumbler = 1;  	while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  		frame2.InitSize (frame.blocksize / 2' true);  		frame2.window_buffer = frame.window_buffer + frame.blocksize;  		frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  		for (int ch = 0; ch < 4; ch++)  			frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  		estimate_frame (frame2' true);  		uint fs2 = measure_frame_size (frame2' true);  		uint fs3 = fs2;  		if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  			frame3.InitSize (frame2.blocksize' true);  			frame3.window_buffer = frame2.window_buffer;  			frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  			for (int ch = 0; ch < 4; ch++)  				frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  			estimate_frame (frame3' true);  			fs3 = measure_frame_size (frame3' true);  		}  		if (fs2 + fs3 > fs)  			break;  		FlacFrame tmp = frame;  		frame = frame2;  		frame2 = tmp;  		fs = fs2;  		if (eparams.variable_block_size <= 2)  			break;  		tumbler = 1 - tumbler;  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (0 != eparams.variable_block_size) {  	FlacFrame frame2 = new FlacFrame (channels * 2);  	FlacFrame frame3 = new FlacFrame (channels * 2);  	int tumbler = 1;  	while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  		frame2.InitSize (frame.blocksize / 2' true);  		frame2.window_buffer = frame.window_buffer + frame.blocksize;  		frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  		for (int ch = 0; ch < 4; ch++)  			frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  		estimate_frame (frame2' true);  		uint fs2 = measure_frame_size (frame2' true);  		uint fs3 = fs2;  		if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  			frame3.InitSize (frame2.blocksize' true);  			frame3.window_buffer = frame2.window_buffer;  			frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  			for (int ch = 0; ch < 4; ch++)  				frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  			estimate_frame (frame3' true);  			fs3 = measure_frame_size (frame3' true);  		}  		if (fs2 + fs3 > fs)  			break;  		FlacFrame tmp = frame;  		frame = frame2;  		frame2 = tmp;  		fs = fs2;  		if (eparams.variable_block_size <= 2)  			break;  		tumbler = 1 - tumbler;  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (0 != eparams.variable_block_size) {  	FlacFrame frame2 = new FlacFrame (channels * 2);  	FlacFrame frame3 = new FlacFrame (channels * 2);  	int tumbler = 1;  	while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  		frame2.InitSize (frame.blocksize / 2' true);  		frame2.window_buffer = frame.window_buffer + frame.blocksize;  		frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  		for (int ch = 0; ch < 4; ch++)  			frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  		estimate_frame (frame2' true);  		uint fs2 = measure_frame_size (frame2' true);  		uint fs3 = fs2;  		if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  			frame3.InitSize (frame2.blocksize' true);  			frame3.window_buffer = frame2.window_buffer;  			frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  			for (int ch = 0; ch < 4; ch++)  				frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  			estimate_frame (frame3' true);  			fs3 = measure_frame_size (frame3' true);  		}  		if (fs2 + fs3 > fs)  			break;  		FlacFrame tmp = frame;  		frame = frame2;  		frame2 = tmp;  		fs = fs2;  		if (eparams.variable_block_size <= 2)  			break;  		tumbler = 1 - tumbler;  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (0 != eparams.variable_block_size) {  	FlacFrame frame2 = new FlacFrame (channels * 2);  	FlacFrame frame3 = new FlacFrame (channels * 2);  	int tumbler = 1;  	while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  		frame2.InitSize (frame.blocksize / 2' true);  		frame2.window_buffer = frame.window_buffer + frame.blocksize;  		frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  		for (int ch = 0; ch < 4; ch++)  			frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  		estimate_frame (frame2' true);  		uint fs2 = measure_frame_size (frame2' true);  		uint fs3 = fs2;  		if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  			frame3.InitSize (frame2.blocksize' true);  			frame3.window_buffer = frame2.window_buffer;  			frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  			for (int ch = 0; ch < 4; ch++)  				frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  			estimate_frame (frame3' true);  			fs3 = measure_frame_size (frame3' true);  		}  		if (fs2 + fs3 > fs)  			break;  		FlacFrame tmp = frame;  		frame = frame2;  		frame2 = tmp;  		fs = fs2;  		if (eparams.variable_block_size <= 2)  			break;  		tumbler = 1 - tumbler;  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  	frame2.InitSize (frame.blocksize / 2' true);  	frame2.window_buffer = frame.window_buffer + frame.blocksize;  	frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  	for (int ch = 0; ch < 4; ch++)  		frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  	estimate_frame (frame2' true);  	uint fs2 = measure_frame_size (frame2' true);  	uint fs3 = fs2;  	if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  		frame3.InitSize (frame2.blocksize' true);  		frame3.window_buffer = frame2.window_buffer;  		frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  		for (int ch = 0; ch < 4; ch++)  			frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  		estimate_frame (frame3' true);  		fs3 = measure_frame_size (frame3' true);  	}  	if (fs2 + fs3 > fs)  		break;  	FlacFrame tmp = frame;  	frame = frame2;  	frame2 = tmp;  	fs = fs2;  	if (eparams.variable_block_size <= 2)  		break;  	tumbler = 1 - tumbler;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  	frame2.InitSize (frame.blocksize / 2' true);  	frame2.window_buffer = frame.window_buffer + frame.blocksize;  	frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  	for (int ch = 0; ch < 4; ch++)  		frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  	estimate_frame (frame2' true);  	uint fs2 = measure_frame_size (frame2' true);  	uint fs3 = fs2;  	if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  		frame3.InitSize (frame2.blocksize' true);  		frame3.window_buffer = frame2.window_buffer;  		frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  		for (int ch = 0; ch < 4; ch++)  			frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  		estimate_frame (frame3' true);  		fs3 = measure_frame_size (frame3' true);  	}  	if (fs2 + fs3 > fs)  		break;  	FlacFrame tmp = frame;  	frame = frame2;  	frame2 = tmp;  	fs = fs2;  	if (eparams.variable_block_size <= 2)  		break;  	tumbler = 1 - tumbler;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  	frame2.InitSize (frame.blocksize / 2' true);  	frame2.window_buffer = frame.window_buffer + frame.blocksize;  	frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  	for (int ch = 0; ch < 4; ch++)  		frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  	estimate_frame (frame2' true);  	uint fs2 = measure_frame_size (frame2' true);  	uint fs3 = fs2;  	if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  		frame3.InitSize (frame2.blocksize' true);  		frame3.window_buffer = frame2.window_buffer;  		frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  		for (int ch = 0; ch < 4; ch++)  			frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  		estimate_frame (frame3' true);  		fs3 = measure_frame_size (frame3' true);  	}  	if (fs2 + fs3 > fs)  		break;  	FlacFrame tmp = frame;  	frame = frame2;  	frame2 = tmp;  	fs = fs2;  	if (eparams.variable_block_size <= 2)  		break;  	tumbler = 1 - tumbler;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  	frame2.InitSize (frame.blocksize / 2' true);  	frame2.window_buffer = frame.window_buffer + frame.blocksize;  	frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  	for (int ch = 0; ch < 4; ch++)  		frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  	estimate_frame (frame2' true);  	uint fs2 = measure_frame_size (frame2' true);  	uint fs3 = fs2;  	if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  		frame3.InitSize (frame2.blocksize' true);  		frame3.window_buffer = frame2.window_buffer;  		frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  		for (int ch = 0; ch < 4; ch++)  			frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  		estimate_frame (frame3' true);  		fs3 = measure_frame_size (frame3' true);  	}  	if (fs2 + fs3 > fs)  		break;  	FlacFrame tmp = frame;  	frame = frame2;  	frame2 = tmp;  	fs = fs2;  	if (eparams.variable_block_size <= 2)  		break;  	tumbler = 1 - tumbler;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  	frame2.InitSize (frame.blocksize / 2' true);  	frame2.window_buffer = frame.window_buffer + frame.blocksize;  	frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  	for (int ch = 0; ch < 4; ch++)  		frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  	estimate_frame (frame2' true);  	uint fs2 = measure_frame_size (frame2' true);  	uint fs3 = fs2;  	if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  		frame3.InitSize (frame2.blocksize' true);  		frame3.window_buffer = frame2.window_buffer;  		frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  		for (int ch = 0; ch < 4; ch++)  			frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  		estimate_frame (frame3' true);  		fs3 = measure_frame_size (frame3' true);  	}  	if (fs2 + fs3 > fs)  		break;  	FlacFrame tmp = frame;  	frame = frame2;  	frame2 = tmp;  	fs = fs2;  	if (eparams.variable_block_size <= 2)  		break;  	tumbler = 1 - tumbler;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  	frame2.InitSize (frame.blocksize / 2' true);  	frame2.window_buffer = frame.window_buffer + frame.blocksize;  	frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  	for (int ch = 0; ch < 4; ch++)  		frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  	estimate_frame (frame2' true);  	uint fs2 = measure_frame_size (frame2' true);  	uint fs3 = fs2;  	if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  		frame3.InitSize (frame2.blocksize' true);  		frame3.window_buffer = frame2.window_buffer;  		frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  		for (int ch = 0; ch < 4; ch++)  			frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  		estimate_frame (frame3' true);  		fs3 = measure_frame_size (frame3' true);  	}  	if (fs2 + fs3 > fs)  		break;  	FlacFrame tmp = frame;  	frame = frame2;  	frame2 = tmp;  	fs = fs2;  	if (eparams.variable_block_size <= 2)  		break;  	tumbler = 1 - tumbler;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  	frame2.InitSize (frame.blocksize / 2' true);  	frame2.window_buffer = frame.window_buffer + frame.blocksize;  	frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  	for (int ch = 0; ch < 4; ch++)  		frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  	estimate_frame (frame2' true);  	uint fs2 = measure_frame_size (frame2' true);  	uint fs3 = fs2;  	if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  		frame3.InitSize (frame2.blocksize' true);  		frame3.window_buffer = frame2.window_buffer;  		frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  		for (int ch = 0; ch < 4; ch++)  			frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  		estimate_frame (frame3' true);  		fs3 = measure_frame_size (frame3' true);  	}  	if (fs2 + fs3 > fs)  		break;  	FlacFrame tmp = frame;  	frame = frame2;  	frame2 = tmp;  	fs = fs2;  	if (eparams.variable_block_size <= 2)  		break;  	tumbler = 1 - tumbler;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  	frame2.InitSize (frame.blocksize / 2' true);  	frame2.window_buffer = frame.window_buffer + frame.blocksize;  	frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  	for (int ch = 0; ch < 4; ch++)  		frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  	estimate_frame (frame2' true);  	uint fs2 = measure_frame_size (frame2' true);  	uint fs3 = fs2;  	if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  		frame3.InitSize (frame2.blocksize' true);  		frame3.window_buffer = frame2.window_buffer;  		frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  		for (int ch = 0; ch < 4; ch++)  			frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  		estimate_frame (frame3' true);  		fs3 = measure_frame_size (frame3' true);  	}  	if (fs2 + fs3 > fs)  		break;  	FlacFrame tmp = frame;  	frame = frame2;  	frame2 = tmp;  	fs = fs2;  	if (eparams.variable_block_size <= 2)  		break;  	tumbler = 1 - tumbler;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: while ((frame.blocksize & 1) == 0 && frame.blocksize >= 1024) {  	frame2.InitSize (frame.blocksize / 2' true);  	frame2.window_buffer = frame.window_buffer + frame.blocksize;  	frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  	for (int ch = 0; ch < 4; ch++)  		frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  	estimate_frame (frame2' true);  	uint fs2 = measure_frame_size (frame2' true);  	uint fs3 = fs2;  	if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  		frame3.InitSize (frame2.blocksize' true);  		frame3.window_buffer = frame2.window_buffer;  		frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  		for (int ch = 0; ch < 4; ch++)  			frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  		estimate_frame (frame3' true);  		fs3 = measure_frame_size (frame3' true);  	}  	if (fs2 + fs3 > fs)  		break;  	FlacFrame tmp = frame;  	frame = frame2;  	frame2 = tmp;  	fs = fs2;  	if (eparams.variable_block_size <= 2)  		break;  	tumbler = 1 - tumbler;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: frame2.InitSize (frame.blocksize / 2' true);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: frame2.current.residual = r + tumbler * 5 * Flake.MAX_BLOCKSIZE;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: for (int ch = 0; ch < 4; ch++)  	frame2.subframes [ch].Init (frame.subframes [ch].samples' frame2.current.residual + (ch + 1) * frame2.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  	frame3.InitSize (frame2.blocksize' true);  	frame3.window_buffer = frame2.window_buffer;  	frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  	for (int ch = 0; ch < 4; ch++)  		frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  	estimate_frame (frame3' true);  	fs3 = measure_frame_size (frame3' true);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  	frame3.InitSize (frame2.blocksize' true);  	frame3.window_buffer = frame2.window_buffer;  	frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  	for (int ch = 0; ch < 4; ch++)  		frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  	estimate_frame (frame3' true);  	fs3 = measure_frame_size (frame3' true);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  	frame3.InitSize (frame2.blocksize' true);  	frame3.window_buffer = frame2.window_buffer;  	frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  	for (int ch = 0; ch < 4; ch++)  		frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  	estimate_frame (frame3' true);  	fs3 = measure_frame_size (frame3' true);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (eparams.variable_block_size == 2 || eparams.variable_block_size == 4) {  	frame3.InitSize (frame2.blocksize' true);  	frame3.window_buffer = frame2.window_buffer;  	frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  	for (int ch = 0; ch < 4; ch++)  		frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  	estimate_frame (frame3' true);  	fs3 = measure_frame_size (frame3' true);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: frame3.current.residual = frame2.current.residual + 5 * frame2.blocksize;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: for (int ch = 0; ch < 4; ch++)  	frame3.subframes [ch].Init (frame2.subframes [ch].samples + frame2.blocksize' frame3.current.residual + (ch + 1) * frame3.blocksize' frame.subframes [ch].obits + frame.subframes [ch].wbits' frame.subframes [ch].wbits);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_frame,The following statement contains a magic number: if (eparams.variable_block_size <= 2)  	break;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_frame,The following statement contains a magic number: if (bs < eparams.block_size) {  	for (int ch = 0; ch < (channels == 2 ? 4 : channels); ch++)  		Buffer.BlockCopy (samplesBuffer' (bs + ch * Flake.MAX_BLOCKSIZE) * sizeof(int)' samplesBuffer' ch * Flake.MAX_BLOCKSIZE * sizeof(int)' (eparams.block_size - bs) * sizeof(int));  	//fixed (int* s = samplesBuffer)  	//    for (int ch = 0; ch < channels; ch++)  	//        AudioSamples.MemCpy(s + ch * Flake.MAX_BLOCKSIZE' s + bs + ch * Flake.MAX_BLOCKSIZE' eparams.block_size - bs);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_frame,The following statement contains a magic number: if (bs < eparams.block_size) {  	for (int ch = 0; ch < (channels == 2 ? 4 : channels); ch++)  		Buffer.BlockCopy (samplesBuffer' (bs + ch * Flake.MAX_BLOCKSIZE) * sizeof(int)' samplesBuffer' ch * Flake.MAX_BLOCKSIZE * sizeof(int)' (eparams.block_size - bs) * sizeof(int));  	//fixed (int* s = samplesBuffer)  	//    for (int ch = 0; ch < channels; ch++)  	//        AudioSamples.MemCpy(s + ch * Flake.MAX_BLOCKSIZE' s + bs + ch * Flake.MAX_BLOCKSIZE' eparams.block_size - bs);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_frame,The following statement contains a magic number: for (int ch = 0; ch < (channels == 2 ? 4 : channels); ch++)  	Buffer.BlockCopy (samplesBuffer' (bs + ch * Flake.MAX_BLOCKSIZE) * sizeof(int)' samplesBuffer' ch * Flake.MAX_BLOCKSIZE * sizeof(int)' (eparams.block_size - bs) * sizeof(int));  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_frame,The following statement contains a magic number: for (int ch = 0; ch < (channels == 2 ? 4 : channels); ch++)  	Buffer.BlockCopy (samplesBuffer' (bs + ch * Flake.MAX_BLOCKSIZE) * sizeof(int)' samplesBuffer' ch * Flake.MAX_BLOCKSIZE * sizeof(int)' (eparams.block_size - bs) * sizeof(int));  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,select_blocksize,The following statement contains a magic number: if (eparams.variable_block_size > 0) {  	blocksize = 1024;  	while (target >= blocksize)  		blocksize <<= 1;  	return blocksize >> 1;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,select_blocksize,The following statement contains a magic number: blocksize = 1024;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_streaminfo,The following statement contains a magic number: Array.Clear (header' pos' 38);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_streaminfo,The following statement contains a magic number: bitwriter.writebits (7' (int)MetadataType.StreamInfo);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_streaminfo,The following statement contains a magic number: bitwriter.writebits (24' 34);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_streaminfo,The following statement contains a magic number: bitwriter.writebits (24' 34);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_streaminfo,The following statement contains a magic number: if (eparams.variable_block_size > 0)  	bitwriter.writebits (16' 0);  else  	bitwriter.writebits (16' eparams.block_size);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_streaminfo,The following statement contains a magic number: if (eparams.variable_block_size > 0)  	bitwriter.writebits (16' 0);  else  	bitwriter.writebits (16' eparams.block_size);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_streaminfo,The following statement contains a magic number: bitwriter.writebits (16' 0);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_streaminfo,The following statement contains a magic number: bitwriter.writebits (16' eparams.block_size);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_streaminfo,The following statement contains a magic number: bitwriter.writebits (16' eparams.block_size);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_streaminfo,The following statement contains a magic number: bitwriter.writebits (24' 0);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_streaminfo,The following statement contains a magic number: bitwriter.writebits (24' max_frame_size);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_streaminfo,The following statement contains a magic number: bitwriter.writebits (20' _pcm.SampleRate);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_streaminfo,The following statement contains a magic number: bitwriter.writebits (3' channels - 1);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_streaminfo,The following statement contains a magic number: bitwriter.writebits (5' _pcm.BitsPerSample - 1);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_streaminfo,The following statement contains a magic number: if (sample_count > 0) {  	bitwriter.writebits (4' 0);  	bitwriter.writebits (32' sample_count);  }  else {  	bitwriter.writebits (4' 0);  	bitwriter.writebits (32' 0);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_streaminfo,The following statement contains a magic number: if (sample_count > 0) {  	bitwriter.writebits (4' 0);  	bitwriter.writebits (32' sample_count);  }  else {  	bitwriter.writebits (4' 0);  	bitwriter.writebits (32' 0);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_streaminfo,The following statement contains a magic number: if (sample_count > 0) {  	bitwriter.writebits (4' 0);  	bitwriter.writebits (32' sample_count);  }  else {  	bitwriter.writebits (4' 0);  	bitwriter.writebits (32' 0);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_streaminfo,The following statement contains a magic number: if (sample_count > 0) {  	bitwriter.writebits (4' 0);  	bitwriter.writebits (32' sample_count);  }  else {  	bitwriter.writebits (4' 0);  	bitwriter.writebits (32' 0);  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_streaminfo,The following statement contains a magic number: bitwriter.writebits (4' 0);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_streaminfo,The following statement contains a magic number: bitwriter.writebits (32' sample_count);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_streaminfo,The following statement contains a magic number: bitwriter.writebits (4' 0);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_streaminfo,The following statement contains a magic number: bitwriter.writebits (32' 0);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_vorbis_comment,The following statement contains a magic number: bitwriter.writebits (7' (int)MetadataType.VorbisComment);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_vorbis_comment,The following statement contains a magic number: bitwriter.writebits (24' vendor_len + 8);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_vorbis_comment,The following statement contains a magic number: bitwriter.writebits (24' vendor_len + 8);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_vorbis_comment,The following statement contains a magic number: comment [pos + 4] = (byte)(vendor_len & 0xFF);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_vorbis_comment,The following statement contains a magic number: comment [pos + 5] = (byte)((vendor_len >> 8) & 0xFF);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_vorbis_comment,The following statement contains a magic number: comment [pos + 5] = (byte)((vendor_len >> 8) & 0xFF);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_vorbis_comment,The following statement contains a magic number: comment [pos + 6] = (byte)((vendor_len >> 16) & 0xFF);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_vorbis_comment,The following statement contains a magic number: comment [pos + 6] = (byte)((vendor_len >> 16) & 0xFF);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_vorbis_comment,The following statement contains a magic number: comment [pos + 7] = (byte)((vendor_len >> 24) & 0xFF);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_vorbis_comment,The following statement contains a magic number: comment [pos + 7] = (byte)((vendor_len >> 24) & 0xFF);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_vorbis_comment,The following statement contains a magic number: comment [pos + 8 + vendor_len] = 0;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_vorbis_comment,The following statement contains a magic number: comment [pos + 9 + vendor_len] = 0;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_vorbis_comment,The following statement contains a magic number: comment [pos + 10 + vendor_len] = 0;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_vorbis_comment,The following statement contains a magic number: comment [pos + 11 + vendor_len] = 0;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_vorbis_comment,The following statement contains a magic number: return vendor_len + 12;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_seekpoints,The following statement contains a magic number: seek_table_offset = pos + 4;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_seekpoints,The following statement contains a magic number: bitwriter.writebits (7' (int)MetadataType.Seektable);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_seekpoints,The following statement contains a magic number: bitwriter.writebits (24' 18 * seek_table.Length);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_seekpoints,The following statement contains a magic number: bitwriter.writebits (24' 18 * seek_table.Length);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_seekpoints,The following statement contains a magic number: return 4 + 18 * seek_table.Length;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_seekpoints,The following statement contains a magic number: return 4 + 18 * seek_table.Length;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_padding,The following statement contains a magic number: bitwriter.writebits (7' (int)MetadataType.Padding);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_padding,The following statement contains a magic number: bitwriter.writebits (24' padlen);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_padding,The following statement contains a magic number: return padlen + 4;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_headers,The following statement contains a magic number: header [2] = 0x61;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_headers,The following statement contains a magic number: header [3] = 0x43;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_headers,The following statement contains a magic number: header_size += 4;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,write_headers,The following statement contains a magic number: header_size += 38;  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_encode_init,The following statement contains a magic number: for (i = 4; i < 12; i++) {  	if (_pcm.SampleRate == Flake.flac_samplerates [i]) {  		sr_code0 = i;  		break;  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_encode_init,The following statement contains a magic number: for (i = 4; i < 12; i++) {  	if (_pcm.SampleRate == Flake.flac_samplerates [i]) {  		sr_code0 = i;  		break;  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_encode_init,The following statement contains a magic number: i = 4
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_encode_init,The following statement contains a magic number: if (i == 12)  	throw new Exception ("non-standard samplerate");  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_encode_init,The following statement contains a magic number: for (i = 1; i < 8; i++) {  	if (_pcm.BitsPerSample == Flake.flac_bitdepths [i]) {  		bps_code = i;  		break;  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_encode_init,The following statement contains a magic number: if (i == 8)  	throw new Exception ("non-standard bps");  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_encode_init,The following statement contains a magic number: if (channels == 2)  	max_frame_size = 16 + ((eparams.block_size * (_pcm.BitsPerSample + _pcm.BitsPerSample + 1) + 7) >> 3);  else  	max_frame_size = 16 + ((eparams.block_size * channels * _pcm.BitsPerSample + 7) >> 3);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_encode_init,The following statement contains a magic number: if (channels == 2)  	max_frame_size = 16 + ((eparams.block_size * (_pcm.BitsPerSample + _pcm.BitsPerSample + 1) + 7) >> 3);  else  	max_frame_size = 16 + ((eparams.block_size * channels * _pcm.BitsPerSample + 7) >> 3);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_encode_init,The following statement contains a magic number: if (channels == 2)  	max_frame_size = 16 + ((eparams.block_size * (_pcm.BitsPerSample + _pcm.BitsPerSample + 1) + 7) >> 3);  else  	max_frame_size = 16 + ((eparams.block_size * channels * _pcm.BitsPerSample + 7) >> 3);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_encode_init,The following statement contains a magic number: if (channels == 2)  	max_frame_size = 16 + ((eparams.block_size * (_pcm.BitsPerSample + _pcm.BitsPerSample + 1) + 7) >> 3);  else  	max_frame_size = 16 + ((eparams.block_size * channels * _pcm.BitsPerSample + 7) >> 3);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_encode_init,The following statement contains a magic number: if (channels == 2)  	max_frame_size = 16 + ((eparams.block_size * (_pcm.BitsPerSample + _pcm.BitsPerSample + 1) + 7) >> 3);  else  	max_frame_size = 16 + ((eparams.block_size * channels * _pcm.BitsPerSample + 7) >> 3);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_encode_init,The following statement contains a magic number: if (channels == 2)  	max_frame_size = 16 + ((eparams.block_size * (_pcm.BitsPerSample + _pcm.BitsPerSample + 1) + 7) >> 3);  else  	max_frame_size = 16 + ((eparams.block_size * channels * _pcm.BitsPerSample + 7) >> 3);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_encode_init,The following statement contains a magic number: if (channels == 2)  	max_frame_size = 16 + ((eparams.block_size * (_pcm.BitsPerSample + _pcm.BitsPerSample + 1) + 7) >> 3);  else  	max_frame_size = 16 + ((eparams.block_size * channels * _pcm.BitsPerSample + 7) >> 3);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_encode_init,The following statement contains a magic number: max_frame_size = 16 + ((eparams.block_size * (_pcm.BitsPerSample + _pcm.BitsPerSample + 1) + 7) >> 3);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_encode_init,The following statement contains a magic number: max_frame_size = 16 + ((eparams.block_size * (_pcm.BitsPerSample + _pcm.BitsPerSample + 1) + 7) >> 3);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_encode_init,The following statement contains a magic number: max_frame_size = 16 + ((eparams.block_size * (_pcm.BitsPerSample + _pcm.BitsPerSample + 1) + 7) >> 3);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_encode_init,The following statement contains a magic number: max_frame_size = 16 + ((eparams.block_size * channels * _pcm.BitsPerSample + 7) >> 3);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_encode_init,The following statement contains a magic number: max_frame_size = 16 + ((eparams.block_size * channels * _pcm.BitsPerSample + 7) >> 3);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_encode_init,The following statement contains a magic number: max_frame_size = 16 + ((eparams.block_size * channels * _pcm.BitsPerSample + 7) >> 3);  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_encode_init,The following statement contains a magic number: if (_IO.CanSeek && eparams.do_seektable && sample_count > 0) {  	int seek_points_distance = _pcm.SampleRate * 10;  	int num_seek_points = 1 + sample_count / seek_points_distance;  	// 1 seek point per 10 seconds  	if (sample_count % seek_points_distance == 0)  		num_seek_points--;  	seek_table = new SeekPoint[num_seek_points];  	for (int sp = 0; sp < num_seek_points; sp++) {  		seek_table [sp].framesize = 0;  		seek_table [sp].offset = 0;  		seek_table [sp].number = sp * seek_points_distance;  	}  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_encode_init,The following statement contains a magic number: header = new byte[eparams.padding_size + 1024 + (seek_table == null ? 0 : seek_table.Length * 18)];  
Magic Number,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_encode_init,The following statement contains a magic number: header = new byte[eparams.padding_size + 1024 + (seek_table == null ? 0 : seek_table.Length * 18)];  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: if ((lvl < 0 || lvl > 12) && (lvl != 99)) {  	return -1;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: if ((lvl < 0 || lvl > 12) && (lvl != 99)) {  	return -1;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: block_time_ms = 105;  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: max_prediction_order = 12;  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: min_fixed_order = 2;  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: max_fixed_order = 2;  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: max_partition_order = 8;  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: switch (lvl) {  case 0:  	block_time_ms = 53;  	prediction_type = PredictionType.Fixed;  	stereo_method = StereoMethod.Independent;  	max_partition_order = 6;  	break;  case 1:  	prediction_type = PredictionType.Levinson;  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	max_partition_order = 6;  	break;  case 2:  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_partition_order = 6;  	break;  case 3:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	break;  case 4:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	break;  case 5:  	stereo_method = StereoMethod.Estimate;  	window_method = WindowMethod.Estimate;  	break;  case 6:  	stereo_method = StereoMethod.Estimate;  	break;  case 7:  	break;  case 8:  	estimation_depth = 2;  	min_fixed_order = 0;  	lpc_min_precision_search = 0;  	break;  case 9:  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 32;  	break;  case 10:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	//lpc_max_precision_search = 2;  	break;  case 11:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	estimation_depth = 5;  	//lpc_max_precision_search = 2;  	variable_block_size = 4;  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: switch (lvl) {  case 0:  	block_time_ms = 53;  	prediction_type = PredictionType.Fixed;  	stereo_method = StereoMethod.Independent;  	max_partition_order = 6;  	break;  case 1:  	prediction_type = PredictionType.Levinson;  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	max_partition_order = 6;  	break;  case 2:  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_partition_order = 6;  	break;  case 3:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	break;  case 4:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	break;  case 5:  	stereo_method = StereoMethod.Estimate;  	window_method = WindowMethod.Estimate;  	break;  case 6:  	stereo_method = StereoMethod.Estimate;  	break;  case 7:  	break;  case 8:  	estimation_depth = 2;  	min_fixed_order = 0;  	lpc_min_precision_search = 0;  	break;  case 9:  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 32;  	break;  case 10:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	//lpc_max_precision_search = 2;  	break;  case 11:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	estimation_depth = 5;  	//lpc_max_precision_search = 2;  	variable_block_size = 4;  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: switch (lvl) {  case 0:  	block_time_ms = 53;  	prediction_type = PredictionType.Fixed;  	stereo_method = StereoMethod.Independent;  	max_partition_order = 6;  	break;  case 1:  	prediction_type = PredictionType.Levinson;  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	max_partition_order = 6;  	break;  case 2:  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_partition_order = 6;  	break;  case 3:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	break;  case 4:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	break;  case 5:  	stereo_method = StereoMethod.Estimate;  	window_method = WindowMethod.Estimate;  	break;  case 6:  	stereo_method = StereoMethod.Estimate;  	break;  case 7:  	break;  case 8:  	estimation_depth = 2;  	min_fixed_order = 0;  	lpc_min_precision_search = 0;  	break;  case 9:  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 32;  	break;  case 10:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	//lpc_max_precision_search = 2;  	break;  case 11:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	estimation_depth = 5;  	//lpc_max_precision_search = 2;  	variable_block_size = 4;  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: switch (lvl) {  case 0:  	block_time_ms = 53;  	prediction_type = PredictionType.Fixed;  	stereo_method = StereoMethod.Independent;  	max_partition_order = 6;  	break;  case 1:  	prediction_type = PredictionType.Levinson;  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	max_partition_order = 6;  	break;  case 2:  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_partition_order = 6;  	break;  case 3:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	break;  case 4:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	break;  case 5:  	stereo_method = StereoMethod.Estimate;  	window_method = WindowMethod.Estimate;  	break;  case 6:  	stereo_method = StereoMethod.Estimate;  	break;  case 7:  	break;  case 8:  	estimation_depth = 2;  	min_fixed_order = 0;  	lpc_min_precision_search = 0;  	break;  case 9:  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 32;  	break;  case 10:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	//lpc_max_precision_search = 2;  	break;  case 11:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	estimation_depth = 5;  	//lpc_max_precision_search = 2;  	variable_block_size = 4;  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: switch (lvl) {  case 0:  	block_time_ms = 53;  	prediction_type = PredictionType.Fixed;  	stereo_method = StereoMethod.Independent;  	max_partition_order = 6;  	break;  case 1:  	prediction_type = PredictionType.Levinson;  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	max_partition_order = 6;  	break;  case 2:  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_partition_order = 6;  	break;  case 3:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	break;  case 4:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	break;  case 5:  	stereo_method = StereoMethod.Estimate;  	window_method = WindowMethod.Estimate;  	break;  case 6:  	stereo_method = StereoMethod.Estimate;  	break;  case 7:  	break;  case 8:  	estimation_depth = 2;  	min_fixed_order = 0;  	lpc_min_precision_search = 0;  	break;  case 9:  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 32;  	break;  case 10:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	//lpc_max_precision_search = 2;  	break;  case 11:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	estimation_depth = 5;  	//lpc_max_precision_search = 2;  	variable_block_size = 4;  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: switch (lvl) {  case 0:  	block_time_ms = 53;  	prediction_type = PredictionType.Fixed;  	stereo_method = StereoMethod.Independent;  	max_partition_order = 6;  	break;  case 1:  	prediction_type = PredictionType.Levinson;  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	max_partition_order = 6;  	break;  case 2:  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_partition_order = 6;  	break;  case 3:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	break;  case 4:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	break;  case 5:  	stereo_method = StereoMethod.Estimate;  	window_method = WindowMethod.Estimate;  	break;  case 6:  	stereo_method = StereoMethod.Estimate;  	break;  case 7:  	break;  case 8:  	estimation_depth = 2;  	min_fixed_order = 0;  	lpc_min_precision_search = 0;  	break;  case 9:  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 32;  	break;  case 10:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	//lpc_max_precision_search = 2;  	break;  case 11:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	estimation_depth = 5;  	//lpc_max_precision_search = 2;  	variable_block_size = 4;  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: switch (lvl) {  case 0:  	block_time_ms = 53;  	prediction_type = PredictionType.Fixed;  	stereo_method = StereoMethod.Independent;  	max_partition_order = 6;  	break;  case 1:  	prediction_type = PredictionType.Levinson;  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	max_partition_order = 6;  	break;  case 2:  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_partition_order = 6;  	break;  case 3:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	break;  case 4:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	break;  case 5:  	stereo_method = StereoMethod.Estimate;  	window_method = WindowMethod.Estimate;  	break;  case 6:  	stereo_method = StereoMethod.Estimate;  	break;  case 7:  	break;  case 8:  	estimation_depth = 2;  	min_fixed_order = 0;  	lpc_min_precision_search = 0;  	break;  case 9:  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 32;  	break;  case 10:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	//lpc_max_precision_search = 2;  	break;  case 11:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	estimation_depth = 5;  	//lpc_max_precision_search = 2;  	variable_block_size = 4;  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: switch (lvl) {  case 0:  	block_time_ms = 53;  	prediction_type = PredictionType.Fixed;  	stereo_method = StereoMethod.Independent;  	max_partition_order = 6;  	break;  case 1:  	prediction_type = PredictionType.Levinson;  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	max_partition_order = 6;  	break;  case 2:  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_partition_order = 6;  	break;  case 3:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	break;  case 4:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	break;  case 5:  	stereo_method = StereoMethod.Estimate;  	window_method = WindowMethod.Estimate;  	break;  case 6:  	stereo_method = StereoMethod.Estimate;  	break;  case 7:  	break;  case 8:  	estimation_depth = 2;  	min_fixed_order = 0;  	lpc_min_precision_search = 0;  	break;  case 9:  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 32;  	break;  case 10:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	//lpc_max_precision_search = 2;  	break;  case 11:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	estimation_depth = 5;  	//lpc_max_precision_search = 2;  	variable_block_size = 4;  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: switch (lvl) {  case 0:  	block_time_ms = 53;  	prediction_type = PredictionType.Fixed;  	stereo_method = StereoMethod.Independent;  	max_partition_order = 6;  	break;  case 1:  	prediction_type = PredictionType.Levinson;  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	max_partition_order = 6;  	break;  case 2:  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_partition_order = 6;  	break;  case 3:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	break;  case 4:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	break;  case 5:  	stereo_method = StereoMethod.Estimate;  	window_method = WindowMethod.Estimate;  	break;  case 6:  	stereo_method = StereoMethod.Estimate;  	break;  case 7:  	break;  case 8:  	estimation_depth = 2;  	min_fixed_order = 0;  	lpc_min_precision_search = 0;  	break;  case 9:  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 32;  	break;  case 10:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	//lpc_max_precision_search = 2;  	break;  case 11:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	estimation_depth = 5;  	//lpc_max_precision_search = 2;  	variable_block_size = 4;  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: switch (lvl) {  case 0:  	block_time_ms = 53;  	prediction_type = PredictionType.Fixed;  	stereo_method = StereoMethod.Independent;  	max_partition_order = 6;  	break;  case 1:  	prediction_type = PredictionType.Levinson;  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	max_partition_order = 6;  	break;  case 2:  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_partition_order = 6;  	break;  case 3:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	break;  case 4:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	break;  case 5:  	stereo_method = StereoMethod.Estimate;  	window_method = WindowMethod.Estimate;  	break;  case 6:  	stereo_method = StereoMethod.Estimate;  	break;  case 7:  	break;  case 8:  	estimation_depth = 2;  	min_fixed_order = 0;  	lpc_min_precision_search = 0;  	break;  case 9:  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 32;  	break;  case 10:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	//lpc_max_precision_search = 2;  	break;  case 11:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	estimation_depth = 5;  	//lpc_max_precision_search = 2;  	variable_block_size = 4;  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: switch (lvl) {  case 0:  	block_time_ms = 53;  	prediction_type = PredictionType.Fixed;  	stereo_method = StereoMethod.Independent;  	max_partition_order = 6;  	break;  case 1:  	prediction_type = PredictionType.Levinson;  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	max_partition_order = 6;  	break;  case 2:  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_partition_order = 6;  	break;  case 3:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	break;  case 4:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	break;  case 5:  	stereo_method = StereoMethod.Estimate;  	window_method = WindowMethod.Estimate;  	break;  case 6:  	stereo_method = StereoMethod.Estimate;  	break;  case 7:  	break;  case 8:  	estimation_depth = 2;  	min_fixed_order = 0;  	lpc_min_precision_search = 0;  	break;  case 9:  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 32;  	break;  case 10:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	//lpc_max_precision_search = 2;  	break;  case 11:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	estimation_depth = 5;  	//lpc_max_precision_search = 2;  	variable_block_size = 4;  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: switch (lvl) {  case 0:  	block_time_ms = 53;  	prediction_type = PredictionType.Fixed;  	stereo_method = StereoMethod.Independent;  	max_partition_order = 6;  	break;  case 1:  	prediction_type = PredictionType.Levinson;  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	max_partition_order = 6;  	break;  case 2:  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_partition_order = 6;  	break;  case 3:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	break;  case 4:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	break;  case 5:  	stereo_method = StereoMethod.Estimate;  	window_method = WindowMethod.Estimate;  	break;  case 6:  	stereo_method = StereoMethod.Estimate;  	break;  case 7:  	break;  case 8:  	estimation_depth = 2;  	min_fixed_order = 0;  	lpc_min_precision_search = 0;  	break;  case 9:  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 32;  	break;  case 10:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	//lpc_max_precision_search = 2;  	break;  case 11:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	estimation_depth = 5;  	//lpc_max_precision_search = 2;  	variable_block_size = 4;  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: switch (lvl) {  case 0:  	block_time_ms = 53;  	prediction_type = PredictionType.Fixed;  	stereo_method = StereoMethod.Independent;  	max_partition_order = 6;  	break;  case 1:  	prediction_type = PredictionType.Levinson;  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	max_partition_order = 6;  	break;  case 2:  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_partition_order = 6;  	break;  case 3:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	break;  case 4:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	break;  case 5:  	stereo_method = StereoMethod.Estimate;  	window_method = WindowMethod.Estimate;  	break;  case 6:  	stereo_method = StereoMethod.Estimate;  	break;  case 7:  	break;  case 8:  	estimation_depth = 2;  	min_fixed_order = 0;  	lpc_min_precision_search = 0;  	break;  case 9:  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 32;  	break;  case 10:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	//lpc_max_precision_search = 2;  	break;  case 11:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	estimation_depth = 5;  	//lpc_max_precision_search = 2;  	variable_block_size = 4;  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: switch (lvl) {  case 0:  	block_time_ms = 53;  	prediction_type = PredictionType.Fixed;  	stereo_method = StereoMethod.Independent;  	max_partition_order = 6;  	break;  case 1:  	prediction_type = PredictionType.Levinson;  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	max_partition_order = 6;  	break;  case 2:  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_partition_order = 6;  	break;  case 3:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	break;  case 4:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	break;  case 5:  	stereo_method = StereoMethod.Estimate;  	window_method = WindowMethod.Estimate;  	break;  case 6:  	stereo_method = StereoMethod.Estimate;  	break;  case 7:  	break;  case 8:  	estimation_depth = 2;  	min_fixed_order = 0;  	lpc_min_precision_search = 0;  	break;  case 9:  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 32;  	break;  case 10:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	//lpc_max_precision_search = 2;  	break;  case 11:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	estimation_depth = 5;  	//lpc_max_precision_search = 2;  	variable_block_size = 4;  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: switch (lvl) {  case 0:  	block_time_ms = 53;  	prediction_type = PredictionType.Fixed;  	stereo_method = StereoMethod.Independent;  	max_partition_order = 6;  	break;  case 1:  	prediction_type = PredictionType.Levinson;  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	max_partition_order = 6;  	break;  case 2:  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_partition_order = 6;  	break;  case 3:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	break;  case 4:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	break;  case 5:  	stereo_method = StereoMethod.Estimate;  	window_method = WindowMethod.Estimate;  	break;  case 6:  	stereo_method = StereoMethod.Estimate;  	break;  case 7:  	break;  case 8:  	estimation_depth = 2;  	min_fixed_order = 0;  	lpc_min_precision_search = 0;  	break;  case 9:  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 32;  	break;  case 10:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	//lpc_max_precision_search = 2;  	break;  case 11:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	estimation_depth = 5;  	//lpc_max_precision_search = 2;  	variable_block_size = 4;  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: switch (lvl) {  case 0:  	block_time_ms = 53;  	prediction_type = PredictionType.Fixed;  	stereo_method = StereoMethod.Independent;  	max_partition_order = 6;  	break;  case 1:  	prediction_type = PredictionType.Levinson;  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	max_partition_order = 6;  	break;  case 2:  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_partition_order = 6;  	break;  case 3:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	break;  case 4:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	break;  case 5:  	stereo_method = StereoMethod.Estimate;  	window_method = WindowMethod.Estimate;  	break;  case 6:  	stereo_method = StereoMethod.Estimate;  	break;  case 7:  	break;  case 8:  	estimation_depth = 2;  	min_fixed_order = 0;  	lpc_min_precision_search = 0;  	break;  case 9:  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 32;  	break;  case 10:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	//lpc_max_precision_search = 2;  	break;  case 11:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	estimation_depth = 5;  	//lpc_max_precision_search = 2;  	variable_block_size = 4;  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: switch (lvl) {  case 0:  	block_time_ms = 53;  	prediction_type = PredictionType.Fixed;  	stereo_method = StereoMethod.Independent;  	max_partition_order = 6;  	break;  case 1:  	prediction_type = PredictionType.Levinson;  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	max_partition_order = 6;  	break;  case 2:  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_partition_order = 6;  	break;  case 3:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	break;  case 4:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	break;  case 5:  	stereo_method = StereoMethod.Estimate;  	window_method = WindowMethod.Estimate;  	break;  case 6:  	stereo_method = StereoMethod.Estimate;  	break;  case 7:  	break;  case 8:  	estimation_depth = 2;  	min_fixed_order = 0;  	lpc_min_precision_search = 0;  	break;  case 9:  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 32;  	break;  case 10:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	//lpc_max_precision_search = 2;  	break;  case 11:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	estimation_depth = 5;  	//lpc_max_precision_search = 2;  	variable_block_size = 4;  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: switch (lvl) {  case 0:  	block_time_ms = 53;  	prediction_type = PredictionType.Fixed;  	stereo_method = StereoMethod.Independent;  	max_partition_order = 6;  	break;  case 1:  	prediction_type = PredictionType.Levinson;  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	max_partition_order = 6;  	break;  case 2:  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_partition_order = 6;  	break;  case 3:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	break;  case 4:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	break;  case 5:  	stereo_method = StereoMethod.Estimate;  	window_method = WindowMethod.Estimate;  	break;  case 6:  	stereo_method = StereoMethod.Estimate;  	break;  case 7:  	break;  case 8:  	estimation_depth = 2;  	min_fixed_order = 0;  	lpc_min_precision_search = 0;  	break;  case 9:  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 32;  	break;  case 10:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	//lpc_max_precision_search = 2;  	break;  case 11:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	estimation_depth = 5;  	//lpc_max_precision_search = 2;  	variable_block_size = 4;  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: switch (lvl) {  case 0:  	block_time_ms = 53;  	prediction_type = PredictionType.Fixed;  	stereo_method = StereoMethod.Independent;  	max_partition_order = 6;  	break;  case 1:  	prediction_type = PredictionType.Levinson;  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	max_partition_order = 6;  	break;  case 2:  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_partition_order = 6;  	break;  case 3:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	break;  case 4:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	break;  case 5:  	stereo_method = StereoMethod.Estimate;  	window_method = WindowMethod.Estimate;  	break;  case 6:  	stereo_method = StereoMethod.Estimate;  	break;  case 7:  	break;  case 8:  	estimation_depth = 2;  	min_fixed_order = 0;  	lpc_min_precision_search = 0;  	break;  case 9:  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 32;  	break;  case 10:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	//lpc_max_precision_search = 2;  	break;  case 11:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	estimation_depth = 5;  	//lpc_max_precision_search = 2;  	variable_block_size = 4;  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: switch (lvl) {  case 0:  	block_time_ms = 53;  	prediction_type = PredictionType.Fixed;  	stereo_method = StereoMethod.Independent;  	max_partition_order = 6;  	break;  case 1:  	prediction_type = PredictionType.Levinson;  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	max_partition_order = 6;  	break;  case 2:  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_partition_order = 6;  	break;  case 3:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	break;  case 4:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	break;  case 5:  	stereo_method = StereoMethod.Estimate;  	window_method = WindowMethod.Estimate;  	break;  case 6:  	stereo_method = StereoMethod.Estimate;  	break;  case 7:  	break;  case 8:  	estimation_depth = 2;  	min_fixed_order = 0;  	lpc_min_precision_search = 0;  	break;  case 9:  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 32;  	break;  case 10:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	//lpc_max_precision_search = 2;  	break;  case 11:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	estimation_depth = 5;  	//lpc_max_precision_search = 2;  	variable_block_size = 4;  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: switch (lvl) {  case 0:  	block_time_ms = 53;  	prediction_type = PredictionType.Fixed;  	stereo_method = StereoMethod.Independent;  	max_partition_order = 6;  	break;  case 1:  	prediction_type = PredictionType.Levinson;  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	max_partition_order = 6;  	break;  case 2:  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_partition_order = 6;  	break;  case 3:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	break;  case 4:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	break;  case 5:  	stereo_method = StereoMethod.Estimate;  	window_method = WindowMethod.Estimate;  	break;  case 6:  	stereo_method = StereoMethod.Estimate;  	break;  case 7:  	break;  case 8:  	estimation_depth = 2;  	min_fixed_order = 0;  	lpc_min_precision_search = 0;  	break;  case 9:  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 32;  	break;  case 10:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	//lpc_max_precision_search = 2;  	break;  case 11:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	estimation_depth = 5;  	//lpc_max_precision_search = 2;  	variable_block_size = 4;  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: switch (lvl) {  case 0:  	block_time_ms = 53;  	prediction_type = PredictionType.Fixed;  	stereo_method = StereoMethod.Independent;  	max_partition_order = 6;  	break;  case 1:  	prediction_type = PredictionType.Levinson;  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	max_partition_order = 6;  	break;  case 2:  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_partition_order = 6;  	break;  case 3:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	break;  case 4:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	break;  case 5:  	stereo_method = StereoMethod.Estimate;  	window_method = WindowMethod.Estimate;  	break;  case 6:  	stereo_method = StereoMethod.Estimate;  	break;  case 7:  	break;  case 8:  	estimation_depth = 2;  	min_fixed_order = 0;  	lpc_min_precision_search = 0;  	break;  case 9:  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 32;  	break;  case 10:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	//lpc_max_precision_search = 2;  	break;  case 11:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	estimation_depth = 5;  	//lpc_max_precision_search = 2;  	variable_block_size = 4;  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: switch (lvl) {  case 0:  	block_time_ms = 53;  	prediction_type = PredictionType.Fixed;  	stereo_method = StereoMethod.Independent;  	max_partition_order = 6;  	break;  case 1:  	prediction_type = PredictionType.Levinson;  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	max_partition_order = 6;  	break;  case 2:  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_partition_order = 6;  	break;  case 3:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	break;  case 4:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	break;  case 5:  	stereo_method = StereoMethod.Estimate;  	window_method = WindowMethod.Estimate;  	break;  case 6:  	stereo_method = StereoMethod.Estimate;  	break;  case 7:  	break;  case 8:  	estimation_depth = 2;  	min_fixed_order = 0;  	lpc_min_precision_search = 0;  	break;  case 9:  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 32;  	break;  case 10:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	//lpc_max_precision_search = 2;  	break;  case 11:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	estimation_depth = 5;  	//lpc_max_precision_search = 2;  	variable_block_size = 4;  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: switch (lvl) {  case 0:  	block_time_ms = 53;  	prediction_type = PredictionType.Fixed;  	stereo_method = StereoMethod.Independent;  	max_partition_order = 6;  	break;  case 1:  	prediction_type = PredictionType.Levinson;  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	max_partition_order = 6;  	break;  case 2:  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_partition_order = 6;  	break;  case 3:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	break;  case 4:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	break;  case 5:  	stereo_method = StereoMethod.Estimate;  	window_method = WindowMethod.Estimate;  	break;  case 6:  	stereo_method = StereoMethod.Estimate;  	break;  case 7:  	break;  case 8:  	estimation_depth = 2;  	min_fixed_order = 0;  	lpc_min_precision_search = 0;  	break;  case 9:  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 32;  	break;  case 10:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	//lpc_max_precision_search = 2;  	break;  case 11:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	estimation_depth = 5;  	//lpc_max_precision_search = 2;  	variable_block_size = 4;  	break;  }  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: block_time_ms = 53;  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: max_partition_order = 6;  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: max_prediction_order = 8;  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: max_partition_order = 6;  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: max_partition_order = 6;  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: max_prediction_order = 8;  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: estimation_depth = 2;  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: max_prediction_order = 32;  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: max_fixed_order = 4;  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: max_prediction_order = 32;  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: max_fixed_order = 4;  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: max_prediction_order = 32;  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: estimation_depth = 5;  
Magic Number,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following statement contains a magic number: variable_block_size = 4;  
Missing Default,CUETools.Codecs.FLAKE,FlacFrame,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\Flake.cs,ChooseSubframes,The following switch statement is missing a default case: switch (ch_mode) {  case ChannelMode.MidSide:  	SwapSubframes (0' 2);  	SwapSubframes (1' 3);  	break;  case ChannelMode.RightSide:  	SwapSubframes (0' 3);  	break;  case ChannelMode.LeftSide:  	SwapSubframes (1' 3);  	break;  }  
Missing Default,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,decode_subframes,The following switch statement is missing a default case: switch (frame.ch_mode) {  case ChannelMode.MidSide:  	frame.subframes [ch].obits += ch;  	break;  case ChannelMode.LeftSide:  	frame.subframes [ch].obits += ch;  	break;  case ChannelMode.RightSide:  	frame.subframes [ch].obits += 1 - ch;  	break;  }  
Missing Default,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples_fixed,The following switch statement is missing a default case: switch (sub.best.order) {  case 0:  	AudioSamples.MemCpy (data' residual' data_len);  	break;  case 1:  	s1 = data [-1];  	for (int i = data_len; i > 0; i--) {  		s1 += *(residual++);  		*(data++) = s1;  	}  	//data[i] = residual[i] + data[i - 1];  	break;  case 2:  	s2 = data [-2];  	s1 = data [-1];  	for (int i = data_len; i > 0; i--) {  		s0 = *(residual++) + (s1 << 1) - s2;  		*(data++) = s0;  		s2 = s1;  		s1 = s0;  	}  	//data[i] = residual[i] + data[i - 1] * 2  - data[i - 2];  	break;  case 3:  	for (int i = 0; i < data_len; i++)  		data [i] = residual [i] + (((data [i - 1] - data [i - 2]) << 1) + (data [i - 1] - data [i - 2])) + data [i - 3];  	break;  case 4:  	for (int i = 0; i < data_len; i++)  		data [i] = residual [i] + ((data [i - 1] + data [i - 3]) << 2) - ((data [i - 2] << 2) + (data [i - 2] << 1)) - data [i - 4];  	break;  }  
Missing Default,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples,The following switch statement is missing a default case: switch (frame.subframes [ch].best.type) {  case SubframeType.Constant:  	AudioSamples.MemSet (frame.subframes [ch].samples' frame.subframes [ch].best.residual [0]' frame.blocksize);  	break;  case SubframeType.Verbatim:  	AudioSamples.MemCpy (frame.subframes [ch].samples' frame.subframes [ch].best.residual' frame.blocksize);  	break;  case SubframeType.Fixed:  	restore_samples_fixed (frame' ch);  	break;  case SubframeType.LPC:  	restore_samples_lpc (frame' ch);  	break;  }  
Missing Default,CUETools.Codecs.FLAKE,FlakeReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeReader.cs,restore_samples,The following switch statement is missing a default case: switch (frame.ch_mode) {  case ChannelMode.LeftRight:  	break;  case ChannelMode.MidSide:  	for (int i = frame.blocksize; i > 0; i--) {  		int mid = *l;  		int side = *r;  		mid <<= 1;  		mid |= (side & 1);  		/* i.e. if 'side' is odd... */*(l++) = (mid + side) >> 1;  		*(r++) = (mid - side) >> 1;  	}  	break;  case ChannelMode.LeftSide:  	for (int i = frame.blocksize; i > 0; i--) {  		int _l = *(l++)' _r = *r;  		*(r++) = _l - _r;  	}  	break;  case ChannelMode.RightSide:  	for (int i = frame.blocksize; i > 0; i--)  		*(l++) += *(r++);  	break;  }  
Missing Default,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,output_subframes,The following switch statement is missing a default case: switch (sub.best.type) {  case SubframeType.Constant:  	output_subframe_constant (frame' bitwriter' sub);  	break;  case SubframeType.Verbatim:  	output_subframe_verbatim (frame' bitwriter' sub);  	break;  case SubframeType.Fixed:  	output_subframe_fixed (frame' bitwriter' sub);  	break;  case SubframeType.LPC:  	output_subframe_lpc (frame' bitwriter' sub);  	break;  }  
Missing Default,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,estimate_best_window,The following switch statement is missing a default case: switch (eparams.window_method) {  case WindowMethod.Estimate: {  	int best_window = -1;  	double best_error = 0;  	int order = 2;  	for (int i = 0; i < _windowcount; i++) {  		frame.subframes [ch].lpc_ctx [i].GetReflection (order' frame.subframes [ch].samples' frame.blocksize' frame.window_buffer + i * Flake.MAX_BLOCKSIZE * 2);  		double err = frame.subframes [ch].lpc_ctx [i].prediction_error [order - 1] / frame.subframes [ch].lpc_ctx [i].autocorr_values [0];  		//double err = frame.subframes[ch].lpc_ctx[i].autocorr_values[0] / frame.subframes[ch].lpc_ctx[i].autocorr_values[2];  		if (best_window == -1 || best_error > err) {  			best_window = i;  			best_error = err;  		}  	}  	return best_window;  }  case WindowMethod.Evaluate:  	encode_residual_pass1 (frame' ch' -1);  	return frame.subframes [ch].best.type == SubframeType.LPC ? frame.subframes [ch].best.window : -1;  case WindowMethod.Search:  	return -1;  }  
Missing Default,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,estimate_frame,The following switch statement is missing a default case: switch (eparams.stereo_method) {  case StereoMethod.Estimate:  	for (int ch = 0; ch < subframes; ch++) {  		LpcContext lpc_ctx = frame.subframes [ch].lpc_ctx [0];  		lpc_ctx.GetReflection (4' frame.subframes [ch].samples' frame.blocksize' frame.window_buffer);  		lpc_ctx.SortOrdersAkaike (frame.blocksize' 1' 4' 4.5' 0.0);  		frame.subframes [ch].best.size = (uint)Math.Max (0' lpc_ctx.Akaike (frame.blocksize' lpc_ctx.best_orders [0]' 4.5' 0.0) + 7.1 * frame.subframes [ch].obits * eparams.max_prediction_order);  	}  	break;  case StereoMethod.Evaluate:  	for (int ch = 0; ch < subframes; ch++)  		encode_residual_pass1 (frame' ch' 0);  	break;  case StereoMethod.Search:  	for (int ch = 0; ch < subframes; ch++)  		encode_residual_pass2 (frame' ch);  	break;  }  
Missing Default,CUETools.Codecs.FLAKE,FlakeWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,encode_estimated_frame,The following switch statement is missing a default case: switch (eparams.stereo_method) {  case StereoMethod.Estimate:  	for (int ch = 0; ch < channels; ch++) {  		frame.subframes [ch].best.size = AudioSamples.UINT32_MAX;  		encode_residual_pass2 (frame' ch);  	}  	break;  case StereoMethod.Evaluate:  	for (int ch = 0; ch < channels; ch++)  		encode_residual_pass2 (frame' ch);  	break;  case StereoMethod.Search:  	break;  }  
Missing Default,CUETools.Codecs.FLAKE,FlakeEncodeParams,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs.FLAKE\FlakeWriter.cs,flake_set_defaults,The following switch statement is missing a default case: switch (lvl) {  case 0:  	block_time_ms = 53;  	prediction_type = PredictionType.Fixed;  	stereo_method = StereoMethod.Independent;  	max_partition_order = 6;  	break;  case 1:  	prediction_type = PredictionType.Levinson;  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	max_partition_order = 6;  	break;  case 2:  	stereo_method = StereoMethod.Independent;  	window_function = WindowFunction.Bartlett;  	max_partition_order = 6;  	break;  case 3:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 8;  	break;  case 4:  	stereo_method = StereoMethod.Estimate;  	window_function = WindowFunction.Bartlett;  	break;  case 5:  	stereo_method = StereoMethod.Estimate;  	window_method = WindowMethod.Estimate;  	break;  case 6:  	stereo_method = StereoMethod.Estimate;  	break;  case 7:  	break;  case 8:  	estimation_depth = 2;  	min_fixed_order = 0;  	lpc_min_precision_search = 0;  	break;  case 9:  	window_function = WindowFunction.Bartlett;  	max_prediction_order = 32;  	break;  case 10:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	//lpc_max_precision_search = 2;  	break;  case 11:  	min_fixed_order = 0;  	max_fixed_order = 4;  	max_prediction_order = 32;  	estimation_depth = 5;  	//lpc_max_precision_search = 2;  	variable_block_size = 4;  	break;  }  
