Implementation smell,Namespace,Class,File,Method,Description
Long Method,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The method has 114 lines of code.
Long Method,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The method has 111 lines of code.
Long Method,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The method has 112 lines of code.
Long Method,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The method has 121 lines of code.
Long Method,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The method has 111 lines of code.
Complex Method,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,Cyclomatic complexity of the method is 10
Complex Method,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,Cyclomatic complexity of the method is 8
Complex Method,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemCpy,Cyclomatic complexity of the method is 9
Complex Method,CUETools.Codecs,WAVReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,ParseHeaders,Cyclomatic complexity of the method is 18
Complex Method,CUETools.Codecs,UserDefinedWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,UserDefinedWriter,Cyclomatic complexity of the method is 8
Complex Method,CUETools.Codecs,UserDefinedWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Close,Cyclomatic complexity of the method is 9
Complex Method,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,compute_lpc_coefs,Cyclomatic complexity of the method is 9
Complex Method,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,quantize_lpc_coefs,Cyclomatic complexity of the method is 12
Complex Method,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,Cyclomatic complexity of the method is 56
Complex Method,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,Cyclomatic complexity of the method is 40
Complex Method,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,Cyclomatic complexity of the method is 54
Complex Method,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,Cyclomatic complexity of the method is 56
Complex Method,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,Cyclomatic complexity of the method is 40
Long Parameter List,CUETools.Codecs,AudioEncoderClass,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,AudioEncoderClass,The method has 7 parameters.
Long Parameter List,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FLACSamplesToBytes_16,The method has 5 parameters.
Long Parameter List,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FLACSamplesToBytes_16,The method has 6 parameters.
Long Parameter List,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FLACSamplesToBytes_24,The method has 7 parameters.
Long Parameter List,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FloatToBytes_16,The method has 6 parameters.
Long Parameter List,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FloatToBytes,The method has 7 parameters.
Long Parameter List,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FLACSamplesToBytes,The method has 7 parameters.
Long Parameter List,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FLACSamplesToBytes,The method has 6 parameters.
Long Parameter List,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Bytes16ToFloat,The method has 6 parameters.
Long Parameter List,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,BytesToFLACSamples_16,The method has 6 parameters.
Long Parameter List,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,BytesToFLACSamples_24,The method has 7 parameters.
Long Parameter List,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,BytesToFLACSamples,The method has 7 parameters.
Long Parameter List,CUETools.Codecs,UserDefinedWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,UserDefinedWriter,The method has 7 parameters.
Long Parameter List,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,compute_corr_int,The method has 6 parameters.
Long Parameter List,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,compute_autocorr,The method has 6 parameters.
Long Parameter List,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,quantize_lpc_coefs,The method has 7 parameters.
Long Parameter List,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The method has 6 parameters.
Long Parameter List,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The method has 6 parameters.
Long Parameter List,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The method has 6 parameters.
Long Parameter List,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The method has 6 parameters.
Long Parameter List,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The method has 6 parameters.
Long Parameter List,CUETools.Codecs,LpcContext,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,SortOrdersAkaike,The method has 5 parameters.
Long Statement,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,peek4,The length of the statement  "	//uint result = ((((uint)buffer[pos]) << 24) | (((uint)buffer[pos + 1]) << 16) | (((uint)buffer[pos + 2]) << 8) | ((uint)buffer[pos + 3])) << _bitaccumulator; " is 158.
Long Statement,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Load,The length of the statement  "		Buffer.BlockCopy (src.Bytes' srcOffset * pcm.BlockAlign' Bytes' dstOffset * pcm.BlockAlign' copyLength * pcm.BlockAlign); " is 121.
Long Statement,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Load,The length of the statement  "		Buffer.BlockCopy (src.Samples' srcOffset * pcm.ChannelCount * 4' Samples' dstOffset * pcm.ChannelCount * 4' copyLength * pcm.ChannelCount * 4); " is 143.
Long Statement,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Load,The length of the statement  "		Buffer.BlockCopy (src.Float' srcOffset * pcm.ChannelCount * 4' Float' dstOffset * pcm.ChannelCount * 4' copyLength * pcm.ChannelCount * 4); " is 139.
Long Statement,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FloatToBytes,The length of the statement  "	//    FLACSamplesToBytes_24(inSamples' inSampleOffset' outSamples' outByteOffset' sampleCount' channelCount' 24 - bitsPerSample); " is 129.
Long Statement,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FloatToBytes,The length of the statement  "		Buffer.BlockCopy (inSamples' inSampleOffset * 4 * channelCount' outSamples' outByteOffset' sampleCount * 4 * channelCount); " is 123.
Long Statement,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FLACSamplesToBytes,The length of the statement  "		FLACSamplesToBytes_24 (inSamples' inSampleOffset' outSamples' outByteOffset' sampleCount' channelCount' 24 - bitsPerSample); " is 124.
Long Statement,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,BytesToFLACSamples,The length of the statement  "		BytesToFLACSamples_24 (inSamples' inByteOffset' outSamples' outSampleOffset' sampleCount' channelCount' 24 - bitsPerSample); " is 124.
Long Statement,CUETools.Codecs,UserDefinedWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Write,The length of the statement  "			throw new IOException (string.Format ("{0} has exited prematurely with code {1}"' _encoder' _encoderProcess.ExitCode)' ex); " is 123.
Long Statement,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,ComputeChecksum,The length of the statement  "	return ComputeChecksum (ComputeChecksum (ComputeChecksum (ComputeChecksum (crc' (byte)s)' (byte)(s >> 8))' (byte)(s >> 16))' (byte)(s >> 24)); " is 142.
Long Statement,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,ComputeChecksum,The length of the statement  "		crc = ComputeChecksum (ComputeChecksum (ComputeChecksum (ComputeChecksum (crc' (byte)s1)' (byte)(s1 >> 8))' (byte)s2)' (byte)(s2 >> 8)); " is 136.
Long Statement,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,gf2_matrix_times,The length of the statement  "	return *(mat++) * (vec & 1) ^ *(mat++) * ((vec >>= 1) & 1) ^ *(mat++) * ((vec >>= 1) & 1) ^ *(mat++) * ((vec >>= 1) & 1) ^ *(mat++) * ((vec >>= 1) & 1) ^ *(mat++) * ((vec >>= 1) & 1) ^ *(mat++) * ((vec >>= 1) & 1) ^ *(mat++) * ((vec >>= 1) & 1) ^ *(mat++) * ((vec >>= 1) & 1) ^ *(mat++) * ((vec >>= 1) & 1) ^ *(mat++) * ((vec >>= 1) & 1) ^ *(mat++) * ((vec >>= 1) & 1) ^ *(mat++) * ((vec >>= 1) & 1) ^ *(mat++) * ((vec >>= 1) & 1) ^ *(mat++) * ((vec >>= 1) & 1) ^ *(mat++) * ((vec >>= 1) & 1) ^ *(mat++) * ((vec >>= 1) & 1) ^ *(mat++) * ((vec >>= 1) & 1) ^ *(mat++) * ((vec >>= 1) & 1) ^ *(mat++) * ((vec >>= 1) & 1) ^ *(mat++) * ((vec >>= 1) & 1) ^ *(mat++) * ((vec >>= 1) & 1) ^ *(mat++) * ((vec >>= 1) & 1) ^ *(mat++) * ((vec >>= 1) & 1) ^ *(mat++) * ((vec >>= 1) & 1) ^ *(mat++) * ((vec >>= 1) & 1) ^ *(mat++) * ((vec >>= 1) & 1) ^ *(mat++) * ((vec >>= 1) & 1) ^ *(mat++) * ((vec >>= 1) & 1) ^ *(mat++) * ((vec >>= 1) & 1) ^ *(mat++) * ((vec >>= 1) & 1) ^ *(mat++) * ((vec >>= 1) & 1); " is 989.
Long Statement,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_flattop,The length of the statement  "		window [n] = (float)(1.0 - 1.93 * Math.Cos (2.0 * Math.PI * n / N) + 1.29 * Math.Cos (4.0 * Math.PI * n / N) - 0.388 * Math.Cos (6.0 * Math.PI * n / N) + 0.0322 * Math.Cos (8.0 * Math.PI * n / N)); " is 197.
Long Statement,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The length of the statement  "			int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++); " is 127.
Long Statement,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The length of the statement  "			int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++); " is 145.
Long Statement,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The length of the statement  "			int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++); " is 163.
Long Statement,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The length of the statement  "			int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++); " is 181.
Long Statement,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The length of the statement  "			int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++); " is 199.
Long Statement,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The length of the statement  "			int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++); " is 217.
Long Statement,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The length of the statement  "			pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++); " is 214.
Long Statement,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The length of the statement  "			int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++); " is 127.
Long Statement,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The length of the statement  "			int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++); " is 145.
Long Statement,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The length of the statement  "			int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++); " is 163.
Long Statement,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The length of the statement  "			int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++); " is 181.
Long Statement,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The length of the statement  "			int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++); " is 199.
Long Statement,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The length of the statement  "			int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++); " is 217.
Long Statement,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The length of the statement  "			pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++); " is 214.
Long Statement,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The length of the statement  "			int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++); " is 132.
Long Statement,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The length of the statement  "			int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++); " is 151.
Long Statement,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The length of the statement  "			int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++); " is 170.
Long Statement,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The length of the statement  "			int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++); " is 189.
Long Statement,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The length of the statement  "			int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++); " is 208.
Long Statement,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The length of the statement  "			int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++); " is 227.
Long Statement,CUETools.Codecs,LpcContext,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,Akaike,The length of the statement  "	//return (blocksize - order) * (Math.Log(prediction_error[order - 1]) - Math.Log(1.0)) + Math.Log(blocksize) * order * (alpha + beta * order); " is 142.
Complex Conditional,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemSet,The conditional expression  "IntPtr.Size == 8 && (((IntPtr)res).ToInt64 () & 7) == 0 && smp == 0 && n > 8"  is complex.
Empty Catch Block,CUETools.Codecs,UserDefinedReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Close,The method has an empty catch block.
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,log2i,The following statement contains a magic number: if (0 != (v & 0xffffffff00000000)) {  	v >>= 32;  	n += 32;  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,log2i,The following statement contains a magic number: if (0 != (v & 0xffffffff00000000)) {  	v >>= 32;  	n += 32;  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,log2i,The following statement contains a magic number: v >>= 32;  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,log2i,The following statement contains a magic number: n += 32;  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,log2i,The following statement contains a magic number: if (0 != (v & 0xffff0000)) {  	v >>= 16;  	n += 16;  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,log2i,The following statement contains a magic number: if (0 != (v & 0xffff0000)) {  	v >>= 16;  	n += 16;  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,log2i,The following statement contains a magic number: v >>= 16;  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,log2i,The following statement contains a magic number: n += 16;  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,log2i,The following statement contains a magic number: if (0 != (v & 0xff00)) {  	v >>= 8;  	n += 8;  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,log2i,The following statement contains a magic number: if (0 != (v & 0xff00)) {  	v >>= 8;  	n += 8;  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,log2i,The following statement contains a magic number: v >>= 8;  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,log2i,The following statement contains a magic number: n += 8;  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,log2i,The following statement contains a magic number: if (0 != (v & 0xffff0000)) {  	v >>= 16;  	n += 16;  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,log2i,The following statement contains a magic number: if (0 != (v & 0xffff0000)) {  	v >>= 16;  	n += 16;  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,log2i,The following statement contains a magic number: v >>= 16;  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,log2i,The following statement contains a magic number: n += 16;  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,log2i,The following statement contains a magic number: if (0 != (v & 0xff00)) {  	v >>= 8;  	n += 8;  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,log2i,The following statement contains a magic number: if (0 != (v & 0xff00)) {  	v >>= 8;  	n += 8;  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,log2i,The following statement contains a magic number: v >>= 8;  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,log2i,The following statement contains a magic number: n += 8;  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,peek4,The following statement contains a magic number: result = (result << 8) + *(b++);  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,peek4,The following statement contains a magic number: result = (result << 8) + *(b++);  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,peek4,The following statement contains a magic number: result = (result << 8) + *(b++);  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,skipbits,The following statement contains a magic number: pos += (new_accumulator >> 3);  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,skipbits,The following statement contains a magic number: _bitaccumulator = (new_accumulator & 7);  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,skipbits16,The following statement contains a magic number: pos += (new_accumulator >> 3);  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,skipbits16,The following statement contains a magic number: _bitaccumulator = (new_accumulator & 7);  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,skipbits16,The following statement contains a magic number: cache |= ((((uint)buffer [pos + 2] << 8) + (uint)buffer [pos + 3]) << _bitaccumulator);  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,skipbits16,The following statement contains a magic number: cache |= ((((uint)buffer [pos + 2] << 8) + (uint)buffer [pos + 3]) << _bitaccumulator);  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,skipbits16,The following statement contains a magic number: cache |= ((((uint)buffer [pos + 2] << 8) + (uint)buffer [pos + 3]) << _bitaccumulator);  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,skipbits8,The following statement contains a magic number: pos += (new_accumulator >> 3);  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,skipbits8,The following statement contains a magic number: _bitaccumulator = (new_accumulator & 7);  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,skipbits8,The following statement contains a magic number: cache |= ((uint)buffer [pos + 3] << _bitaccumulator);  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,peekbits24,The following statement contains a magic number: return cache >> 32 - bits;  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,readbits,The following statement contains a magic number: if (bits <= 24) {  	skipbits (bits);  	return result;  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,readbits,The following statement contains a magic number: skipbits (24);  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,readbits,The following statement contains a magic number: result |= cache >> 56 - bits;  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,readbits,The following statement contains a magic number: skipbits (bits - 24);  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,readbits64,The following statement contains a magic number: if (bits <= 24)  	return readbits24 (bits);  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,readbits64,The following statement contains a magic number: bits -= 24;  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,readbits64,The following statement contains a magic number: if (bits <= 24)  	return (result << bits) | readbits24 (bits);  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,readbits64,The following statement contains a magic number: result = (result << 24) | readbits24 (24);  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,readbits64,The following statement contains a magic number: result = (result << 24) | readbits24 (24);  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,readbits64,The following statement contains a magic number: bits -= 24;  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_unary,The following statement contains a magic number: while (result == 0) {  	val += 8;  	skipbits8 (8);  	result = cache >> 24;  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_unary,The following statement contains a magic number: while (result == 0) {  	val += 8;  	skipbits8 (8);  	result = cache >> 24;  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_unary,The following statement contains a magic number: while (result == 0) {  	val += 8;  	skipbits8 (8);  	result = cache >> 24;  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_unary,The following statement contains a magic number: val += 8;  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_unary,The following statement contains a magic number: skipbits8 (8);  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_unary,The following statement contains a magic number: result = cache >> 24;  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_unary,The following statement contains a magic number: skipbits8 ((int)(val & 7) + 1);  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,flush,The following statement contains a magic number: if (_bitaccumulator > 0)  	skipbits8 (8 - _bitaccumulator);  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,flush,The following statement contains a magic number: skipbits8 (8 - _bitaccumulator);  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,readbits_signed,The following statement contains a magic number: val <<= (32 - bits);  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,readbits_signed,The following statement contains a magic number: val >>= (32 - bits);  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: if (0 == (x & 0x80)) {  	v = x;  	i = 0;  }  else if (0xC0 == (x & 0xE0))/* 110xxxxx */ {  	v = x & 0x1F;  	i = 1;  }  else if (0xE0 == (x & 0xF0))/* 1110xxxx */ {  	v = x & 0x0F;  	i = 2;  }  else if (0xF0 == (x & 0xF8))/* 11110xxx */ {  	v = x & 0x07;  	i = 3;  }  else if (0xF8 == (x & 0xFC))/* 111110xx */ {  	v = x & 0x03;  	i = 4;  }  else if (0xFC == (x & 0xFE))/* 1111110x */ {  	v = x & 0x01;  	i = 5;  }  else if (0xFE == x)/* 11111110 */ {  	v = 0;  	i = 6;  }  else  	throw new Exception ("invalid utf8 encoding");  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: if (0 == (x & 0x80)) {  	v = x;  	i = 0;  }  else if (0xC0 == (x & 0xE0))/* 110xxxxx */ {  	v = x & 0x1F;  	i = 1;  }  else if (0xE0 == (x & 0xF0))/* 1110xxxx */ {  	v = x & 0x0F;  	i = 2;  }  else if (0xF0 == (x & 0xF8))/* 11110xxx */ {  	v = x & 0x07;  	i = 3;  }  else if (0xF8 == (x & 0xFC))/* 111110xx */ {  	v = x & 0x03;  	i = 4;  }  else if (0xFC == (x & 0xFE))/* 1111110x */ {  	v = x & 0x01;  	i = 5;  }  else if (0xFE == x)/* 11111110 */ {  	v = 0;  	i = 6;  }  else  	throw new Exception ("invalid utf8 encoding");  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: if (0 == (x & 0x80)) {  	v = x;  	i = 0;  }  else if (0xC0 == (x & 0xE0))/* 110xxxxx */ {  	v = x & 0x1F;  	i = 1;  }  else if (0xE0 == (x & 0xF0))/* 1110xxxx */ {  	v = x & 0x0F;  	i = 2;  }  else if (0xF0 == (x & 0xF8))/* 11110xxx */ {  	v = x & 0x07;  	i = 3;  }  else if (0xF8 == (x & 0xFC))/* 111110xx */ {  	v = x & 0x03;  	i = 4;  }  else if (0xFC == (x & 0xFE))/* 1111110x */ {  	v = x & 0x01;  	i = 5;  }  else if (0xFE == x)/* 11111110 */ {  	v = 0;  	i = 6;  }  else  	throw new Exception ("invalid utf8 encoding");  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: if (0 == (x & 0x80)) {  	v = x;  	i = 0;  }  else if (0xC0 == (x & 0xE0))/* 110xxxxx */ {  	v = x & 0x1F;  	i = 1;  }  else if (0xE0 == (x & 0xF0))/* 1110xxxx */ {  	v = x & 0x0F;  	i = 2;  }  else if (0xF0 == (x & 0xF8))/* 11110xxx */ {  	v = x & 0x07;  	i = 3;  }  else if (0xF8 == (x & 0xFC))/* 111110xx */ {  	v = x & 0x03;  	i = 4;  }  else if (0xFC == (x & 0xFE))/* 1111110x */ {  	v = x & 0x01;  	i = 5;  }  else if (0xFE == x)/* 11111110 */ {  	v = 0;  	i = 6;  }  else  	throw new Exception ("invalid utf8 encoding");  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: if (0 == (x & 0x80)) {  	v = x;  	i = 0;  }  else if (0xC0 == (x & 0xE0))/* 110xxxxx */ {  	v = x & 0x1F;  	i = 1;  }  else if (0xE0 == (x & 0xF0))/* 1110xxxx */ {  	v = x & 0x0F;  	i = 2;  }  else if (0xF0 == (x & 0xF8))/* 11110xxx */ {  	v = x & 0x07;  	i = 3;  }  else if (0xF8 == (x & 0xFC))/* 111110xx */ {  	v = x & 0x03;  	i = 4;  }  else if (0xFC == (x & 0xFE))/* 1111110x */ {  	v = x & 0x01;  	i = 5;  }  else if (0xFE == x)/* 11111110 */ {  	v = 0;  	i = 6;  }  else  	throw new Exception ("invalid utf8 encoding");  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: if (0xC0 == (x & 0xE0))/* 110xxxxx */ {  	v = x & 0x1F;  	i = 1;  }  else if (0xE0 == (x & 0xF0))/* 1110xxxx */ {  	v = x & 0x0F;  	i = 2;  }  else if (0xF0 == (x & 0xF8))/* 11110xxx */ {  	v = x & 0x07;  	i = 3;  }  else if (0xF8 == (x & 0xFC))/* 111110xx */ {  	v = x & 0x03;  	i = 4;  }  else if (0xFC == (x & 0xFE))/* 1111110x */ {  	v = x & 0x01;  	i = 5;  }  else if (0xFE == x)/* 11111110 */ {  	v = 0;  	i = 6;  }  else  	throw new Exception ("invalid utf8 encoding");  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: if (0xC0 == (x & 0xE0))/* 110xxxxx */ {  	v = x & 0x1F;  	i = 1;  }  else if (0xE0 == (x & 0xF0))/* 1110xxxx */ {  	v = x & 0x0F;  	i = 2;  }  else if (0xF0 == (x & 0xF8))/* 11110xxx */ {  	v = x & 0x07;  	i = 3;  }  else if (0xF8 == (x & 0xFC))/* 111110xx */ {  	v = x & 0x03;  	i = 4;  }  else if (0xFC == (x & 0xFE))/* 1111110x */ {  	v = x & 0x01;  	i = 5;  }  else if (0xFE == x)/* 11111110 */ {  	v = 0;  	i = 6;  }  else  	throw new Exception ("invalid utf8 encoding");  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: if (0xC0 == (x & 0xE0))/* 110xxxxx */ {  	v = x & 0x1F;  	i = 1;  }  else if (0xE0 == (x & 0xF0))/* 1110xxxx */ {  	v = x & 0x0F;  	i = 2;  }  else if (0xF0 == (x & 0xF8))/* 11110xxx */ {  	v = x & 0x07;  	i = 3;  }  else if (0xF8 == (x & 0xFC))/* 111110xx */ {  	v = x & 0x03;  	i = 4;  }  else if (0xFC == (x & 0xFE))/* 1111110x */ {  	v = x & 0x01;  	i = 5;  }  else if (0xFE == x)/* 11111110 */ {  	v = 0;  	i = 6;  }  else  	throw new Exception ("invalid utf8 encoding");  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: if (0xC0 == (x & 0xE0))/* 110xxxxx */ {  	v = x & 0x1F;  	i = 1;  }  else if (0xE0 == (x & 0xF0))/* 1110xxxx */ {  	v = x & 0x0F;  	i = 2;  }  else if (0xF0 == (x & 0xF8))/* 11110xxx */ {  	v = x & 0x07;  	i = 3;  }  else if (0xF8 == (x & 0xFC))/* 111110xx */ {  	v = x & 0x03;  	i = 4;  }  else if (0xFC == (x & 0xFE))/* 1111110x */ {  	v = x & 0x01;  	i = 5;  }  else if (0xFE == x)/* 11111110 */ {  	v = 0;  	i = 6;  }  else  	throw new Exception ("invalid utf8 encoding");  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: if (0xC0 == (x & 0xE0))/* 110xxxxx */ {  	v = x & 0x1F;  	i = 1;  }  else if (0xE0 == (x & 0xF0))/* 1110xxxx */ {  	v = x & 0x0F;  	i = 2;  }  else if (0xF0 == (x & 0xF8))/* 11110xxx */ {  	v = x & 0x07;  	i = 3;  }  else if (0xF8 == (x & 0xFC))/* 111110xx */ {  	v = x & 0x03;  	i = 4;  }  else if (0xFC == (x & 0xFE))/* 1111110x */ {  	v = x & 0x01;  	i = 5;  }  else if (0xFE == x)/* 11111110 */ {  	v = 0;  	i = 6;  }  else  	throw new Exception ("invalid utf8 encoding");  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: if (0xE0 == (x & 0xF0))/* 1110xxxx */ {  	v = x & 0x0F;  	i = 2;  }  else if (0xF0 == (x & 0xF8))/* 11110xxx */ {  	v = x & 0x07;  	i = 3;  }  else if (0xF8 == (x & 0xFC))/* 111110xx */ {  	v = x & 0x03;  	i = 4;  }  else if (0xFC == (x & 0xFE))/* 1111110x */ {  	v = x & 0x01;  	i = 5;  }  else if (0xFE == x)/* 11111110 */ {  	v = 0;  	i = 6;  }  else  	throw new Exception ("invalid utf8 encoding");  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: if (0xE0 == (x & 0xF0))/* 1110xxxx */ {  	v = x & 0x0F;  	i = 2;  }  else if (0xF0 == (x & 0xF8))/* 11110xxx */ {  	v = x & 0x07;  	i = 3;  }  else if (0xF8 == (x & 0xFC))/* 111110xx */ {  	v = x & 0x03;  	i = 4;  }  else if (0xFC == (x & 0xFE))/* 1111110x */ {  	v = x & 0x01;  	i = 5;  }  else if (0xFE == x)/* 11111110 */ {  	v = 0;  	i = 6;  }  else  	throw new Exception ("invalid utf8 encoding");  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: if (0xE0 == (x & 0xF0))/* 1110xxxx */ {  	v = x & 0x0F;  	i = 2;  }  else if (0xF0 == (x & 0xF8))/* 11110xxx */ {  	v = x & 0x07;  	i = 3;  }  else if (0xF8 == (x & 0xFC))/* 111110xx */ {  	v = x & 0x03;  	i = 4;  }  else if (0xFC == (x & 0xFE))/* 1111110x */ {  	v = x & 0x01;  	i = 5;  }  else if (0xFE == x)/* 11111110 */ {  	v = 0;  	i = 6;  }  else  	throw new Exception ("invalid utf8 encoding");  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: if (0xE0 == (x & 0xF0))/* 1110xxxx */ {  	v = x & 0x0F;  	i = 2;  }  else if (0xF0 == (x & 0xF8))/* 11110xxx */ {  	v = x & 0x07;  	i = 3;  }  else if (0xF8 == (x & 0xFC))/* 111110xx */ {  	v = x & 0x03;  	i = 4;  }  else if (0xFC == (x & 0xFE))/* 1111110x */ {  	v = x & 0x01;  	i = 5;  }  else if (0xFE == x)/* 11111110 */ {  	v = 0;  	i = 6;  }  else  	throw new Exception ("invalid utf8 encoding");  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: if (0xE0 == (x & 0xF0))/* 1110xxxx */ {  	v = x & 0x0F;  	i = 2;  }  else if (0xF0 == (x & 0xF8))/* 11110xxx */ {  	v = x & 0x07;  	i = 3;  }  else if (0xF8 == (x & 0xFC))/* 111110xx */ {  	v = x & 0x03;  	i = 4;  }  else if (0xFC == (x & 0xFE))/* 1111110x */ {  	v = x & 0x01;  	i = 5;  }  else if (0xFE == x)/* 11111110 */ {  	v = 0;  	i = 6;  }  else  	throw new Exception ("invalid utf8 encoding");  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: i = 2;  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: if (0xF0 == (x & 0xF8))/* 11110xxx */ {  	v = x & 0x07;  	i = 3;  }  else if (0xF8 == (x & 0xFC))/* 111110xx */ {  	v = x & 0x03;  	i = 4;  }  else if (0xFC == (x & 0xFE))/* 1111110x */ {  	v = x & 0x01;  	i = 5;  }  else if (0xFE == x)/* 11111110 */ {  	v = 0;  	i = 6;  }  else  	throw new Exception ("invalid utf8 encoding");  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: if (0xF0 == (x & 0xF8))/* 11110xxx */ {  	v = x & 0x07;  	i = 3;  }  else if (0xF8 == (x & 0xFC))/* 111110xx */ {  	v = x & 0x03;  	i = 4;  }  else if (0xFC == (x & 0xFE))/* 1111110x */ {  	v = x & 0x01;  	i = 5;  }  else if (0xFE == x)/* 11111110 */ {  	v = 0;  	i = 6;  }  else  	throw new Exception ("invalid utf8 encoding");  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: if (0xF0 == (x & 0xF8))/* 11110xxx */ {  	v = x & 0x07;  	i = 3;  }  else if (0xF8 == (x & 0xFC))/* 111110xx */ {  	v = x & 0x03;  	i = 4;  }  else if (0xFC == (x & 0xFE))/* 1111110x */ {  	v = x & 0x01;  	i = 5;  }  else if (0xFE == x)/* 11111110 */ {  	v = 0;  	i = 6;  }  else  	throw new Exception ("invalid utf8 encoding");  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: if (0xF0 == (x & 0xF8))/* 11110xxx */ {  	v = x & 0x07;  	i = 3;  }  else if (0xF8 == (x & 0xFC))/* 111110xx */ {  	v = x & 0x03;  	i = 4;  }  else if (0xFC == (x & 0xFE))/* 1111110x */ {  	v = x & 0x01;  	i = 5;  }  else if (0xFE == x)/* 11111110 */ {  	v = 0;  	i = 6;  }  else  	throw new Exception ("invalid utf8 encoding");  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: i = 3;  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: if (0xF8 == (x & 0xFC))/* 111110xx */ {  	v = x & 0x03;  	i = 4;  }  else if (0xFC == (x & 0xFE))/* 1111110x */ {  	v = x & 0x01;  	i = 5;  }  else if (0xFE == x)/* 11111110 */ {  	v = 0;  	i = 6;  }  else  	throw new Exception ("invalid utf8 encoding");  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: if (0xF8 == (x & 0xFC))/* 111110xx */ {  	v = x & 0x03;  	i = 4;  }  else if (0xFC == (x & 0xFE))/* 1111110x */ {  	v = x & 0x01;  	i = 5;  }  else if (0xFE == x)/* 11111110 */ {  	v = 0;  	i = 6;  }  else  	throw new Exception ("invalid utf8 encoding");  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: if (0xF8 == (x & 0xFC))/* 111110xx */ {  	v = x & 0x03;  	i = 4;  }  else if (0xFC == (x & 0xFE))/* 1111110x */ {  	v = x & 0x01;  	i = 5;  }  else if (0xFE == x)/* 11111110 */ {  	v = 0;  	i = 6;  }  else  	throw new Exception ("invalid utf8 encoding");  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: i = 4;  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: if (0xFC == (x & 0xFE))/* 1111110x */ {  	v = x & 0x01;  	i = 5;  }  else if (0xFE == x)/* 11111110 */ {  	v = 0;  	i = 6;  }  else  	throw new Exception ("invalid utf8 encoding");  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: if (0xFC == (x & 0xFE))/* 1111110x */ {  	v = x & 0x01;  	i = 5;  }  else if (0xFE == x)/* 11111110 */ {  	v = 0;  	i = 6;  }  else  	throw new Exception ("invalid utf8 encoding");  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: i = 5;  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: if (0xFE == x)/* 11111110 */ {  	v = 0;  	i = 6;  }  else  	throw new Exception ("invalid utf8 encoding");  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: i = 6;  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: for (; i > 0; i--) {  	x = readbits (8);  	if (0x80 != (x & 0xC0))  		/* 10xxxxxx */throw new Exception ("invalid utf8 encoding");  	v <<= 6;  	v |= (x & 0x3F);  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: for (; i > 0; i--) {  	x = readbits (8);  	if (0x80 != (x & 0xC0))  		/* 10xxxxxx */throw new Exception ("invalid utf8 encoding");  	v <<= 6;  	v |= (x & 0x3F);  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: x = readbits (8);  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_utf8,The following statement contains a magic number: v <<= 6;  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: fixed (byte* unary_table = byte_to_unary_table) {  	uint mask = (1U << k) - 1;  	if (k == 0)  		for (int i = n; i > 0; i--)  			*(r++) = read_unary_signed ();  	else if (k <= 8)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits16 (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else if (k <= 16)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			skipbits8 ((int)(msbs & 7) + 1);  			uint uval = (msbs << k) | ((cache >> (32 - k)));  			skipbits (k);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: fixed (byte* unary_table = byte_to_unary_table) {  	uint mask = (1U << k) - 1;  	if (k == 0)  		for (int i = n; i > 0; i--)  			*(r++) = read_unary_signed ();  	else if (k <= 8)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits16 (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else if (k <= 16)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			skipbits8 ((int)(msbs & 7) + 1);  			uint uval = (msbs << k) | ((cache >> (32 - k)));  			skipbits (k);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: fixed (byte* unary_table = byte_to_unary_table) {  	uint mask = (1U << k) - 1;  	if (k == 0)  		for (int i = n; i > 0; i--)  			*(r++) = read_unary_signed ();  	else if (k <= 8)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits16 (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else if (k <= 16)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			skipbits8 ((int)(msbs & 7) + 1);  			uint uval = (msbs << k) | ((cache >> (32 - k)));  			skipbits (k);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: fixed (byte* unary_table = byte_to_unary_table) {  	uint mask = (1U << k) - 1;  	if (k == 0)  		for (int i = n; i > 0; i--)  			*(r++) = read_unary_signed ();  	else if (k <= 8)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits16 (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else if (k <= 16)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			skipbits8 ((int)(msbs & 7) + 1);  			uint uval = (msbs << k) | ((cache >> (32 - k)));  			skipbits (k);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: fixed (byte* unary_table = byte_to_unary_table) {  	uint mask = (1U << k) - 1;  	if (k == 0)  		for (int i = n; i > 0; i--)  			*(r++) = read_unary_signed ();  	else if (k <= 8)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits16 (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else if (k <= 16)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			skipbits8 ((int)(msbs & 7) + 1);  			uint uval = (msbs << k) | ((cache >> (32 - k)));  			skipbits (k);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: fixed (byte* unary_table = byte_to_unary_table) {  	uint mask = (1U << k) - 1;  	if (k == 0)  		for (int i = n; i > 0; i--)  			*(r++) = read_unary_signed ();  	else if (k <= 8)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits16 (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else if (k <= 16)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			skipbits8 ((int)(msbs & 7) + 1);  			uint uval = (msbs << k) | ((cache >> (32 - k)));  			skipbits (k);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: fixed (byte* unary_table = byte_to_unary_table) {  	uint mask = (1U << k) - 1;  	if (k == 0)  		for (int i = n; i > 0; i--)  			*(r++) = read_unary_signed ();  	else if (k <= 8)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits16 (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else if (k <= 16)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			skipbits8 ((int)(msbs & 7) + 1);  			uint uval = (msbs << k) | ((cache >> (32 - k)));  			skipbits (k);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: fixed (byte* unary_table = byte_to_unary_table) {  	uint mask = (1U << k) - 1;  	if (k == 0)  		for (int i = n; i > 0; i--)  			*(r++) = read_unary_signed ();  	else if (k <= 8)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits16 (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else if (k <= 16)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			skipbits8 ((int)(msbs & 7) + 1);  			uint uval = (msbs << k) | ((cache >> (32 - k)));  			skipbits (k);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: fixed (byte* unary_table = byte_to_unary_table) {  	uint mask = (1U << k) - 1;  	if (k == 0)  		for (int i = n; i > 0; i--)  			*(r++) = read_unary_signed ();  	else if (k <= 8)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits16 (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else if (k <= 16)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			skipbits8 ((int)(msbs & 7) + 1);  			uint uval = (msbs << k) | ((cache >> (32 - k)));  			skipbits (k);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: fixed (byte* unary_table = byte_to_unary_table) {  	uint mask = (1U << k) - 1;  	if (k == 0)  		for (int i = n; i > 0; i--)  			*(r++) = read_unary_signed ();  	else if (k <= 8)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits16 (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else if (k <= 16)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			skipbits8 ((int)(msbs & 7) + 1);  			uint uval = (msbs << k) | ((cache >> (32 - k)));  			skipbits (k);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: fixed (byte* unary_table = byte_to_unary_table) {  	uint mask = (1U << k) - 1;  	if (k == 0)  		for (int i = n; i > 0; i--)  			*(r++) = read_unary_signed ();  	else if (k <= 8)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits16 (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else if (k <= 16)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			skipbits8 ((int)(msbs & 7) + 1);  			uint uval = (msbs << k) | ((cache >> (32 - k)));  			skipbits (k);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: fixed (byte* unary_table = byte_to_unary_table) {  	uint mask = (1U << k) - 1;  	if (k == 0)  		for (int i = n; i > 0; i--)  			*(r++) = read_unary_signed ();  	else if (k <= 8)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits16 (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else if (k <= 16)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			skipbits8 ((int)(msbs & 7) + 1);  			uint uval = (msbs << k) | ((cache >> (32 - k)));  			skipbits (k);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: fixed (byte* unary_table = byte_to_unary_table) {  	uint mask = (1U << k) - 1;  	if (k == 0)  		for (int i = n; i > 0; i--)  			*(r++) = read_unary_signed ();  	else if (k <= 8)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits16 (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else if (k <= 16)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			skipbits8 ((int)(msbs & 7) + 1);  			uint uval = (msbs << k) | ((cache >> (32 - k)));  			skipbits (k);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: fixed (byte* unary_table = byte_to_unary_table) {  	uint mask = (1U << k) - 1;  	if (k == 0)  		for (int i = n; i > 0; i--)  			*(r++) = read_unary_signed ();  	else if (k <= 8)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits16 (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else if (k <= 16)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			skipbits8 ((int)(msbs & 7) + 1);  			uint uval = (msbs << k) | ((cache >> (32 - k)));  			skipbits (k);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: fixed (byte* unary_table = byte_to_unary_table) {  	uint mask = (1U << k) - 1;  	if (k == 0)  		for (int i = n; i > 0; i--)  			*(r++) = read_unary_signed ();  	else if (k <= 8)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits16 (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else if (k <= 16)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			skipbits8 ((int)(msbs & 7) + 1);  			uint uval = (msbs << k) | ((cache >> (32 - k)));  			skipbits (k);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: fixed (byte* unary_table = byte_to_unary_table) {  	uint mask = (1U << k) - 1;  	if (k == 0)  		for (int i = n; i > 0; i--)  			*(r++) = read_unary_signed ();  	else if (k <= 8)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits16 (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else if (k <= 16)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			skipbits8 ((int)(msbs & 7) + 1);  			uint uval = (msbs << k) | ((cache >> (32 - k)));  			skipbits (k);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: fixed (byte* unary_table = byte_to_unary_table) {  	uint mask = (1U << k) - 1;  	if (k == 0)  		for (int i = n; i > 0; i--)  			*(r++) = read_unary_signed ();  	else if (k <= 8)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits16 (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else if (k <= 16)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			skipbits8 ((int)(msbs & 7) + 1);  			uint uval = (msbs << k) | ((cache >> (32 - k)));  			skipbits (k);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: fixed (byte* unary_table = byte_to_unary_table) {  	uint mask = (1U << k) - 1;  	if (k == 0)  		for (int i = n; i > 0; i--)  			*(r++) = read_unary_signed ();  	else if (k <= 8)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits16 (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else if (k <= 16)  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			int btsk = k + (int)bits + 1;  			uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  			skipbits (btsk);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  	else  		for (int i = n; i > 0; i--) {  			//*(r++) = read_rice_signed((int)k);  			uint bits = unary_table [cache >> 24];  			uint msbs = bits;  			while (bits == 8) {  				skipbits8 (8);  				bits = unary_table [cache >> 24];  				msbs += bits;  			}  			skipbits8 ((int)(msbs & 7) + 1);  			uint uval = (msbs << k) | ((cache >> (32 - k)));  			skipbits (k);  			*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  		}  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k == 0)  	for (int i = n; i > 0; i--)  		*(r++) = read_unary_signed ();  else if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k == 0)  	for (int i = n; i > 0; i--)  		*(r++) = read_unary_signed ();  else if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k == 0)  	for (int i = n; i > 0; i--)  		*(r++) = read_unary_signed ();  else if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k == 0)  	for (int i = n; i > 0; i--)  		*(r++) = read_unary_signed ();  else if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k == 0)  	for (int i = n; i > 0; i--)  		*(r++) = read_unary_signed ();  else if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k == 0)  	for (int i = n; i > 0; i--)  		*(r++) = read_unary_signed ();  else if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k == 0)  	for (int i = n; i > 0; i--)  		*(r++) = read_unary_signed ();  else if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k == 0)  	for (int i = n; i > 0; i--)  		*(r++) = read_unary_signed ();  else if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k == 0)  	for (int i = n; i > 0; i--)  		*(r++) = read_unary_signed ();  else if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k == 0)  	for (int i = n; i > 0; i--)  		*(r++) = read_unary_signed ();  else if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k == 0)  	for (int i = n; i > 0; i--)  		*(r++) = read_unary_signed ();  else if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k == 0)  	for (int i = n; i > 0; i--)  		*(r++) = read_unary_signed ();  else if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k == 0)  	for (int i = n; i > 0; i--)  		*(r++) = read_unary_signed ();  else if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k == 0)  	for (int i = n; i > 0; i--)  		*(r++) = read_unary_signed ();  else if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k == 0)  	for (int i = n; i > 0; i--)  		*(r++) = read_unary_signed ();  else if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k == 0)  	for (int i = n; i > 0; i--)  		*(r++) = read_unary_signed ();  else if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k == 0)  	for (int i = n; i > 0; i--)  		*(r++) = read_unary_signed ();  else if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k == 0)  	for (int i = n; i > 0; i--)  		*(r++) = read_unary_signed ();  else if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k <= 8)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits16 (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: for (int i = n; i > 0; i--) {  	//*(r++) = read_rice_signed((int)k);  	uint bits = unary_table [cache >> 24];  	uint msbs = bits;  	while (bits == 8) {  		skipbits8 (8);  		bits = unary_table [cache >> 24];  		msbs += bits;  	}  	int btsk = k + (int)bits + 1;  	uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  	skipbits16 (btsk);  	*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: for (int i = n; i > 0; i--) {  	//*(r++) = read_rice_signed((int)k);  	uint bits = unary_table [cache >> 24];  	uint msbs = bits;  	while (bits == 8) {  		skipbits8 (8);  		bits = unary_table [cache >> 24];  		msbs += bits;  	}  	int btsk = k + (int)bits + 1;  	uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  	skipbits16 (btsk);  	*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: for (int i = n; i > 0; i--) {  	//*(r++) = read_rice_signed((int)k);  	uint bits = unary_table [cache >> 24];  	uint msbs = bits;  	while (bits == 8) {  		skipbits8 (8);  		bits = unary_table [cache >> 24];  		msbs += bits;  	}  	int btsk = k + (int)bits + 1;  	uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  	skipbits16 (btsk);  	*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: for (int i = n; i > 0; i--) {  	//*(r++) = read_rice_signed((int)k);  	uint bits = unary_table [cache >> 24];  	uint msbs = bits;  	while (bits == 8) {  		skipbits8 (8);  		bits = unary_table [cache >> 24];  		msbs += bits;  	}  	int btsk = k + (int)bits + 1;  	uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  	skipbits16 (btsk);  	*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: for (int i = n; i > 0; i--) {  	//*(r++) = read_rice_signed((int)k);  	uint bits = unary_table [cache >> 24];  	uint msbs = bits;  	while (bits == 8) {  		skipbits8 (8);  		bits = unary_table [cache >> 24];  		msbs += bits;  	}  	int btsk = k + (int)bits + 1;  	uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  	skipbits16 (btsk);  	*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: while (bits == 8) {  	skipbits8 (8);  	bits = unary_table [cache >> 24];  	msbs += bits;  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: while (bits == 8) {  	skipbits8 (8);  	bits = unary_table [cache >> 24];  	msbs += bits;  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: while (bits == 8) {  	skipbits8 (8);  	bits = unary_table [cache >> 24];  	msbs += bits;  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: skipbits8 (8);  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: bits = unary_table [cache >> 24];  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: if (k <= 16)  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		int btsk = k + (int)bits + 1;  		uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  		skipbits (btsk);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  else  	for (int i = n; i > 0; i--) {  		//*(r++) = read_rice_signed((int)k);  		uint bits = unary_table [cache >> 24];  		uint msbs = bits;  		while (bits == 8) {  			skipbits8 (8);  			bits = unary_table [cache >> 24];  			msbs += bits;  		}  		skipbits8 ((int)(msbs & 7) + 1);  		uint uval = (msbs << k) | ((cache >> (32 - k)));  		skipbits (k);  		*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  	}  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: for (int i = n; i > 0; i--) {  	//*(r++) = read_rice_signed((int)k);  	uint bits = unary_table [cache >> 24];  	uint msbs = bits;  	while (bits == 8) {  		skipbits8 (8);  		bits = unary_table [cache >> 24];  		msbs += bits;  	}  	int btsk = k + (int)bits + 1;  	uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  	skipbits (btsk);  	*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: for (int i = n; i > 0; i--) {  	//*(r++) = read_rice_signed((int)k);  	uint bits = unary_table [cache >> 24];  	uint msbs = bits;  	while (bits == 8) {  		skipbits8 (8);  		bits = unary_table [cache >> 24];  		msbs += bits;  	}  	int btsk = k + (int)bits + 1;  	uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  	skipbits (btsk);  	*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: for (int i = n; i > 0; i--) {  	//*(r++) = read_rice_signed((int)k);  	uint bits = unary_table [cache >> 24];  	uint msbs = bits;  	while (bits == 8) {  		skipbits8 (8);  		bits = unary_table [cache >> 24];  		msbs += bits;  	}  	int btsk = k + (int)bits + 1;  	uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  	skipbits (btsk);  	*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: for (int i = n; i > 0; i--) {  	//*(r++) = read_rice_signed((int)k);  	uint bits = unary_table [cache >> 24];  	uint msbs = bits;  	while (bits == 8) {  		skipbits8 (8);  		bits = unary_table [cache >> 24];  		msbs += bits;  	}  	int btsk = k + (int)bits + 1;  	uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  	skipbits (btsk);  	*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: for (int i = n; i > 0; i--) {  	//*(r++) = read_rice_signed((int)k);  	uint bits = unary_table [cache >> 24];  	uint msbs = bits;  	while (bits == 8) {  		skipbits8 (8);  		bits = unary_table [cache >> 24];  		msbs += bits;  	}  	int btsk = k + (int)bits + 1;  	uint uval = (msbs << k) | ((cache >> (32 - btsk)) & mask);  	skipbits (btsk);  	*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: while (bits == 8) {  	skipbits8 (8);  	bits = unary_table [cache >> 24];  	msbs += bits;  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: while (bits == 8) {  	skipbits8 (8);  	bits = unary_table [cache >> 24];  	msbs += bits;  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: while (bits == 8) {  	skipbits8 (8);  	bits = unary_table [cache >> 24];  	msbs += bits;  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: skipbits8 (8);  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: bits = unary_table [cache >> 24];  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: for (int i = n; i > 0; i--) {  	//*(r++) = read_rice_signed((int)k);  	uint bits = unary_table [cache >> 24];  	uint msbs = bits;  	while (bits == 8) {  		skipbits8 (8);  		bits = unary_table [cache >> 24];  		msbs += bits;  	}  	skipbits8 ((int)(msbs & 7) + 1);  	uint uval = (msbs << k) | ((cache >> (32 - k)));  	skipbits (k);  	*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: for (int i = n; i > 0; i--) {  	//*(r++) = read_rice_signed((int)k);  	uint bits = unary_table [cache >> 24];  	uint msbs = bits;  	while (bits == 8) {  		skipbits8 (8);  		bits = unary_table [cache >> 24];  		msbs += bits;  	}  	skipbits8 ((int)(msbs & 7) + 1);  	uint uval = (msbs << k) | ((cache >> (32 - k)));  	skipbits (k);  	*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: for (int i = n; i > 0; i--) {  	//*(r++) = read_rice_signed((int)k);  	uint bits = unary_table [cache >> 24];  	uint msbs = bits;  	while (bits == 8) {  		skipbits8 (8);  		bits = unary_table [cache >> 24];  		msbs += bits;  	}  	skipbits8 ((int)(msbs & 7) + 1);  	uint uval = (msbs << k) | ((cache >> (32 - k)));  	skipbits (k);  	*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: for (int i = n; i > 0; i--) {  	//*(r++) = read_rice_signed((int)k);  	uint bits = unary_table [cache >> 24];  	uint msbs = bits;  	while (bits == 8) {  		skipbits8 (8);  		bits = unary_table [cache >> 24];  		msbs += bits;  	}  	skipbits8 ((int)(msbs & 7) + 1);  	uint uval = (msbs << k) | ((cache >> (32 - k)));  	skipbits (k);  	*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: for (int i = n; i > 0; i--) {  	//*(r++) = read_rice_signed((int)k);  	uint bits = unary_table [cache >> 24];  	uint msbs = bits;  	while (bits == 8) {  		skipbits8 (8);  		bits = unary_table [cache >> 24];  		msbs += bits;  	}  	skipbits8 ((int)(msbs & 7) + 1);  	uint uval = (msbs << k) | ((cache >> (32 - k)));  	skipbits (k);  	*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: for (int i = n; i > 0; i--) {  	//*(r++) = read_rice_signed((int)k);  	uint bits = unary_table [cache >> 24];  	uint msbs = bits;  	while (bits == 8) {  		skipbits8 (8);  		bits = unary_table [cache >> 24];  		msbs += bits;  	}  	skipbits8 ((int)(msbs & 7) + 1);  	uint uval = (msbs << k) | ((cache >> (32 - k)));  	skipbits (k);  	*(r++) = (int)(uval >> 1 ^ -(int)(uval & 1));  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: while (bits == 8) {  	skipbits8 (8);  	bits = unary_table [cache >> 24];  	msbs += bits;  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: while (bits == 8) {  	skipbits8 (8);  	bits = unary_table [cache >> 24];  	msbs += bits;  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: while (bits == 8) {  	skipbits8 (8);  	bits = unary_table [cache >> 24];  	msbs += bits;  }  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: skipbits8 (8);  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: bits = unary_table [cache >> 24];  
Magic Number,CUETools.Codecs,BitReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitReader.cs,read_rice_block,The following statement contains a magic number: skipbits8 ((int)(msbs & 7) + 1);  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,BitWriter,The following statement contains a magic number: bit_left = 32;  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,Reset,The following statement contains a magic number: bit_left = 32;  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebytes,The following statement contains a magic number: for (; bytes > 0; bytes--)  	writebits (8' c);  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebytes,The following statement contains a magic number: writebits (8' c);  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writeints,The following statement contains a magic number: if ((old_pos + len) % 8 != 0)  	writebits ((old_pos + len) % 8' buf [end1] >> (8 - ((old_pos + len) % 8)));  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writeints,The following statement contains a magic number: if ((old_pos + len) % 8 != 0)  	writebits ((old_pos + len) % 8' buf [end1] >> (8 - ((old_pos + len) % 8)));  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writeints,The following statement contains a magic number: if ((old_pos + len) % 8 != 0)  	writebits ((old_pos + len) % 8' buf [end1] >> (8 - ((old_pos + len) % 8)));  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writeints,The following statement contains a magic number: if ((old_pos + len) % 8 != 0)  	writebits ((old_pos + len) % 8' buf [end1] >> (8 - ((old_pos + len) % 8)));  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writeints,The following statement contains a magic number: writebits ((old_pos + len) % 8' buf [end1] >> (8 - ((old_pos + len) % 8)));  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writeints,The following statement contains a magic number: writebits ((old_pos + len) % 8' buf [end1] >> (8 - ((old_pos + len) % 8)));  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writeints,The following statement contains a magic number: writebits ((old_pos + len) % 8' buf [end1] >> (8 - ((old_pos + len) % 8)));  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write,The following statement contains a magic number: foreach (char c in chars)  	writebits (8' (byte)c);  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write,The following statement contains a magic number: writebits (8' (byte)c);  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write,The following statement contains a magic number: for (int i = 0; i < s.Length; i++)  	writebits (8' (byte)s [i]);  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write,The following statement contains a magic number: writebits (8' (byte)s [i]);  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits,The following statement contains a magic number: writebits (32' (uint)span.TotalSeconds);  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits64,The following statement contains a magic number: if (bits > 32) {  	writebits (bits - 32' (uint)(val >> 32));  	val &= 0xffffffffL;  	bits = 32;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits64,The following statement contains a magic number: if (bits > 32) {  	writebits (bits - 32' (uint)(val >> 32));  	val &= 0xffffffffL;  	bits = 32;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits64,The following statement contains a magic number: if (bits > 32) {  	writebits (bits - 32' (uint)(val >> 32));  	val &= 0xffffffffL;  	bits = 32;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits64,The following statement contains a magic number: if (bits > 32) {  	writebits (bits - 32' (uint)(val >> 32));  	val &= 0xffffffffL;  	bits = 32;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits64,The following statement contains a magic number: writebits (bits - 32' (uint)(val >> 32));  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits64,The following statement contains a magic number: writebits (bits - 32' (uint)(val >> 32));  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits64,The following statement contains a magic number: bits = 32;  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits,The following statement contains a magic number: if ((buf_ptr + 3) >= buf_end) {  	eof = true;  	return;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits,The following statement contains a magic number: if (bits < bit_left) {  	bit_buf = (bit_buf << bits) | val;  	bit_left -= bits;  }  else {  	uint bb = 0;  	if (bit_left == 32) {  		//assert(bits == 32);  		bb = val;  	}  	else {  		bb = (bit_buf << bit_left) | (val >> (bits - bit_left));  		bit_left += (32 - bits);  	}  	if (buffer != null) {  		buffer [buf_ptr + 3] = (byte)(bb & 0xFF);  		bb >>= 8;  		buffer [buf_ptr + 2] = (byte)(bb & 0xFF);  		bb >>= 8;  		buffer [buf_ptr + 1] = (byte)(bb & 0xFF);  		bb >>= 8;  		buffer [buf_ptr + 0] = (byte)(bb & 0xFF);  	}  	buf_ptr += 4;  	bit_buf = val;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits,The following statement contains a magic number: if (bits < bit_left) {  	bit_buf = (bit_buf << bits) | val;  	bit_left -= bits;  }  else {  	uint bb = 0;  	if (bit_left == 32) {  		//assert(bits == 32);  		bb = val;  	}  	else {  		bb = (bit_buf << bit_left) | (val >> (bits - bit_left));  		bit_left += (32 - bits);  	}  	if (buffer != null) {  		buffer [buf_ptr + 3] = (byte)(bb & 0xFF);  		bb >>= 8;  		buffer [buf_ptr + 2] = (byte)(bb & 0xFF);  		bb >>= 8;  		buffer [buf_ptr + 1] = (byte)(bb & 0xFF);  		bb >>= 8;  		buffer [buf_ptr + 0] = (byte)(bb & 0xFF);  	}  	buf_ptr += 4;  	bit_buf = val;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits,The following statement contains a magic number: if (bits < bit_left) {  	bit_buf = (bit_buf << bits) | val;  	bit_left -= bits;  }  else {  	uint bb = 0;  	if (bit_left == 32) {  		//assert(bits == 32);  		bb = val;  	}  	else {  		bb = (bit_buf << bit_left) | (val >> (bits - bit_left));  		bit_left += (32 - bits);  	}  	if (buffer != null) {  		buffer [buf_ptr + 3] = (byte)(bb & 0xFF);  		bb >>= 8;  		buffer [buf_ptr + 2] = (byte)(bb & 0xFF);  		bb >>= 8;  		buffer [buf_ptr + 1] = (byte)(bb & 0xFF);  		bb >>= 8;  		buffer [buf_ptr + 0] = (byte)(bb & 0xFF);  	}  	buf_ptr += 4;  	bit_buf = val;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits,The following statement contains a magic number: if (bits < bit_left) {  	bit_buf = (bit_buf << bits) | val;  	bit_left -= bits;  }  else {  	uint bb = 0;  	if (bit_left == 32) {  		//assert(bits == 32);  		bb = val;  	}  	else {  		bb = (bit_buf << bit_left) | (val >> (bits - bit_left));  		bit_left += (32 - bits);  	}  	if (buffer != null) {  		buffer [buf_ptr + 3] = (byte)(bb & 0xFF);  		bb >>= 8;  		buffer [buf_ptr + 2] = (byte)(bb & 0xFF);  		bb >>= 8;  		buffer [buf_ptr + 1] = (byte)(bb & 0xFF);  		bb >>= 8;  		buffer [buf_ptr + 0] = (byte)(bb & 0xFF);  	}  	buf_ptr += 4;  	bit_buf = val;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits,The following statement contains a magic number: if (bits < bit_left) {  	bit_buf = (bit_buf << bits) | val;  	bit_left -= bits;  }  else {  	uint bb = 0;  	if (bit_left == 32) {  		//assert(bits == 32);  		bb = val;  	}  	else {  		bb = (bit_buf << bit_left) | (val >> (bits - bit_left));  		bit_left += (32 - bits);  	}  	if (buffer != null) {  		buffer [buf_ptr + 3] = (byte)(bb & 0xFF);  		bb >>= 8;  		buffer [buf_ptr + 2] = (byte)(bb & 0xFF);  		bb >>= 8;  		buffer [buf_ptr + 1] = (byte)(bb & 0xFF);  		bb >>= 8;  		buffer [buf_ptr + 0] = (byte)(bb & 0xFF);  	}  	buf_ptr += 4;  	bit_buf = val;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits,The following statement contains a magic number: if (bits < bit_left) {  	bit_buf = (bit_buf << bits) | val;  	bit_left -= bits;  }  else {  	uint bb = 0;  	if (bit_left == 32) {  		//assert(bits == 32);  		bb = val;  	}  	else {  		bb = (bit_buf << bit_left) | (val >> (bits - bit_left));  		bit_left += (32 - bits);  	}  	if (buffer != null) {  		buffer [buf_ptr + 3] = (byte)(bb & 0xFF);  		bb >>= 8;  		buffer [buf_ptr + 2] = (byte)(bb & 0xFF);  		bb >>= 8;  		buffer [buf_ptr + 1] = (byte)(bb & 0xFF);  		bb >>= 8;  		buffer [buf_ptr + 0] = (byte)(bb & 0xFF);  	}  	buf_ptr += 4;  	bit_buf = val;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits,The following statement contains a magic number: if (bits < bit_left) {  	bit_buf = (bit_buf << bits) | val;  	bit_left -= bits;  }  else {  	uint bb = 0;  	if (bit_left == 32) {  		//assert(bits == 32);  		bb = val;  	}  	else {  		bb = (bit_buf << bit_left) | (val >> (bits - bit_left));  		bit_left += (32 - bits);  	}  	if (buffer != null) {  		buffer [buf_ptr + 3] = (byte)(bb & 0xFF);  		bb >>= 8;  		buffer [buf_ptr + 2] = (byte)(bb & 0xFF);  		bb >>= 8;  		buffer [buf_ptr + 1] = (byte)(bb & 0xFF);  		bb >>= 8;  		buffer [buf_ptr + 0] = (byte)(bb & 0xFF);  	}  	buf_ptr += 4;  	bit_buf = val;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits,The following statement contains a magic number: if (bits < bit_left) {  	bit_buf = (bit_buf << bits) | val;  	bit_left -= bits;  }  else {  	uint bb = 0;  	if (bit_left == 32) {  		//assert(bits == 32);  		bb = val;  	}  	else {  		bb = (bit_buf << bit_left) | (val >> (bits - bit_left));  		bit_left += (32 - bits);  	}  	if (buffer != null) {  		buffer [buf_ptr + 3] = (byte)(bb & 0xFF);  		bb >>= 8;  		buffer [buf_ptr + 2] = (byte)(bb & 0xFF);  		bb >>= 8;  		buffer [buf_ptr + 1] = (byte)(bb & 0xFF);  		bb >>= 8;  		buffer [buf_ptr + 0] = (byte)(bb & 0xFF);  	}  	buf_ptr += 4;  	bit_buf = val;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits,The following statement contains a magic number: if (bit_left == 32) {  	//assert(bits == 32);  	bb = val;  }  else {  	bb = (bit_buf << bit_left) | (val >> (bits - bit_left));  	bit_left += (32 - bits);  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits,The following statement contains a magic number: if (bit_left == 32) {  	//assert(bits == 32);  	bb = val;  }  else {  	bb = (bit_buf << bit_left) | (val >> (bits - bit_left));  	bit_left += (32 - bits);  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits,The following statement contains a magic number: bit_left += (32 - bits);  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits,The following statement contains a magic number: if (buffer != null) {  	buffer [buf_ptr + 3] = (byte)(bb & 0xFF);  	bb >>= 8;  	buffer [buf_ptr + 2] = (byte)(bb & 0xFF);  	bb >>= 8;  	buffer [buf_ptr + 1] = (byte)(bb & 0xFF);  	bb >>= 8;  	buffer [buf_ptr + 0] = (byte)(bb & 0xFF);  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits,The following statement contains a magic number: if (buffer != null) {  	buffer [buf_ptr + 3] = (byte)(bb & 0xFF);  	bb >>= 8;  	buffer [buf_ptr + 2] = (byte)(bb & 0xFF);  	bb >>= 8;  	buffer [buf_ptr + 1] = (byte)(bb & 0xFF);  	bb >>= 8;  	buffer [buf_ptr + 0] = (byte)(bb & 0xFF);  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits,The following statement contains a magic number: if (buffer != null) {  	buffer [buf_ptr + 3] = (byte)(bb & 0xFF);  	bb >>= 8;  	buffer [buf_ptr + 2] = (byte)(bb & 0xFF);  	bb >>= 8;  	buffer [buf_ptr + 1] = (byte)(bb & 0xFF);  	bb >>= 8;  	buffer [buf_ptr + 0] = (byte)(bb & 0xFF);  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits,The following statement contains a magic number: if (buffer != null) {  	buffer [buf_ptr + 3] = (byte)(bb & 0xFF);  	bb >>= 8;  	buffer [buf_ptr + 2] = (byte)(bb & 0xFF);  	bb >>= 8;  	buffer [buf_ptr + 1] = (byte)(bb & 0xFF);  	bb >>= 8;  	buffer [buf_ptr + 0] = (byte)(bb & 0xFF);  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits,The following statement contains a magic number: if (buffer != null) {  	buffer [buf_ptr + 3] = (byte)(bb & 0xFF);  	bb >>= 8;  	buffer [buf_ptr + 2] = (byte)(bb & 0xFF);  	bb >>= 8;  	buffer [buf_ptr + 1] = (byte)(bb & 0xFF);  	bb >>= 8;  	buffer [buf_ptr + 0] = (byte)(bb & 0xFF);  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits,The following statement contains a magic number: buffer [buf_ptr + 3] = (byte)(bb & 0xFF);  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits,The following statement contains a magic number: bb >>= 8;  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits,The following statement contains a magic number: buffer [buf_ptr + 2] = (byte)(bb & 0xFF);  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits,The following statement contains a magic number: bb >>= 8;  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits,The following statement contains a magic number: bb >>= 8;  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits,The following statement contains a magic number: buf_ptr += 4;  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits_fast,The following statement contains a magic number: if ((buf_ptr + 3) >= buf_end) {  	eof = true;  	return;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits_fast,The following statement contains a magic number: if (bits < bit_left) {  	bit_buf = (bit_buf << bits) | val;  	bit_left -= bits;  }  else {  	uint bb = (bit_buf << bit_left) | (val >> (bits - bit_left));  	bit_left += (32 - bits);  	*(buf++) = (byte)(bb >> 24);  	*(buf++) = (byte)(bb >> 16);  	*(buf++) = (byte)(bb >> 8);  	*(buf++) = (byte)(bb);  	bit_buf = val;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits_fast,The following statement contains a magic number: if (bits < bit_left) {  	bit_buf = (bit_buf << bits) | val;  	bit_left -= bits;  }  else {  	uint bb = (bit_buf << bit_left) | (val >> (bits - bit_left));  	bit_left += (32 - bits);  	*(buf++) = (byte)(bb >> 24);  	*(buf++) = (byte)(bb >> 16);  	*(buf++) = (byte)(bb >> 8);  	*(buf++) = (byte)(bb);  	bit_buf = val;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits_fast,The following statement contains a magic number: if (bits < bit_left) {  	bit_buf = (bit_buf << bits) | val;  	bit_left -= bits;  }  else {  	uint bb = (bit_buf << bit_left) | (val >> (bits - bit_left));  	bit_left += (32 - bits);  	*(buf++) = (byte)(bb >> 24);  	*(buf++) = (byte)(bb >> 16);  	*(buf++) = (byte)(bb >> 8);  	*(buf++) = (byte)(bb);  	bit_buf = val;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits_fast,The following statement contains a magic number: if (bits < bit_left) {  	bit_buf = (bit_buf << bits) | val;  	bit_left -= bits;  }  else {  	uint bb = (bit_buf << bit_left) | (val >> (bits - bit_left));  	bit_left += (32 - bits);  	*(buf++) = (byte)(bb >> 24);  	*(buf++) = (byte)(bb >> 16);  	*(buf++) = (byte)(bb >> 8);  	*(buf++) = (byte)(bb);  	bit_buf = val;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits_fast,The following statement contains a magic number: bit_left += (32 - bits);  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits_fast,The following statement contains a magic number: *(buf++) = (byte)(bb >> 24);  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits_fast,The following statement contains a magic number: *(buf++) = (byte)(bb >> 16);  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,writebits_fast,The following statement contains a magic number: *(buf++) = (byte)(bb >> 8);  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_utf8,The following statement contains a magic number: if (val < 0x80) {  	writebits (8' val);  	return;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_utf8,The following statement contains a magic number: writebits (8' val);  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_utf8,The following statement contains a magic number: writebits (8' (256U - (256U >> bytes)) | (val >> shift));  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_utf8,The following statement contains a magic number: while (shift >= 6) {  	shift -= 6;  	writebits (8' 0x80 | ((val >> shift) & 0x3F));  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_utf8,The following statement contains a magic number: while (shift >= 6) {  	shift -= 6;  	writebits (8' 0x80 | ((val >> shift) & 0x3F));  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_utf8,The following statement contains a magic number: while (shift >= 6) {  	shift -= 6;  	writebits (8' 0x80 | ((val >> shift) & 0x3F));  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_utf8,The following statement contains a magic number: shift -= 6;  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_utf8,The following statement contains a magic number: writebits (8' 0x80 | ((val >> shift) & 0x3F));  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_unary_signed,The following statement contains a magic number: v ^= (v >> 31);  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_unary_signed,The following statement contains a magic number: while (q > 31) {  	writebits (31' 0);  	q -= 31;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_unary_signed,The following statement contains a magic number: while (q > 31) {  	writebits (31' 0);  	q -= 31;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_unary_signed,The following statement contains a magic number: while (q > 31) {  	writebits (31' 0);  	q -= 31;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_unary_signed,The following statement contains a magic number: writebits (31' 0);  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_unary_signed,The following statement contains a magic number: q -= 31;  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_signed,The following statement contains a magic number: v ^= (v >> 31);  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_signed,The following statement contains a magic number: while (q + k > 31) {  	int b = Math.Min (q + k - 31' 31);  	writebits (b' 0);  	q -= b;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_signed,The following statement contains a magic number: while (q + k > 31) {  	int b = Math.Min (q + k - 31' 31);  	writebits (b' 0);  	q -= b;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_signed,The following statement contains a magic number: while (q + k > 31) {  	int b = Math.Min (q + k - 31' 31);  	writebits (b' 0);  	q -= b;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: for (int i = count; i > 0; i--) {  	int v = *(residual++);  	v = (v << 1) ^ (v >> 31);  	// write quotient in unary  	int q = (v >> k) + 1;  	int bits = k + q;  	while (bits > 31) {  		#if DEBUG  		if (buf + 3 >= fixedbuf + buf_end) {  			eof = true;  			return;  		}  		#endif  		int b = Math.Min (bits - 31' 31);  		if (b < bit_left) {  			bit_buf = (bit_buf << b);  			bit_left -= b;  		}  		else {  			uint bb = bit_buf << bit_left;  			bit_buf = 0;  			bit_left += (32 - b);  			*(buf++) = (byte)(bb >> 24);  			*(buf++) = (byte)(bb >> 16);  			*(buf++) = (byte)(bb >> 8);  			*(buf++) = (byte)(bb);  		}  		bits -= b;  	}  	#if DEBUG  	if (buf + 3 >= fixedbuf + buf_end) {  		eof = true;  		return;  	}  	#endif  	// write remainder in binary using 'k' bits  	//writebits_fast(k + q' (uint)((v & ((1 << k) - 1)) | (1 << k))' ref buf);  	uint val = (uint)((v & ((1 << k) - 1)) | (1 << k));  	if (bits < bit_left) {  		bit_buf = (bit_buf << bits) | val;  		bit_left -= bits;  	}  	else {  		uint bb = (bit_buf << bit_left) | (val >> (bits - bit_left));  		bit_buf = val;  		bit_left += (32 - bits);  		*(buf++) = (byte)(bb >> 24);  		*(buf++) = (byte)(bb >> 16);  		*(buf++) = (byte)(bb >> 8);  		*(buf++) = (byte)(bb);  	}  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: for (int i = count; i > 0; i--) {  	int v = *(residual++);  	v = (v << 1) ^ (v >> 31);  	// write quotient in unary  	int q = (v >> k) + 1;  	int bits = k + q;  	while (bits > 31) {  		#if DEBUG  		if (buf + 3 >= fixedbuf + buf_end) {  			eof = true;  			return;  		}  		#endif  		int b = Math.Min (bits - 31' 31);  		if (b < bit_left) {  			bit_buf = (bit_buf << b);  			bit_left -= b;  		}  		else {  			uint bb = bit_buf << bit_left;  			bit_buf = 0;  			bit_left += (32 - b);  			*(buf++) = (byte)(bb >> 24);  			*(buf++) = (byte)(bb >> 16);  			*(buf++) = (byte)(bb >> 8);  			*(buf++) = (byte)(bb);  		}  		bits -= b;  	}  	#if DEBUG  	if (buf + 3 >= fixedbuf + buf_end) {  		eof = true;  		return;  	}  	#endif  	// write remainder in binary using 'k' bits  	//writebits_fast(k + q' (uint)((v & ((1 << k) - 1)) | (1 << k))' ref buf);  	uint val = (uint)((v & ((1 << k) - 1)) | (1 << k));  	if (bits < bit_left) {  		bit_buf = (bit_buf << bits) | val;  		bit_left -= bits;  	}  	else {  		uint bb = (bit_buf << bit_left) | (val >> (bits - bit_left));  		bit_buf = val;  		bit_left += (32 - bits);  		*(buf++) = (byte)(bb >> 24);  		*(buf++) = (byte)(bb >> 16);  		*(buf++) = (byte)(bb >> 8);  		*(buf++) = (byte)(bb);  	}  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: for (int i = count; i > 0; i--) {  	int v = *(residual++);  	v = (v << 1) ^ (v >> 31);  	// write quotient in unary  	int q = (v >> k) + 1;  	int bits = k + q;  	while (bits > 31) {  		#if DEBUG  		if (buf + 3 >= fixedbuf + buf_end) {  			eof = true;  			return;  		}  		#endif  		int b = Math.Min (bits - 31' 31);  		if (b < bit_left) {  			bit_buf = (bit_buf << b);  			bit_left -= b;  		}  		else {  			uint bb = bit_buf << bit_left;  			bit_buf = 0;  			bit_left += (32 - b);  			*(buf++) = (byte)(bb >> 24);  			*(buf++) = (byte)(bb >> 16);  			*(buf++) = (byte)(bb >> 8);  			*(buf++) = (byte)(bb);  		}  		bits -= b;  	}  	#if DEBUG  	if (buf + 3 >= fixedbuf + buf_end) {  		eof = true;  		return;  	}  	#endif  	// write remainder in binary using 'k' bits  	//writebits_fast(k + q' (uint)((v & ((1 << k) - 1)) | (1 << k))' ref buf);  	uint val = (uint)((v & ((1 << k) - 1)) | (1 << k));  	if (bits < bit_left) {  		bit_buf = (bit_buf << bits) | val;  		bit_left -= bits;  	}  	else {  		uint bb = (bit_buf << bit_left) | (val >> (bits - bit_left));  		bit_buf = val;  		bit_left += (32 - bits);  		*(buf++) = (byte)(bb >> 24);  		*(buf++) = (byte)(bb >> 16);  		*(buf++) = (byte)(bb >> 8);  		*(buf++) = (byte)(bb);  	}  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: for (int i = count; i > 0; i--) {  	int v = *(residual++);  	v = (v << 1) ^ (v >> 31);  	// write quotient in unary  	int q = (v >> k) + 1;  	int bits = k + q;  	while (bits > 31) {  		#if DEBUG  		if (buf + 3 >= fixedbuf + buf_end) {  			eof = true;  			return;  		}  		#endif  		int b = Math.Min (bits - 31' 31);  		if (b < bit_left) {  			bit_buf = (bit_buf << b);  			bit_left -= b;  		}  		else {  			uint bb = bit_buf << bit_left;  			bit_buf = 0;  			bit_left += (32 - b);  			*(buf++) = (byte)(bb >> 24);  			*(buf++) = (byte)(bb >> 16);  			*(buf++) = (byte)(bb >> 8);  			*(buf++) = (byte)(bb);  		}  		bits -= b;  	}  	#if DEBUG  	if (buf + 3 >= fixedbuf + buf_end) {  		eof = true;  		return;  	}  	#endif  	// write remainder in binary using 'k' bits  	//writebits_fast(k + q' (uint)((v & ((1 << k) - 1)) | (1 << k))' ref buf);  	uint val = (uint)((v & ((1 << k) - 1)) | (1 << k));  	if (bits < bit_left) {  		bit_buf = (bit_buf << bits) | val;  		bit_left -= bits;  	}  	else {  		uint bb = (bit_buf << bit_left) | (val >> (bits - bit_left));  		bit_buf = val;  		bit_left += (32 - bits);  		*(buf++) = (byte)(bb >> 24);  		*(buf++) = (byte)(bb >> 16);  		*(buf++) = (byte)(bb >> 8);  		*(buf++) = (byte)(bb);  	}  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: for (int i = count; i > 0; i--) {  	int v = *(residual++);  	v = (v << 1) ^ (v >> 31);  	// write quotient in unary  	int q = (v >> k) + 1;  	int bits = k + q;  	while (bits > 31) {  		#if DEBUG  		if (buf + 3 >= fixedbuf + buf_end) {  			eof = true;  			return;  		}  		#endif  		int b = Math.Min (bits - 31' 31);  		if (b < bit_left) {  			bit_buf = (bit_buf << b);  			bit_left -= b;  		}  		else {  			uint bb = bit_buf << bit_left;  			bit_buf = 0;  			bit_left += (32 - b);  			*(buf++) = (byte)(bb >> 24);  			*(buf++) = (byte)(bb >> 16);  			*(buf++) = (byte)(bb >> 8);  			*(buf++) = (byte)(bb);  		}  		bits -= b;  	}  	#if DEBUG  	if (buf + 3 >= fixedbuf + buf_end) {  		eof = true;  		return;  	}  	#endif  	// write remainder in binary using 'k' bits  	//writebits_fast(k + q' (uint)((v & ((1 << k) - 1)) | (1 << k))' ref buf);  	uint val = (uint)((v & ((1 << k) - 1)) | (1 << k));  	if (bits < bit_left) {  		bit_buf = (bit_buf << bits) | val;  		bit_left -= bits;  	}  	else {  		uint bb = (bit_buf << bit_left) | (val >> (bits - bit_left));  		bit_buf = val;  		bit_left += (32 - bits);  		*(buf++) = (byte)(bb >> 24);  		*(buf++) = (byte)(bb >> 16);  		*(buf++) = (byte)(bb >> 8);  		*(buf++) = (byte)(bb);  	}  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: for (int i = count; i > 0; i--) {  	int v = *(residual++);  	v = (v << 1) ^ (v >> 31);  	// write quotient in unary  	int q = (v >> k) + 1;  	int bits = k + q;  	while (bits > 31) {  		#if DEBUG  		if (buf + 3 >= fixedbuf + buf_end) {  			eof = true;  			return;  		}  		#endif  		int b = Math.Min (bits - 31' 31);  		if (b < bit_left) {  			bit_buf = (bit_buf << b);  			bit_left -= b;  		}  		else {  			uint bb = bit_buf << bit_left;  			bit_buf = 0;  			bit_left += (32 - b);  			*(buf++) = (byte)(bb >> 24);  			*(buf++) = (byte)(bb >> 16);  			*(buf++) = (byte)(bb >> 8);  			*(buf++) = (byte)(bb);  		}  		bits -= b;  	}  	#if DEBUG  	if (buf + 3 >= fixedbuf + buf_end) {  		eof = true;  		return;  	}  	#endif  	// write remainder in binary using 'k' bits  	//writebits_fast(k + q' (uint)((v & ((1 << k) - 1)) | (1 << k))' ref buf);  	uint val = (uint)((v & ((1 << k) - 1)) | (1 << k));  	if (bits < bit_left) {  		bit_buf = (bit_buf << bits) | val;  		bit_left -= bits;  	}  	else {  		uint bb = (bit_buf << bit_left) | (val >> (bits - bit_left));  		bit_buf = val;  		bit_left += (32 - bits);  		*(buf++) = (byte)(bb >> 24);  		*(buf++) = (byte)(bb >> 16);  		*(buf++) = (byte)(bb >> 8);  		*(buf++) = (byte)(bb);  	}  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: for (int i = count; i > 0; i--) {  	int v = *(residual++);  	v = (v << 1) ^ (v >> 31);  	// write quotient in unary  	int q = (v >> k) + 1;  	int bits = k + q;  	while (bits > 31) {  		#if DEBUG  		if (buf + 3 >= fixedbuf + buf_end) {  			eof = true;  			return;  		}  		#endif  		int b = Math.Min (bits - 31' 31);  		if (b < bit_left) {  			bit_buf = (bit_buf << b);  			bit_left -= b;  		}  		else {  			uint bb = bit_buf << bit_left;  			bit_buf = 0;  			bit_left += (32 - b);  			*(buf++) = (byte)(bb >> 24);  			*(buf++) = (byte)(bb >> 16);  			*(buf++) = (byte)(bb >> 8);  			*(buf++) = (byte)(bb);  		}  		bits -= b;  	}  	#if DEBUG  	if (buf + 3 >= fixedbuf + buf_end) {  		eof = true;  		return;  	}  	#endif  	// write remainder in binary using 'k' bits  	//writebits_fast(k + q' (uint)((v & ((1 << k) - 1)) | (1 << k))' ref buf);  	uint val = (uint)((v & ((1 << k) - 1)) | (1 << k));  	if (bits < bit_left) {  		bit_buf = (bit_buf << bits) | val;  		bit_left -= bits;  	}  	else {  		uint bb = (bit_buf << bit_left) | (val >> (bits - bit_left));  		bit_buf = val;  		bit_left += (32 - bits);  		*(buf++) = (byte)(bb >> 24);  		*(buf++) = (byte)(bb >> 16);  		*(buf++) = (byte)(bb >> 8);  		*(buf++) = (byte)(bb);  	}  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: for (int i = count; i > 0; i--) {  	int v = *(residual++);  	v = (v << 1) ^ (v >> 31);  	// write quotient in unary  	int q = (v >> k) + 1;  	int bits = k + q;  	while (bits > 31) {  		#if DEBUG  		if (buf + 3 >= fixedbuf + buf_end) {  			eof = true;  			return;  		}  		#endif  		int b = Math.Min (bits - 31' 31);  		if (b < bit_left) {  			bit_buf = (bit_buf << b);  			bit_left -= b;  		}  		else {  			uint bb = bit_buf << bit_left;  			bit_buf = 0;  			bit_left += (32 - b);  			*(buf++) = (byte)(bb >> 24);  			*(buf++) = (byte)(bb >> 16);  			*(buf++) = (byte)(bb >> 8);  			*(buf++) = (byte)(bb);  		}  		bits -= b;  	}  	#if DEBUG  	if (buf + 3 >= fixedbuf + buf_end) {  		eof = true;  		return;  	}  	#endif  	// write remainder in binary using 'k' bits  	//writebits_fast(k + q' (uint)((v & ((1 << k) - 1)) | (1 << k))' ref buf);  	uint val = (uint)((v & ((1 << k) - 1)) | (1 << k));  	if (bits < bit_left) {  		bit_buf = (bit_buf << bits) | val;  		bit_left -= bits;  	}  	else {  		uint bb = (bit_buf << bit_left) | (val >> (bits - bit_left));  		bit_buf = val;  		bit_left += (32 - bits);  		*(buf++) = (byte)(bb >> 24);  		*(buf++) = (byte)(bb >> 16);  		*(buf++) = (byte)(bb >> 8);  		*(buf++) = (byte)(bb);  	}  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: for (int i = count; i > 0; i--) {  	int v = *(residual++);  	v = (v << 1) ^ (v >> 31);  	// write quotient in unary  	int q = (v >> k) + 1;  	int bits = k + q;  	while (bits > 31) {  		#if DEBUG  		if (buf + 3 >= fixedbuf + buf_end) {  			eof = true;  			return;  		}  		#endif  		int b = Math.Min (bits - 31' 31);  		if (b < bit_left) {  			bit_buf = (bit_buf << b);  			bit_left -= b;  		}  		else {  			uint bb = bit_buf << bit_left;  			bit_buf = 0;  			bit_left += (32 - b);  			*(buf++) = (byte)(bb >> 24);  			*(buf++) = (byte)(bb >> 16);  			*(buf++) = (byte)(bb >> 8);  			*(buf++) = (byte)(bb);  		}  		bits -= b;  	}  	#if DEBUG  	if (buf + 3 >= fixedbuf + buf_end) {  		eof = true;  		return;  	}  	#endif  	// write remainder in binary using 'k' bits  	//writebits_fast(k + q' (uint)((v & ((1 << k) - 1)) | (1 << k))' ref buf);  	uint val = (uint)((v & ((1 << k) - 1)) | (1 << k));  	if (bits < bit_left) {  		bit_buf = (bit_buf << bits) | val;  		bit_left -= bits;  	}  	else {  		uint bb = (bit_buf << bit_left) | (val >> (bits - bit_left));  		bit_buf = val;  		bit_left += (32 - bits);  		*(buf++) = (byte)(bb >> 24);  		*(buf++) = (byte)(bb >> 16);  		*(buf++) = (byte)(bb >> 8);  		*(buf++) = (byte)(bb);  	}  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: for (int i = count; i > 0; i--) {  	int v = *(residual++);  	v = (v << 1) ^ (v >> 31);  	// write quotient in unary  	int q = (v >> k) + 1;  	int bits = k + q;  	while (bits > 31) {  		#if DEBUG  		if (buf + 3 >= fixedbuf + buf_end) {  			eof = true;  			return;  		}  		#endif  		int b = Math.Min (bits - 31' 31);  		if (b < bit_left) {  			bit_buf = (bit_buf << b);  			bit_left -= b;  		}  		else {  			uint bb = bit_buf << bit_left;  			bit_buf = 0;  			bit_left += (32 - b);  			*(buf++) = (byte)(bb >> 24);  			*(buf++) = (byte)(bb >> 16);  			*(buf++) = (byte)(bb >> 8);  			*(buf++) = (byte)(bb);  		}  		bits -= b;  	}  	#if DEBUG  	if (buf + 3 >= fixedbuf + buf_end) {  		eof = true;  		return;  	}  	#endif  	// write remainder in binary using 'k' bits  	//writebits_fast(k + q' (uint)((v & ((1 << k) - 1)) | (1 << k))' ref buf);  	uint val = (uint)((v & ((1 << k) - 1)) | (1 << k));  	if (bits < bit_left) {  		bit_buf = (bit_buf << bits) | val;  		bit_left -= bits;  	}  	else {  		uint bb = (bit_buf << bit_left) | (val >> (bits - bit_left));  		bit_buf = val;  		bit_left += (32 - bits);  		*(buf++) = (byte)(bb >> 24);  		*(buf++) = (byte)(bb >> 16);  		*(buf++) = (byte)(bb >> 8);  		*(buf++) = (byte)(bb);  	}  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: for (int i = count; i > 0; i--) {  	int v = *(residual++);  	v = (v << 1) ^ (v >> 31);  	// write quotient in unary  	int q = (v >> k) + 1;  	int bits = k + q;  	while (bits > 31) {  		#if DEBUG  		if (buf + 3 >= fixedbuf + buf_end) {  			eof = true;  			return;  		}  		#endif  		int b = Math.Min (bits - 31' 31);  		if (b < bit_left) {  			bit_buf = (bit_buf << b);  			bit_left -= b;  		}  		else {  			uint bb = bit_buf << bit_left;  			bit_buf = 0;  			bit_left += (32 - b);  			*(buf++) = (byte)(bb >> 24);  			*(buf++) = (byte)(bb >> 16);  			*(buf++) = (byte)(bb >> 8);  			*(buf++) = (byte)(bb);  		}  		bits -= b;  	}  	#if DEBUG  	if (buf + 3 >= fixedbuf + buf_end) {  		eof = true;  		return;  	}  	#endif  	// write remainder in binary using 'k' bits  	//writebits_fast(k + q' (uint)((v & ((1 << k) - 1)) | (1 << k))' ref buf);  	uint val = (uint)((v & ((1 << k) - 1)) | (1 << k));  	if (bits < bit_left) {  		bit_buf = (bit_buf << bits) | val;  		bit_left -= bits;  	}  	else {  		uint bb = (bit_buf << bit_left) | (val >> (bits - bit_left));  		bit_buf = val;  		bit_left += (32 - bits);  		*(buf++) = (byte)(bb >> 24);  		*(buf++) = (byte)(bb >> 16);  		*(buf++) = (byte)(bb >> 8);  		*(buf++) = (byte)(bb);  	}  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: for (int i = count; i > 0; i--) {  	int v = *(residual++);  	v = (v << 1) ^ (v >> 31);  	// write quotient in unary  	int q = (v >> k) + 1;  	int bits = k + q;  	while (bits > 31) {  		#if DEBUG  		if (buf + 3 >= fixedbuf + buf_end) {  			eof = true;  			return;  		}  		#endif  		int b = Math.Min (bits - 31' 31);  		if (b < bit_left) {  			bit_buf = (bit_buf << b);  			bit_left -= b;  		}  		else {  			uint bb = bit_buf << bit_left;  			bit_buf = 0;  			bit_left += (32 - b);  			*(buf++) = (byte)(bb >> 24);  			*(buf++) = (byte)(bb >> 16);  			*(buf++) = (byte)(bb >> 8);  			*(buf++) = (byte)(bb);  		}  		bits -= b;  	}  	#if DEBUG  	if (buf + 3 >= fixedbuf + buf_end) {  		eof = true;  		return;  	}  	#endif  	// write remainder in binary using 'k' bits  	//writebits_fast(k + q' (uint)((v & ((1 << k) - 1)) | (1 << k))' ref buf);  	uint val = (uint)((v & ((1 << k) - 1)) | (1 << k));  	if (bits < bit_left) {  		bit_buf = (bit_buf << bits) | val;  		bit_left -= bits;  	}  	else {  		uint bb = (bit_buf << bit_left) | (val >> (bits - bit_left));  		bit_buf = val;  		bit_left += (32 - bits);  		*(buf++) = (byte)(bb >> 24);  		*(buf++) = (byte)(bb >> 16);  		*(buf++) = (byte)(bb >> 8);  		*(buf++) = (byte)(bb);  	}  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: for (int i = count; i > 0; i--) {  	int v = *(residual++);  	v = (v << 1) ^ (v >> 31);  	// write quotient in unary  	int q = (v >> k) + 1;  	int bits = k + q;  	while (bits > 31) {  		#if DEBUG  		if (buf + 3 >= fixedbuf + buf_end) {  			eof = true;  			return;  		}  		#endif  		int b = Math.Min (bits - 31' 31);  		if (b < bit_left) {  			bit_buf = (bit_buf << b);  			bit_left -= b;  		}  		else {  			uint bb = bit_buf << bit_left;  			bit_buf = 0;  			bit_left += (32 - b);  			*(buf++) = (byte)(bb >> 24);  			*(buf++) = (byte)(bb >> 16);  			*(buf++) = (byte)(bb >> 8);  			*(buf++) = (byte)(bb);  		}  		bits -= b;  	}  	#if DEBUG  	if (buf + 3 >= fixedbuf + buf_end) {  		eof = true;  		return;  	}  	#endif  	// write remainder in binary using 'k' bits  	//writebits_fast(k + q' (uint)((v & ((1 << k) - 1)) | (1 << k))' ref buf);  	uint val = (uint)((v & ((1 << k) - 1)) | (1 << k));  	if (bits < bit_left) {  		bit_buf = (bit_buf << bits) | val;  		bit_left -= bits;  	}  	else {  		uint bb = (bit_buf << bit_left) | (val >> (bits - bit_left));  		bit_buf = val;  		bit_left += (32 - bits);  		*(buf++) = (byte)(bb >> 24);  		*(buf++) = (byte)(bb >> 16);  		*(buf++) = (byte)(bb >> 8);  		*(buf++) = (byte)(bb);  	}  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: for (int i = count; i > 0; i--) {  	int v = *(residual++);  	v = (v << 1) ^ (v >> 31);  	// write quotient in unary  	int q = (v >> k) + 1;  	int bits = k + q;  	while (bits > 31) {  		#if DEBUG  		if (buf + 3 >= fixedbuf + buf_end) {  			eof = true;  			return;  		}  		#endif  		int b = Math.Min (bits - 31' 31);  		if (b < bit_left) {  			bit_buf = (bit_buf << b);  			bit_left -= b;  		}  		else {  			uint bb = bit_buf << bit_left;  			bit_buf = 0;  			bit_left += (32 - b);  			*(buf++) = (byte)(bb >> 24);  			*(buf++) = (byte)(bb >> 16);  			*(buf++) = (byte)(bb >> 8);  			*(buf++) = (byte)(bb);  		}  		bits -= b;  	}  	#if DEBUG  	if (buf + 3 >= fixedbuf + buf_end) {  		eof = true;  		return;  	}  	#endif  	// write remainder in binary using 'k' bits  	//writebits_fast(k + q' (uint)((v & ((1 << k) - 1)) | (1 << k))' ref buf);  	uint val = (uint)((v & ((1 << k) - 1)) | (1 << k));  	if (bits < bit_left) {  		bit_buf = (bit_buf << bits) | val;  		bit_left -= bits;  	}  	else {  		uint bb = (bit_buf << bit_left) | (val >> (bits - bit_left));  		bit_buf = val;  		bit_left += (32 - bits);  		*(buf++) = (byte)(bb >> 24);  		*(buf++) = (byte)(bb >> 16);  		*(buf++) = (byte)(bb >> 8);  		*(buf++) = (byte)(bb);  	}  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: v = (v << 1) ^ (v >> 31);  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: while (bits > 31) {  	#if DEBUG  	if (buf + 3 >= fixedbuf + buf_end) {  		eof = true;  		return;  	}  	#endif  	int b = Math.Min (bits - 31' 31);  	if (b < bit_left) {  		bit_buf = (bit_buf << b);  		bit_left -= b;  	}  	else {  		uint bb = bit_buf << bit_left;  		bit_buf = 0;  		bit_left += (32 - b);  		*(buf++) = (byte)(bb >> 24);  		*(buf++) = (byte)(bb >> 16);  		*(buf++) = (byte)(bb >> 8);  		*(buf++) = (byte)(bb);  	}  	bits -= b;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: while (bits > 31) {  	#if DEBUG  	if (buf + 3 >= fixedbuf + buf_end) {  		eof = true;  		return;  	}  	#endif  	int b = Math.Min (bits - 31' 31);  	if (b < bit_left) {  		bit_buf = (bit_buf << b);  		bit_left -= b;  	}  	else {  		uint bb = bit_buf << bit_left;  		bit_buf = 0;  		bit_left += (32 - b);  		*(buf++) = (byte)(bb >> 24);  		*(buf++) = (byte)(bb >> 16);  		*(buf++) = (byte)(bb >> 8);  		*(buf++) = (byte)(bb);  	}  	bits -= b;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: while (bits > 31) {  	#if DEBUG  	if (buf + 3 >= fixedbuf + buf_end) {  		eof = true;  		return;  	}  	#endif  	int b = Math.Min (bits - 31' 31);  	if (b < bit_left) {  		bit_buf = (bit_buf << b);  		bit_left -= b;  	}  	else {  		uint bb = bit_buf << bit_left;  		bit_buf = 0;  		bit_left += (32 - b);  		*(buf++) = (byte)(bb >> 24);  		*(buf++) = (byte)(bb >> 16);  		*(buf++) = (byte)(bb >> 8);  		*(buf++) = (byte)(bb);  	}  	bits -= b;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: while (bits > 31) {  	#if DEBUG  	if (buf + 3 >= fixedbuf + buf_end) {  		eof = true;  		return;  	}  	#endif  	int b = Math.Min (bits - 31' 31);  	if (b < bit_left) {  		bit_buf = (bit_buf << b);  		bit_left -= b;  	}  	else {  		uint bb = bit_buf << bit_left;  		bit_buf = 0;  		bit_left += (32 - b);  		*(buf++) = (byte)(bb >> 24);  		*(buf++) = (byte)(bb >> 16);  		*(buf++) = (byte)(bb >> 8);  		*(buf++) = (byte)(bb);  	}  	bits -= b;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: while (bits > 31) {  	#if DEBUG  	if (buf + 3 >= fixedbuf + buf_end) {  		eof = true;  		return;  	}  	#endif  	int b = Math.Min (bits - 31' 31);  	if (b < bit_left) {  		bit_buf = (bit_buf << b);  		bit_left -= b;  	}  	else {  		uint bb = bit_buf << bit_left;  		bit_buf = 0;  		bit_left += (32 - b);  		*(buf++) = (byte)(bb >> 24);  		*(buf++) = (byte)(bb >> 16);  		*(buf++) = (byte)(bb >> 8);  		*(buf++) = (byte)(bb);  	}  	bits -= b;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: while (bits > 31) {  	#if DEBUG  	if (buf + 3 >= fixedbuf + buf_end) {  		eof = true;  		return;  	}  	#endif  	int b = Math.Min (bits - 31' 31);  	if (b < bit_left) {  		bit_buf = (bit_buf << b);  		bit_left -= b;  	}  	else {  		uint bb = bit_buf << bit_left;  		bit_buf = 0;  		bit_left += (32 - b);  		*(buf++) = (byte)(bb >> 24);  		*(buf++) = (byte)(bb >> 16);  		*(buf++) = (byte)(bb >> 8);  		*(buf++) = (byte)(bb);  	}  	bits -= b;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: while (bits > 31) {  	#if DEBUG  	if (buf + 3 >= fixedbuf + buf_end) {  		eof = true;  		return;  	}  	#endif  	int b = Math.Min (bits - 31' 31);  	if (b < bit_left) {  		bit_buf = (bit_buf << b);  		bit_left -= b;  	}  	else {  		uint bb = bit_buf << bit_left;  		bit_buf = 0;  		bit_left += (32 - b);  		*(buf++) = (byte)(bb >> 24);  		*(buf++) = (byte)(bb >> 16);  		*(buf++) = (byte)(bb >> 8);  		*(buf++) = (byte)(bb);  	}  	bits -= b;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: while (bits > 31) {  	#if DEBUG  	if (buf + 3 >= fixedbuf + buf_end) {  		eof = true;  		return;  	}  	#endif  	int b = Math.Min (bits - 31' 31);  	if (b < bit_left) {  		bit_buf = (bit_buf << b);  		bit_left -= b;  	}  	else {  		uint bb = bit_buf << bit_left;  		bit_buf = 0;  		bit_left += (32 - b);  		*(buf++) = (byte)(bb >> 24);  		*(buf++) = (byte)(bb >> 16);  		*(buf++) = (byte)(bb >> 8);  		*(buf++) = (byte)(bb);  	}  	bits -= b;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: if (buf + 3 >= fixedbuf + buf_end) {  	eof = true;  	return;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: if (b < bit_left) {  	bit_buf = (bit_buf << b);  	bit_left -= b;  }  else {  	uint bb = bit_buf << bit_left;  	bit_buf = 0;  	bit_left += (32 - b);  	*(buf++) = (byte)(bb >> 24);  	*(buf++) = (byte)(bb >> 16);  	*(buf++) = (byte)(bb >> 8);  	*(buf++) = (byte)(bb);  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: if (b < bit_left) {  	bit_buf = (bit_buf << b);  	bit_left -= b;  }  else {  	uint bb = bit_buf << bit_left;  	bit_buf = 0;  	bit_left += (32 - b);  	*(buf++) = (byte)(bb >> 24);  	*(buf++) = (byte)(bb >> 16);  	*(buf++) = (byte)(bb >> 8);  	*(buf++) = (byte)(bb);  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: if (b < bit_left) {  	bit_buf = (bit_buf << b);  	bit_left -= b;  }  else {  	uint bb = bit_buf << bit_left;  	bit_buf = 0;  	bit_left += (32 - b);  	*(buf++) = (byte)(bb >> 24);  	*(buf++) = (byte)(bb >> 16);  	*(buf++) = (byte)(bb >> 8);  	*(buf++) = (byte)(bb);  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: if (b < bit_left) {  	bit_buf = (bit_buf << b);  	bit_left -= b;  }  else {  	uint bb = bit_buf << bit_left;  	bit_buf = 0;  	bit_left += (32 - b);  	*(buf++) = (byte)(bb >> 24);  	*(buf++) = (byte)(bb >> 16);  	*(buf++) = (byte)(bb >> 8);  	*(buf++) = (byte)(bb);  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: bit_left += (32 - b);  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: *(buf++) = (byte)(bb >> 24);  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: *(buf++) = (byte)(bb >> 16);  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: *(buf++) = (byte)(bb >> 8);  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: if (buf + 3 >= fixedbuf + buf_end) {  	eof = true;  	return;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: if (bits < bit_left) {  	bit_buf = (bit_buf << bits) | val;  	bit_left -= bits;  }  else {  	uint bb = (bit_buf << bit_left) | (val >> (bits - bit_left));  	bit_buf = val;  	bit_left += (32 - bits);  	*(buf++) = (byte)(bb >> 24);  	*(buf++) = (byte)(bb >> 16);  	*(buf++) = (byte)(bb >> 8);  	*(buf++) = (byte)(bb);  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: if (bits < bit_left) {  	bit_buf = (bit_buf << bits) | val;  	bit_left -= bits;  }  else {  	uint bb = (bit_buf << bit_left) | (val >> (bits - bit_left));  	bit_buf = val;  	bit_left += (32 - bits);  	*(buf++) = (byte)(bb >> 24);  	*(buf++) = (byte)(bb >> 16);  	*(buf++) = (byte)(bb >> 8);  	*(buf++) = (byte)(bb);  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: if (bits < bit_left) {  	bit_buf = (bit_buf << bits) | val;  	bit_left -= bits;  }  else {  	uint bb = (bit_buf << bit_left) | (val >> (bits - bit_left));  	bit_buf = val;  	bit_left += (32 - bits);  	*(buf++) = (byte)(bb >> 24);  	*(buf++) = (byte)(bb >> 16);  	*(buf++) = (byte)(bb >> 8);  	*(buf++) = (byte)(bb);  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: if (bits < bit_left) {  	bit_buf = (bit_buf << bits) | val;  	bit_left -= bits;  }  else {  	uint bb = (bit_buf << bit_left) | (val >> (bits - bit_left));  	bit_buf = val;  	bit_left += (32 - bits);  	*(buf++) = (byte)(bb >> 24);  	*(buf++) = (byte)(bb >> 16);  	*(buf++) = (byte)(bb >> 8);  	*(buf++) = (byte)(bb);  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: bit_left += (32 - bits);  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: *(buf++) = (byte)(bb >> 24);  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: *(buf++) = (byte)(bb >> 16);  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,write_rice_block_signed,The following statement contains a magic number: *(buf++) = (byte)(bb >> 8);  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,flush,The following statement contains a magic number: while (bit_left < 32 && !eof) {  	if (buf_ptr >= buf_end) {  		eof = true;  		break;  	}  	if (buffer != null)  		buffer [buf_ptr] = (byte)(bit_buf >> 24);  	buf_ptr++;  	bit_buf <<= 8;  	bit_left += 8;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,flush,The following statement contains a magic number: while (bit_left < 32 && !eof) {  	if (buf_ptr >= buf_end) {  		eof = true;  		break;  	}  	if (buffer != null)  		buffer [buf_ptr] = (byte)(bit_buf >> 24);  	buf_ptr++;  	bit_buf <<= 8;  	bit_left += 8;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,flush,The following statement contains a magic number: while (bit_left < 32 && !eof) {  	if (buf_ptr >= buf_end) {  		eof = true;  		break;  	}  	if (buffer != null)  		buffer [buf_ptr] = (byte)(bit_buf >> 24);  	buf_ptr++;  	bit_buf <<= 8;  	bit_left += 8;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,flush,The following statement contains a magic number: while (bit_left < 32 && !eof) {  	if (buf_ptr >= buf_end) {  		eof = true;  		break;  	}  	if (buffer != null)  		buffer [buf_ptr] = (byte)(bit_buf >> 24);  	buf_ptr++;  	bit_buf <<= 8;  	bit_left += 8;  }  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,flush,The following statement contains a magic number: if (buffer != null)  	buffer [buf_ptr] = (byte)(bit_buf >> 24);  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,flush,The following statement contains a magic number: buffer [buf_ptr] = (byte)(bit_buf >> 24);  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,flush,The following statement contains a magic number: bit_buf <<= 8;  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,flush,The following statement contains a magic number: bit_left += 8;  
Magic Number,CUETools.Codecs,BitWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\BitWriter.cs,flush,The following statement contains a magic number: bit_left = 32;  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Load,The following statement contains a magic number: if (dataInSamples)  	Buffer.BlockCopy (src.Samples' srcOffset * pcm.ChannelCount * 4' Samples' dstOffset * pcm.ChannelCount * 4' copyLength * pcm.ChannelCount * 4);  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Load,The following statement contains a magic number: if (dataInSamples)  	Buffer.BlockCopy (src.Samples' srcOffset * pcm.ChannelCount * 4' Samples' dstOffset * pcm.ChannelCount * 4' copyLength * pcm.ChannelCount * 4);  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Load,The following statement contains a magic number: if (dataInSamples)  	Buffer.BlockCopy (src.Samples' srcOffset * pcm.ChannelCount * 4' Samples' dstOffset * pcm.ChannelCount * 4' copyLength * pcm.ChannelCount * 4);  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Load,The following statement contains a magic number: Buffer.BlockCopy (src.Samples' srcOffset * pcm.ChannelCount * 4' Samples' dstOffset * pcm.ChannelCount * 4' copyLength * pcm.ChannelCount * 4);  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Load,The following statement contains a magic number: Buffer.BlockCopy (src.Samples' srcOffset * pcm.ChannelCount * 4' Samples' dstOffset * pcm.ChannelCount * 4' copyLength * pcm.ChannelCount * 4);  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Load,The following statement contains a magic number: Buffer.BlockCopy (src.Samples' srcOffset * pcm.ChannelCount * 4' Samples' dstOffset * pcm.ChannelCount * 4' copyLength * pcm.ChannelCount * 4);  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Load,The following statement contains a magic number: if (dataInFloat)  	Buffer.BlockCopy (src.Float' srcOffset * pcm.ChannelCount * 4' Float' dstOffset * pcm.ChannelCount * 4' copyLength * pcm.ChannelCount * 4);  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Load,The following statement contains a magic number: if (dataInFloat)  	Buffer.BlockCopy (src.Float' srcOffset * pcm.ChannelCount * 4' Float' dstOffset * pcm.ChannelCount * 4' copyLength * pcm.ChannelCount * 4);  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Load,The following statement contains a magic number: if (dataInFloat)  	Buffer.BlockCopy (src.Float' srcOffset * pcm.ChannelCount * 4' Float' dstOffset * pcm.ChannelCount * 4' copyLength * pcm.ChannelCount * 4);  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Load,The following statement contains a magic number: Buffer.BlockCopy (src.Float' srcOffset * pcm.ChannelCount * 4' Float' dstOffset * pcm.ChannelCount * 4' copyLength * pcm.ChannelCount * 4);  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Load,The following statement contains a magic number: Buffer.BlockCopy (src.Float' srcOffset * pcm.ChannelCount * 4' Float' dstOffset * pcm.ChannelCount * 4' copyLength * pcm.ChannelCount * 4);  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Load,The following statement contains a magic number: Buffer.BlockCopy (src.Float' srcOffset * pcm.ChannelCount * 4' Float' dstOffset * pcm.ChannelCount * 4' copyLength * pcm.ChannelCount * 4);  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Interlace,The following statement contains a magic number: if (PCM.ChannelCount != 2)  	throw new Exception ("Must be stereo");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Interlace,The following statement contains a magic number: if (PCM.BitsPerSample == 16) {  	fixed (byte* bs = Bytes) {  		int* res = ((int*)bs) + pos;  		for (int i = n; i > 0; i--)  			*(res++) = (*(src1++) & 0xffff) ^ (*(src2++) << 16);  	}  }  else if (PCM.BitsPerSample == 24) {  	fixed (byte* bs = Bytes) {  		byte* res = bs + pos * 6;  		for (int i = n; i > 0; i--) {  			uint sample_out = (uint)*(src1++);  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out = (uint)*(src2++);  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  		}  	}  }  else  	throw new Exception ("Unsupported BPS");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Interlace,The following statement contains a magic number: if (PCM.BitsPerSample == 16) {  	fixed (byte* bs = Bytes) {  		int* res = ((int*)bs) + pos;  		for (int i = n; i > 0; i--)  			*(res++) = (*(src1++) & 0xffff) ^ (*(src2++) << 16);  	}  }  else if (PCM.BitsPerSample == 24) {  	fixed (byte* bs = Bytes) {  		byte* res = bs + pos * 6;  		for (int i = n; i > 0; i--) {  			uint sample_out = (uint)*(src1++);  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out = (uint)*(src2++);  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  		}  	}  }  else  	throw new Exception ("Unsupported BPS");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Interlace,The following statement contains a magic number: if (PCM.BitsPerSample == 16) {  	fixed (byte* bs = Bytes) {  		int* res = ((int*)bs) + pos;  		for (int i = n; i > 0; i--)  			*(res++) = (*(src1++) & 0xffff) ^ (*(src2++) << 16);  	}  }  else if (PCM.BitsPerSample == 24) {  	fixed (byte* bs = Bytes) {  		byte* res = bs + pos * 6;  		for (int i = n; i > 0; i--) {  			uint sample_out = (uint)*(src1++);  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out = (uint)*(src2++);  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  		}  	}  }  else  	throw new Exception ("Unsupported BPS");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Interlace,The following statement contains a magic number: if (PCM.BitsPerSample == 16) {  	fixed (byte* bs = Bytes) {  		int* res = ((int*)bs) + pos;  		for (int i = n; i > 0; i--)  			*(res++) = (*(src1++) & 0xffff) ^ (*(src2++) << 16);  	}  }  else if (PCM.BitsPerSample == 24) {  	fixed (byte* bs = Bytes) {  		byte* res = bs + pos * 6;  		for (int i = n; i > 0; i--) {  			uint sample_out = (uint)*(src1++);  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out = (uint)*(src2++);  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  		}  	}  }  else  	throw new Exception ("Unsupported BPS");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Interlace,The following statement contains a magic number: if (PCM.BitsPerSample == 16) {  	fixed (byte* bs = Bytes) {  		int* res = ((int*)bs) + pos;  		for (int i = n; i > 0; i--)  			*(res++) = (*(src1++) & 0xffff) ^ (*(src2++) << 16);  	}  }  else if (PCM.BitsPerSample == 24) {  	fixed (byte* bs = Bytes) {  		byte* res = bs + pos * 6;  		for (int i = n; i > 0; i--) {  			uint sample_out = (uint)*(src1++);  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out = (uint)*(src2++);  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  		}  	}  }  else  	throw new Exception ("Unsupported BPS");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Interlace,The following statement contains a magic number: if (PCM.BitsPerSample == 16) {  	fixed (byte* bs = Bytes) {  		int* res = ((int*)bs) + pos;  		for (int i = n; i > 0; i--)  			*(res++) = (*(src1++) & 0xffff) ^ (*(src2++) << 16);  	}  }  else if (PCM.BitsPerSample == 24) {  	fixed (byte* bs = Bytes) {  		byte* res = bs + pos * 6;  		for (int i = n; i > 0; i--) {  			uint sample_out = (uint)*(src1++);  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out = (uint)*(src2++);  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  		}  	}  }  else  	throw new Exception ("Unsupported BPS");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Interlace,The following statement contains a magic number: if (PCM.BitsPerSample == 16) {  	fixed (byte* bs = Bytes) {  		int* res = ((int*)bs) + pos;  		for (int i = n; i > 0; i--)  			*(res++) = (*(src1++) & 0xffff) ^ (*(src2++) << 16);  	}  }  else if (PCM.BitsPerSample == 24) {  	fixed (byte* bs = Bytes) {  		byte* res = bs + pos * 6;  		for (int i = n; i > 0; i--) {  			uint sample_out = (uint)*(src1++);  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out = (uint)*(src2++);  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  		}  	}  }  else  	throw new Exception ("Unsupported BPS");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Interlace,The following statement contains a magic number: if (PCM.BitsPerSample == 16) {  	fixed (byte* bs = Bytes) {  		int* res = ((int*)bs) + pos;  		for (int i = n; i > 0; i--)  			*(res++) = (*(src1++) & 0xffff) ^ (*(src2++) << 16);  	}  }  else if (PCM.BitsPerSample == 24) {  	fixed (byte* bs = Bytes) {  		byte* res = bs + pos * 6;  		for (int i = n; i > 0; i--) {  			uint sample_out = (uint)*(src1++);  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out = (uint)*(src2++);  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  		}  	}  }  else  	throw new Exception ("Unsupported BPS");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Interlace,The following statement contains a magic number: fixed (byte* bs = Bytes) {  	int* res = ((int*)bs) + pos;  	for (int i = n; i > 0; i--)  		*(res++) = (*(src1++) & 0xffff) ^ (*(src2++) << 16);  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Interlace,The following statement contains a magic number: for (int i = n; i > 0; i--)  	*(res++) = (*(src1++) & 0xffff) ^ (*(src2++) << 16);  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Interlace,The following statement contains a magic number: *(res++) = (*(src1++) & 0xffff) ^ (*(src2++) << 16);  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Interlace,The following statement contains a magic number: if (PCM.BitsPerSample == 24) {  	fixed (byte* bs = Bytes) {  		byte* res = bs + pos * 6;  		for (int i = n; i > 0; i--) {  			uint sample_out = (uint)*(src1++);  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out = (uint)*(src2++);  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  		}  	}  }  else  	throw new Exception ("Unsupported BPS");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Interlace,The following statement contains a magic number: if (PCM.BitsPerSample == 24) {  	fixed (byte* bs = Bytes) {  		byte* res = bs + pos * 6;  		for (int i = n; i > 0; i--) {  			uint sample_out = (uint)*(src1++);  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out = (uint)*(src2++);  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  		}  	}  }  else  	throw new Exception ("Unsupported BPS");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Interlace,The following statement contains a magic number: if (PCM.BitsPerSample == 24) {  	fixed (byte* bs = Bytes) {  		byte* res = bs + pos * 6;  		for (int i = n; i > 0; i--) {  			uint sample_out = (uint)*(src1++);  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out = (uint)*(src2++);  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  		}  	}  }  else  	throw new Exception ("Unsupported BPS");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Interlace,The following statement contains a magic number: if (PCM.BitsPerSample == 24) {  	fixed (byte* bs = Bytes) {  		byte* res = bs + pos * 6;  		for (int i = n; i > 0; i--) {  			uint sample_out = (uint)*(src1++);  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out = (uint)*(src2++);  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  		}  	}  }  else  	throw new Exception ("Unsupported BPS");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Interlace,The following statement contains a magic number: if (PCM.BitsPerSample == 24) {  	fixed (byte* bs = Bytes) {  		byte* res = bs + pos * 6;  		for (int i = n; i > 0; i--) {  			uint sample_out = (uint)*(src1++);  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out = (uint)*(src2++);  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  		}  	}  }  else  	throw new Exception ("Unsupported BPS");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Interlace,The following statement contains a magic number: if (PCM.BitsPerSample == 24) {  	fixed (byte* bs = Bytes) {  		byte* res = bs + pos * 6;  		for (int i = n; i > 0; i--) {  			uint sample_out = (uint)*(src1++);  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out = (uint)*(src2++);  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(res++) = (byte)(sample_out & 0xFF);  		}  	}  }  else  	throw new Exception ("Unsupported BPS");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Interlace,The following statement contains a magic number: fixed (byte* bs = Bytes) {  	byte* res = bs + pos * 6;  	for (int i = n; i > 0; i--) {  		uint sample_out = (uint)*(src1++);  		*(res++) = (byte)(sample_out & 0xFF);  		sample_out >>= 8;  		*(res++) = (byte)(sample_out & 0xFF);  		sample_out >>= 8;  		*(res++) = (byte)(sample_out & 0xFF);  		sample_out = (uint)*(src2++);  		*(res++) = (byte)(sample_out & 0xFF);  		sample_out >>= 8;  		*(res++) = (byte)(sample_out & 0xFF);  		sample_out >>= 8;  		*(res++) = (byte)(sample_out & 0xFF);  	}  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Interlace,The following statement contains a magic number: fixed (byte* bs = Bytes) {  	byte* res = bs + pos * 6;  	for (int i = n; i > 0; i--) {  		uint sample_out = (uint)*(src1++);  		*(res++) = (byte)(sample_out & 0xFF);  		sample_out >>= 8;  		*(res++) = (byte)(sample_out & 0xFF);  		sample_out >>= 8;  		*(res++) = (byte)(sample_out & 0xFF);  		sample_out = (uint)*(src2++);  		*(res++) = (byte)(sample_out & 0xFF);  		sample_out >>= 8;  		*(res++) = (byte)(sample_out & 0xFF);  		sample_out >>= 8;  		*(res++) = (byte)(sample_out & 0xFF);  	}  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Interlace,The following statement contains a magic number: fixed (byte* bs = Bytes) {  	byte* res = bs + pos * 6;  	for (int i = n; i > 0; i--) {  		uint sample_out = (uint)*(src1++);  		*(res++) = (byte)(sample_out & 0xFF);  		sample_out >>= 8;  		*(res++) = (byte)(sample_out & 0xFF);  		sample_out >>= 8;  		*(res++) = (byte)(sample_out & 0xFF);  		sample_out = (uint)*(src2++);  		*(res++) = (byte)(sample_out & 0xFF);  		sample_out >>= 8;  		*(res++) = (byte)(sample_out & 0xFF);  		sample_out >>= 8;  		*(res++) = (byte)(sample_out & 0xFF);  	}  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Interlace,The following statement contains a magic number: fixed (byte* bs = Bytes) {  	byte* res = bs + pos * 6;  	for (int i = n; i > 0; i--) {  		uint sample_out = (uint)*(src1++);  		*(res++) = (byte)(sample_out & 0xFF);  		sample_out >>= 8;  		*(res++) = (byte)(sample_out & 0xFF);  		sample_out >>= 8;  		*(res++) = (byte)(sample_out & 0xFF);  		sample_out = (uint)*(src2++);  		*(res++) = (byte)(sample_out & 0xFF);  		sample_out >>= 8;  		*(res++) = (byte)(sample_out & 0xFF);  		sample_out >>= 8;  		*(res++) = (byte)(sample_out & 0xFF);  	}  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Interlace,The following statement contains a magic number: fixed (byte* bs = Bytes) {  	byte* res = bs + pos * 6;  	for (int i = n; i > 0; i--) {  		uint sample_out = (uint)*(src1++);  		*(res++) = (byte)(sample_out & 0xFF);  		sample_out >>= 8;  		*(res++) = (byte)(sample_out & 0xFF);  		sample_out >>= 8;  		*(res++) = (byte)(sample_out & 0xFF);  		sample_out = (uint)*(src2++);  		*(res++) = (byte)(sample_out & 0xFF);  		sample_out >>= 8;  		*(res++) = (byte)(sample_out & 0xFF);  		sample_out >>= 8;  		*(res++) = (byte)(sample_out & 0xFF);  	}  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Interlace,The following statement contains a magic number: for (int i = n; i > 0; i--) {  	uint sample_out = (uint)*(src1++);  	*(res++) = (byte)(sample_out & 0xFF);  	sample_out >>= 8;  	*(res++) = (byte)(sample_out & 0xFF);  	sample_out >>= 8;  	*(res++) = (byte)(sample_out & 0xFF);  	sample_out = (uint)*(src2++);  	*(res++) = (byte)(sample_out & 0xFF);  	sample_out >>= 8;  	*(res++) = (byte)(sample_out & 0xFF);  	sample_out >>= 8;  	*(res++) = (byte)(sample_out & 0xFF);  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Interlace,The following statement contains a magic number: for (int i = n; i > 0; i--) {  	uint sample_out = (uint)*(src1++);  	*(res++) = (byte)(sample_out & 0xFF);  	sample_out >>= 8;  	*(res++) = (byte)(sample_out & 0xFF);  	sample_out >>= 8;  	*(res++) = (byte)(sample_out & 0xFF);  	sample_out = (uint)*(src2++);  	*(res++) = (byte)(sample_out & 0xFF);  	sample_out >>= 8;  	*(res++) = (byte)(sample_out & 0xFF);  	sample_out >>= 8;  	*(res++) = (byte)(sample_out & 0xFF);  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Interlace,The following statement contains a magic number: for (int i = n; i > 0; i--) {  	uint sample_out = (uint)*(src1++);  	*(res++) = (byte)(sample_out & 0xFF);  	sample_out >>= 8;  	*(res++) = (byte)(sample_out & 0xFF);  	sample_out >>= 8;  	*(res++) = (byte)(sample_out & 0xFF);  	sample_out = (uint)*(src2++);  	*(res++) = (byte)(sample_out & 0xFF);  	sample_out >>= 8;  	*(res++) = (byte)(sample_out & 0xFF);  	sample_out >>= 8;  	*(res++) = (byte)(sample_out & 0xFF);  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Interlace,The following statement contains a magic number: for (int i = n; i > 0; i--) {  	uint sample_out = (uint)*(src1++);  	*(res++) = (byte)(sample_out & 0xFF);  	sample_out >>= 8;  	*(res++) = (byte)(sample_out & 0xFF);  	sample_out >>= 8;  	*(res++) = (byte)(sample_out & 0xFF);  	sample_out = (uint)*(src2++);  	*(res++) = (byte)(sample_out & 0xFF);  	sample_out >>= 8;  	*(res++) = (byte)(sample_out & 0xFF);  	sample_out >>= 8;  	*(res++) = (byte)(sample_out & 0xFF);  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Interlace,The following statement contains a magic number: sample_out >>= 8;  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Interlace,The following statement contains a magic number: sample_out >>= 8;  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Interlace,The following statement contains a magic number: sample_out >>= 8;  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Interlace,The following statement contains a magic number: sample_out >>= 8;  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FLACSamplesToBytes_16,The following statement contains a magic number: if ((inSamples.GetLength (0) - inSampleOffset < sampleCount) || (outSamples.Length - outByteOffset < loopCount * 2)) {  	throw new IndexOutOfRangeException ();  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FLACSamplesToBytes_24,The following statement contains a magic number: if ((inSamples.GetLength (0) - inSampleOffset < sampleCount) || (outSamples.Length - outByteOffset < loopCount * 3)) {  	throw new IndexOutOfRangeException ();  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FLACSamplesToBytes_24,The following statement contains a magic number: fixed (int* pInSamplesFixed = &inSamples [inSampleOffset' 0]) {  	fixed (byte* pOutSamplesFixed = &outSamples [outByteOffset]) {  		int* pInSamples = pInSamplesFixed;  		byte* pOutSamples = pOutSamplesFixed;  		for (int i = 0; i < loopCount; i++) {  			uint sample_out = (uint)*(pInSamples++) << wastedBits;  			*(pOutSamples++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(pOutSamples++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(pOutSamples++) = (byte)(sample_out & 0xFF);  		}  	}  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FLACSamplesToBytes_24,The following statement contains a magic number: fixed (int* pInSamplesFixed = &inSamples [inSampleOffset' 0]) {  	fixed (byte* pOutSamplesFixed = &outSamples [outByteOffset]) {  		int* pInSamples = pInSamplesFixed;  		byte* pOutSamples = pOutSamplesFixed;  		for (int i = 0; i < loopCount; i++) {  			uint sample_out = (uint)*(pInSamples++) << wastedBits;  			*(pOutSamples++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(pOutSamples++) = (byte)(sample_out & 0xFF);  			sample_out >>= 8;  			*(pOutSamples++) = (byte)(sample_out & 0xFF);  		}  	}  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FLACSamplesToBytes_24,The following statement contains a magic number: fixed (byte* pOutSamplesFixed = &outSamples [outByteOffset]) {  	int* pInSamples = pInSamplesFixed;  	byte* pOutSamples = pOutSamplesFixed;  	for (int i = 0; i < loopCount; i++) {  		uint sample_out = (uint)*(pInSamples++) << wastedBits;  		*(pOutSamples++) = (byte)(sample_out & 0xFF);  		sample_out >>= 8;  		*(pOutSamples++) = (byte)(sample_out & 0xFF);  		sample_out >>= 8;  		*(pOutSamples++) = (byte)(sample_out & 0xFF);  	}  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FLACSamplesToBytes_24,The following statement contains a magic number: fixed (byte* pOutSamplesFixed = &outSamples [outByteOffset]) {  	int* pInSamples = pInSamplesFixed;  	byte* pOutSamples = pOutSamplesFixed;  	for (int i = 0; i < loopCount; i++) {  		uint sample_out = (uint)*(pInSamples++) << wastedBits;  		*(pOutSamples++) = (byte)(sample_out & 0xFF);  		sample_out >>= 8;  		*(pOutSamples++) = (byte)(sample_out & 0xFF);  		sample_out >>= 8;  		*(pOutSamples++) = (byte)(sample_out & 0xFF);  	}  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FLACSamplesToBytes_24,The following statement contains a magic number: for (int i = 0; i < loopCount; i++) {  	uint sample_out = (uint)*(pInSamples++) << wastedBits;  	*(pOutSamples++) = (byte)(sample_out & 0xFF);  	sample_out >>= 8;  	*(pOutSamples++) = (byte)(sample_out & 0xFF);  	sample_out >>= 8;  	*(pOutSamples++) = (byte)(sample_out & 0xFF);  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FLACSamplesToBytes_24,The following statement contains a magic number: for (int i = 0; i < loopCount; i++) {  	uint sample_out = (uint)*(pInSamples++) << wastedBits;  	*(pOutSamples++) = (byte)(sample_out & 0xFF);  	sample_out >>= 8;  	*(pOutSamples++) = (byte)(sample_out & 0xFF);  	sample_out >>= 8;  	*(pOutSamples++) = (byte)(sample_out & 0xFF);  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FLACSamplesToBytes_24,The following statement contains a magic number: sample_out >>= 8;  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FLACSamplesToBytes_24,The following statement contains a magic number: sample_out >>= 8;  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FloatToBytes_16,The following statement contains a magic number: if ((inSamples.GetLength (0) - inSampleOffset < sampleCount) || (outSamples.Length - outByteOffset < loopCount * 2)) {  	throw new IndexOutOfRangeException ();  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FloatToBytes_16,The following statement contains a magic number: fixed (float* pInSamplesFixed = &inSamples [inSampleOffset' 0]) {  	fixed (byte* pOutSamplesFixed = &outSamples [outByteOffset]) {  		float* pInSamples = pInSamplesFixed;  		short* pOutSamples = (short*)pOutSamplesFixed;  		for (int i = 0; i < loopCount; i++) {  			*(pOutSamples++) = (short)(32758 * (*(pInSamples++)));  		}  	}  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FloatToBytes_16,The following statement contains a magic number: fixed (byte* pOutSamplesFixed = &outSamples [outByteOffset]) {  	float* pInSamples = pInSamplesFixed;  	short* pOutSamples = (short*)pOutSamplesFixed;  	for (int i = 0; i < loopCount; i++) {  		*(pOutSamples++) = (short)(32758 * (*(pInSamples++)));  	}  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FloatToBytes_16,The following statement contains a magic number: for (int i = 0; i < loopCount; i++) {  	*(pOutSamples++) = (short)(32758 * (*(pInSamples++)));  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FloatToBytes_16,The following statement contains a magic number: *(pOutSamples++) = (short)(32758 * (*(pInSamples++)));  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FloatToBytes,The following statement contains a magic number: if (bitsPerSample == 16)  	FloatToBytes_16 (inSamples' inSampleOffset' outSamples' outByteOffset' sampleCount' channelCount);  //else if (bitsPerSample > 16 && bitsPerSample <= 24)  //    FLACSamplesToBytes_24(inSamples' inSampleOffset' outSamples' outByteOffset' sampleCount' channelCount' 24 - bitsPerSample);  else if (bitsPerSample == 32)  	Buffer.BlockCopy (inSamples' inSampleOffset * 4 * channelCount' outSamples' outByteOffset' sampleCount * 4 * channelCount);  else  	throw new Exception ("Unsupported bitsPerSample value");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FloatToBytes,The following statement contains a magic number: if (bitsPerSample == 16)  	FloatToBytes_16 (inSamples' inSampleOffset' outSamples' outByteOffset' sampleCount' channelCount);  //else if (bitsPerSample > 16 && bitsPerSample <= 24)  //    FLACSamplesToBytes_24(inSamples' inSampleOffset' outSamples' outByteOffset' sampleCount' channelCount' 24 - bitsPerSample);  else if (bitsPerSample == 32)  	Buffer.BlockCopy (inSamples' inSampleOffset * 4 * channelCount' outSamples' outByteOffset' sampleCount * 4 * channelCount);  else  	throw new Exception ("Unsupported bitsPerSample value");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FloatToBytes,The following statement contains a magic number: if (bitsPerSample == 16)  	FloatToBytes_16 (inSamples' inSampleOffset' outSamples' outByteOffset' sampleCount' channelCount);  //else if (bitsPerSample > 16 && bitsPerSample <= 24)  //    FLACSamplesToBytes_24(inSamples' inSampleOffset' outSamples' outByteOffset' sampleCount' channelCount' 24 - bitsPerSample);  else if (bitsPerSample == 32)  	Buffer.BlockCopy (inSamples' inSampleOffset * 4 * channelCount' outSamples' outByteOffset' sampleCount * 4 * channelCount);  else  	throw new Exception ("Unsupported bitsPerSample value");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FloatToBytes,The following statement contains a magic number: if (bitsPerSample == 16)  	FloatToBytes_16 (inSamples' inSampleOffset' outSamples' outByteOffset' sampleCount' channelCount);  //else if (bitsPerSample > 16 && bitsPerSample <= 24)  //    FLACSamplesToBytes_24(inSamples' inSampleOffset' outSamples' outByteOffset' sampleCount' channelCount' 24 - bitsPerSample);  else if (bitsPerSample == 32)  	Buffer.BlockCopy (inSamples' inSampleOffset * 4 * channelCount' outSamples' outByteOffset' sampleCount * 4 * channelCount);  else  	throw new Exception ("Unsupported bitsPerSample value");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FloatToBytes,The following statement contains a magic number: if (bitsPerSample == 32)  	Buffer.BlockCopy (inSamples' inSampleOffset * 4 * channelCount' outSamples' outByteOffset' sampleCount * 4 * channelCount);  else  	throw new Exception ("Unsupported bitsPerSample value");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FloatToBytes,The following statement contains a magic number: if (bitsPerSample == 32)  	Buffer.BlockCopy (inSamples' inSampleOffset * 4 * channelCount' outSamples' outByteOffset' sampleCount * 4 * channelCount);  else  	throw new Exception ("Unsupported bitsPerSample value");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FloatToBytes,The following statement contains a magic number: if (bitsPerSample == 32)  	Buffer.BlockCopy (inSamples' inSampleOffset * 4 * channelCount' outSamples' outByteOffset' sampleCount * 4 * channelCount);  else  	throw new Exception ("Unsupported bitsPerSample value");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FloatToBytes,The following statement contains a magic number: Buffer.BlockCopy (inSamples' inSampleOffset * 4 * channelCount' outSamples' outByteOffset' sampleCount * 4 * channelCount);  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FloatToBytes,The following statement contains a magic number: Buffer.BlockCopy (inSamples' inSampleOffset * 4 * channelCount' outSamples' outByteOffset' sampleCount * 4 * channelCount);  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FLACSamplesToBytes,The following statement contains a magic number: if (bitsPerSample == 16)  	FLACSamplesToBytes_16 (inSamples' inSampleOffset' outSamples' outByteOffset' sampleCount' channelCount);  else if (bitsPerSample > 16 && bitsPerSample <= 24)  	FLACSamplesToBytes_24 (inSamples' inSampleOffset' outSamples' outByteOffset' sampleCount' channelCount' 24 - bitsPerSample);  else  	throw new Exception ("Unsupported bitsPerSample value");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FLACSamplesToBytes,The following statement contains a magic number: if (bitsPerSample == 16)  	FLACSamplesToBytes_16 (inSamples' inSampleOffset' outSamples' outByteOffset' sampleCount' channelCount);  else if (bitsPerSample > 16 && bitsPerSample <= 24)  	FLACSamplesToBytes_24 (inSamples' inSampleOffset' outSamples' outByteOffset' sampleCount' channelCount' 24 - bitsPerSample);  else  	throw new Exception ("Unsupported bitsPerSample value");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FLACSamplesToBytes,The following statement contains a magic number: if (bitsPerSample == 16)  	FLACSamplesToBytes_16 (inSamples' inSampleOffset' outSamples' outByteOffset' sampleCount' channelCount);  else if (bitsPerSample > 16 && bitsPerSample <= 24)  	FLACSamplesToBytes_24 (inSamples' inSampleOffset' outSamples' outByteOffset' sampleCount' channelCount' 24 - bitsPerSample);  else  	throw new Exception ("Unsupported bitsPerSample value");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FLACSamplesToBytes,The following statement contains a magic number: if (bitsPerSample == 16)  	FLACSamplesToBytes_16 (inSamples' inSampleOffset' outSamples' outByteOffset' sampleCount' channelCount);  else if (bitsPerSample > 16 && bitsPerSample <= 24)  	FLACSamplesToBytes_24 (inSamples' inSampleOffset' outSamples' outByteOffset' sampleCount' channelCount' 24 - bitsPerSample);  else  	throw new Exception ("Unsupported bitsPerSample value");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FLACSamplesToBytes,The following statement contains a magic number: if (bitsPerSample > 16 && bitsPerSample <= 24)  	FLACSamplesToBytes_24 (inSamples' inSampleOffset' outSamples' outByteOffset' sampleCount' channelCount' 24 - bitsPerSample);  else  	throw new Exception ("Unsupported bitsPerSample value");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FLACSamplesToBytes,The following statement contains a magic number: if (bitsPerSample > 16 && bitsPerSample <= 24)  	FLACSamplesToBytes_24 (inSamples' inSampleOffset' outSamples' outByteOffset' sampleCount' channelCount' 24 - bitsPerSample);  else  	throw new Exception ("Unsupported bitsPerSample value");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FLACSamplesToBytes,The following statement contains a magic number: if (bitsPerSample > 16 && bitsPerSample <= 24)  	FLACSamplesToBytes_24 (inSamples' inSampleOffset' outSamples' outByteOffset' sampleCount' channelCount' 24 - bitsPerSample);  else  	throw new Exception ("Unsupported bitsPerSample value");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FLACSamplesToBytes,The following statement contains a magic number: FLACSamplesToBytes_24 (inSamples' inSampleOffset' outSamples' outByteOffset' sampleCount' channelCount' 24 - bitsPerSample);  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,FLACSamplesToBytes,The following statement contains a magic number: if (bitsPerSample == 16)  	FLACSamplesToBytes_16 (inSamples' inSampleOffset' outSamples' sampleCount' channelCount);  else  	throw new Exception ("Unsupported bitsPerSample value");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Bytes16ToFloat,The following statement contains a magic number: if ((inSamples.Length - inByteOffset < loopCount * 2) || (outSamples.GetLength (0) - outSampleOffset < sampleCount))  	throw new IndexOutOfRangeException ();  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,BytesToFLACSamples_16,The following statement contains a magic number: if ((inSamples.Length - inByteOffset < loopCount * 2) || (outSamples.GetLength (0) - outSampleOffset < sampleCount)) {  	throw new IndexOutOfRangeException ();  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,BytesToFLACSamples_24,The following statement contains a magic number: if ((inSamples.Length - inByteOffset < loopCount * 3) || (outSamples.GetLength (0) - outSampleOffset < sampleCount))  	throw new IndexOutOfRangeException ();  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,BytesToFLACSamples_24,The following statement contains a magic number: fixed (byte* pInSamplesFixed = &inSamples [inByteOffset]) {  	fixed (int* pOutSamplesFixed = &outSamples [outSampleOffset' 0]) {  		byte* pInSamples = (byte*)pInSamplesFixed;  		int* pOutSamples = pOutSamplesFixed;  		for (int i = 0; i < loopCount; i++) {  			int sample = (int)*(pInSamples++);  			sample += (int)*(pInSamples++) << 8;  			sample += (int)*(pInSamples++) << 16;  			*(pOutSamples++) = (sample << 8) >> (8 + wastedBits);  		}  	}  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,BytesToFLACSamples_24,The following statement contains a magic number: fixed (byte* pInSamplesFixed = &inSamples [inByteOffset]) {  	fixed (int* pOutSamplesFixed = &outSamples [outSampleOffset' 0]) {  		byte* pInSamples = (byte*)pInSamplesFixed;  		int* pOutSamples = pOutSamplesFixed;  		for (int i = 0; i < loopCount; i++) {  			int sample = (int)*(pInSamples++);  			sample += (int)*(pInSamples++) << 8;  			sample += (int)*(pInSamples++) << 16;  			*(pOutSamples++) = (sample << 8) >> (8 + wastedBits);  		}  	}  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,BytesToFLACSamples_24,The following statement contains a magic number: fixed (byte* pInSamplesFixed = &inSamples [inByteOffset]) {  	fixed (int* pOutSamplesFixed = &outSamples [outSampleOffset' 0]) {  		byte* pInSamples = (byte*)pInSamplesFixed;  		int* pOutSamples = pOutSamplesFixed;  		for (int i = 0; i < loopCount; i++) {  			int sample = (int)*(pInSamples++);  			sample += (int)*(pInSamples++) << 8;  			sample += (int)*(pInSamples++) << 16;  			*(pOutSamples++) = (sample << 8) >> (8 + wastedBits);  		}  	}  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,BytesToFLACSamples_24,The following statement contains a magic number: fixed (byte* pInSamplesFixed = &inSamples [inByteOffset]) {  	fixed (int* pOutSamplesFixed = &outSamples [outSampleOffset' 0]) {  		byte* pInSamples = (byte*)pInSamplesFixed;  		int* pOutSamples = pOutSamplesFixed;  		for (int i = 0; i < loopCount; i++) {  			int sample = (int)*(pInSamples++);  			sample += (int)*(pInSamples++) << 8;  			sample += (int)*(pInSamples++) << 16;  			*(pOutSamples++) = (sample << 8) >> (8 + wastedBits);  		}  	}  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,BytesToFLACSamples_24,The following statement contains a magic number: fixed (int* pOutSamplesFixed = &outSamples [outSampleOffset' 0]) {  	byte* pInSamples = (byte*)pInSamplesFixed;  	int* pOutSamples = pOutSamplesFixed;  	for (int i = 0; i < loopCount; i++) {  		int sample = (int)*(pInSamples++);  		sample += (int)*(pInSamples++) << 8;  		sample += (int)*(pInSamples++) << 16;  		*(pOutSamples++) = (sample << 8) >> (8 + wastedBits);  	}  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,BytesToFLACSamples_24,The following statement contains a magic number: fixed (int* pOutSamplesFixed = &outSamples [outSampleOffset' 0]) {  	byte* pInSamples = (byte*)pInSamplesFixed;  	int* pOutSamples = pOutSamplesFixed;  	for (int i = 0; i < loopCount; i++) {  		int sample = (int)*(pInSamples++);  		sample += (int)*(pInSamples++) << 8;  		sample += (int)*(pInSamples++) << 16;  		*(pOutSamples++) = (sample << 8) >> (8 + wastedBits);  	}  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,BytesToFLACSamples_24,The following statement contains a magic number: fixed (int* pOutSamplesFixed = &outSamples [outSampleOffset' 0]) {  	byte* pInSamples = (byte*)pInSamplesFixed;  	int* pOutSamples = pOutSamplesFixed;  	for (int i = 0; i < loopCount; i++) {  		int sample = (int)*(pInSamples++);  		sample += (int)*(pInSamples++) << 8;  		sample += (int)*(pInSamples++) << 16;  		*(pOutSamples++) = (sample << 8) >> (8 + wastedBits);  	}  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,BytesToFLACSamples_24,The following statement contains a magic number: fixed (int* pOutSamplesFixed = &outSamples [outSampleOffset' 0]) {  	byte* pInSamples = (byte*)pInSamplesFixed;  	int* pOutSamples = pOutSamplesFixed;  	for (int i = 0; i < loopCount; i++) {  		int sample = (int)*(pInSamples++);  		sample += (int)*(pInSamples++) << 8;  		sample += (int)*(pInSamples++) << 16;  		*(pOutSamples++) = (sample << 8) >> (8 + wastedBits);  	}  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,BytesToFLACSamples_24,The following statement contains a magic number: for (int i = 0; i < loopCount; i++) {  	int sample = (int)*(pInSamples++);  	sample += (int)*(pInSamples++) << 8;  	sample += (int)*(pInSamples++) << 16;  	*(pOutSamples++) = (sample << 8) >> (8 + wastedBits);  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,BytesToFLACSamples_24,The following statement contains a magic number: for (int i = 0; i < loopCount; i++) {  	int sample = (int)*(pInSamples++);  	sample += (int)*(pInSamples++) << 8;  	sample += (int)*(pInSamples++) << 16;  	*(pOutSamples++) = (sample << 8) >> (8 + wastedBits);  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,BytesToFLACSamples_24,The following statement contains a magic number: for (int i = 0; i < loopCount; i++) {  	int sample = (int)*(pInSamples++);  	sample += (int)*(pInSamples++) << 8;  	sample += (int)*(pInSamples++) << 16;  	*(pOutSamples++) = (sample << 8) >> (8 + wastedBits);  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,BytesToFLACSamples_24,The following statement contains a magic number: for (int i = 0; i < loopCount; i++) {  	int sample = (int)*(pInSamples++);  	sample += (int)*(pInSamples++) << 8;  	sample += (int)*(pInSamples++) << 16;  	*(pOutSamples++) = (sample << 8) >> (8 + wastedBits);  }  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,BytesToFLACSamples_24,The following statement contains a magic number: sample += (int)*(pInSamples++) << 8;  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,BytesToFLACSamples_24,The following statement contains a magic number: sample += (int)*(pInSamples++) << 16;  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,BytesToFLACSamples_24,The following statement contains a magic number: *(pOutSamples++) = (sample << 8) >> (8 + wastedBits);  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,BytesToFLACSamples_24,The following statement contains a magic number: *(pOutSamples++) = (sample << 8) >> (8 + wastedBits);  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,BytesToFLACSamples,The following statement contains a magic number: if (bitsPerSample == 16)  	BytesToFLACSamples_16 (inSamples' inByteOffset' outSamples' outSampleOffset' sampleCount' channelCount);  else if (bitsPerSample > 16 && bitsPerSample <= 24)  	BytesToFLACSamples_24 (inSamples' inByteOffset' outSamples' outSampleOffset' sampleCount' channelCount' 24 - bitsPerSample);  else  	throw new Exception ("Unsupported bitsPerSample value");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,BytesToFLACSamples,The following statement contains a magic number: if (bitsPerSample == 16)  	BytesToFLACSamples_16 (inSamples' inByteOffset' outSamples' outSampleOffset' sampleCount' channelCount);  else if (bitsPerSample > 16 && bitsPerSample <= 24)  	BytesToFLACSamples_24 (inSamples' inByteOffset' outSamples' outSampleOffset' sampleCount' channelCount' 24 - bitsPerSample);  else  	throw new Exception ("Unsupported bitsPerSample value");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,BytesToFLACSamples,The following statement contains a magic number: if (bitsPerSample == 16)  	BytesToFLACSamples_16 (inSamples' inByteOffset' outSamples' outSampleOffset' sampleCount' channelCount);  else if (bitsPerSample > 16 && bitsPerSample <= 24)  	BytesToFLACSamples_24 (inSamples' inByteOffset' outSamples' outSampleOffset' sampleCount' channelCount' 24 - bitsPerSample);  else  	throw new Exception ("Unsupported bitsPerSample value");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,BytesToFLACSamples,The following statement contains a magic number: if (bitsPerSample == 16)  	BytesToFLACSamples_16 (inSamples' inByteOffset' outSamples' outSampleOffset' sampleCount' channelCount);  else if (bitsPerSample > 16 && bitsPerSample <= 24)  	BytesToFLACSamples_24 (inSamples' inByteOffset' outSamples' outSampleOffset' sampleCount' channelCount' 24 - bitsPerSample);  else  	throw new Exception ("Unsupported bitsPerSample value");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,BytesToFLACSamples,The following statement contains a magic number: if (bitsPerSample > 16 && bitsPerSample <= 24)  	BytesToFLACSamples_24 (inSamples' inByteOffset' outSamples' outSampleOffset' sampleCount' channelCount' 24 - bitsPerSample);  else  	throw new Exception ("Unsupported bitsPerSample value");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,BytesToFLACSamples,The following statement contains a magic number: if (bitsPerSample > 16 && bitsPerSample <= 24)  	BytesToFLACSamples_24 (inSamples' inByteOffset' outSamples' outSampleOffset' sampleCount' channelCount' 24 - bitsPerSample);  else  	throw new Exception ("Unsupported bitsPerSample value");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,BytesToFLACSamples,The following statement contains a magic number: if (bitsPerSample > 16 && bitsPerSample <= 24)  	BytesToFLACSamples_24 (inSamples' inByteOffset' outSamples' outSampleOffset' sampleCount' channelCount' 24 - bitsPerSample);  else  	throw new Exception ("Unsupported bitsPerSample value");  
Magic Number,CUETools.Codecs,AudioBuffer,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,BytesToFLACSamples,The following statement contains a magic number: BytesToFLACSamples_24 (inSamples' inByteOffset' outSamples' outSampleOffset' sampleCount' channelCount' 24 - bitsPerSample);  
Magic Number,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemCpy,The following statement contains a magic number: if ((((IntPtr)smp).ToInt64 () & 7) == (((IntPtr)res).ToInt64 () & 7) && n > 32) {  	int delta = (int)((8 - (((IntPtr)smp).ToInt64 () & 7)) & 7);  	for (int i = delta; i > 0; i--)  		*(res++) = *(smp++);  	n -= delta;  	MemCpy ((long*)res' (long*)smp' n >> 3);  	int n8 = (n >> 3) << 3;  	n -= n8;  	smp += n8;  	res += n8;  }  
Magic Number,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemCpy,The following statement contains a magic number: if ((((IntPtr)smp).ToInt64 () & 7) == (((IntPtr)res).ToInt64 () & 7) && n > 32) {  	int delta = (int)((8 - (((IntPtr)smp).ToInt64 () & 7)) & 7);  	for (int i = delta; i > 0; i--)  		*(res++) = *(smp++);  	n -= delta;  	MemCpy ((long*)res' (long*)smp' n >> 3);  	int n8 = (n >> 3) << 3;  	n -= n8;  	smp += n8;  	res += n8;  }  
Magic Number,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemCpy,The following statement contains a magic number: if ((((IntPtr)smp).ToInt64 () & 7) == (((IntPtr)res).ToInt64 () & 7) && n > 32) {  	int delta = (int)((8 - (((IntPtr)smp).ToInt64 () & 7)) & 7);  	for (int i = delta; i > 0; i--)  		*(res++) = *(smp++);  	n -= delta;  	MemCpy ((long*)res' (long*)smp' n >> 3);  	int n8 = (n >> 3) << 3;  	n -= n8;  	smp += n8;  	res += n8;  }  
Magic Number,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemCpy,The following statement contains a magic number: if ((((IntPtr)smp).ToInt64 () & 7) == (((IntPtr)res).ToInt64 () & 7) && n > 32) {  	int delta = (int)((8 - (((IntPtr)smp).ToInt64 () & 7)) & 7);  	for (int i = delta; i > 0; i--)  		*(res++) = *(smp++);  	n -= delta;  	MemCpy ((long*)res' (long*)smp' n >> 3);  	int n8 = (n >> 3) << 3;  	n -= n8;  	smp += n8;  	res += n8;  }  
Magic Number,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemCpy,The following statement contains a magic number: if ((((IntPtr)smp).ToInt64 () & 7) == (((IntPtr)res).ToInt64 () & 7) && n > 32) {  	int delta = (int)((8 - (((IntPtr)smp).ToInt64 () & 7)) & 7);  	for (int i = delta; i > 0; i--)  		*(res++) = *(smp++);  	n -= delta;  	MemCpy ((long*)res' (long*)smp' n >> 3);  	int n8 = (n >> 3) << 3;  	n -= n8;  	smp += n8;  	res += n8;  }  
Magic Number,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemCpy,The following statement contains a magic number: if ((((IntPtr)smp).ToInt64 () & 7) == (((IntPtr)res).ToInt64 () & 7) && n > 32) {  	int delta = (int)((8 - (((IntPtr)smp).ToInt64 () & 7)) & 7);  	for (int i = delta; i > 0; i--)  		*(res++) = *(smp++);  	n -= delta;  	MemCpy ((long*)res' (long*)smp' n >> 3);  	int n8 = (n >> 3) << 3;  	n -= n8;  	smp += n8;  	res += n8;  }  
Magic Number,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemCpy,The following statement contains a magic number: if ((((IntPtr)smp).ToInt64 () & 7) == (((IntPtr)res).ToInt64 () & 7) && n > 32) {  	int delta = (int)((8 - (((IntPtr)smp).ToInt64 () & 7)) & 7);  	for (int i = delta; i > 0; i--)  		*(res++) = *(smp++);  	n -= delta;  	MemCpy ((long*)res' (long*)smp' n >> 3);  	int n8 = (n >> 3) << 3;  	n -= n8;  	smp += n8;  	res += n8;  }  
Magic Number,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemCpy,The following statement contains a magic number: if ((((IntPtr)smp).ToInt64 () & 7) == (((IntPtr)res).ToInt64 () & 7) && n > 32) {  	int delta = (int)((8 - (((IntPtr)smp).ToInt64 () & 7)) & 7);  	for (int i = delta; i > 0; i--)  		*(res++) = *(smp++);  	n -= delta;  	MemCpy ((long*)res' (long*)smp' n >> 3);  	int n8 = (n >> 3) << 3;  	n -= n8;  	smp += n8;  	res += n8;  }  
Magic Number,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemCpy,The following statement contains a magic number: if ((((IntPtr)smp).ToInt64 () & 7) == (((IntPtr)res).ToInt64 () & 7) && n > 32) {  	int delta = (int)((8 - (((IntPtr)smp).ToInt64 () & 7)) & 7);  	for (int i = delta; i > 0; i--)  		*(res++) = *(smp++);  	n -= delta;  	MemCpy ((long*)res' (long*)smp' n >> 3);  	int n8 = (n >> 3) << 3;  	n -= n8;  	smp += n8;  	res += n8;  }  
Magic Number,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemCpy,The following statement contains a magic number: MemCpy ((long*)res' (long*)smp' n >> 3);  
Magic Number,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemCpy,The following statement contains a magic number: if ((((IntPtr)smp).ToInt64 () & 3) == (((IntPtr)res).ToInt64 () & 3) && n > 16) {  	int delta = (int)((4 - (((IntPtr)smp).ToInt64 () & 3)) & 3);  	for (int i = delta; i > 0; i--)  		*(res++) = *(smp++);  	n -= delta;  	MemCpy ((int*)res' (int*)smp' n >> 2);  	int n4 = (n >> 2) << 2;  	n -= n4;  	smp += n4;  	res += n4;  }  
Magic Number,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemCpy,The following statement contains a magic number: if ((((IntPtr)smp).ToInt64 () & 3) == (((IntPtr)res).ToInt64 () & 3) && n > 16) {  	int delta = (int)((4 - (((IntPtr)smp).ToInt64 () & 3)) & 3);  	for (int i = delta; i > 0; i--)  		*(res++) = *(smp++);  	n -= delta;  	MemCpy ((int*)res' (int*)smp' n >> 2);  	int n4 = (n >> 2) << 2;  	n -= n4;  	smp += n4;  	res += n4;  }  
Magic Number,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemCpy,The following statement contains a magic number: if ((((IntPtr)smp).ToInt64 () & 3) == (((IntPtr)res).ToInt64 () & 3) && n > 16) {  	int delta = (int)((4 - (((IntPtr)smp).ToInt64 () & 3)) & 3);  	for (int i = delta; i > 0; i--)  		*(res++) = *(smp++);  	n -= delta;  	MemCpy ((int*)res' (int*)smp' n >> 2);  	int n4 = (n >> 2) << 2;  	n -= n4;  	smp += n4;  	res += n4;  }  
Magic Number,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemCpy,The following statement contains a magic number: if ((((IntPtr)smp).ToInt64 () & 3) == (((IntPtr)res).ToInt64 () & 3) && n > 16) {  	int delta = (int)((4 - (((IntPtr)smp).ToInt64 () & 3)) & 3);  	for (int i = delta; i > 0; i--)  		*(res++) = *(smp++);  	n -= delta;  	MemCpy ((int*)res' (int*)smp' n >> 2);  	int n4 = (n >> 2) << 2;  	n -= n4;  	smp += n4;  	res += n4;  }  
Magic Number,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemCpy,The following statement contains a magic number: if ((((IntPtr)smp).ToInt64 () & 3) == (((IntPtr)res).ToInt64 () & 3) && n > 16) {  	int delta = (int)((4 - (((IntPtr)smp).ToInt64 () & 3)) & 3);  	for (int i = delta; i > 0; i--)  		*(res++) = *(smp++);  	n -= delta;  	MemCpy ((int*)res' (int*)smp' n >> 2);  	int n4 = (n >> 2) << 2;  	n -= n4;  	smp += n4;  	res += n4;  }  
Magic Number,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemCpy,The following statement contains a magic number: if ((((IntPtr)smp).ToInt64 () & 3) == (((IntPtr)res).ToInt64 () & 3) && n > 16) {  	int delta = (int)((4 - (((IntPtr)smp).ToInt64 () & 3)) & 3);  	for (int i = delta; i > 0; i--)  		*(res++) = *(smp++);  	n -= delta;  	MemCpy ((int*)res' (int*)smp' n >> 2);  	int n4 = (n >> 2) << 2;  	n -= n4;  	smp += n4;  	res += n4;  }  
Magic Number,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemCpy,The following statement contains a magic number: if ((((IntPtr)smp).ToInt64 () & 3) == (((IntPtr)res).ToInt64 () & 3) && n > 16) {  	int delta = (int)((4 - (((IntPtr)smp).ToInt64 () & 3)) & 3);  	for (int i = delta; i > 0; i--)  		*(res++) = *(smp++);  	n -= delta;  	MemCpy ((int*)res' (int*)smp' n >> 2);  	int n4 = (n >> 2) << 2;  	n -= n4;  	smp += n4;  	res += n4;  }  
Magic Number,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemCpy,The following statement contains a magic number: if ((((IntPtr)smp).ToInt64 () & 3) == (((IntPtr)res).ToInt64 () & 3) && n > 16) {  	int delta = (int)((4 - (((IntPtr)smp).ToInt64 () & 3)) & 3);  	for (int i = delta; i > 0; i--)  		*(res++) = *(smp++);  	n -= delta;  	MemCpy ((int*)res' (int*)smp' n >> 2);  	int n4 = (n >> 2) << 2;  	n -= n4;  	smp += n4;  	res += n4;  }  
Magic Number,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemCpy,The following statement contains a magic number: if ((((IntPtr)smp).ToInt64 () & 3) == (((IntPtr)res).ToInt64 () & 3) && n > 16) {  	int delta = (int)((4 - (((IntPtr)smp).ToInt64 () & 3)) & 3);  	for (int i = delta; i > 0; i--)  		*(res++) = *(smp++);  	n -= delta;  	MemCpy ((int*)res' (int*)smp' n >> 2);  	int n4 = (n >> 2) << 2;  	n -= n4;  	smp += n4;  	res += n4;  }  
Magic Number,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemCpy,The following statement contains a magic number: MemCpy ((int*)res' (int*)smp' n >> 2);  
Magic Number,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemSet,The following statement contains a magic number: if (IntPtr.Size == 8 && (((IntPtr)res).ToInt64 () & 7) == 0 && smp == 0 && n > 8) {  	MemSet ((long*)res' 0' n >> 3);  	int n8 = (n >> 3) << 3;  	n -= n8;  	res += n8;  }  
Magic Number,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemSet,The following statement contains a magic number: if (IntPtr.Size == 8 && (((IntPtr)res).ToInt64 () & 7) == 0 && smp == 0 && n > 8) {  	MemSet ((long*)res' 0' n >> 3);  	int n8 = (n >> 3) << 3;  	n -= n8;  	res += n8;  }  
Magic Number,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemSet,The following statement contains a magic number: if (IntPtr.Size == 8 && (((IntPtr)res).ToInt64 () & 7) == 0 && smp == 0 && n > 8) {  	MemSet ((long*)res' 0' n >> 3);  	int n8 = (n >> 3) << 3;  	n -= n8;  	res += n8;  }  
Magic Number,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemSet,The following statement contains a magic number: if (IntPtr.Size == 8 && (((IntPtr)res).ToInt64 () & 7) == 0 && smp == 0 && n > 8) {  	MemSet ((long*)res' 0' n >> 3);  	int n8 = (n >> 3) << 3;  	n -= n8;  	res += n8;  }  
Magic Number,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemSet,The following statement contains a magic number: if (IntPtr.Size == 8 && (((IntPtr)res).ToInt64 () & 7) == 0 && smp == 0 && n > 8) {  	MemSet ((long*)res' 0' n >> 3);  	int n8 = (n >> 3) << 3;  	n -= n8;  	res += n8;  }  
Magic Number,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemSet,The following statement contains a magic number: if (IntPtr.Size == 8 && (((IntPtr)res).ToInt64 () & 7) == 0 && smp == 0 && n > 8) {  	MemSet ((long*)res' 0' n >> 3);  	int n8 = (n >> 3) << 3;  	n -= n8;  	res += n8;  }  
Magic Number,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemSet,The following statement contains a magic number: MemSet ((long*)res' 0' n >> 3);  
Magic Number,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemSet,The following statement contains a magic number: if ((((IntPtr)res).ToInt64 () & 3) == 0 && smp == 0 && n > 4) {  	MemSet ((int*)res' 0' n >> 2);  	int n4 = (n >> 2) << 2;  	n -= n4;  	res += n4;  }  
Magic Number,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemSet,The following statement contains a magic number: if ((((IntPtr)res).ToInt64 () & 3) == 0 && smp == 0 && n > 4) {  	MemSet ((int*)res' 0' n >> 2);  	int n4 = (n >> 2) << 2;  	n -= n4;  	res += n4;  }  
Magic Number,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemSet,The following statement contains a magic number: if ((((IntPtr)res).ToInt64 () & 3) == 0 && smp == 0 && n > 4) {  	MemSet ((int*)res' 0' n >> 2);  	int n4 = (n >> 2) << 2;  	n -= n4;  	res += n4;  }  
Magic Number,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemSet,The following statement contains a magic number: if ((((IntPtr)res).ToInt64 () & 3) == 0 && smp == 0 && n > 4) {  	MemSet ((int*)res' 0' n >> 2);  	int n4 = (n >> 2) << 2;  	n -= n4;  	res += n4;  }  
Magic Number,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemSet,The following statement contains a magic number: if ((((IntPtr)res).ToInt64 () & 3) == 0 && smp == 0 && n > 4) {  	MemSet ((int*)res' 0' n >> 2);  	int n4 = (n >> 2) << 2;  	n -= n4;  	res += n4;  }  
Magic Number,CUETools.Codecs,AudioSamples,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,MemSet,The following statement contains a magic number: MemSet ((int*)res' 0' n >> 2);  
Magic Number,CUETools.Codecs,WAVReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,ParseHeaders,The following statement contains a magic number: fileEnd = (long)lenRIFF + 8;  
Magic Number,CUETools.Codecs,WAVReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,ParseHeaders,The following statement contains a magic number: do {  	uint ckID' ckSize' ckSizePadded;  	long ckEnd;  	ckID = _br.ReadUInt32 ();  	ckSize = _br.ReadUInt32 ();  	ckSizePadded = (ckSize + 1U) & ~1U;  	pos += 8;  	ckEnd = pos + (long)ckSizePadded;  	if (ckID == fccFormat) {  		foundFormat = true;  		uint fmtTag = _br.ReadUInt16 ();  		int _channelCount = _br.ReadInt16 ();  		int _sampleRate = _br.ReadInt32 ();  		_br.ReadInt32 ();  		// bytes per second  		int _blockAlign = _br.ReadInt16 ();  		int _bitsPerSample = _br.ReadInt16 ();  		pos += 16;  		if (fmtTag == 0xFFFEU && ckSize >= 34)// WAVE_FORMAT_EXTENSIBLE   		 {  			_br.ReadInt16 ();  			// CbSize  			_br.ReadInt16 ();  			// ValidBitsPerSample  			int channelMask = _br.ReadInt32 ();  			fmtTag = _br.ReadUInt16 ();  			pos += 10;  		}  		if (fmtTag != 1)  			// WAVE_FORMAT_PCM  			throw new Exception ("WAVE format tag not WAVE_FORMAT_PCM.");  		pcm = new AudioPCMConfig (_bitsPerSample' _channelCount' _sampleRate);  		if (pcm.BlockAlign != _blockAlign)  			throw new Exception ("WAVE has strange BlockAlign");  	}  	else if (ckID == fccData) {  		foundData = true;  		_dataOffset = pos;  		if (!_IO.CanSeek || _IO.Length <= maxFileSize) {  			if (ckSize >= 0x7fffffff)  				_dataLen = -1;  			else  				_dataLen = (long)ckSize;  		}  		else {  			_largeFile = true;  			_dataLen = _IO.Length - pos;  		}  	}  	if ((foundFormat & foundData) || _largeFile)  		break;  	if (_IO.CanSeek)  		_IO.Seek (ckEnd' SeekOrigin.Begin);  	else  		_br.ReadBytes ((int)(ckEnd - pos));  	pos = ckEnd;  }  while (true);  
Magic Number,CUETools.Codecs,WAVReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,ParseHeaders,The following statement contains a magic number: do {  	uint ckID' ckSize' ckSizePadded;  	long ckEnd;  	ckID = _br.ReadUInt32 ();  	ckSize = _br.ReadUInt32 ();  	ckSizePadded = (ckSize + 1U) & ~1U;  	pos += 8;  	ckEnd = pos + (long)ckSizePadded;  	if (ckID == fccFormat) {  		foundFormat = true;  		uint fmtTag = _br.ReadUInt16 ();  		int _channelCount = _br.ReadInt16 ();  		int _sampleRate = _br.ReadInt32 ();  		_br.ReadInt32 ();  		// bytes per second  		int _blockAlign = _br.ReadInt16 ();  		int _bitsPerSample = _br.ReadInt16 ();  		pos += 16;  		if (fmtTag == 0xFFFEU && ckSize >= 34)// WAVE_FORMAT_EXTENSIBLE   		 {  			_br.ReadInt16 ();  			// CbSize  			_br.ReadInt16 ();  			// ValidBitsPerSample  			int channelMask = _br.ReadInt32 ();  			fmtTag = _br.ReadUInt16 ();  			pos += 10;  		}  		if (fmtTag != 1)  			// WAVE_FORMAT_PCM  			throw new Exception ("WAVE format tag not WAVE_FORMAT_PCM.");  		pcm = new AudioPCMConfig (_bitsPerSample' _channelCount' _sampleRate);  		if (pcm.BlockAlign != _blockAlign)  			throw new Exception ("WAVE has strange BlockAlign");  	}  	else if (ckID == fccData) {  		foundData = true;  		_dataOffset = pos;  		if (!_IO.CanSeek || _IO.Length <= maxFileSize) {  			if (ckSize >= 0x7fffffff)  				_dataLen = -1;  			else  				_dataLen = (long)ckSize;  		}  		else {  			_largeFile = true;  			_dataLen = _IO.Length - pos;  		}  	}  	if ((foundFormat & foundData) || _largeFile)  		break;  	if (_IO.CanSeek)  		_IO.Seek (ckEnd' SeekOrigin.Begin);  	else  		_br.ReadBytes ((int)(ckEnd - pos));  	pos = ckEnd;  }  while (true);  
Magic Number,CUETools.Codecs,WAVReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,ParseHeaders,The following statement contains a magic number: do {  	uint ckID' ckSize' ckSizePadded;  	long ckEnd;  	ckID = _br.ReadUInt32 ();  	ckSize = _br.ReadUInt32 ();  	ckSizePadded = (ckSize + 1U) & ~1U;  	pos += 8;  	ckEnd = pos + (long)ckSizePadded;  	if (ckID == fccFormat) {  		foundFormat = true;  		uint fmtTag = _br.ReadUInt16 ();  		int _channelCount = _br.ReadInt16 ();  		int _sampleRate = _br.ReadInt32 ();  		_br.ReadInt32 ();  		// bytes per second  		int _blockAlign = _br.ReadInt16 ();  		int _bitsPerSample = _br.ReadInt16 ();  		pos += 16;  		if (fmtTag == 0xFFFEU && ckSize >= 34)// WAVE_FORMAT_EXTENSIBLE   		 {  			_br.ReadInt16 ();  			// CbSize  			_br.ReadInt16 ();  			// ValidBitsPerSample  			int channelMask = _br.ReadInt32 ();  			fmtTag = _br.ReadUInt16 ();  			pos += 10;  		}  		if (fmtTag != 1)  			// WAVE_FORMAT_PCM  			throw new Exception ("WAVE format tag not WAVE_FORMAT_PCM.");  		pcm = new AudioPCMConfig (_bitsPerSample' _channelCount' _sampleRate);  		if (pcm.BlockAlign != _blockAlign)  			throw new Exception ("WAVE has strange BlockAlign");  	}  	else if (ckID == fccData) {  		foundData = true;  		_dataOffset = pos;  		if (!_IO.CanSeek || _IO.Length <= maxFileSize) {  			if (ckSize >= 0x7fffffff)  				_dataLen = -1;  			else  				_dataLen = (long)ckSize;  		}  		else {  			_largeFile = true;  			_dataLen = _IO.Length - pos;  		}  	}  	if ((foundFormat & foundData) || _largeFile)  		break;  	if (_IO.CanSeek)  		_IO.Seek (ckEnd' SeekOrigin.Begin);  	else  		_br.ReadBytes ((int)(ckEnd - pos));  	pos = ckEnd;  }  while (true);  
Magic Number,CUETools.Codecs,WAVReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,ParseHeaders,The following statement contains a magic number: do {  	uint ckID' ckSize' ckSizePadded;  	long ckEnd;  	ckID = _br.ReadUInt32 ();  	ckSize = _br.ReadUInt32 ();  	ckSizePadded = (ckSize + 1U) & ~1U;  	pos += 8;  	ckEnd = pos + (long)ckSizePadded;  	if (ckID == fccFormat) {  		foundFormat = true;  		uint fmtTag = _br.ReadUInt16 ();  		int _channelCount = _br.ReadInt16 ();  		int _sampleRate = _br.ReadInt32 ();  		_br.ReadInt32 ();  		// bytes per second  		int _blockAlign = _br.ReadInt16 ();  		int _bitsPerSample = _br.ReadInt16 ();  		pos += 16;  		if (fmtTag == 0xFFFEU && ckSize >= 34)// WAVE_FORMAT_EXTENSIBLE   		 {  			_br.ReadInt16 ();  			// CbSize  			_br.ReadInt16 ();  			// ValidBitsPerSample  			int channelMask = _br.ReadInt32 ();  			fmtTag = _br.ReadUInt16 ();  			pos += 10;  		}  		if (fmtTag != 1)  			// WAVE_FORMAT_PCM  			throw new Exception ("WAVE format tag not WAVE_FORMAT_PCM.");  		pcm = new AudioPCMConfig (_bitsPerSample' _channelCount' _sampleRate);  		if (pcm.BlockAlign != _blockAlign)  			throw new Exception ("WAVE has strange BlockAlign");  	}  	else if (ckID == fccData) {  		foundData = true;  		_dataOffset = pos;  		if (!_IO.CanSeek || _IO.Length <= maxFileSize) {  			if (ckSize >= 0x7fffffff)  				_dataLen = -1;  			else  				_dataLen = (long)ckSize;  		}  		else {  			_largeFile = true;  			_dataLen = _IO.Length - pos;  		}  	}  	if ((foundFormat & foundData) || _largeFile)  		break;  	if (_IO.CanSeek)  		_IO.Seek (ckEnd' SeekOrigin.Begin);  	else  		_br.ReadBytes ((int)(ckEnd - pos));  	pos = ckEnd;  }  while (true);  
Magic Number,CUETools.Codecs,WAVReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,ParseHeaders,The following statement contains a magic number: pos += 8;  
Magic Number,CUETools.Codecs,WAVReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,ParseHeaders,The following statement contains a magic number: if (ckID == fccFormat) {  	foundFormat = true;  	uint fmtTag = _br.ReadUInt16 ();  	int _channelCount = _br.ReadInt16 ();  	int _sampleRate = _br.ReadInt32 ();  	_br.ReadInt32 ();  	// bytes per second  	int _blockAlign = _br.ReadInt16 ();  	int _bitsPerSample = _br.ReadInt16 ();  	pos += 16;  	if (fmtTag == 0xFFFEU && ckSize >= 34)// WAVE_FORMAT_EXTENSIBLE   	 {  		_br.ReadInt16 ();  		// CbSize  		_br.ReadInt16 ();  		// ValidBitsPerSample  		int channelMask = _br.ReadInt32 ();  		fmtTag = _br.ReadUInt16 ();  		pos += 10;  	}  	if (fmtTag != 1)  		// WAVE_FORMAT_PCM  		throw new Exception ("WAVE format tag not WAVE_FORMAT_PCM.");  	pcm = new AudioPCMConfig (_bitsPerSample' _channelCount' _sampleRate);  	if (pcm.BlockAlign != _blockAlign)  		throw new Exception ("WAVE has strange BlockAlign");  }  else if (ckID == fccData) {  	foundData = true;  	_dataOffset = pos;  	if (!_IO.CanSeek || _IO.Length <= maxFileSize) {  		if (ckSize >= 0x7fffffff)  			_dataLen = -1;  		else  			_dataLen = (long)ckSize;  	}  	else {  		_largeFile = true;  		_dataLen = _IO.Length - pos;  	}  }  
Magic Number,CUETools.Codecs,WAVReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,ParseHeaders,The following statement contains a magic number: if (ckID == fccFormat) {  	foundFormat = true;  	uint fmtTag = _br.ReadUInt16 ();  	int _channelCount = _br.ReadInt16 ();  	int _sampleRate = _br.ReadInt32 ();  	_br.ReadInt32 ();  	// bytes per second  	int _blockAlign = _br.ReadInt16 ();  	int _bitsPerSample = _br.ReadInt16 ();  	pos += 16;  	if (fmtTag == 0xFFFEU && ckSize >= 34)// WAVE_FORMAT_EXTENSIBLE   	 {  		_br.ReadInt16 ();  		// CbSize  		_br.ReadInt16 ();  		// ValidBitsPerSample  		int channelMask = _br.ReadInt32 ();  		fmtTag = _br.ReadUInt16 ();  		pos += 10;  	}  	if (fmtTag != 1)  		// WAVE_FORMAT_PCM  		throw new Exception ("WAVE format tag not WAVE_FORMAT_PCM.");  	pcm = new AudioPCMConfig (_bitsPerSample' _channelCount' _sampleRate);  	if (pcm.BlockAlign != _blockAlign)  		throw new Exception ("WAVE has strange BlockAlign");  }  else if (ckID == fccData) {  	foundData = true;  	_dataOffset = pos;  	if (!_IO.CanSeek || _IO.Length <= maxFileSize) {  		if (ckSize >= 0x7fffffff)  			_dataLen = -1;  		else  			_dataLen = (long)ckSize;  	}  	else {  		_largeFile = true;  		_dataLen = _IO.Length - pos;  	}  }  
Magic Number,CUETools.Codecs,WAVReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,ParseHeaders,The following statement contains a magic number: if (ckID == fccFormat) {  	foundFormat = true;  	uint fmtTag = _br.ReadUInt16 ();  	int _channelCount = _br.ReadInt16 ();  	int _sampleRate = _br.ReadInt32 ();  	_br.ReadInt32 ();  	// bytes per second  	int _blockAlign = _br.ReadInt16 ();  	int _bitsPerSample = _br.ReadInt16 ();  	pos += 16;  	if (fmtTag == 0xFFFEU && ckSize >= 34)// WAVE_FORMAT_EXTENSIBLE   	 {  		_br.ReadInt16 ();  		// CbSize  		_br.ReadInt16 ();  		// ValidBitsPerSample  		int channelMask = _br.ReadInt32 ();  		fmtTag = _br.ReadUInt16 ();  		pos += 10;  	}  	if (fmtTag != 1)  		// WAVE_FORMAT_PCM  		throw new Exception ("WAVE format tag not WAVE_FORMAT_PCM.");  	pcm = new AudioPCMConfig (_bitsPerSample' _channelCount' _sampleRate);  	if (pcm.BlockAlign != _blockAlign)  		throw new Exception ("WAVE has strange BlockAlign");  }  else if (ckID == fccData) {  	foundData = true;  	_dataOffset = pos;  	if (!_IO.CanSeek || _IO.Length <= maxFileSize) {  		if (ckSize >= 0x7fffffff)  			_dataLen = -1;  		else  			_dataLen = (long)ckSize;  	}  	else {  		_largeFile = true;  		_dataLen = _IO.Length - pos;  	}  }  
Magic Number,CUETools.Codecs,WAVReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,ParseHeaders,The following statement contains a magic number: pos += 16;  
Magic Number,CUETools.Codecs,WAVReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,ParseHeaders,The following statement contains a magic number: if (fmtTag == 0xFFFEU && ckSize >= 34)// WAVE_FORMAT_EXTENSIBLE    {  	_br.ReadInt16 ();  	// CbSize  	_br.ReadInt16 ();  	// ValidBitsPerSample  	int channelMask = _br.ReadInt32 ();  	fmtTag = _br.ReadUInt16 ();  	pos += 10;  }  
Magic Number,CUETools.Codecs,WAVReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,ParseHeaders,The following statement contains a magic number: if (fmtTag == 0xFFFEU && ckSize >= 34)// WAVE_FORMAT_EXTENSIBLE    {  	_br.ReadInt16 ();  	// CbSize  	_br.ReadInt16 ();  	// ValidBitsPerSample  	int channelMask = _br.ReadInt32 ();  	fmtTag = _br.ReadUInt16 ();  	pos += 10;  }  
Magic Number,CUETools.Codecs,WAVReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,ParseHeaders,The following statement contains a magic number: pos += 10;  
Magic Number,CUETools.Codecs,WAVReader,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,ParseHeaders,The following statement contains a magic number: if ((pcm.BitsPerSample <= 0) || (pcm.BitsPerSample > 32))  	throw new Exception ("Bits per sample is invalid.");  
Magic Number,CUETools.Codecs,WAVWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,WriteChunk,The following statement contains a magic number: hdrLen += 8 + data.Length + (data.Length & 1);  
Magic Number,CUETools.Codecs,WAVWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,WriteHeaders,The following statement contains a magic number: hdrLen += 36 + (wavex ? 24 : 0) + 8;  
Magic Number,CUETools.Codecs,WAVWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,WriteHeaders,The following statement contains a magic number: hdrLen += 36 + (wavex ? 24 : 0) + 8;  
Magic Number,CUETools.Codecs,WAVWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,WriteHeaders,The following statement contains a magic number: hdrLen += 36 + (wavex ? 24 : 0) + 8;  
Magic Number,CUETools.Codecs,WAVWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,WriteHeaders,The following statement contains a magic number: _bw.Write ((uint)(dataLenPadded + hdrLen - 8));  
Magic Number,CUETools.Codecs,WAVWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,WriteHeaders,The following statement contains a magic number: if (wavex) {  	_bw.Write ((uint)40);  	_bw.Write ((ushort)0xfffe);  	// WAVEX follows  }  else {  	_bw.Write ((uint)16);  	_bw.Write ((ushort)1);  	// PCM  }  
Magic Number,CUETools.Codecs,WAVWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,WriteHeaders,The following statement contains a magic number: if (wavex) {  	_bw.Write ((uint)40);  	_bw.Write ((ushort)0xfffe);  	// WAVEX follows  }  else {  	_bw.Write ((uint)16);  	_bw.Write ((ushort)1);  	// PCM  }  
Magic Number,CUETools.Codecs,WAVWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,WriteHeaders,The following statement contains a magic number: _bw.Write ((uint)40);  
Magic Number,CUETools.Codecs,WAVWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,WriteHeaders,The following statement contains a magic number: _bw.Write ((uint)16);  
Magic Number,CUETools.Codecs,WAVWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,WriteHeaders,The following statement contains a magic number: _bw.Write ((ushort)((_pcm.BitsPerSample + 7) / 8 * 8));  
Magic Number,CUETools.Codecs,WAVWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,WriteHeaders,The following statement contains a magic number: _bw.Write ((ushort)((_pcm.BitsPerSample + 7) / 8 * 8));  
Magic Number,CUETools.Codecs,WAVWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,WriteHeaders,The following statement contains a magic number: _bw.Write ((ushort)((_pcm.BitsPerSample + 7) / 8 * 8));  
Magic Number,CUETools.Codecs,WAVWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,WriteHeaders,The following statement contains a magic number: if (wavex) {  	_bw.Write ((ushort)22);  	// length of WAVEX structure  	_bw.Write ((ushort)_pcm.BitsPerSample);  	_bw.Write ((uint)3);  	// speaker positions (3 == stereo)  	_bw.Write ((ushort)1);  	// PCM  	_bw.Write ((ushort)0);  	_bw.Write ((ushort)0);  	_bw.Write ((ushort)0x10);  	_bw.Write ((byte)0x80);  	_bw.Write ((byte)0x00);  	_bw.Write ((byte)0x00);  	_bw.Write ((byte)0xaa);  	_bw.Write ((byte)0x00);  	_bw.Write ((byte)0x38);  	_bw.Write ((byte)0x9b);  	_bw.Write ((byte)0x71);  }  
Magic Number,CUETools.Codecs,WAVWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,WriteHeaders,The following statement contains a magic number: if (wavex) {  	_bw.Write ((ushort)22);  	// length of WAVEX structure  	_bw.Write ((ushort)_pcm.BitsPerSample);  	_bw.Write ((uint)3);  	// speaker positions (3 == stereo)  	_bw.Write ((ushort)1);  	// PCM  	_bw.Write ((ushort)0);  	_bw.Write ((ushort)0);  	_bw.Write ((ushort)0x10);  	_bw.Write ((byte)0x80);  	_bw.Write ((byte)0x00);  	_bw.Write ((byte)0x00);  	_bw.Write ((byte)0xaa);  	_bw.Write ((byte)0x00);  	_bw.Write ((byte)0x38);  	_bw.Write ((byte)0x9b);  	_bw.Write ((byte)0x71);  }  
Magic Number,CUETools.Codecs,WAVWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,WriteHeaders,The following statement contains a magic number: _bw.Write ((ushort)22);  
Magic Number,CUETools.Codecs,WAVWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,WriteHeaders,The following statement contains a magic number: _bw.Write ((uint)3);  
Magic Number,CUETools.Codecs,WAVWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Close,The following statement contains a magic number: if (_finalSampleCount <= 0) {  	const long maxFileSize = 0x7FFFFFFEL;  	long dataLen = _sampleLen * _pcm.BlockAlign;  	if ((dataLen & 1) == 1)  		_bw.Write ((byte)0);  	if (dataLen + hdrLen > maxFileSize)  		dataLen = ((maxFileSize - hdrLen) / _pcm.BlockAlign) * _pcm.BlockAlign;  	long dataLenPadded = dataLen + (dataLen & 1);  	_bw.Seek (4' SeekOrigin.Begin);  	_bw.Write ((uint)(dataLenPadded + hdrLen - 8));  	_bw.Seek ((int)hdrLen - 4' SeekOrigin.Begin);  	_bw.Write ((uint)dataLen);  }  
Magic Number,CUETools.Codecs,WAVWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Close,The following statement contains a magic number: if (_finalSampleCount <= 0) {  	const long maxFileSize = 0x7FFFFFFEL;  	long dataLen = _sampleLen * _pcm.BlockAlign;  	if ((dataLen & 1) == 1)  		_bw.Write ((byte)0);  	if (dataLen + hdrLen > maxFileSize)  		dataLen = ((maxFileSize - hdrLen) / _pcm.BlockAlign) * _pcm.BlockAlign;  	long dataLenPadded = dataLen + (dataLen & 1);  	_bw.Seek (4' SeekOrigin.Begin);  	_bw.Write ((uint)(dataLenPadded + hdrLen - 8));  	_bw.Seek ((int)hdrLen - 4' SeekOrigin.Begin);  	_bw.Write ((uint)dataLen);  }  
Magic Number,CUETools.Codecs,WAVWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Close,The following statement contains a magic number: if (_finalSampleCount <= 0) {  	const long maxFileSize = 0x7FFFFFFEL;  	long dataLen = _sampleLen * _pcm.BlockAlign;  	if ((dataLen & 1) == 1)  		_bw.Write ((byte)0);  	if (dataLen + hdrLen > maxFileSize)  		dataLen = ((maxFileSize - hdrLen) / _pcm.BlockAlign) * _pcm.BlockAlign;  	long dataLenPadded = dataLen + (dataLen & 1);  	_bw.Seek (4' SeekOrigin.Begin);  	_bw.Write ((uint)(dataLenPadded + hdrLen - 8));  	_bw.Seek ((int)hdrLen - 4' SeekOrigin.Begin);  	_bw.Write ((uint)dataLen);  }  
Magic Number,CUETools.Codecs,WAVWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Close,The following statement contains a magic number: _bw.Seek (4' SeekOrigin.Begin);  
Magic Number,CUETools.Codecs,WAVWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Close,The following statement contains a magic number: _bw.Write ((uint)(dataLenPadded + hdrLen - 8));  
Magic Number,CUETools.Codecs,WAVWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,Close,The following statement contains a magic number: _bw.Seek ((int)hdrLen - 4' SeekOrigin.Begin);  
Magic Number,CUETools.Codecs,UserDefinedWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,UserDefinedWriter,The following statement contains a magic number: if (_encoderProcess.StartInfo.RedirectStandardOutput) {  	Stream outputStream = new FileStream (path' FileMode.Create' FileAccess.Write' FileShare.Read);  	outputBuffer = new CyclicBuffer (2 * 1024 * 1024' _encoderProcess.StandardOutput.BaseStream' outputStream);  }  
Magic Number,CUETools.Codecs,UserDefinedWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,UserDefinedWriter,The following statement contains a magic number: if (_encoderProcess.StartInfo.RedirectStandardOutput) {  	Stream outputStream = new FileStream (path' FileMode.Create' FileAccess.Write' FileShare.Read);  	outputBuffer = new CyclicBuffer (2 * 1024 * 1024' _encoderProcess.StandardOutput.BaseStream' outputStream);  }  
Magic Number,CUETools.Codecs,UserDefinedWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,UserDefinedWriter,The following statement contains a magic number: if (_encoderProcess.StartInfo.RedirectStandardOutput) {  	Stream outputStream = new FileStream (path' FileMode.Create' FileAccess.Write' FileShare.Read);  	outputBuffer = new CyclicBuffer (2 * 1024 * 1024' _encoderProcess.StandardOutput.BaseStream' outputStream);  }  
Magic Number,CUETools.Codecs,UserDefinedWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,UserDefinedWriter,The following statement contains a magic number: outputBuffer = new CyclicBuffer (2 * 1024 * 1024' _encoderProcess.StandardOutput.BaseStream' outputStream);  
Magic Number,CUETools.Codecs,UserDefinedWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,UserDefinedWriter,The following statement contains a magic number: outputBuffer = new CyclicBuffer (2 * 1024 * 1024' _encoderProcess.StandardOutput.BaseStream' outputStream);  
Magic Number,CUETools.Codecs,UserDefinedWriter,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\Codecs.cs,UserDefinedWriter,The following statement contains a magic number: outputBuffer = new CyclicBuffer (2 * 1024 * 1024' _encoderProcess.StandardOutput.BaseStream' outputStream);  
Magic Number,CUETools.Codecs,Crc16,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC16.cs,ComputeChecksum,The following statement contains a magic number: fixed (ushort* t = table)  	for (int i = count; i > 0; i--)  		crc = (ushort)((crc << 8) ^ t [(crc >> 8) ^ *(bytes++)]);  
Magic Number,CUETools.Codecs,Crc16,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC16.cs,ComputeChecksum,The following statement contains a magic number: fixed (ushort* t = table)  	for (int i = count; i > 0; i--)  		crc = (ushort)((crc << 8) ^ t [(crc >> 8) ^ *(bytes++)]);  
Magic Number,CUETools.Codecs,Crc16,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC16.cs,ComputeChecksum,The following statement contains a magic number: for (int i = count; i > 0; i--)  	crc = (ushort)((crc << 8) ^ t [(crc >> 8) ^ *(bytes++)]);  
Magic Number,CUETools.Codecs,Crc16,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC16.cs,ComputeChecksum,The following statement contains a magic number: for (int i = count; i > 0; i--)  	crc = (ushort)((crc << 8) ^ t [(crc >> 8) ^ *(bytes++)]);  
Magic Number,CUETools.Codecs,Crc16,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC16.cs,ComputeChecksum,The following statement contains a magic number: crc = (ushort)((crc << 8) ^ t [(crc >> 8) ^ *(bytes++)]);  
Magic Number,CUETools.Codecs,Crc16,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC16.cs,ComputeChecksum,The following statement contains a magic number: crc = (ushort)((crc << 8) ^ t [(crc >> 8) ^ *(bytes++)]);  
Magic Number,CUETools.Codecs,Crc16Ccitt,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC16CCITT.cs,ComputeChecksum,The following statement contains a magic number: for (int i = pos; i < pos + count; i++) {  	crc = (ushort)((crc << 8) ^ table [((crc >> 8) ^ (0xff & bytes [i]))]);  }  
Magic Number,CUETools.Codecs,Crc16Ccitt,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC16CCITT.cs,ComputeChecksum,The following statement contains a magic number: for (int i = pos; i < pos + count; i++) {  	crc = (ushort)((crc << 8) ^ table [((crc >> 8) ^ (0xff & bytes [i]))]);  }  
Magic Number,CUETools.Codecs,Crc16Ccitt,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC16CCITT.cs,ComputeChecksum,The following statement contains a magic number: crc = (ushort)((crc << 8) ^ table [((crc >> 8) ^ (0xff & bytes [i]))]);  
Magic Number,CUETools.Codecs,Crc16Ccitt,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC16CCITT.cs,ComputeChecksum,The following statement contains a magic number: crc = (ushort)((crc << 8) ^ table [((crc >> 8) ^ (0xff & bytes [i]))]);  
Magic Number,CUETools.Codecs,Crc16Ccitt,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC16CCITT.cs,ComputeChecksumBytes,The following statement contains a magic number: return new byte[] {  	(byte)(crc >> 8)'  	(byte)(crc & 0x00ff)  };  
Magic Number,CUETools.Codecs,Crc16Ccitt,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC16CCITT.cs,Crc16Ccitt,The following statement contains a magic number: for (int i = 0; i < table.Length; i++) {  	temp = 0;  	a = (ushort)(i << 8);  	for (int j = 0; j < 8; j++) {  		if (((temp ^ a) & 0x8000) != 0) {  			temp = (ushort)((temp << 1) ^ poly);  		}  		else {  			temp <<= 1;  		}  		a <<= 1;  	}  	table [i] = temp;  }  
Magic Number,CUETools.Codecs,Crc16Ccitt,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC16CCITT.cs,Crc16Ccitt,The following statement contains a magic number: for (int i = 0; i < table.Length; i++) {  	temp = 0;  	a = (ushort)(i << 8);  	for (int j = 0; j < 8; j++) {  		if (((temp ^ a) & 0x8000) != 0) {  			temp = (ushort)((temp << 1) ^ poly);  		}  		else {  			temp <<= 1;  		}  		a <<= 1;  	}  	table [i] = temp;  }  
Magic Number,CUETools.Codecs,Crc16Ccitt,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC16CCITT.cs,Crc16Ccitt,The following statement contains a magic number: a = (ushort)(i << 8);  
Magic Number,CUETools.Codecs,Crc16Ccitt,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC16CCITT.cs,Crc16Ccitt,The following statement contains a magic number: for (int j = 0; j < 8; j++) {  	if (((temp ^ a) & 0x8000) != 0) {  		temp = (ushort)((temp << 1) ^ poly);  	}  	else {  		temp <<= 1;  	}  	a <<= 1;  }  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,ComputeChecksum,The following statement contains a magic number: return (crc >> 8) ^ table [(crc & 0xff) ^ val];  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,ComputeChecksum,The following statement contains a magic number: fixed (uint* t = table)  	for (int i = 0; i < count; i++)  		crc = (crc >> 8) ^ t [(crc ^ bytes [i]) & 0xff];  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,ComputeChecksum,The following statement contains a magic number: for (int i = 0; i < count; i++)  	crc = (crc >> 8) ^ t [(crc ^ bytes [i]) & 0xff];  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,ComputeChecksum,The following statement contains a magic number: crc = (crc >> 8) ^ t [(crc ^ bytes [i]) & 0xff];  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,ComputeChecksum,The following statement contains a magic number: return ComputeChecksum (ComputeChecksum (ComputeChecksum (ComputeChecksum (crc' (byte)s)' (byte)(s >> 8))' (byte)(s >> 16))' (byte)(s >> 24));  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,ComputeChecksum,The following statement contains a magic number: return ComputeChecksum (ComputeChecksum (ComputeChecksum (ComputeChecksum (crc' (byte)s)' (byte)(s >> 8))' (byte)(s >> 16))' (byte)(s >> 24));  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,ComputeChecksum,The following statement contains a magic number: return ComputeChecksum (ComputeChecksum (ComputeChecksum (ComputeChecksum (crc' (byte)s)' (byte)(s >> 8))' (byte)(s >> 16))' (byte)(s >> 24));  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,ComputeChecksum,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	int s1 = samples [2 * i]' s2 = samples [2 * i + 1];  	crc = ComputeChecksum (ComputeChecksum (ComputeChecksum (ComputeChecksum (crc' (byte)s1)' (byte)(s1 >> 8))' (byte)s2)' (byte)(s2 >> 8));  }  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,ComputeChecksum,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	int s1 = samples [2 * i]' s2 = samples [2 * i + 1];  	crc = ComputeChecksum (ComputeChecksum (ComputeChecksum (ComputeChecksum (crc' (byte)s1)' (byte)(s1 >> 8))' (byte)s2)' (byte)(s2 >> 8));  }  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,ComputeChecksum,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	int s1 = samples [2 * i]' s2 = samples [2 * i + 1];  	crc = ComputeChecksum (ComputeChecksum (ComputeChecksum (ComputeChecksum (crc' (byte)s1)' (byte)(s1 >> 8))' (byte)s2)' (byte)(s2 >> 8));  }  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,ComputeChecksum,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	int s1 = samples [2 * i]' s2 = samples [2 * i + 1];  	crc = ComputeChecksum (ComputeChecksum (ComputeChecksum (ComputeChecksum (crc' (byte)s1)' (byte)(s1 >> 8))' (byte)s2)' (byte)(s2 >> 8));  }  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,ComputeChecksum,The following statement contains a magic number: crc = ComputeChecksum (ComputeChecksum (ComputeChecksum (ComputeChecksum (crc' (byte)s1)' (byte)(s1 >> 8))' (byte)s2)' (byte)(s2 >> 8));  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,ComputeChecksum,The following statement contains a magic number: crc = ComputeChecksum (ComputeChecksum (ComputeChecksum (ComputeChecksum (crc' (byte)s1)' (byte)(s1 >> 8))' (byte)s2)' (byte)(s2 >> 8));  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Crc32,The following statement contains a magic number: table = new uint[256];  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Crc32,The following statement contains a magic number: for (uint i = 0; i < table.Length; i++) {  	table [i] = Reflect (i' 8) << 24;  	for (int j = 0; j < 8; j++)  		table [i] = (table [i] << 1) ^ ((table [i] & (1U << 31)) == 0 ? 0 : ulPolynomial);  	table [i] = Reflect (table [i]' 32);  }  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Crc32,The following statement contains a magic number: for (uint i = 0; i < table.Length; i++) {  	table [i] = Reflect (i' 8) << 24;  	for (int j = 0; j < 8; j++)  		table [i] = (table [i] << 1) ^ ((table [i] & (1U << 31)) == 0 ? 0 : ulPolynomial);  	table [i] = Reflect (table [i]' 32);  }  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Crc32,The following statement contains a magic number: for (uint i = 0; i < table.Length; i++) {  	table [i] = Reflect (i' 8) << 24;  	for (int j = 0; j < 8; j++)  		table [i] = (table [i] << 1) ^ ((table [i] & (1U << 31)) == 0 ? 0 : ulPolynomial);  	table [i] = Reflect (table [i]' 32);  }  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Crc32,The following statement contains a magic number: for (uint i = 0; i < table.Length; i++) {  	table [i] = Reflect (i' 8) << 24;  	for (int j = 0; j < 8; j++)  		table [i] = (table [i] << 1) ^ ((table [i] & (1U << 31)) == 0 ? 0 : ulPolynomial);  	table [i] = Reflect (table [i]' 32);  }  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Crc32,The following statement contains a magic number: for (uint i = 0; i < table.Length; i++) {  	table [i] = Reflect (i' 8) << 24;  	for (int j = 0; j < 8; j++)  		table [i] = (table [i] << 1) ^ ((table [i] & (1U << 31)) == 0 ? 0 : ulPolynomial);  	table [i] = Reflect (table [i]' 32);  }  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Crc32,The following statement contains a magic number: table [i] = Reflect (i' 8) << 24;  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Crc32,The following statement contains a magic number: table [i] = Reflect (i' 8) << 24;  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Crc32,The following statement contains a magic number: for (int j = 0; j < 8; j++)  	table [i] = (table [i] << 1) ^ ((table [i] & (1U << 31)) == 0 ? 0 : ulPolynomial);  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Crc32,The following statement contains a magic number: for (int j = 0; j < 8; j++)  	table [i] = (table [i] << 1) ^ ((table [i] & (1U << 31)) == 0 ? 0 : ulPolynomial);  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Crc32,The following statement contains a magic number: table [i] = (table [i] << 1) ^ ((table [i] & (1U << 31)) == 0 ? 0 : ulPolynomial);  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Crc32,The following statement contains a magic number: table [i] = Reflect (table [i]' 32);  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Crc32,The following statement contains a magic number: substractTable [0' 31] = 0xdb710641;  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Crc32,The following statement contains a magic number: fixed (uint* ct = &combineTable [0' 0]' st = &substractTable [0' 0]) {  	//for (int i = 0; i < GF2_DIM; i++)  	//	st[32 + i] = ct[i];  	//invert_binary_matrix(st + 32' st' GF2_DIM);  	for (int i = 1; i < GF2_DIM; i++) {  		gf2_matrix_square (ct + i * 32' ct + (i - 1) * 32);  		gf2_matrix_square (st + i * 32' st + (i - 1) * 32);  	}  }  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Crc32,The following statement contains a magic number: fixed (uint* ct = &combineTable [0' 0]' st = &substractTable [0' 0]) {  	//for (int i = 0; i < GF2_DIM; i++)  	//	st[32 + i] = ct[i];  	//invert_binary_matrix(st + 32' st' GF2_DIM);  	for (int i = 1; i < GF2_DIM; i++) {  		gf2_matrix_square (ct + i * 32' ct + (i - 1) * 32);  		gf2_matrix_square (st + i * 32' st + (i - 1) * 32);  	}  }  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Crc32,The following statement contains a magic number: fixed (uint* ct = &combineTable [0' 0]' st = &substractTable [0' 0]) {  	//for (int i = 0; i < GF2_DIM; i++)  	//	st[32 + i] = ct[i];  	//invert_binary_matrix(st + 32' st' GF2_DIM);  	for (int i = 1; i < GF2_DIM; i++) {  		gf2_matrix_square (ct + i * 32' ct + (i - 1) * 32);  		gf2_matrix_square (st + i * 32' st + (i - 1) * 32);  	}  }  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Crc32,The following statement contains a magic number: fixed (uint* ct = &combineTable [0' 0]' st = &substractTable [0' 0]) {  	//for (int i = 0; i < GF2_DIM; i++)  	//	st[32 + i] = ct[i];  	//invert_binary_matrix(st + 32' st' GF2_DIM);  	for (int i = 1; i < GF2_DIM; i++) {  		gf2_matrix_square (ct + i * 32' ct + (i - 1) * 32);  		gf2_matrix_square (st + i * 32' st + (i - 1) * 32);  	}  }  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Crc32,The following statement contains a magic number: for (int i = 1; i < GF2_DIM; i++) {  	gf2_matrix_square (ct + i * 32' ct + (i - 1) * 32);  	gf2_matrix_square (st + i * 32' st + (i - 1) * 32);  }  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Crc32,The following statement contains a magic number: for (int i = 1; i < GF2_DIM; i++) {  	gf2_matrix_square (ct + i * 32' ct + (i - 1) * 32);  	gf2_matrix_square (st + i * 32' st + (i - 1) * 32);  }  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Crc32,The following statement contains a magic number: for (int i = 1; i < GF2_DIM; i++) {  	gf2_matrix_square (ct + i * 32' ct + (i - 1) * 32);  	gf2_matrix_square (st + i * 32' st + (i - 1) * 32);  }  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Crc32,The following statement contains a magic number: for (int i = 1; i < GF2_DIM; i++) {  	gf2_matrix_square (ct + i * 32' ct + (i - 1) * 32);  	gf2_matrix_square (st + i * 32' st + (i - 1) * 32);  }  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Crc32,The following statement contains a magic number: gf2_matrix_square (ct + i * 32' ct + (i - 1) * 32);  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Crc32,The following statement contains a magic number: gf2_matrix_square (ct + i * 32' ct + (i - 1) * 32);  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Crc32,The following statement contains a magic number: gf2_matrix_square (st + i * 32' st + (i - 1) * 32);  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Crc32,The following statement contains a magic number: gf2_matrix_square (st + i * 32' st + (i - 1) * 32);  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Combine,The following statement contains a magic number: fixed (uint* ct = &combineTable [0' 0]) {  	int n = 3;  	do {  		/* apply zeros operator for this bit of len2 */if ((len2 & 1) != 0)  			crc1 = gf2_matrix_times (ct + 32 * n' crc1);  		len2 >>= 1;  		n = (n + 1) & (GF2_DIM - 1);  		/* if no more bits set' then done */}  	while (len2 != 0);  }  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Combine,The following statement contains a magic number: fixed (uint* ct = &combineTable [0' 0]) {  	int n = 3;  	do {  		/* apply zeros operator for this bit of len2 */if ((len2 & 1) != 0)  			crc1 = gf2_matrix_times (ct + 32 * n' crc1);  		len2 >>= 1;  		n = (n + 1) & (GF2_DIM - 1);  		/* if no more bits set' then done */}  	while (len2 != 0);  }  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Combine,The following statement contains a magic number: do {  	/* apply zeros operator for this bit of len2 */if ((len2 & 1) != 0)  		crc1 = gf2_matrix_times (ct + 32 * n' crc1);  	len2 >>= 1;  	n = (n + 1) & (GF2_DIM - 1);  	/* if no more bits set' then done */}  while (len2 != 0);  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Combine,The following statement contains a magic number: if ((len2 & 1) != 0)  	crc1 = gf2_matrix_times (ct + 32 * n' crc1);  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Combine,The following statement contains a magic number: crc1 = gf2_matrix_times (ct + 32 * n' crc1);  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Substract,The following statement contains a magic number: fixed (uint* st = &substractTable [0' 0]) {  	int n = 3;  	do {  		/* apply zeros operator for this bit of len2 */if ((len2 & 1) != 0)  			crc1 = gf2_matrix_times (st + 32 * n' crc1);  		len2 >>= 1;  		n = (n + 1) & (GF2_DIM - 1);  		/* if no more bits set' then done */}  	while (len2 != 0);  }  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Substract,The following statement contains a magic number: fixed (uint* st = &substractTable [0' 0]) {  	int n = 3;  	do {  		/* apply zeros operator for this bit of len2 */if ((len2 & 1) != 0)  			crc1 = gf2_matrix_times (st + 32 * n' crc1);  		len2 >>= 1;  		n = (n + 1) & (GF2_DIM - 1);  		/* if no more bits set' then done */}  	while (len2 != 0);  }  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Substract,The following statement contains a magic number: do {  	/* apply zeros operator for this bit of len2 */if ((len2 & 1) != 0)  		crc1 = gf2_matrix_times (st + 32 * n' crc1);  	len2 >>= 1;  	n = (n + 1) & (GF2_DIM - 1);  	/* if no more bits set' then done */}  while (len2 != 0);  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Substract,The following statement contains a magic number: if ((len2 & 1) != 0)  	crc1 = gf2_matrix_times (st + 32 * n' crc1);  
Magic Number,CUETools.Codecs,Crc32,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\CRCs\CRC32.cs,Substract,The following statement contains a magic number: crc1 = gf2_matrix_times (st + 32 * n' crc1);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_flattop,The following statement contains a magic number: for (int n = 0; n < L; n++)  	window [n] = (float)(1.0 - 1.93 * Math.Cos (2.0 * Math.PI * n / N) + 1.29 * Math.Cos (4.0 * Math.PI * n / N) - 0.388 * Math.Cos (6.0 * Math.PI * n / N) + 0.0322 * Math.Cos (8.0 * Math.PI * n / N));  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_flattop,The following statement contains a magic number: for (int n = 0; n < L; n++)  	window [n] = (float)(1.0 - 1.93 * Math.Cos (2.0 * Math.PI * n / N) + 1.29 * Math.Cos (4.0 * Math.PI * n / N) - 0.388 * Math.Cos (6.0 * Math.PI * n / N) + 0.0322 * Math.Cos (8.0 * Math.PI * n / N));  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_flattop,The following statement contains a magic number: for (int n = 0; n < L; n++)  	window [n] = (float)(1.0 - 1.93 * Math.Cos (2.0 * Math.PI * n / N) + 1.29 * Math.Cos (4.0 * Math.PI * n / N) - 0.388 * Math.Cos (6.0 * Math.PI * n / N) + 0.0322 * Math.Cos (8.0 * Math.PI * n / N));  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_flattop,The following statement contains a magic number: for (int n = 0; n < L; n++)  	window [n] = (float)(1.0 - 1.93 * Math.Cos (2.0 * Math.PI * n / N) + 1.29 * Math.Cos (4.0 * Math.PI * n / N) - 0.388 * Math.Cos (6.0 * Math.PI * n / N) + 0.0322 * Math.Cos (8.0 * Math.PI * n / N));  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_flattop,The following statement contains a magic number: for (int n = 0; n < L; n++)  	window [n] = (float)(1.0 - 1.93 * Math.Cos (2.0 * Math.PI * n / N) + 1.29 * Math.Cos (4.0 * Math.PI * n / N) - 0.388 * Math.Cos (6.0 * Math.PI * n / N) + 0.0322 * Math.Cos (8.0 * Math.PI * n / N));  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_flattop,The following statement contains a magic number: for (int n = 0; n < L; n++)  	window [n] = (float)(1.0 - 1.93 * Math.Cos (2.0 * Math.PI * n / N) + 1.29 * Math.Cos (4.0 * Math.PI * n / N) - 0.388 * Math.Cos (6.0 * Math.PI * n / N) + 0.0322 * Math.Cos (8.0 * Math.PI * n / N));  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_flattop,The following statement contains a magic number: for (int n = 0; n < L; n++)  	window [n] = (float)(1.0 - 1.93 * Math.Cos (2.0 * Math.PI * n / N) + 1.29 * Math.Cos (4.0 * Math.PI * n / N) - 0.388 * Math.Cos (6.0 * Math.PI * n / N) + 0.0322 * Math.Cos (8.0 * Math.PI * n / N));  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_flattop,The following statement contains a magic number: for (int n = 0; n < L; n++)  	window [n] = (float)(1.0 - 1.93 * Math.Cos (2.0 * Math.PI * n / N) + 1.29 * Math.Cos (4.0 * Math.PI * n / N) - 0.388 * Math.Cos (6.0 * Math.PI * n / N) + 0.0322 * Math.Cos (8.0 * Math.PI * n / N));  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_flattop,The following statement contains a magic number: window [n] = (float)(1.0 - 1.93 * Math.Cos (2.0 * Math.PI * n / N) + 1.29 * Math.Cos (4.0 * Math.PI * n / N) - 0.388 * Math.Cos (6.0 * Math.PI * n / N) + 0.0322 * Math.Cos (8.0 * Math.PI * n / N));  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_flattop,The following statement contains a magic number: window [n] = (float)(1.0 - 1.93 * Math.Cos (2.0 * Math.PI * n / N) + 1.29 * Math.Cos (4.0 * Math.PI * n / N) - 0.388 * Math.Cos (6.0 * Math.PI * n / N) + 0.0322 * Math.Cos (8.0 * Math.PI * n / N));  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_flattop,The following statement contains a magic number: window [n] = (float)(1.0 - 1.93 * Math.Cos (2.0 * Math.PI * n / N) + 1.29 * Math.Cos (4.0 * Math.PI * n / N) - 0.388 * Math.Cos (6.0 * Math.PI * n / N) + 0.0322 * Math.Cos (8.0 * Math.PI * n / N));  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_flattop,The following statement contains a magic number: window [n] = (float)(1.0 - 1.93 * Math.Cos (2.0 * Math.PI * n / N) + 1.29 * Math.Cos (4.0 * Math.PI * n / N) - 0.388 * Math.Cos (6.0 * Math.PI * n / N) + 0.0322 * Math.Cos (8.0 * Math.PI * n / N));  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_flattop,The following statement contains a magic number: window [n] = (float)(1.0 - 1.93 * Math.Cos (2.0 * Math.PI * n / N) + 1.29 * Math.Cos (4.0 * Math.PI * n / N) - 0.388 * Math.Cos (6.0 * Math.PI * n / N) + 0.0322 * Math.Cos (8.0 * Math.PI * n / N));  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_flattop,The following statement contains a magic number: window [n] = (float)(1.0 - 1.93 * Math.Cos (2.0 * Math.PI * n / N) + 1.29 * Math.Cos (4.0 * Math.PI * n / N) - 0.388 * Math.Cos (6.0 * Math.PI * n / N) + 0.0322 * Math.Cos (8.0 * Math.PI * n / N));  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_flattop,The following statement contains a magic number: window [n] = (float)(1.0 - 1.93 * Math.Cos (2.0 * Math.PI * n / N) + 1.29 * Math.Cos (4.0 * Math.PI * n / N) - 0.388 * Math.Cos (6.0 * Math.PI * n / N) + 0.0322 * Math.Cos (8.0 * Math.PI * n / N));  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_flattop,The following statement contains a magic number: window [n] = (float)(1.0 - 1.93 * Math.Cos (2.0 * Math.PI * n / N) + 1.29 * Math.Cos (4.0 * Math.PI * n / N) - 0.388 * Math.Cos (6.0 * Math.PI * n / N) + 0.0322 * Math.Cos (8.0 * Math.PI * n / N));  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_tukey,The following statement contains a magic number: if (Np > 0) {  	for (int n = 0; n <= Np; n++) {  		window [n] = (float)(0.5 - 0.5 * Math.Cos (Math.PI * n / Np));  		window [L - Np - 1 + n] = (float)(0.5 - 0.5 * Math.Cos (Math.PI * (n + Np) / Np));  	}  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_tukey,The following statement contains a magic number: if (Np > 0) {  	for (int n = 0; n <= Np; n++) {  		window [n] = (float)(0.5 - 0.5 * Math.Cos (Math.PI * n / Np));  		window [L - Np - 1 + n] = (float)(0.5 - 0.5 * Math.Cos (Math.PI * (n + Np) / Np));  	}  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_tukey,The following statement contains a magic number: if (Np > 0) {  	for (int n = 0; n <= Np; n++) {  		window [n] = (float)(0.5 - 0.5 * Math.Cos (Math.PI * n / Np));  		window [L - Np - 1 + n] = (float)(0.5 - 0.5 * Math.Cos (Math.PI * (n + Np) / Np));  	}  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_tukey,The following statement contains a magic number: if (Np > 0) {  	for (int n = 0; n <= Np; n++) {  		window [n] = (float)(0.5 - 0.5 * Math.Cos (Math.PI * n / Np));  		window [L - Np - 1 + n] = (float)(0.5 - 0.5 * Math.Cos (Math.PI * (n + Np) / Np));  	}  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_tukey,The following statement contains a magic number: for (int n = 0; n <= Np; n++) {  	window [n] = (float)(0.5 - 0.5 * Math.Cos (Math.PI * n / Np));  	window [L - Np - 1 + n] = (float)(0.5 - 0.5 * Math.Cos (Math.PI * (n + Np) / Np));  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_tukey,The following statement contains a magic number: for (int n = 0; n <= Np; n++) {  	window [n] = (float)(0.5 - 0.5 * Math.Cos (Math.PI * n / Np));  	window [L - Np - 1 + n] = (float)(0.5 - 0.5 * Math.Cos (Math.PI * (n + Np) / Np));  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_tukey,The following statement contains a magic number: for (int n = 0; n <= Np; n++) {  	window [n] = (float)(0.5 - 0.5 * Math.Cos (Math.PI * n / Np));  	window [L - Np - 1 + n] = (float)(0.5 - 0.5 * Math.Cos (Math.PI * (n + Np) / Np));  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_tukey,The following statement contains a magic number: for (int n = 0; n <= Np; n++) {  	window [n] = (float)(0.5 - 0.5 * Math.Cos (Math.PI * n / Np));  	window [L - Np - 1 + n] = (float)(0.5 - 0.5 * Math.Cos (Math.PI * (n + Np) / Np));  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_tukey,The following statement contains a magic number: window [n] = (float)(0.5 - 0.5 * Math.Cos (Math.PI * n / Np));  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_tukey,The following statement contains a magic number: window [n] = (float)(0.5 - 0.5 * Math.Cos (Math.PI * n / Np));  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_tukey,The following statement contains a magic number: window [L - Np - 1 + n] = (float)(0.5 - 0.5 * Math.Cos (Math.PI * (n + Np) / Np));  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_tukey,The following statement contains a magic number: window [L - Np - 1 + n] = (float)(0.5 - 0.5 * Math.Cos (Math.PI * (n + Np) / Np));  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_hann,The following statement contains a magic number: for (int n = 0; n < L; n++)  	window [n] = (float)(0.5 - 0.5 * Math.Cos (2.0 * Math.PI * n / N));  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_hann,The following statement contains a magic number: for (int n = 0; n < L; n++)  	window [n] = (float)(0.5 - 0.5 * Math.Cos (2.0 * Math.PI * n / N));  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_hann,The following statement contains a magic number: for (int n = 0; n < L; n++)  	window [n] = (float)(0.5 - 0.5 * Math.Cos (2.0 * Math.PI * n / N));  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_hann,The following statement contains a magic number: window [n] = (float)(0.5 - 0.5 * Math.Cos (2.0 * Math.PI * n / N));  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_hann,The following statement contains a magic number: window [n] = (float)(0.5 - 0.5 * Math.Cos (2.0 * Math.PI * n / N));  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,window_hann,The following statement contains a magic number: window [n] = (float)(0.5 - 0.5 * Math.Cos (2.0 * Math.PI * n / N));  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,sign_only,The following statement contains a magic number: return (short)((val >> 31) + ((val - 1) >> 31) + 1);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,sign_only,The following statement contains a magic number: return (short)((val >> 31) + ((val - 1) >> 31) + 1);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,compute_corr_int,The following statement contains a magic number: for (int i = min; i <= lag; ++i) {  	int temp = 0;  	int temp2 = 0;  	for (int j = 0; j <= lag - i; ++j)  		temp += data1 [j + i] * data2 [j];  	for (int j = lag + 1 - i; j < len - i; j += 2) {  		temp += data1 [j + i] * data2 [j];  		temp2 += data1 [j + i + 1] * data2 [j + 1];  	}  	autoc [i] = temp + temp2;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,compute_corr_int,The following statement contains a magic number: for (int j = lag + 1 - i; j < len - i; j += 2) {  	temp += data1 [j + i] * data2 [j];  	temp2 += data1 [j + i + 1] * data2 [j + 1];  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,compute_corr_int,The following statement contains a magic number: j += 2
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,compute_autocorr,The following statement contains a magic number: for (i = min; i <= lag; ++i) {  	double temp = 1.0;  	double temp2 = 1.0;  	double* finish = data1 + len - i;  	for (double* pdata = data1; pdata < finish; pdata += 2) {  		temp += pdata [i] * pdata [0];  		temp2 += pdata [i + 1] * pdata [1];  	}  	autoc [i] = temp + temp2;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,compute_autocorr,The following statement contains a magic number: for (double* pdata = data1; pdata < finish; pdata += 2) {  	temp += pdata [i] * pdata [0];  	temp2 += pdata [i + 1] * pdata [1];  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,compute_autocorr,The following statement contains a magic number: pdata += 2
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,quantize_lpc_coefs,The following statement contains a magic number: for (i = 0; i < order; i++) {  	error += lpc_in [i] * (1 << sh);  	q = (int)(error + 0.5);  	if (q <= -qmax)  		q = -qmax + 1;  	if (q > qmax)  		q = qmax;  	error -= q;  	lpc_out [i] = q;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,quantize_lpc_coefs,The following statement contains a magic number: q = (int)(error + 0.5);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  	*(r++) = *s - (pred >> shift);  	s -= 2;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  	*(r++) = *s - (pred >> shift);  	s -= 2;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: s -= 2;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	int* c = coefs + order - 1;  	int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  	*(r++) = *s - (pred >> shift);  	s -= 3;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: s -= 3;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	int* c = coefs + order - 1;  	int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  	*(r++) = *s - (pred >> shift);  	s -= 4;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: s -= 4;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	int* c = coefs + order - 1;  	int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  	*(r++) = *s - (pred >> shift);  	s -= 5;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: s -= 5;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	int* c = coefs + order - 1;  	int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  	*(r++) = *s - (pred >> shift);  	s -= 6;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: s -= 6;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	int* c = coefs + order - 1;  	int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  	*(r++) = *s - (pred >> shift);  	s -= 7;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: s -= 7;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	int* c = coefs + order - 1;  	int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  	*(r++) = *s - (pred >> shift);  	s -= 8;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: s -= 8;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	int* c = coefs + order - 1;  	int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  	*(r++) = *s - (pred >> shift);  	s -= 9;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: s -= 9;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	int* c = coefs + order - 1;  	int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  	*(r++) = *s - (pred >> shift);  	s -= 10;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: s -= 10;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	int* c = coefs + order - 1;  	int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  	*(r++) = *s - (pred >> shift);  	s -= 11;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: s -= 11;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual,The following statement contains a magic number: for (int i = order; i < n; i++) {  	s = smp + i - order;  	int pred = 0;  	int* c = coefs + order - 1;  	int* c11 = coefs + 11;  	while (c > c11)  		pred += *(c--) * *(s++);  	pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  	*(r++) = *s - (pred >> shift);  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *(s--) - (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(r++) = *s - (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  	s -= 2;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  	s -= 2;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: s -= 2;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  	s -= 3;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  	s -= 3;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  	s -= 3;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: pred += coefs [2] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: s -= 3;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  	s -= 4;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  	s -= 4;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  	s -= 4;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  	s -= 4;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: pred += coefs [3] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: pred += coefs [2] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: s -= 4;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  	s -= 5;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  	s -= 5;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  	s -= 5;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  	s -= 5;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  	s -= 5;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: pred += coefs [4] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: pred += coefs [3] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: pred += coefs [2] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: s -= 5;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  	s -= 6;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  	s -= 6;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  	s -= 6;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  	s -= 6;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  	s -= 6;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  	s -= 6;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: pred += coefs [5] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: pred += coefs [4] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: pred += coefs [3] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: pred += coefs [2] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: s -= 6;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [7] * (long)*(s++);  	pred += coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  	s -= 7;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [7] * (long)*(s++);  	pred += coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  	s -= 7;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [7] * (long)*(s++);  	pred += coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  	s -= 7;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [7] * (long)*(s++);  	pred += coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  	s -= 7;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [7] * (long)*(s++);  	pred += coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  	s -= 7;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [7] * (long)*(s++);  	pred += coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  	s -= 7;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [7] * (long)*(s++);  	pred += coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  	s -= 7;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: pred += coefs [6] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: pred += coefs [5] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: pred += coefs [4] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: pred += coefs [3] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: pred += coefs [2] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: s -= 7;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = order; i < n; i++) {  	s = smp + i - order;  	long pred = 0;  	int* co = coefs + order - 1;  	int* c7 = coefs + 7;  	while (co > c7)  		pred += *(co--) * (long)*(s++);  	pred += coefs [7] * (long)*(s++);  	pred += coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = order; i < n; i++) {  	s = smp + i - order;  	long pred = 0;  	int* co = coefs + order - 1;  	int* c7 = coefs + 7;  	while (co > c7)  		pred += *(co--) * (long)*(s++);  	pred += coefs [7] * (long)*(s++);  	pred += coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = order; i < n; i++) {  	s = smp + i - order;  	long pred = 0;  	int* co = coefs + order - 1;  	int* c7 = coefs + 7;  	while (co > c7)  		pred += *(co--) * (long)*(s++);  	pred += coefs [7] * (long)*(s++);  	pred += coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = order; i < n; i++) {  	s = smp + i - order;  	long pred = 0;  	int* co = coefs + order - 1;  	int* c7 = coefs + 7;  	while (co > c7)  		pred += *(co--) * (long)*(s++);  	pred += coefs [7] * (long)*(s++);  	pred += coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = order; i < n; i++) {  	s = smp + i - order;  	long pred = 0;  	int* co = coefs + order - 1;  	int* c7 = coefs + 7;  	while (co > c7)  		pred += *(co--) * (long)*(s++);  	pred += coefs [7] * (long)*(s++);  	pred += coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = order; i < n; i++) {  	s = smp + i - order;  	long pred = 0;  	int* co = coefs + order - 1;  	int* c7 = coefs + 7;  	while (co > c7)  		pred += *(co--) * (long)*(s++);  	pred += coefs [7] * (long)*(s++);  	pred += coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: for (int i = order; i < n; i++) {  	s = smp + i - order;  	long pred = 0;  	int* co = coefs + order - 1;  	int* c7 = coefs + 7;  	while (co > c7)  		pred += *(co--) * (long)*(s++);  	pred += coefs [7] * (long)*(s++);  	pred += coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*(r++) = *s - (int)(pred >> shift);  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: pred += coefs [7] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: pred += coefs [6] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: pred += coefs [5] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: pred += coefs [4] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: pred += coefs [3] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual_long,The following statement contains a magic number: pred += coefs [2] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++);  		pred += c0 * *(s++);  		*(r++) = *(s--) - (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* c = coefs + order - 1;  		int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* c = coefs + order - 1;  		int* c11 = coefs + 11;  		while (c > c11)  			pred += *(c--) * *(s++);  		pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*(r++) = *s - (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  	*(r++) = *s - (pred >> shift);  	s -= 2;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	int pred = coefs [2] * *(s++) + c1 * *(s++) + c0 * *(s++);  	*(r++) = *s - (pred >> shift);  	s -= 2;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: s -= 2;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	int* c = coefs + order - 1;  	int pred = *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  	*(r++) = *s - (pred >> shift);  	s -= 3;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: s -= 3;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	int* c = coefs + order - 1;  	int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  	*(r++) = *s - (pred >> shift);  	s -= 4;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: s -= 4;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	int* c = coefs + order - 1;  	int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  	*(r++) = *s - (pred >> shift);  	s -= 5;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: s -= 5;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	int* c = coefs + order - 1;  	int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  	*(r++) = *s - (pred >> shift);  	s -= 6;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: s -= 6;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	int* c = coefs + order - 1;  	int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  	*(r++) = *s - (pred >> shift);  	s -= 7;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: s -= 7;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	int* c = coefs + order - 1;  	int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  	*(r++) = *s - (pred >> shift);  	s -= 8;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: s -= 8;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	int* c = coefs + order - 1;  	int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  	*(r++) = *s - (pred >> shift);  	s -= 9;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: s -= 9;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	int* c = coefs + order - 1;  	int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  	*(r++) = *s - (pred >> shift);  	s -= 10;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: s -= 10;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	int* c = coefs + order - 1;  	int pred = *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  	*(r++) = *s - (pred >> shift);  	s -= 11;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: s -= 11;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,encode_residual2,The following statement contains a magic number: for (int i = order; i < n; i++) {  	s = smp + i - order;  	int pred = 0;  	int* c = coefs + order - 1;  	int* c11 = coefs + 11;  	while (c > c11)  		pred += *(c--) * *(s++);  	pred += *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + *(c--) * *(s++) + c1 * *(s++) + c0 * *(s++);  	*(r++) = *s - (pred >> shift);  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++) + c0 * *(s++);  		*(s--) = *(r++) + (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * *(s++);  		pred += coefs [7] * *(s++);  		pred += coefs [6] * *(s++);  		pred += coefs [5] * *(s++);  		pred += coefs [4] * *(s++);  		pred += coefs [3] * *(s++);  		pred += coefs [2] * *(s++);  		pred += c1 * *(s++);  		pred += c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++) + c0 * *(s++);  		*(s--) = *(r++) + (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * *(s++);  		pred += coefs [7] * *(s++);  		pred += coefs [6] * *(s++);  		pred += coefs [5] * *(s++);  		pred += coefs [4] * *(s++);  		pred += coefs [3] * *(s++);  		pred += coefs [2] * *(s++);  		pred += c1 * *(s++);  		pred += c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++) + c0 * *(s++);  		*(s--) = *(r++) + (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * *(s++);  		pred += coefs [7] * *(s++);  		pred += coefs [6] * *(s++);  		pred += coefs [5] * *(s++);  		pred += coefs [4] * *(s++);  		pred += coefs [3] * *(s++);  		pred += coefs [2] * *(s++);  		pred += c1 * *(s++);  		pred += c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++) + c0 * *(s++);  		*(s--) = *(r++) + (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * *(s++);  		pred += coefs [7] * *(s++);  		pred += coefs [6] * *(s++);  		pred += coefs [5] * *(s++);  		pred += coefs [4] * *(s++);  		pred += coefs [3] * *(s++);  		pred += coefs [2] * *(s++);  		pred += c1 * *(s++);  		pred += c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++) + c0 * *(s++);  		*(s--) = *(r++) + (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * *(s++);  		pred += coefs [7] * *(s++);  		pred += coefs [6] * *(s++);  		pred += coefs [5] * *(s++);  		pred += coefs [4] * *(s++);  		pred += coefs [3] * *(s++);  		pred += coefs [2] * *(s++);  		pred += c1 * *(s++);  		pred += c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++) + c0 * *(s++);  		*(s--) = *(r++) + (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * *(s++);  		pred += coefs [7] * *(s++);  		pred += coefs [6] * *(s++);  		pred += coefs [5] * *(s++);  		pred += coefs [4] * *(s++);  		pred += coefs [3] * *(s++);  		pred += coefs [2] * *(s++);  		pred += c1 * *(s++);  		pred += c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++) + c0 * *(s++);  		*(s--) = *(r++) + (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * *(s++);  		pred += coefs [7] * *(s++);  		pred += coefs [6] * *(s++);  		pred += coefs [5] * *(s++);  		pred += coefs [4] * *(s++);  		pred += coefs [3] * *(s++);  		pred += coefs [2] * *(s++);  		pred += c1 * *(s++);  		pred += c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++) + c0 * *(s++);  		*(s--) = *(r++) + (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * *(s++);  		pred += coefs [7] * *(s++);  		pred += coefs [6] * *(s++);  		pred += coefs [5] * *(s++);  		pred += coefs [4] * *(s++);  		pred += coefs [3] * *(s++);  		pred += coefs [2] * *(s++);  		pred += c1 * *(s++);  		pred += c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++) + c0 * *(s++);  		*(s--) = *(r++) + (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * *(s++);  		pred += coefs [7] * *(s++);  		pred += coefs [6] * *(s++);  		pred += coefs [5] * *(s++);  		pred += coefs [4] * *(s++);  		pred += coefs [3] * *(s++);  		pred += coefs [2] * *(s++);  		pred += c1 * *(s++);  		pred += c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++) + c0 * *(s++);  		*(s--) = *(r++) + (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * *(s++);  		pred += coefs [7] * *(s++);  		pred += coefs [6] * *(s++);  		pred += coefs [5] * *(s++);  		pred += coefs [4] * *(s++);  		pred += coefs [3] * *(s++);  		pred += coefs [2] * *(s++);  		pred += c1 * *(s++);  		pred += c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++) + c0 * *(s++);  		*(s--) = *(r++) + (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * *(s++);  		pred += coefs [7] * *(s++);  		pred += coefs [6] * *(s++);  		pred += coefs [5] * *(s++);  		pred += coefs [4] * *(s++);  		pred += coefs [3] * *(s++);  		pred += coefs [2] * *(s++);  		pred += c1 * *(s++);  		pred += c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++) + c0 * *(s++);  		*(s--) = *(r++) + (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * *(s++);  		pred += coefs [7] * *(s++);  		pred += coefs [6] * *(s++);  		pred += coefs [5] * *(s++);  		pred += coefs [4] * *(s++);  		pred += coefs [3] * *(s++);  		pred += coefs [2] * *(s++);  		pred += c1 * *(s++);  		pred += c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++) + c0 * *(s++);  		*(s--) = *(r++) + (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * *(s++);  		pred += coefs [7] * *(s++);  		pred += coefs [6] * *(s++);  		pred += coefs [5] * *(s++);  		pred += coefs [4] * *(s++);  		pred += coefs [3] * *(s++);  		pred += coefs [2] * *(s++);  		pred += c1 * *(s++);  		pred += c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++) + c0 * *(s++);  		*(s--) = *(r++) + (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * *(s++);  		pred += coefs [7] * *(s++);  		pred += coefs [6] * *(s++);  		pred += coefs [5] * *(s++);  		pred += coefs [4] * *(s++);  		pred += coefs [3] * *(s++);  		pred += coefs [2] * *(s++);  		pred += c1 * *(s++);  		pred += c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++) + c0 * *(s++);  		*(s--) = *(r++) + (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * *(s++);  		pred += coefs [7] * *(s++);  		pred += coefs [6] * *(s++);  		pred += coefs [5] * *(s++);  		pred += coefs [4] * *(s++);  		pred += coefs [3] * *(s++);  		pred += coefs [2] * *(s++);  		pred += c1 * *(s++);  		pred += c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++) + c0 * *(s++);  		*(s--) = *(r++) + (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * *(s++);  		pred += coefs [7] * *(s++);  		pred += coefs [6] * *(s++);  		pred += coefs [5] * *(s++);  		pred += coefs [4] * *(s++);  		pred += coefs [3] * *(s++);  		pred += coefs [2] * *(s++);  		pred += c1 * *(s++);  		pred += c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++) + c0 * *(s++);  		*(s--) = *(r++) + (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * *(s++);  		pred += coefs [7] * *(s++);  		pred += coefs [6] * *(s++);  		pred += coefs [5] * *(s++);  		pred += coefs [4] * *(s++);  		pred += coefs [3] * *(s++);  		pred += coefs [2] * *(s++);  		pred += c1 * *(s++);  		pred += c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++) + c0 * *(s++);  		*(s--) = *(r++) + (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * *(s++);  		pred += coefs [7] * *(s++);  		pred += coefs [6] * *(s++);  		pred += coefs [5] * *(s++);  		pred += coefs [4] * *(s++);  		pred += coefs [3] * *(s++);  		pred += coefs [2] * *(s++);  		pred += c1 * *(s++);  		pred += c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++) + c0 * *(s++);  		*(s--) = *(r++) + (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * *(s++);  		pred += coefs [7] * *(s++);  		pred += coefs [6] * *(s++);  		pred += coefs [5] * *(s++);  		pred += coefs [4] * *(s++);  		pred += coefs [3] * *(s++);  		pred += coefs [2] * *(s++);  		pred += c1 * *(s++);  		pred += c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++) + c0 * *(s++);  		*(s--) = *(r++) + (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * *(s++);  		pred += coefs [7] * *(s++);  		pred += coefs [6] * *(s++);  		pred += coefs [5] * *(s++);  		pred += coefs [4] * *(s++);  		pred += coefs [3] * *(s++);  		pred += coefs [2] * *(s++);  		pred += c1 * *(s++);  		pred += c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++) + c0 * *(s++);  		*(s--) = *(r++) + (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * *(s++);  		pred += coefs [7] * *(s++);  		pred += coefs [6] * *(s++);  		pred += coefs [5] * *(s++);  		pred += coefs [4] * *(s++);  		pred += coefs [3] * *(s++);  		pred += coefs [2] * *(s++);  		pred += c1 * *(s++);  		pred += c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++) + c0 * *(s++);  		*(s--) = *(r++) + (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * *(s++);  		pred += coefs [7] * *(s++);  		pred += coefs [6] * *(s++);  		pred += coefs [5] * *(s++);  		pred += coefs [4] * *(s++);  		pred += coefs [3] * *(s++);  		pred += coefs [2] * *(s++);  		pred += c1 * *(s++);  		pred += c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++) + c0 * *(s++);  		*(s--) = *(r++) + (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * *(s++);  		pred += coefs [7] * *(s++);  		pred += coefs [6] * *(s++);  		pred += coefs [5] * *(s++);  		pred += coefs [4] * *(s++);  		pred += coefs [3] * *(s++);  		pred += coefs [2] * *(s++);  		pred += c1 * *(s++);  		pred += c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++) + c0 * *(s++);  		*(s--) = *(r++) + (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * *(s++);  		pred += coefs [7] * *(s++);  		pred += coefs [6] * *(s++);  		pred += coefs [5] * *(s++);  		pred += coefs [4] * *(s++);  		pred += coefs [3] * *(s++);  		pred += coefs [2] * *(s++);  		pred += c1 * *(s++);  		pred += c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++) + c0 * *(s++);  		*(s--) = *(r++) + (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * *(s++);  		pred += coefs [7] * *(s++);  		pred += coefs [6] * *(s++);  		pred += coefs [5] * *(s++);  		pred += coefs [4] * *(s++);  		pred += coefs [3] * *(s++);  		pred += coefs [2] * *(s++);  		pred += c1 * *(s++);  		pred += c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++) + c0 * *(s++);  		*(s--) = *(r++) + (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * *(s++);  		pred += coefs [7] * *(s++);  		pred += coefs [6] * *(s++);  		pred += coefs [5] * *(s++);  		pred += coefs [4] * *(s++);  		pred += coefs [3] * *(s++);  		pred += coefs [2] * *(s++);  		pred += c1 * *(s++);  		pred += c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++) + c0 * *(s++);  		*(s--) = *(r++) + (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * *(s++);  		pred += coefs [7] * *(s++);  		pred += coefs [6] * *(s++);  		pred += coefs [5] * *(s++);  		pred += coefs [4] * *(s++);  		pred += coefs [3] * *(s++);  		pred += coefs [2] * *(s++);  		pred += c1 * *(s++);  		pred += c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		int pred = c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		int pred = c1 * *(s++) + c0 * *(s++);  		*(s--) = *(r++) + (pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 7;  	}  	break;  case 9:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 8;  	}  	break;  case 10:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 9;  	}  	break;  case 11:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 10;  	}  	break;  case 12:  	for (int i = n - order; i > 0; i--) {  		int* co = coefs + order - 1;  		int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  		*s = *(r++) + (pred >> shift);  		s -= 11;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		int pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * *(s++);  		pred += coefs [7] * *(s++);  		pred += coefs [6] * *(s++);  		pred += coefs [5] * *(s++);  		pred += coefs [4] * *(s++);  		pred += coefs [3] * *(s++);  		pred += coefs [2] * *(s++);  		pred += c1 * *(s++);  		pred += c0 * *(s++);  		*s = *(r++) + (pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	int* co = coefs + order - 1;  	int pred = *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  	*s = *(r++) + (pred >> shift);  	s -= 2;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: s -= 2;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	int* co = coefs + order - 1;  	int pred = *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  	*s = *(r++) + (pred >> shift);  	s -= 3;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: s -= 3;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	int* co = coefs + order - 1;  	int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  	*s = *(r++) + (pred >> shift);  	s -= 4;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: s -= 4;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	int* co = coefs + order - 1;  	int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  	*s = *(r++) + (pred >> shift);  	s -= 5;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: s -= 5;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	int* co = coefs + order - 1;  	int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  	*s = *(r++) + (pred >> shift);  	s -= 6;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: s -= 6;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	int* co = coefs + order - 1;  	int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  	*s = *(r++) + (pred >> shift);  	s -= 7;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: s -= 7;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	int* co = coefs + order - 1;  	int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  	*s = *(r++) + (pred >> shift);  	s -= 8;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: s -= 8;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	int* co = coefs + order - 1;  	int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  	*s = *(r++) + (pred >> shift);  	s -= 9;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: s -= 9;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	int* co = coefs + order - 1;  	int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  	*s = *(r++) + (pred >> shift);  	s -= 10;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: s -= 10;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	int* co = coefs + order - 1;  	int pred = *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + *(co--) * *(s++) + c1 * *(s++) + c0 * *(s++);  	*s = *(r++) + (pred >> shift);  	s -= 11;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: s -= 11;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: for (int i = order; i < n; i++) {  	s = smp + i - order;  	int pred = 0;  	int* co = coefs + order - 1;  	int* c7 = coefs + 7;  	while (co > c7)  		pred += *(co--) * *(s++);  	pred += coefs [7] * *(s++);  	pred += coefs [6] * *(s++);  	pred += coefs [5] * *(s++);  	pred += coefs [4] * *(s++);  	pred += coefs [3] * *(s++);  	pred += coefs [2] * *(s++);  	pred += c1 * *(s++);  	pred += c0 * *(s++);  	*s = *(r++) + (pred >> shift);  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: for (int i = order; i < n; i++) {  	s = smp + i - order;  	int pred = 0;  	int* co = coefs + order - 1;  	int* c7 = coefs + 7;  	while (co > c7)  		pred += *(co--) * *(s++);  	pred += coefs [7] * *(s++);  	pred += coefs [6] * *(s++);  	pred += coefs [5] * *(s++);  	pred += coefs [4] * *(s++);  	pred += coefs [3] * *(s++);  	pred += coefs [2] * *(s++);  	pred += c1 * *(s++);  	pred += c0 * *(s++);  	*s = *(r++) + (pred >> shift);  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: for (int i = order; i < n; i++) {  	s = smp + i - order;  	int pred = 0;  	int* co = coefs + order - 1;  	int* c7 = coefs + 7;  	while (co > c7)  		pred += *(co--) * *(s++);  	pred += coefs [7] * *(s++);  	pred += coefs [6] * *(s++);  	pred += coefs [5] * *(s++);  	pred += coefs [4] * *(s++);  	pred += coefs [3] * *(s++);  	pred += coefs [2] * *(s++);  	pred += c1 * *(s++);  	pred += c0 * *(s++);  	*s = *(r++) + (pred >> shift);  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: for (int i = order; i < n; i++) {  	s = smp + i - order;  	int pred = 0;  	int* co = coefs + order - 1;  	int* c7 = coefs + 7;  	while (co > c7)  		pred += *(co--) * *(s++);  	pred += coefs [7] * *(s++);  	pred += coefs [6] * *(s++);  	pred += coefs [5] * *(s++);  	pred += coefs [4] * *(s++);  	pred += coefs [3] * *(s++);  	pred += coefs [2] * *(s++);  	pred += c1 * *(s++);  	pred += c0 * *(s++);  	*s = *(r++) + (pred >> shift);  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: for (int i = order; i < n; i++) {  	s = smp + i - order;  	int pred = 0;  	int* co = coefs + order - 1;  	int* c7 = coefs + 7;  	while (co > c7)  		pred += *(co--) * *(s++);  	pred += coefs [7] * *(s++);  	pred += coefs [6] * *(s++);  	pred += coefs [5] * *(s++);  	pred += coefs [4] * *(s++);  	pred += coefs [3] * *(s++);  	pred += coefs [2] * *(s++);  	pred += c1 * *(s++);  	pred += c0 * *(s++);  	*s = *(r++) + (pred >> shift);  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: for (int i = order; i < n; i++) {  	s = smp + i - order;  	int pred = 0;  	int* co = coefs + order - 1;  	int* c7 = coefs + 7;  	while (co > c7)  		pred += *(co--) * *(s++);  	pred += coefs [7] * *(s++);  	pred += coefs [6] * *(s++);  	pred += coefs [5] * *(s++);  	pred += coefs [4] * *(s++);  	pred += coefs [3] * *(s++);  	pred += coefs [2] * *(s++);  	pred += c1 * *(s++);  	pred += c0 * *(s++);  	*s = *(r++) + (pred >> shift);  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: for (int i = order; i < n; i++) {  	s = smp + i - order;  	int pred = 0;  	int* co = coefs + order - 1;  	int* c7 = coefs + 7;  	while (co > c7)  		pred += *(co--) * *(s++);  	pred += coefs [7] * *(s++);  	pred += coefs [6] * *(s++);  	pred += coefs [5] * *(s++);  	pred += coefs [4] * *(s++);  	pred += coefs [3] * *(s++);  	pred += coefs [2] * *(s++);  	pred += c1 * *(s++);  	pred += c0 * *(s++);  	*s = *(r++) + (pred >> shift);  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: pred += coefs [7] * *(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: pred += coefs [6] * *(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: pred += coefs [5] * *(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: pred += coefs [4] * *(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: pred += coefs [3] * *(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual,The following statement contains a magic number: pred += coefs [2] * *(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: switch (order) {  case 1:  	for (int i = n - order; i > 0; i--) {  		long pred = c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  case 2:  	for (int i = n - order; i > 0; i--) {  		long pred = c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*(s--) = *(r++) + (int)(pred >> shift);  	}  	break;  case 3:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 2;  	}  	break;  case 4:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 3;  	}  	break;  case 5:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 4;  	}  	break;  case 6:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 5;  	}  	break;  case 7:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 6;  	}  	break;  case 8:  	for (int i = n - order; i > 0; i--) {  		long pred = coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  		s -= 7;  	}  	break;  default:  	for (int i = order; i < n; i++) {  		s = smp + i - order;  		long pred = 0;  		int* co = coefs + order - 1;  		int* c7 = coefs + 7;  		while (co > c7)  			pred += *(co--) * (long)*(s++);  		pred += coefs [7] * (long)*(s++);  		pred += coefs [6] * (long)*(s++);  		pred += coefs [5] * (long)*(s++);  		pred += coefs [4] * (long)*(s++);  		pred += coefs [3] * (long)*(s++);  		pred += coefs [2] * (long)*(s++);  		pred += c1 * (long)*(s++);  		pred += c0 * (long)*(s++);  		*s = *(r++) + (int)(pred >> shift);  	}  	break;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  	s -= 2;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  	s -= 2;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: s -= 2;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  	s -= 3;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  	s -= 3;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  	s -= 3;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: pred += coefs [2] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: s -= 3;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  	s -= 4;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  	s -= 4;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  	s -= 4;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  	s -= 4;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: pred += coefs [3] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: pred += coefs [2] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: s -= 4;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  	s -= 5;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  	s -= 5;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  	s -= 5;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  	s -= 5;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  	s -= 5;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: pred += coefs [4] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: pred += coefs [3] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: pred += coefs [2] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: s -= 5;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  	s -= 6;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  	s -= 6;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  	s -= 6;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  	s -= 6;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  	s -= 6;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  	s -= 6;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: pred += coefs [5] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: pred += coefs [4] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: pred += coefs [3] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: pred += coefs [2] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: s -= 6;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [7] * (long)*(s++);  	pred += coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  	s -= 7;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [7] * (long)*(s++);  	pred += coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  	s -= 7;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [7] * (long)*(s++);  	pred += coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  	s -= 7;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [7] * (long)*(s++);  	pred += coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  	s -= 7;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [7] * (long)*(s++);  	pred += coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  	s -= 7;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [7] * (long)*(s++);  	pred += coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  	s -= 7;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = n - order; i > 0; i--) {  	long pred = coefs [7] * (long)*(s++);  	pred += coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  	s -= 7;  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: pred += coefs [6] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: pred += coefs [5] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: pred += coefs [4] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: pred += coefs [3] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: pred += coefs [2] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: s -= 7;  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = order; i < n; i++) {  	s = smp + i - order;  	long pred = 0;  	int* co = coefs + order - 1;  	int* c7 = coefs + 7;  	while (co > c7)  		pred += *(co--) * (long)*(s++);  	pred += coefs [7] * (long)*(s++);  	pred += coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = order; i < n; i++) {  	s = smp + i - order;  	long pred = 0;  	int* co = coefs + order - 1;  	int* c7 = coefs + 7;  	while (co > c7)  		pred += *(co--) * (long)*(s++);  	pred += coefs [7] * (long)*(s++);  	pred += coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = order; i < n; i++) {  	s = smp + i - order;  	long pred = 0;  	int* co = coefs + order - 1;  	int* c7 = coefs + 7;  	while (co > c7)  		pred += *(co--) * (long)*(s++);  	pred += coefs [7] * (long)*(s++);  	pred += coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = order; i < n; i++) {  	s = smp + i - order;  	long pred = 0;  	int* co = coefs + order - 1;  	int* c7 = coefs + 7;  	while (co > c7)  		pred += *(co--) * (long)*(s++);  	pred += coefs [7] * (long)*(s++);  	pred += coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = order; i < n; i++) {  	s = smp + i - order;  	long pred = 0;  	int* co = coefs + order - 1;  	int* c7 = coefs + 7;  	while (co > c7)  		pred += *(co--) * (long)*(s++);  	pred += coefs [7] * (long)*(s++);  	pred += coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = order; i < n; i++) {  	s = smp + i - order;  	long pred = 0;  	int* co = coefs + order - 1;  	int* c7 = coefs + 7;  	while (co > c7)  		pred += *(co--) * (long)*(s++);  	pred += coefs [7] * (long)*(s++);  	pred += coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: for (int i = order; i < n; i++) {  	s = smp + i - order;  	long pred = 0;  	int* co = coefs + order - 1;  	int* c7 = coefs + 7;  	while (co > c7)  		pred += *(co--) * (long)*(s++);  	pred += coefs [7] * (long)*(s++);  	pred += coefs [6] * (long)*(s++);  	pred += coefs [5] * (long)*(s++);  	pred += coefs [4] * (long)*(s++);  	pred += coefs [3] * (long)*(s++);  	pred += coefs [2] * (long)*(s++);  	pred += c1 * (long)*(s++);  	pred += c0 * (long)*(s++);  	*s = *(r++) + (int)(pred >> shift);  }  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: pred += coefs [7] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: pred += coefs [6] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: pred += coefs [5] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: pred += coefs [4] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: pred += coefs [3] * (long)*(s++);  
Magic Number,CUETools.Codecs,lpc,C:\repos\lasitsin__GLDNBT\TestSoundRecord\TestSoundRecord\cutetools\CUETools.Codecs\LPC.cs,decode_residual_long,The following statement contains a magic number: pred += coefs [2] * (long)*(s++);  
